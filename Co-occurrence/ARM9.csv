Workaround	Failure	Errata ID	Core	Masks Affected	Revisions Impacted	Chip	Fix Status	Details	Module	Criticality	Manufacturer
 This requires bit 18 (instruction TCM order bit) in the configuration control register of the ARM966E-S core to be set. This can be done by the following assembler code: MOV R0, #0x40000 MCR P15,0x1,R0,C15,C1,0 When set, the write and read to the Flash bank are performed in the order generated by the ARM966-ES core.This ensures that writes are committed to the Flash memory before any subsequent read. This will not be fixed in future silicon revisions. 	2.1 Flash memory status register bit 7 		ARM9			STR91xFA		Description of limitation Status register bit 7 (ready bit) does not reflect the correct status when it is read immediately after the CPU issues a Flash memory program or erase command. 			ST
 Firmware must change the values if desired. This will not be fixed in future silicon revisions. 	2.2 Flash memory sector protection 		ARM9			STR91xFA		Description of limitation At power up, the Flash protection level 1 register is reset to 0FFFh (all Flash sectors are protected). A warm reset does not reset the register. 			ST
 using revision G Do not remap the banks after IAP (keep secondary bank at address 0x0), and in the secondary bank redirect ARM interrupts to be handled in the primary bank. This limitation is fixed in revision H devices by clearing all FMI registers (including bank base address and bank size) after a system reset. 	2.3 Flash memory remapping 		ARM9			STR91xFA		Description of limitation in revision G There are two independent Flash memory banks (primary and secondary) that allow read-while-write capability from one bank to the other, enabling in-application programming (IAP) of the primary bank while executing code from the secondary bank. After IAP has upgraded firmware in the primary bank, the bootloader code in the secondary bank should remap the banks by writing to FMI registers FMI_BBADR and FMI_NBBADR in order to have the primary bank start at address 0x0, which allows interrupt handlers to reside in the application code primary bank instead of interrupts being handled by bootloader code in the secondary bank. There are two forms of reset in the STR91xFA: A global reset (from power-up or voltage drop-out) that clears all functions in the device, and a system reset (from the reset input pin, watchdog, or JTAG reset command) that clears all but a few configuration registers. 4/16  STR91xFA Silicon limitations and fixes Silicon limitation The remapping operation is possible. However, when a system reset occurs after the remapping, the application hangs because the FMI_BBADR and FMI_NBBADR registers which define bank locations are not cleared by the system reset, while the FMI_CR register which controls the chip select enable of the non boot bank are cleared by the system reset. 			ST
s For the first case, three workarounds are proposed: 1. Do not use the last 8 x 32-bit words of a Flash bank for storing code and use it instead to store data constants (this can be configured by the linker to specify the last zone). 2. If the application firmware is larger than one bank in size, ensure that before reaching the last 8 x 32-bit words of one bank, application code must jump (using LDR, or a branch) to an address forced by the linker to a location in the other bank. 3. Disable the PFQ block before executing code stored across a bank boundary. For the second case, the workaround is as follows: Disable the PFQ block before reading (data/constants) from a bank other than the bank from which code is fetched and enable it again after completing the read operations.  5/16 Silicon limitations and fixes STR91xFA 	2.4 Flash fetch/read across banks 		ARM9			STR91xFA		Description of limitation In either of the following two conditions, the CPU may freeze or generate an exception: 1. When the two banks (Bank0 and Bank1) are configured at contiguous addresses in the STR91xFA address map and if a code sequence is stored and then fetched by the CPU across this boundary, 2. When data is read from a bank other than the bank fetched by the CPU for execution. This will not be fixed in future silicon revisions. 			ST
 To ensure that internal Flash programming and CUI registers (command user interface) programmings are performed correctly, configure the frequency of FMICLK to RCLK/2 during these operations. 	2.5 Flash frequency limitation when programming 		ARM9			STR91xFA		Description of limitation When programming the internal Flash or the Flash registers with an FMICLK frequency of 96 MHz, either using read-while-write operations or executing from the internal SRAM, for some STR91xFA slow parts that may be seen in the field, some data are not properly written. This issue is due to a limitation in the Flash command interface that affects Flash write operations (such as program or erase). 			ST
 When booting up an emulator, do not select the automatic configuration option. Instead, configure the ETM to be a 4-bit port manually. This limitation will not be fixed in future silicon revisions. 	2.6 ETM (embedded trace module) configuration 		ARM9			STR91xFA		Description of limitation By default, the ETM9 interface in the STR91xFA core is an 8-bit medium size model as defined by ARM Ltd. When an emulator tool boots up and performs an automatic configuration on the ETM (ETM sniffers), the configuration register always sends back the 8-bit model status. However, in order to reduce the number of I/O pins required for debugging, the ETM trace data port is implemented as a 4-bit port. When polled, the 8-bit status provided by the configuration register is incorrect. 			ST
 Whenever the SCU_CLKCNTR register is modified, the EMI must be subsequently reset by writing bit 6 (RST_EMI) of the SCU_PRR0 register to 0 and setting it again just before configuring and using the EMI. 6/16  STR91xFA Silicon limitations and fixes 2.7.2 Address boundary limitation in 16-bit asynchronous or synchronous modes Description of limitation When accessing the external memory in 16-bit mode, the address must always be aligned to half word (16 bit) or word (32 bit) boundary. The memory address must consequently be an even address, and reading or writing from/to an odd address location may result in incorrect data. This limitation applies to data memory space only, as code fetch is always aligned to word boundary. Workaround All data must be stored at even address location. 2.7.3 Write signal configuration in 16-bit synchronous mode Description of limitation (applies only to BGA144 devices) There are two sets of write control signals for 16-bit write bus cycle: 1. EMI_WRLn, EMI_WRHn 2. EMI_WEn, EMI_UBn, EMI_LBn The 2nd set of signals is activated by setting bit 2 in the SCU_GPIOEMI register. When configured in 16-bit synchronous mode, the EMI bus works only with the 2nd set of write signals. The 1st set of signal results in incorrect write signal timings. Workaround When using EMI in 16-bit synchronous mode, choose a memory device which accepts write enable (EMI_WEn), EMI_UBn and EMI_LBn signals. If these signals are not available on the memory, it is recommended to operate in asynchronous mode. 	2.7 EMI bus limitations 2.7.1 Impact of SCU_CLKCNTR register modification on EMI operation with clock ratio of 2 		ARM9			STR91xFA		Description of limitation When the EMI clock is configured with a ratio of 2, modifying SCU_CLKCNTR register may cause incorrect EMI write cycles to occur when the EMI is used. This is due to the de-synchronization of the two clock state machines feeding the EMI when the EMI clock ratio is configured with a ratio of 2. 			ST
 using revision G A limited workaround may be implemented to save around 120 ÂµA by using firmware to put the USB transceiver into Suspend mode (bit2, LP_MODE in the USB_CNTR register). This allows reducing Sleep mode current on VDDQ pins to around 380 ÂµA.  7/16 Silicon limitations and fixes STR91xFA Sleep mode current consumption on VDDQ pins is reduced to less than 10 ÂµA on revision H silicon devices. 	2.8 Sleep mode current (ISLEEP) on VDDQ pins 		ARM9			STR91xFA		Description of limitation When the STR91xFA enters Sleep mode, the current drawn from the CPU core voltage (VDD) and from the I/O supply voltage (VDDQ) should drop to a very low value. ISLEEP current on VDD pins correctly drops to as low as 50 ÂµA at 25 Â°C. However ISLEEP current on the VDDQ pins drops to around 500 ÂµA at 25 Â°C while it should be less than 10 ÂµA. 			ST
s Workaround solutions include: 1. Use the 32 kHz RTC clock as the clock source for sleep mode: a) Select the RTC clock as the CPU clock source prior entering sleep mode. b) The CPU wakes up following any of the three wakeup events and waits for the crystal to start oscillation. A crystal startup time is about 1.5 ms typical. c) After the crystal wakes up, the CPU waits for a tWAIT time before the first code is fetched from Flash memory. The software can then change the CPU clock source back to the OSC or PLL clock. The duration of tWAIT depends on the crystal frequency. tWAIT equals 50 Âµs at 25 MHz and 312 Âµs at 4 MHz. 2. Instead of a crystal, use an oscillator as STR91xFA clock source. This limitation will not be fixed in future silicon revisions 	2.9 Waking up from sleep mode 		ARM9			STR91xFA		Description of limitation After the CPU enters sleep mode, it can be woken up by: 1. External interrupt 2. RTC/USB interrupt 3. External reset When an oscillator chip is used as the clock source for the STR91xFA, the CPU wakes up from sleep mode following any of the above three input events. If a crystal is used as the clock source, the crystal is disabled in sleep mode to save power consumption. When a wakeup event occurs, the crystal does not recover fast enough and the CPU hangs. 			ST
s In order to avoid executing any valid instructions after setting the idle or sleep bit and before entering the mode, it is mandatory to execute a certain number of dummy instructions after setting the SCU_PWRMNG register. The number of dummy instructions to be executed is given by the following formula: No_dummy_instr = (f â f ) Ã 12 CPUCLK OSC Where fCPUCLK is the CPU core clock frequency and fOSC is the oscillator frequency. The worst scenario is obtained when the core works from the PLL maximum frequency (96 MHz) with an 4 MHz crystal or oscillator connected to the X1_CPU input. In this case 288 dummy instructions are needed. Note: If (fCPUCLK/ fOSC) is less than 1, the number of dummy instruction is always 3. Random external/internal wakeup events or interrupts may freeze the STR91xFA when occurring during the execution of these dummy instructions. In this case, only a reset event can wake up the CPU. This limitation will not be fixed in future silicon revisions 2.10.2 Time required to enter sleep mode Description of limitation After the mode bit is set in the SCU_PWRMNG register, the power management unit requires a period of time (tSLEEP) to switch off all CPU and peripheral clocks safely before entering sleep mode. A very slow peripheral clock results in a long switch off time. The tSLEEP time required to enter sleep mode depends on the oscillator frequency, on the slowest peripheral clock frequency, and on the CPU clock frequency. If a wakeup event occurs during tSLEEP, it is ignored and the STR91xFA does not exit from sleep mode. tSLEEP is given by the following formula: t = 17 Ã t_OSC + 14 Ã t_Slowest_IP_CLK + 6 Ã t_CPUCLK SLEEP Where t_OSC is the oscillator frequency, t_Slowest_IP_CLK the slowest peripheral clock frequency, and t_CPUCLK the CPU clock frequency. Example â CPU running on RTC clock before entering sleep mode (fCPUCLK = 32 kHz) (see Section 2.9). â t_OSC = 40 ns (fOSC = 25 MHz) â t_CPUCLK = t_RTC = 31,250 ns (fCPUCLK = 32 kHz) â t_Slowest_IP_CLK = 2*31,250 ns assuming all clock dividers are set to 1 (default state) except for APB clock divided which is set to 2, the slowest peripheral clock frequency is then fCPUCLK/2. Then, the value of tSLEEP is: t = 17 Ã 40 + 14 Ã 2 Ã 31, 250 + 6 Ã 31, 250 1.06 â¼ ms SLEEP  9/16 Silicon limitations and fixes STR91xFA Workaround To prevent random external wakeup events from occurring while the device is entering sleep mode (during tSLEEP), the maximum time required by the application to enter sleep mode must be taken into account. This limitation will not be fixed in future silicon revisions. 	2.10 Sleep and Idle mode requirements 2.10.1 Code execution after setting the sleep or idle mode bit 		ARM9			STR91xFA		Description of limitation Once the idle or sleep mode are entered by writing the PWR_MODE[2:0] bits in the SCU_PWRMNG register, it takes about 12 fOSC cycles for the device to stop the execution. In addition, if a wakeup event or an interrupt (external or internal coming from peripherals) occurs during this period while entering idle, the internal low power state machine is frozen and the STR91xFA hangs. In this case, only a reset event can wake up the device. 8/16  STR91xFA Silicon limitations and fixes 			ST
s Some possible software workarounds can be implemented depending on the application and the impact of the limitation. A hardware workaround, feasible in all cases, is to implement an external Schmitt trigger to act as a noise filter. 	2.11 Noise sensitivity of GPIO ports 		ARM9			STR91xFA		Description of limitation None of the STR9 general inputs have hysteresis which means they have no Schmitt trigger. Simulation in typical conditions (3.3 V, ambient temperature, typical processing) shows that approximately 25 mV noise is enough to provide unexpected glitches in the core when the 1 kHz pad signaling crosses the input buffer threshold. The slower the input signaling frequency is, the greater this limitation. 			ST
 Limit the voltage applied to the 5 V-tolerant I/O pins to 5 V to limit the leakage current. 10/16  STR91xFA Silicon limitations and fixes 	2.12 High leakage on GPIO ports at 5.5 V 		ARM9			STR91xFA		Description of limitation A high leakage current is observed when applying 5.5 V on 5 V-tolerant I/O pins. This leakage does not dependent on VDDQ, and increases with the temperature. This high leakage is distributed between the different pins when using a 5.5 V supply voltage. If the application hardware has 10 pins connected to 5.5 V, the leakage current is not multiplied by 10, but distributed between the 10 pins. This limitation will not be fixed in future silicon revisions. 			ST
 Instead of clearing the ADC interrupt flag at the end of the ISR, clear the flag when ISR is entered. This limitation will not be fixed in future silicon revisions. 	2.13 ADC interrupt generation 		ARM9			STR91xFA		Description of limitation The ADC generates an end of conversion (EVC) or an analog watchdog (AWD) interrupt when enabled. Before returning from serving the interrupt, the ISR typically clears the interrupt by setting the corresponding EVC or AWD flag bit in the ADC_CR register to â0â. The ADC clock is used to clear the interrupt flags. The time taken to clear the flags is longer when the ADC runs on a slow clock. The CPU may return from ISR before the interrupt flag has been cleared. Since the interrupt controller input is level sensitive, the CPU sees immediately if another interrupt is pending. 			ST
 on revision G In single conversion mode, there is no workaround to exceed 500 Ksps conversion rate with external trigger or timer trigger, and no workaround to reduce jitter from one sample to the next. In continuous and scan conversion modes there is no workaround to reduce delay of the first conversion. To eliminate jitter, a new conversion mode started by fast trigger has been added in silicon revision H (refer to STR91xFA datasheet and reference manual). It allows each conversion to be completed in 16 ADC clocks after it has been triggered by external ADC trigger or internal timer event. A minimum conversion rate of 1.2 Msps can be achieved on a single channel. In single and scan mode, the time to complete the first conversion is reduced to the range of 20 to 32 clocks (down from 36 to 48 clocks) after a trigger event allowing continuous conversion. In this case, the maximum rate on subsequent continuous conversions remains 1.5 Msps on a single channel.  11/16 Silicon limitations and fixes STR91xFA 	2.14 ADC conversion time and external trigger mode 		ARM9			STR91xFA		"Description of limitation When the ADC unit is in single conversion mode, the time to complete the conversion varies between 36 and 48 ADC clock periods after the conversion is initiated by an external ADC trigger, a timer trigger, or a firmware command. This limits the maximum ADC conversion rate to 500,000 samples per second for a single channel using an external trigger. This situation also introduces a ""jitter"" of as many as 12 ADC clocks from one completed conversion to the next. When the ADC unit is in continuous and scan conversion modes, the time to complete the first conversion varies between 36 and 48 ADC clocks like single conversion mode, but subsequent conversions complete every 16 ADC clocks producing a maximum ADC conversion rate of 1,500,000 samples per second for a single channel. "			ST
 Instead of using scan mode with continuous mode, the application has to select scan mode in single mode. Each conversion can be started by an internal trigger (PWM) for the required number of channels. The conversion time is deterministic in fast trigger mode. This is a new feature available in revision H silicon (see STR91xFA datasheet and reference manual). It can be computed using the following formula: f < 1 â (nb_channels Ã 16 â f ) TRIGGER ADC 	2.15 ADC scan and continuous modes 		ARM9			STR91xFA		Description of limitation only in revision H ADC scan and continuous mode cannot be used together on revision H silicon. The first conversion is performed, but the next channel is not selected, so the end of conversion never occurs. 			ST
 A delay max. of 16 ADC clocks between the channel selection and the conversion start should be enough to prevent this effect. A generic dummy loop (equivalent to 16 ADC clocks) is recommended. This workaround is only needed in single mode with a channel selection change. 	2.16 ADC single mode and channel selection 		ARM9			STR91xFA		Description of limitation only in rev H If both channel selection and start conversion bits (SC and STR bits) are written at the same time, it may occur that the ADC sampling/conversion is performed on the previous selected channel. 			ST
 Note: This workaround is taken from the ARM prime cell vectored interrupt controller (PL190) errata notice. For already existing software that services daisy-chained nested interrupts, a possible software workaround is to branch to the address provided by the VIC1 VAR register. This ensures that the correct ISR is serviced. 0x18 LDR pc, [VIC0_VAR] ; VIC0 VAR read ; daisy_chained_vector_handler: STMFD r13!, {r12-r14} LDR r12, [VIC1_VAR] ; Read VIC1 VAR and update PC, ; VIC1 priority hardware is updated LDR PC, [r12, #12] ; Processor branches to the highest priority ; daisy chained ISR and skips ; the preamble(+12) Note: The value, 12, used in instruction LDR PC, [r12, #12] is only specific to the example code given here. The offset #12 is dependent on the system's interrupt stacking preamble code size. 	2.17 Daisy chained interrupt controller VIC1 hardware priority management limitation 		ARM9			STR91xFA		Description of limitation For daisy-chained interrupts, if only the VAR from one VIC is read, it does not update the hardware priority in the other VIC. This means the daisy chained interrupt controller doesn't realize the interrupt is being serviced and keeps the interrupt request active. For daisy-chained interrupts the processor must read the VAR register from both interrupt controllers and branch to the addresses provided. However, the address provided by reading the daisy-chained VAR register must be manipulated to skip the interrupt preamble. If two daisy chained interrupts occur soon after each other and the daisy chained VAR register address isn't branched to, the interrupt controller priority logic may be updated incorrectly. This may cause a low priority interrupt to be missed. 12/16  STR91xFA Silicon limitations and fixes 			ST
 To ensure that the application use of the above bits is well supported, a new Flash configuration specification has been put in place: Bits 12:11 WSTATES[1:0]: Wait states These bits define the number of wait states inserted in asynchronous read access. 00: 1 wait state (default) 01: 2 wait states 10: 3 wait states Note: Wait states are inserted only for non-bursting Flash read bus cycles. One wait state is required for a Flash memory interface (FMI) bus clock frequency < 66 MHz. Two wait states are required for an FMI bus clock frequency â¥ 66 MHz. Bit 4 BUSCFG: Flash bus clock configuration This bit selects the FMI Flash bus clock configuration. 0: BUSCFG disabled (default) 1: BUSCFG enabled Note: The BUSCFG bit must be set for a frequency of: â¥ 48 MHz (with 1 wait state) â¥ 66 MHz (with 2 wait state).	2.18 Flash configuration register bits correction 		ARM9			STR91xFA		Description of limitation Using wait state insertion bits and/or the Flash bus clock bit under some specific configurations and/or combinations with respect to the Flash programming manual, may cause the device to be used outside its operating conditions. 			ST
 When interfacing an external peripheral device that does not support burst mode access through the EMC Static Memory interface the following work-arounds are recommended: 1. Avoid using DMA to transfer read blocks of data from the external device. Instead use a software loop with LDR instruction to read blocks of data from the external device. 2. If DMA can't be avoided, ensure there is at least one unused address between the highest address used for the external device DMA data buffer and any status or control register in the device that will initiate any unwanted action just by reading from the register (i.e. clear an interrupt or status). 	3.1 DMA.1: Single burst DMA memory-to-memory transfers have additional memory cycles when the DMA source memory is on the EMC bus 		ARM9			LPC3220		 The DMA controller is an AHB master that can transfer blocks of data between peripheral-to-memory, memory-to-peripheral, peripheral-to-peripheral, and memory-to-memory. In addition to transferring data between memories, a DMA memory-to-memory flow can be used to transfer blocks of data to / from an FPGA or external peripheral chip connected to an EMC static memory chip select. When a memory, FPGA or external peripheral chip does not support burst transfers (i.e. multiple reads for each active chip select or read strobe) the burst size for that memory-to-memory flow must be set for one transfer per burst.  When using memory-to-memory DMA with the EMC static chip select (EMC_CS[x]_N) as the DMA source and the DMA channel source burst size is set for a single transfer (DMACCxControl:SBSIZE = 0), each DMA source read should be a single bus-wide access. The access should be similar to reading the EMC_CS[x]_N static memory with an ARM LDR instruction, as shown in Figure 1. Note the EMC signal timing for the read is controlled by the EMCSTATICx registers. In all example scope shots the EMCSTATICWAITx registers are set to the maximum value. Fig 1. Scope shot 1 - expected read timing However, the actual EMC timing for the source DMA read is a double wide chip select with a burst of two reads (notice how the address increments near the halfway point of nCS0 active), see Figure 2. The second data read during the burst is discarded, as the DMA destination write (also to nCS0 in Figure 2) following each read, always writes the first value read during the read burst. When the DMA source address is set to auto-increment, the last DMA read transfer will address the last address of the source buffer and the last source buffer address +1. This behavior only happens during the read part of the DMA transfer. Memory-to-memory DMA destination writes to the EMC static chip select work as expected. ES_LPC3220 . Â©   Rev. 9 â 1 June 2011 4 of 16  ES_LPC3220  LPC3220 DMA register values used in Figure 2: DMACConfig = 0x01 DMACCxSrcAddr = 0xe0000000; EMC_CS0 DMACCxDestAddr = 0xe0000040; EMC_CS0 DMACCxLLI = 0x0 DMACCxControl = 0x0c480004; Dest & Src addrs increment, Dest & Src 32-bit; Dburst & Sburst size 1; transfer size 4 DMACCxConfig = 0x01 EMCStaticConfig0 = 0x00000082; 32-bit width, Byte lane state 1 Fig 2. Scope shot 2 - actual read timing Results of this behavior: 1. DMA reads from an external memory will have lower performance than a software read loop. The source read burst of two, to get one transfer, will significantly increase the time to complete all transfers in the memory-to-memory DMA, therefore decreasing the overall throughput possible on the EMC_CSx_N static memory interface. 2. Potential unintended consequence when the last DMA read accesses the address beyond the DMA source buffer address in the FPGA or external peripheral chip. This extra address is the second access during the last DMA source read. ES_LPC3220 . Â©   Rev. 9 â 1 June 2011 5 of 16  ES_LPC3220  LPC3220 			NXP
 Since this issue only occurs with NOR FLASH, using one of the other boot methods such as NAND or SPI FLASH boot is a good workaround for the issue. If booting from NOR FLASH is a requirement, the simple circuit shown in Figure 3 can be used to clear the SDRAM state at system reset. This will not change the normal functioning of the LPC3220 EMC or SDRAM operations. If SDRAM devices are also present on the 2nd SDRAM chip select, a similar circuit will be needed for those devices using EMC_CKE1. ES_LPC3220 . Â©   Rev. 9 â 1 June 2011 6 of 16  ES_LPC3220  LPC3220 Fig 3. 128 MB DDR SDRAM example ES_LPC3220 . Â©   Rev. 9 â 1 June 2011 7 of 16  ES_LPC3220  LPC3220 	3.2 NOR.1: When booting from NOR flash, SDRAM devices will not release the data bus, preventing the LPC3220 from booting correctly 		ARM9			LPC3220		 In systems that use SDRAM and boot from NOR FLASH, an issue can occur on system reset that will prevent the SDRAM devices from releasing the data bus. This will prevent normal operation of NOR FLASH due to data bus contention and prevent the LPC3220 from booting correctly. This applies to systems using either Single Data Rate (SDR) or Double Data Rate (DDR) SDRAM devices.  If the LPC3220 is reset during an SDRAM access, the SDRAM clock and clock enable will be immediately de-asserted. If the de-assertion occurs during the period of time the SDRAM is driving the data bus, the SDRAM will hold that state until the next clock occurs at the SDRAM clock input when the clock enable is active. However, the LPC3220 won't deliver the clock and clock enables until software actually sets up the EMC state to do this, so the SDRAM will remain in the data assertion state on the data bus while the LPC3220 tries to boot. When the chip attempts to load boot code from NOR FLASH after reset, the correct signals are asserted to the NOR FLASH device and the NOR FLASH device places its data on the data bus. But if the SDRAM is still driving the bus, the NOR FLASH device and SDRAM device are in contention and the data will not be read correctly into the LPC3220. In this situation, the LPC3220 will fail to boot. 			NXP
" To get the most DDR set-up time margin, the following is recommended: 1. The DDR initialization software should set the SDRAMCLK_CTRL register (0x4000 4068) SDRAM_PIN_SPEED[3:1] bits = 0 (fast slew rate). This is for both 1.8 V mobile and 2.5 V DDR memories. 2. Systems requiring 128 MB or less of DDR should be implemented using a single EMC_DYCSx_N for DDR. The single chip select system may be constructed with a single 16-bit wide DDR or two 8-bit wide DDR SDRAMs using up to the maximum supported 512 Mbit DDR density. Using two 8-bit wide DDRs will have less capacitive loading and facilitate simple point-to-point routing of EMC_D[15:0] and EMC_DQS[1:0] signals over using two 16-bit DDRs and two EMC_DYCSx banks. ES_LPC3220 . Â©   Rev. 9 â 1 June 2011 8 of 16  ES_LPC3220  LPC3220 3. Series termination resistors are not needed for the LPC3220 EMC outputs. If series termination resistors are used they should be placed as close to the DDR EMC_D[15:0] and EMC_DQS[1:0] pins as possible. 4. If the data bus EMC_D[15:0] is shared with additional devices (i.e., NOR flash, buffers, etc.) the board should be routed with a daisy chain topology, where the LPC3220 is placed at one extreme of the data bus and the DDR(s) at the other extreme. Other device(s) should be placed between the LPC3220 and DDR memory (closer to the DDR). 5. The PCB trace length of EMC_DQS[1:0] should be at least 2 inches (but not more than 4 inches) longer than EMC_DQ[15:0] and EMC_DQM[1:0]. On a typical FR4 PCB this adds at least 334 ps to set-up time margin for DDR writes. For reads from DDR the increased trace length of EMC_DQS[1:0] will be automatically compensated for by the software initialization function find_ddr_dqsin_delay() which sets the optimal value DDR_DQSIN_DELAY(SDRAMCLK_CTRL[6:2]). The function find_ddr_dqsin_delay() can be found in the ""DDR SDRAM setup code for the LPC32x0 series"" on the NXP web site. Example 128 MB system DDR SDRAM using a single EMC_DYCSx_N: LPC32x0 EMC DDR high byte (64M x 8) EMC_D[15:08] DQ7:0 22ohms EMC_DQS1 DQS 22ohms EMC_DQM1 DM BA1:0 / A12:0 nCS CKE, nRAS, nCAS, nWE CLK nCLK VREF low byte (64M x 8) V+_EMC EMC_D[07:00] DQ7:0 22ohms EMC_DQS0 DQS 22ohms EMC_DQM0 DM 20Kohms EMC_A[14:00] BA1:0 / A12:0 0.1uF 1% EMC_DYCS0_N nCS EMC_Control CKE, nRAS, nCAS, nWE EMC_CLK CLK 20Kohms 0.1uF 1% EMC_CLK_N NC nCLK VREF EMC_CLKIN Fig 5. 128 MB DDR SDRAM example ES_LPC3220 . Â©   Rev. 9 â 1 June 2011 9 of 16  ES_LPC3220  LPC3220 "	3.3 DDR.2: DDR EMC_D[15:0] to EMC_DQS[1:0] data output set-up time, tsu(Q), for MCU write to DDR provides limited timing margin Remark: This affects both 1.8 V mobile and 2.5 V DDR SDRAM system implementations. 		ARM9			LPC3220		 DDR memory interface signal EMC_DQS[1:0] is source synchronous, defined to be driven by the MCU center aligned to the data EMC_D[15:0] for writes, while driven by the DDR memory edge aligned to the EMC_D[15:0] for reads. The basic DDR write timing is shown in the data sheet Fig 1. EMC_CLK t t DSS DSH command WRITE tDQSS tDQSL tDQSH EMC_DQS[1:0] t t su(Q) h(Q) EMC_D[15:0], EMC_DQM[1:0] 002aae437 Fig 4. Basic DDR write timing  For DDR writes the LPC3220 drives the EMC_DQS[1:0] earlier in the data valid window than center aligned. With the EMC_CLK at 133 MHz this produces a minimum set-up time between the EMC_D[15:0] and EMC_DQS[1:0] of 600 ps across silicon process, voltage and temperature. Test conditions are with the EMC buffers set to fast slew rate driving 2 inches of 50 ï transmission line and 10 pF load capacitance. DDR memories specify EMC_D[15:0] to EMC_DQS[1:0] set-up time minimum as 400 ps. This leaves 200 ps set-up time margin due to customer specific load and PCB layout implementation. See the LPC3220_30_40_50 data sheet for the complete range of DDR data output set-up time, tsu(Q), and data output hold time th(Q) times. 			NXP
 Connecting the DDR device negative clock input (DDR_nCLK from the LPC3220) to the DDR Reference Voltage (Vref - the midpoint of the DDR signal voltage swing, which is generally VDDQ/2) avoids the clock skew problem, though it also eliminates the advantages of differential signaling. The LPC3220 DDR_nCLK output should be left unconnected. DDR Reference Voltage can be generated with a divide-by-two voltage divider. Standard DDR memories usually require a Vref input, so this DDR reference voltage should already be available. Mobile DDR devices typically do not have a Vref input, so the external voltage divider may need to be added to the design for this work-around. It is also possible to compensate for the 1.27 ns clock skew by adding an additional 7 inches of pcb trace length to the EMC_CLK signal. However, this could have unintentional consequences; such as increased Electro-Magnetic Interference. ES_LPC3220 . Â©   Rev. 9 â 1 June 2011 10 of 16  ES_LPC3220  LPC3220 	3.4 DDR.1: DDR interface has >1.2 ns clock skew 		ARM9			LPC3220		 DDR memory uses a differential clock which is generated by the LPC3220. The differential clock consists of two clock signals: EMC_CLK is the positive clock and DDR_nCLK is the negative clock.  There is approximately 1.27 ns of skew between the low transition of the DDR_nCLK and the high transition of the EMC_CLK. This can cause two problems: 1) Some DDR devices use this clock transition to drive a digital lock loop (DLL) in the DDR device. The DDR clock skew can cause the DDR device's internal DLL to loose lock, resulting in the wrong data being latched. 2) The DDR clock skew can also cause a reduced Data Valid Window (also called Data-Out Window) from a DDR device. However, the LPC3220 has a programmable DQS delay to achieve center alignment for accurate data reads. 			NXP
 There is no work-around for this problem. 	3.5 RTC.1: An RTC match doesnât drive the ONSW pin active (HIGH) 		ARM9			LPC3220		 An ONSW output pin (M15) is included in the LPC3220 to assist in waking up the chip after power is removed from all functions except the RTC and Battery RAM. When there is an active match condition the RTC will drive the ONSW pin HIGH. The RTC only drives the ONSW pin while the match is active, and after 1 second of active match, if the software has not accessed the RTC block, the ONSW pin will go low when the match is no longer active.  When power is removed from all functions except the RTC and Battery RAM, the RTC does NOT drive the ONSW pin HIGH when there is an active match condition. 			NXP
 There is no work-around for this problem. ES_LPC3220 . Â©   Rev. 9 â 1 June 2011 11 of 16  ES_LPC3220  LPC3220 	3.6 INT.1: GPI_08 does not generate an interrupt signal 		ARM9			LPC3220		 The LPC3220 contains 12 pins (GPI_00 - GPI_09, GPI_19, GPI_28) that function as dedicated General Purpose Inputs. Each of these pins can generate an individual interrupt for the input pin. Sub Interrupt Controller Register 1 (SIC1_ER) and Sub Interrupt Controller Register 2 (SIC2_ER) contains bits that allow enabling or disabling the interrupt for the associated pin.  When bit nine is set to one in the Sub Interrupt Controller 2 Enable register (SIC2_ER[9]) it does not enable the interrupt for the GPI_08 pin. All other General Purpose Input pins (GPI_00 - GPI_07, GPI_09, GPI_19, GPI_28) interrupts work correctly. 			NXP
 The GPIO interrupts1 need to be used instead of the MCPWM MCI0-2 pins. On the LPC3220, the GPIO interrupts can only be set to either trigger on the rising edge or on the falling edge. Therefore, in order to detect all six states of the connected hall sensor through an interrupt, the state of the pin needs to be determined and switch to rising or falling edge interrupt accordingly. 1. Available GPIO interrupt pins: GPIO_00 to GPIO_05, GPI_00 to GPI_09, GPI_19, GPI_28, and all port 0 and port 1 pins. ES_LPC3220 . Â©   Rev. 9 â 1 June 2011 12 of 16  ES_LPC3220  LPC3220 	3.7 MCPWM.1: Input pins (MCI0-2) on the Motor Control PWM peripheral are not functional 		ARM9			LPC3220		 On the LPC3220, the Motor Control PWM (MCPWM) peripheral is optimized for three-phase AC and DC motor control applications and can also be used in applications which require timing, counting, capture, and comparison. The MCPWM contains three input pins (MCI0-2) for PWM channels 0, 1, and 2. The inputs can be used as feedbacks for controlling brushless DC motors with Hall sensors, and also can be used to trigger a Timer/Counterâs (TC) capture or increment a channelâs TC when MCPWM is configured as a timer/counter. Note: MCI0-2 pins are also called MCFB0-2 (refer to LPC32x0 User manual for more details).  The input pins (MCI0-2) are not functional. 			NXP
 If all 7 UARTs aren't needed or 921.6 Kbps transfer rate isn't needed, use the standard UARTs instead of the high speed UARTs to avoid the issue altogether. For systems that require the HSUARTs, care must be taken to limit the exposure of the HSUART RX signal for the type of signal conditions that can cause the state to occur. There are several possible solutions that can help reduce the state from occurring. Whenever the HSUART is not in use, place the HSUART into loopback mode. When in loopback, the RX pin is connected internally to the HSUARTs TX pin and is isolated from the external RX input. While in this loopback state, the condition won't occur on the HSUART regardless of the signal on the RX input. The HSUART TX pin will remain in the idle state in loopback mode when no data is being sent from the HSUART. Optionally, if the HSUART is connected to a transceiver that supports enabling and disabling of the input signal from the transceiver RX input to the transceiver RX output to the HSUART RX input, disable it when not expecting a transmission. Regardless of how the transceiver is connected to the RX pin, the RX pin should be prevented from floating at power-up, reset, or when the transceiver is disabled. This can be done by adding a pull-up resistor to the HSUART RX pin. If using a system where the HSUART always need to be enabled, consider adding the capability to sense when the cable has been plugged into the connector and switch the HSUART out of loopback mode only once the cable has been installed to prevent cable insertion noise. ES_LPC3220 . Â©   Rev. 9 â 1 June 2011 13 of 16  ES_LPC3220  LPC3220 	3.8 HSUART.1: High speed UART receive FIFO and status can freeze 		ARM9			LPC3220		 The three high speed UART's (HSUART) receive (RX) FIFOs can sometimes enter a state where they no longer accept received data. When this state occurs, the HSUART's RX FIFO will no longer accept data regardless of RX FIFO fill status. The receive state of the HSUART may indicate a number of possible, but invalid, receive statuses. These invalid statuses may include RX FIFO or timeout interrupts pending with no receive data in the RX FIFO, invalid RX FIFO status, stuck RX interrupts, or other possible RX statuses. Once the HSUART enters this state, the state can only be cleared by a chip reset. This applies to the U1_RX, U2_RX, and U7_RX pins. The HSUART's transmit side is not affected by this issue and will work as normal when the HSUART receive side stops. The four standard UARTs do not exhibit this behavior.  It has been determined that this failed receive state can be entered by receiving a burst of high frequency noise into the HSUART RX pin. High frequency noise consists of pulsed or random toggling of the HSUART RX line at about 2.5 MHz or greater. The chance of the HSUART entering the state increases with the number of pulses and frequency of the pulses received. Generally, a single pulse won't cause the state to occur. During normal data transfer with transfer rates 2400 bps (416 uS) to 921.6 Kbps (1.085 uS), this state won't occur. However, conditions outside the transfer itself may cause the state to occur. It has been observed in some systems that insertion of the serial cable into the board's serial connector can cause connection noise or oscillations on the transceiver. This noise is driven onto the HSUART RX pin from the transceiver as a series of random pulses. 			NXP
 None. 4. AC/DC deviations detail 	3.9 USB.1: USB host controller hangs on a dribble bit 		ARM9			LPC3220		 Full-/low-speed signaling uses bit stuffing throughout the packet without exception. If the receiver sees seven consecutive ones anywhere in the packet, then a bit stuffing error has occurred and the packet should be ignored. The time interval just before an EOP is a special case. The last data bit before the EOP can become stretched by hub switching skews. This is known as dribble and can lead to a situation where dribble introduces a sixth bit that does not require a bit stuff. Therefore, the receiver must accept a packet for which there are up to six full bit times at the port with no transitions prior to the EOP.  The USB host controller will hang indefinitely if it sees a dribble bit on the USB bus. It will hang the first time a dribble bit is seen. Once it is in this state there is no recovery other than a hard chip reset. This problem has no effect on the USB device controller. 			NXP
 Observe proper ESD handling precautions for the RESET_N pin ES_LPC3220 . Â©   Rev. 9 â 1 June 2011 14 of 16	4.1 ESD.1: Weak ESD protection on Reset_N pad 		ARM9			LPC3220		 The LPC3220 was designed to withstand electrostatic discharges up to 2000 V using the Human Body Model.  The RESET_N pad (pin M14) does not pass ESD tests above 1000 V. 			NXP
 When interfacing an external peripheral device that does not support burst mode access through the EMC Static Memory interface the following work-arounds are recommended: 1. Avoid using DMA to transfer read blocks of data from the external device. Instead use a software loop with LDR instruction to read blocks of data from the external device. 2. If DMA can't be avoided, ensure there is at least one unused address between the highest address used for the external device DMA data buffer and any status or control register in the device that will initiate any unwanted action just by reading from the register (i.e. clear an interrupt or status). 	3.1 DMA.1: Single burst DMA memory-to-memory transfers have additional memory cycles when the DMA source memory is on the EMC bus 		ARM9			LPC3240		 The DMA controller is an AHB master that can transfer blocks of data between peripheral-to-memory, memory-to-peripheral, peripheral-to-peripheral, and memory-to-memory. In addition to transferring data between memories, a DMA memory-to-memory flow can be used to transfer blocks of data to / from an FPGA or external peripheral chip connected to an EMC static memory chip select. When a memory, FPGA or external peripheral chip does not support burst transfers (i.e. multiple reads for each active chip select or read strobe) the burst size for that memory-to-memory flow must be set for one transfer per burst.  When using memory-to-memory DMA with the EMC static chip select (EMC_CS[x]_N) as the DMA source and the DMA channel source burst size is set for a single transfer (DMACCxControl:SBSIZE = 0), each DMA source read should be a single bus-wide access. The access should be similar to reading the EMC_CS[x]_N static memory with an ARM LDR instruction, as shown in Figure 1. Note the EMC signal timing for the read is controlled by the EMCSTATICx registers. In all example scope shots the EMCSTATICWAITx registers are set to the maximum value. Fig 1. Scope shot 1 - expected read timing However, the actual EMC timing for the source DMA read is a double wide chip select with a burst of two reads (notice how the address increments near the halfway point of nCS0 active), see Figure 2. The second data read during the burst is discarded, as the DMA destination write (also to nCS0 in Figure 2) following each read, always writes the first value read during the read burst. When the DMA source address is set to auto-increment, the last DMA read transfer will address the last address of the source buffer and the last source buffer address +1. This behavior only happens during the read part of the DMA transfer. Memory-to-memory DMA destination writes to the EMC static chip select work as expected. ES_LPC3240 . Â©   Rev. 9 â 1 June 2011 5 of 17  ES_LPC3240  LPC3240 DMA register values used in Figure 2: DMACConfig = 0x01 DMACCxSrcAddr = 0xe0000000; EMC_CS0 DMACCxDestAddr = 0xe0000040; EMC_CS0 DMACCxLLI = 0x0 DMACCxControl = 0x0c480004; Dest & Src addrs increment, Dest & Src 32-bit; Dburst & Sburst size 1; transfer size 4 DMACCxConfig = 0x01 EMCStaticConfig0 = 0x00000082; 32-bit width, Byte lane state 1 Fig 2. Scope shot 2 - actual read timing Results of this behavior: 1. DMA reads from an external memory will have lower performance than a software read loop. The source read burst of two, to get one transfer, will significantly increase the time to complete all transfers in the memory-to-memory DMA, therefore decreasing the overall throughput possible on the EMC_CSx_N static memory interface. 2. Potential unintended consequence when the last DMA read accesses the address beyond the DMA source buffer address in the FPGA or external peripheral chip. This extra address is the second access during the last DMA source read. ES_LPC3240 . Â©   Rev. 9 â 1 June 2011 6 of 17  ES_LPC3240  LPC3240 			NXP
 Since this issue only occurs with NOR FLASH, using one of the other boot methods such as NAND or SPI FLASH boot is a good workaround for the issue. If booting from NOR FLASH is a requirement, the simple circuit shown in Figure 3 can be used to clear the SDRAM state at system reset. This will not change the normal functioning of the LPC3240 EMC or SDRAM operations. If SDRAM devices are also present on the 2nd SDRAM chip select, a similar circuit will be needed for those devices using EMC_CKE1. ES_LPC3240 . Â©   Rev. 9 â 1 June 2011 7 of 17  ES_LPC3240  LPC3240 Fig 3. 128 MB DDR SDRAM example 	3.2 NOR.1: When booting from NOR flash, SDRAM devices will not release the data bus, preventing the LPC3240 from booting correctly 		ARM9			LPC3240		 In systems that use SDRAM and boot from NOR FLASH, an issue can occur on system reset that will prevent the SDRAM devices from releasing the data bus. This will prevent normal operation of NOR FLASH due to data bus contention and prevent the LPC3240 from booting correctly. This applies to systems using either Single Data Rate (SDR) or Double Data Rate (DDR) SDRAM devices.  If the LPC3240 is reset during an SDRAM access, the SDRAM clock and clock enable will be immediately de-asserted. If the de-assertion occurs during the period of time the SDRAM is driving the data bus, the SDRAM will hold that state until the next clock occurs at the SDRAM clock input when the clock enable is active. However, the LPC3240 won't deliver the clock and clock enables until software actually sets up the EMC state to do this, so the SDRAM will remain in the data assertion state on the data bus while the LPC3240 tries to boot. When the chip attempts to load boot code from NOR FLASH after reset, the correct signals are asserted to the NOR FLASH device and the NOR FLASH device places its data on the data bus. But if the SDRAM is still driving the bus, the NOR FLASH device and SDRAM device are in contention and the data will not be read correctly into the LPC3240. In this situation, the LPC3240 will fail to boot. 			NXP
 Software can correct this situation in many ways; for example, sending a dummy frame after initialization. 	3.3 Ethernet.1: Ethernet TxConsumeIndex register does not update correctly after the first frame is sent 		ARM9			LPC3240		 The transmit consume index register defines the descriptor that is going to be transmitted next by the hardware transmit process. After a frame has been transmitted hardware increments the index, wrapping the value to 0 once the value of TxDescriptorNumber has been reached. If the TxConsumeIndex equals TxProduceIndex the descriptor array is empty and the transmit channel will stop transmitting until software produces new descriptors.  The TxConsumeIndex register is not updated correctly (from 0 to 1) after the first frame is sent. After the next frame sent, the TxConsumeIndex register is updated by two (from 0 to 2). This only happens the very first time, so subsequent updates are correct (even those from 0 to 1, after wrapping the value to 0 once the value of TxDescriptorNumber has been reached) 			NXP
" To get the most DDR set-up time margin, the following is recommended: 1. The DDR initialization software should set the SDRAMCLK_CTRL register (0x4000 4068) SDRAM_PIN_SPEED[3:1] bits = 0 (fast slew rate). This is for both 1.8 V mobile and 2.5 V DDR memories. 2. Systems requiring 128 MB or less of DDR should be implemented using a single EMC_DYCSx_N for DDR. The single chip select system may be constructed with a single 16-bit wide DDR or two 8-bit wide DDR SDRAMs using up to the maximum supported 512 Mbit DDR density. Using two 8-bit wide DDRs will have less capacitive loading and facilitate simple point-to-point routing of EMC_D[15:0] and EMC_DQS[1:0] signals over using two 16-bit DDRs and two EMC_DYCSx banks. 3. Series termination resistors are not needed for the LPC3240 EMC outputs. If series termination resistors are used they should be placed as close to the DDR EMC_D[15:0] and EMC_DQS[1:0] pins as possible. 4. If the data bus EMC_D[15:0] is shared with additional devices (i.e., NOR flash, buffers, etc.) the board should be routed with a daisy chain topology, where the LPC3240 is placed at one extreme of the data bus and the DDR(s) at the other extreme. Other device(s) should be placed between the LPC3240 and DDR memory (closer to the DDR). ES_LPC3240 . Â©   Rev. 9 â 1 June 2011 9 of 17  ES_LPC3240  LPC3240 5. The PCB trace length of EMC_DQS[1:0] should be at least 2 inches (but not more than 4 inches) longer than EMC_DQ[15:0] and EMC_DQM[1:0]. On a typical FR4 PCB this adds at least 334 ps to set-up time margin for DDR writes. For reads from DDR the increased trace length of EMC_DQS[1:0] will be automatically compensated for by the software initialization function find_ddr_dqsin_delay() which sets the optimal value DDR_DQSIN_DELAY(SDRAMCLK_CTRL[6:2]). The function find_ddr_dqsin_delay() can be found in the ""DDR SDRAM setup code for the LPC32x0 series"" on the NXP web site. Example 128 MB system DDR SDRAM using a single EMC_DYCSx_N: LPC32x0 EMC DDR high byte (64M x 8) EMC_D[15:08] DQ7:0 22ohms EMC_DQS1 DQS 22ohms EMC_DQM1 DM BA1:0 / A12:0 nCS CKE, nRAS, nCAS, nWE CLK nCLK VREF low byte (64M x 8) V+_EMC EMC_D[07:00] DQ7:0 22ohms EMC_DQS0 DQS 22ohms EMC_DQM0 DM 20Kohms EMC_A[14:00] BA1:0 / A12:0 0.1uF 1% EMC_DYCS0_N nCS EMC_Control CKE, nRAS, nCAS, nWE EMC_CLK CLK 20Kohms 0.1uF 1% EMC_CLK_N NC nCLK VREF EMC_CLKIN Fig 5. 128 MB DDR SDRAM example ES_LPC3240 . Â©   Rev. 9 â 1 June 2011 10 of 17  ES_LPC3240  LPC3240 "	3.4 DDR.2: DDR EMC_D[15:0] to EMC_DQS[1:0] data output set-up time, tsu(Q), for MCU write to DDR provides limited timing margin Remark: This affects both 1.8 V mobile and 2.5 V DDR SDRAM system implementations. 		ARM9			LPC3240		 DDR memory interface signal EMC_DQS[1:0] is source synchronous, defined to be driven by the MCU center aligned to the data EMC_D[15:0] for writes, while driven by the DDR memory edge aligned to the EMC_D[15:0] for reads. The basic DDR write timing is shown in the data sheet Fig 1. ES_LPC3240 . Â©   Rev. 9 â 1 June 2011 8 of 17  ES_LPC3240  LPC3240 EMC_CLK t t DSS DSH command WRITE tDQSS tDQSL tDQSH EMC_DQS[1:0] t t su(Q) h(Q) EMC_D[15:0], EMC_DQM[1:0] 002aae437 Fig 4. Basic DDR write timing  For DDR writes the LPC3240 drives the EMC_DQS[1:0] earlier in the data valid window than center aligned. With the EMC_CLK at 133 MHz this produces a minimum set-up time between the EMC_D[15:0] and EMC_DQS[1:0] of 600 ps across silicon process, voltage and temperature. Test conditions are with the EMC buffers set to fast slew rate driving 2 inches of 50 ï transmission line and 10 pF load capacitance. DDR memories specify EMC_D[15:0] to EMC_DQS[1:0] set-up time minimum as 400 ps. This leaves 200 ps set-up time margin due to customer specific load and PCB layout implementation. See the LPC3220_30_40_50 data sheet for the complete range of DDR data output set-up time, tsu(Q), and data output hold time th(Q) times. 			NXP
 Connecting the DDR device negative clock input (DDR_nCLK from the LPC3240) to the DDR Reference Voltage (Vref - the midpoint of the DDR signal voltage swing, which is generally VDDQ/2) avoids the clock skew problem, though it also eliminates the advantages of differential signaling. The LPC3240 DDR_nCLK output should be left unconnected. DDR Reference Voltage can be generated with a divide-by-two voltage divider. Standard DDR memories usually require a Vref input, so this DDR reference voltage should already be available. Mobile DDR devices typically do not have a Vref input, so the external voltage divider may need to be added to the design for this work-around. It is also possible to compensate for the 1.27 ns clock skew by adding an additional 7 inches of pcb trace length to the EMC_CLK signal. However, this could have unintentional consequences; such as increased Electro-Magnetic Interference. ES_LPC3240 . Â©   Rev. 9 â 1 June 2011 11 of 17  ES_LPC3240  LPC3240 	3.5 DDR.1: DDR interface has >1.2 ns clock skew 		ARM9			LPC3240		 DDR memory uses a differential clock which is generated by the LPC3240. The differential clock consists of two clock signals: EMC_CLK is the positive clock and DDR_nCLK is the negative clock.  There is approximately 1.27 ns of skew between the low transition of the DDR_nCLK and the high transition of the EMC_CLK. This can cause two problems: 1) Some DDR devices use this clock transition to drive a digital lock loop (DLL) in the DDR device. The DDR clock skew can cause the DDR device's internal DLL to loose lock, resulting in the wrong data being latched. 2) The DDR clock skew can also cause a reduced Data Valid Window (also called Data-Out Window) from a DDR device. However, the LPC3240 has a programmable DQS delay to achieve center alignment for accurate data reads. 			NXP
 There is no work-around for this problem. 	3.6 RTC.1: An RTC match doesnât drive the ONSW pin active (HIGH) 		ARM9			LPC3240		 An ONSW output pin (M15) is included in the LPC3240 to assist in waking up the chip after power is removed from all functions except the RTC and Battery RAM. When there is an active match condition the RTC will drive the ONSW pin HIGH. The RTC only drives the ONSW pin while the match is active, and after 1 second of active match, if the software has not accessed the RTC block, the ONSW pin will go low when the match is no longer active.  When power is removed from all functions except the RTC and Battery RAM, the RTC does NOT drive the ONSW pin HIGH when there is an active match condition. 			NXP
 There is no work-around for this problem. ES_LPC3240 . Â©   Rev. 9 â 1 June 2011 12 of 17  ES_LPC3240  LPC3240 	3.7 INT.1: GPI_08 does not generate an interrupt signal 		ARM9			LPC3240		 The LPC3240 contains 12 pins (GPI_00 - GPI_09, GPI_19, GPI_28 ) that function as dedicated General Purpose Inputs. Each of these pins can generate an individual interrupt for the input pin. Sub Interrupt Controller Register 1 (SIC1_ER) and Sub Interrupt Controller Register 2 (SIC2_ER) contains bits that allow enabling or disabling the interrupt for the associated pin.  When bit nine is set to one in the Sub Interrupt Controller 2 Enable register (SIC2_ER[9]) it does not enable the interrupt for the GPI_08 pin. All other General Purpose Input pins (GPI_00 - GPI_07, GPI_09, GPI_19, GPI_28) interrupts work correctly. 			NXP
 The GPIO interrupts1 need to be used instead of the MCPWM MCI0-2 pins. On the LPC3240, the GPIO interrupts can only be set to either trigger on the rising edge or on the falling edge. Therefore, in order to detect all six states of the connected hall sensor through an interrupt, the state of the pin needs to be determined and switch to rising or falling edge interrupt accordingly. 1. Available GPIO interrupt pins: GPIO_00 to GPIO_05, GPI_00 to GPI_09, GPI_19, GPI_28, and all port 0 and port 1 pins. ES_LPC3240 . Â©   Rev. 9 â 1 June 2011 13 of 17  ES_LPC3240  LPC3240 	3.8 MCPWM.1: Input pins (MCI0-2) on the Motor Control PWM peripheral are not functional 		ARM9			LPC3240		 On the LPC3240, the Motor Control PWM (MCPWM) peripheral is optimized for three-phase AC and DC motor control applications and can also be used in applications which require timing, counting, capture, and comparison. The MCPWM contains three input pins (MCI0-2) for PWM channels 0, 1, and 2. The inputs can be used as feedbacks for controlling brushless DC motors with Hall sensors, and also can be used to trigger a Timer/Counterâs (TC) capture or increment a channelâs TC when MCPWM is configured as a timer/counter. Note: MCI0-2 pins are also called MCFB0-2 (refer to LPC32x0 User manual for more details).  The input pins (MCI0-2) are not functional. 			NXP
 If all 7 UARTs aren't needed or 921.6 Kbps transfer rate isn't needed, use the standard UARTs instead of the high speed UARTs to avoid the issue altogether. For systems that require the HSUARTs, care must be taken to limit the exposure of the HSUART RX signal for the type of signal conditions that can cause the state to occur. There are several possible solutions that can help reduce the state from occurring. Whenever the HSUART is not in use, place the HSUART into loopback mode. When in loopback, the RX pin is connected internally to the HSUARTs TX pin and is isolated from the external RX input. While in this loopback state, the condition won't occur on the HSUART regardless of the signal on the RX input. The HSUART TX pin will remain in the idle state in loopback mode when no data is being sent from the HSUART. Optionally, if the HSUART is connected to a transceiver that supports enabling and disabling of the input signal from the transceiver RX input to the transceiver RX output to the HSUART RX input, disable it when not expecting a transmission. Regardless of how the transceiver is connected to the RX pin, the RX pin should be prevented from floating at power-up, reset, or when the transceiver is disabled. This can be done by adding a pull-up resistor to the HSUART RX pin. If using a system where the HSUART always need to be enabled, consider adding the capability to sense when the cable has been plugged into the connector and switch the HSUART out of loopback mode only once the cable has been installed to prevent cable insertion noise. ES_LPC3240 . Â©   Rev. 9 â 1 June 2011 14 of 17  ES_LPC3240  LPC3240 	3.9 HSUART.1: High speed UART receive FIFO and status can freeze 		ARM9			LPC3240		 The three high speed UART's (HSUART) receive (RX) FIFOs can sometimes enter a state where they no longer accept received data. When this state occurs, the HSUART's RX FIFO will no longer accept data regardless of RX FIFO fill status. The receive state of the HSUART may indicate a number of possible, but invalid, receive statuses. These invalid statuses may include RX FIFO or timeout interrupts pending with no receive data in the RX FIFO, invalid RX FIFO status, stuck RX interrupts, or other possible RX statuses. Once the HSUART enters this state, the state can only be cleared by a chip reset. This applies to the U1_RX, U2_RX, and U7_RX pins. The HSUART's transmit side is not affected by this issue and will work as normal when the HSUART receive side stops. The four standard UARTs do not exhibit this behavior.  It has been determined that this failed receive state can be entered by receiving a burst of high frequency noise into the HSUART RX pin. High frequency noise consists of pulsed or random toggling of the HSUART RX line at about 2.5 MHz or greater. The chance of the HSUART entering the state increases with the number of pulses and frequency of the pulses received. Generally, a single pulse won't cause the state to occur. During normal data transfer with transfer rates 2400 bps (416 uS) to 921.6 Kbps (1.085 uS), this state won't occur. However, conditions outside the transfer itself may cause the state to occur. It has been observed in some systems that insertion of the serial cable into the board's serial connector can cause connection noise or oscillations on the transceiver. This noise is driven onto the HSUART RX pin from the transceiver as a series of random pulses. 			NXP
 None. 4. AC/DC deviations detail 	3.10 USB.1: USB host controller hangs on a dribble bit 		ARM9			LPC3240		 Full-/low-speed signaling uses bit stuffing throughout the packet without exception. If the receiver sees seven consecutive ones anywhere in the packet, then a bit stuffing error has occurred and the packet should be ignored. The time interval just before an EOP is a special case. The last data bit before the EOP can become stretched by hub switching skews. This is known as dribble and can lead to a situation where dribble introduces a sixth bit that does not require a bit stuff. Therefore, the receiver must accept a packet for which there are up to six full bit times at the port with no transitions prior to the EOP.  The USB host controller will hang indefinitely if it sees a dribble bit on the USB bus. It will hang the first time a dribble bit is seen. Once it is in this state there is no recovery other than a hard chip reset. This problem has no effect on the USB device controller. 			NXP
 Observe proper ESD handling precautions for the RESET_N pin	4.1 ESD.1: Weak ESD protection on Reset_N pad 		ARM9			LPC3240		 The LPC3240 was designed to withstand electrostatic discharges up to 2000 V using the Human Body Model.  The RESET_N pad (pin M14) does not pass ESD tests above 1000 V. 			NXP
 When interfacing an external peripheral device that does not support burst mode access through the EMC Static Memory interface the following work-arounds are recommended: 1. Avoid using DMA to transfer read blocks of data from the external device. Instead use a software loop with LDR instruction to read blocks of data from the external device. 2. If DMA can't be avoided, ensure there is at least one unused address between the highest address used for the external device DMA data buffer and any status or control register in the device that will initiate any unwanted action just by reading from the register (i.e. clear an interrupt or status). 	3.1 DMA.1: Single burst DMA memory-to-memory transfers have additional memory cycles when the DMA source memory is on the EMC bus 		ARM9			LPC3250		 The DMA controller is an AHB master that can transfer blocks of data between peripheral-to-memory, memory-to-peripheral, peripheral-to-peripheral, and memory-to-memory. In addition to transferring data between memories, a DMA memory-to-memory flow can be used to transfer blocks of data to / from an FPGA or external peripheral chip connected to an EMC static memory chip select. When a memory, FPGA or external peripheral chip does not support burst transfers (i.e. multiple reads for each active chip select or read strobe) the burst size for that memory-to-memory flow must be set for one transfer per burst.  When using memory-to-memory DMA with the EMC static chip select (EMC_CS[x]_N) as the DMA source and the DMA channel source burst size is set for a single transfer (DMACCxControl:SBSIZE = 0), each DMA source read should be a single bus-wide access. The access should be similar to reading the EMC_CS[x]_N static memory with an ARM LDR instruction, as shown in Figure 1. Note the EMC signal timing for the read is controlled by the EMCSTATICx registers. In all example scope shots the EMCSTATICWAITx registers are set to the maximum value. Fig 1. Scope shot 1 - expected read timing However, the actual EMC timing for the source DMA read is a double wide chip select with a burst of two reads (notice how the address increments near the halfway point of nCS0 active), see Figure 2. The second data read during the burst is discarded, as the DMA destination write (also to nCS0 in Figure 2) following each read, always writes the first value read during the read burst. When the DMA source address is set to auto-increment, the last DMA read transfer will address the last address of the source buffer and the last source buffer address +1. This behavior only happens during the read part of the DMA transfer. Memory-to-memory DMA destination writes to the EMC static chip select work as expected. ES_LPC3250 . Â©   Rev. 9 â 1 June 2011 5 of 17  ES_LPC3250  LPC3250 DMA register values used in Figure 2: DMACConfig = 0x01 DMACCxSrcAddr = 0xe0000000; EMC_CS0 DMACCxDestAddr = 0xe0000040; EMC_CS0 DMACCxLLI = 0x0 DMACCxControl = 0x0c480004; Dest & Src addrs increment, Dest & Src 32-bit; Dburst & Sburst size 1; transfer size 4 DMACCxConfig = 0x01 EMCStaticConfig0 = 0x00000082; 32-bit width, Byte lane state 1 Fig 2. Scope shot 2 - actual read timing Results of this behavior: 1. DMA reads from an external memory will have lower performance than a software read loop. The source read burst of two, to get one transfer, will significantly increase the time to complete all transfers in the memory-to-memory DMA, therefore decreasing the overall throughput possible on the EMC_CSx_N static memory interface. 2. Potential unintended consequence when the last DMA read accesses the address beyond the DMA source buffer address in the FPGA or external peripheral chip. This extra address is the second access during the last DMA source read. ES_LPC3250 . Â©   Rev. 9 â 1 June 2011 6 of 17  ES_LPC3250  LPC3250 			NXP
 Since this issue only occurs with NOR FLASH, using one of the other boot methods such as NAND or SPI FLASH boot is a good workaround for the issue. If booting from NOR FLASH is a requirement, the simple circuit shown in Figure 3 can be used to clear the SDRAM state at system reset. This will not change the normal functioning of the LPC3250 EMC or SDRAM operations. If SDRAM devices are also present on the 2nd SDRAM chip select, a similar circuit will be needed for those devices using EMC_CKE1. ES_LPC3250 . Â©   Rev. 9 â 1 June 2011 7 of 17  ES_LPC3250  LPC3250 Fig 3. 128 MB DDR SDRAM example 	3.2 NOR.1: When booting from NOR flash, SDRAM devices will not release the data bus, preventing the LPC3250 from booting correctly 		ARM9			LPC3250		 In systems that use SDRAM and boot from NOR FLASH, an issue can occur on system reset that will prevent the SDRAM devices from releasing the data bus. This will prevent normal operation of NOR FLASH due to data bus contention and prevent the LPC3250 from booting correctly. This applies to systems using either Single Data Rate (SDR) or Double Data Rate (DDR) SDRAM devices.  If the LPC3250 is reset during an SDRAM access, the SDRAM clock and clock enable will be immediately de-asserted. If the de-assertion occurs during the period of time the SDRAM is driving the data bus, the SDRAM will hold that state until the next clock occurs at the SDRAM clock input when the clock enable is active. However, the LPC3250 won't deliver the clock and clock enables until software actually sets up the EMC state to do this, so the SDRAM will remain in the data assertion state on the data bus while the LPC3250 tries to boot. When the chip attempts to load boot code from NOR FLASH after reset, the correct signals are asserted to the NOR FLASH device and the NOR FLASH device places its data on the data bus. But if the SDRAM is still driving the bus, the NOR FLASH device and SDRAM device are in contention and the data will not be read correctly into the LPC3250. In this situation, the LPC3250 will fail to boot. 			NXP
 Software can correct this situation in many ways; for example, sending a dummy frame after initialization. 	3.3 Ethernet.1: Ethernet TxConsumeIndex register does not update correctly after the first frame is sent 		ARM9			LPC3250		 The transmit consume index register defines the descriptor that is going to be transmitted next by the hardware transmit process. After a frame has been transmitted hardware increments the index, wrapping the value to 0 once the value of TxDescriptorNumber has been reached. If the TxConsumeIndex equals TxProduceIndex the descriptor array is empty and the transmit channel will stop transmitting until software produces new descriptors.  The TxConsumeIndex register is not updated correctly (from 0 to 1) after the first frame is sent. After the next frame sent, the TxConsumeIndex register is updated by two (from 0 to 2). This only happens the very first time, so subsequent updates are correct (even those from 0 to 1, after wrapping the value to 0 once the value of TxDescriptorNumber has been reached) 			NXP
" To get the most DDR set-up time margin, the following is recommended: 1. The DDR initialization software should set the SDRAMCLK_CTRL register (0x4000 4068) SDRAM_PIN_SPEED[3:1] bits = 0 (fast slew rate). This is for both 1.8 V mobile and 2.5 V DDR memories. 2. Systems requiring 128 MB or less of DDR should be implemented using a single EMC_DYCSx_N for DDR. The single chip select system may be constructed with a single 16-bit wide DDR or two 8-bit wide DDR SDRAMs using up to the maximum supported 512 Mbit DDR density. Using two 8-bit wide DDRs will have less capacitive loading and facilitate simple point-to-point routing of EMC_D[15:0] and EMC_DQS[1:0] signals over using two 16-bit DDRs and two EMC_DYCSx banks. 3. Series termination resistors are not needed for the LPC3250 EMC outputs. If series termination resistors are used they should be placed as close to the DDR EMC_D[15:0] and EMC_DQS[1:0] pins as possible. 4. If the data bus EMC_D[15:0] is shared with additional devices (i.e., NOR flash, buffers, etc.) the board should be routed with a daisy chain topology, where the LPC3250 is placed at one extreme of the data bus and the DDR(s) at the other extreme. Other device(s) should be placed between the LPC3250 and DDR memory (closer to the DDR). ES_LPC3250 . Â©   Rev. 9 â 1 June 2011 9 of 17  ES_LPC3250  LPC3250 5. The PCB trace length of EMC_DQS[1:0] should be at least 2 inches (but not more than 4 inches) longer than EMC_DQ[15:0] and EMC_DQM[1:0]. On a typical FR4 PCB this adds at least 334 ps to set-up time margin for DDR writes. For reads from DDR the increased trace length of EMC_DQS[1:0] will be automatically compensated for by the software initialization function find_ddr_dqsin_delay() which sets the optimal value DDR_DQSIN_DELAY(SDRAMCLK_CTRL[6:2]). The function find_ddr_dqsin_delay() can be found in the ""DDR SDRAM setup code for the LPC32x0 series"" on the NXP web site. Example 128 MB system DDR SDRAM using a single EMC_DYCSx_N: LPC32x0 EMC DDR high byte (64M x 8) EMC_D[15:08] DQ7:0 22ohms EMC_DQS1 DQS 22ohms EMC_DQM1 DM BA1:0 / A12:0 nCS CKE, nRAS, nCAS, nWE CLK nCLK VREF low byte (64M x 8) V+_EMC EMC_D[07:00] DQ7:0 22ohms EMC_DQS0 DQS 22ohms EMC_DQM0 DM 20Kohms EMC_A[14:00] BA1:0 / A12:0 0.1uF 1% EMC_DYCS0_N nCS EMC_Control CKE, nRAS, nCAS, nWE EMC_CLK CLK 20Kohms 0.1uF 1% EMC_CLK_N NC nCLK VREF EMC_CLKIN Fig 5. 128 MB DDR SDRAM example ES_LPC3250 . Â©   Rev. 9 â 1 June 2011 10 of 17  ES_LPC3250  LPC3250 "	3.4 DDR.2: DDR EMC_D[15:0] to EMC_DQS[1:0] data output set-up time, tsu(Q), for MCU write to DDR provides limited timing margin Remark: This affects both 1.8 V mobile and 2.5 V DDR SDRAM system implementations. 		ARM9			LPC3250		 DDR memory interface signal EMC_DQS[1:0] is source synchronous, defined to be driven by the MCU center aligned to the data EMC_D[15:0] for writes, while driven by the DDR memory edge aligned to the EMC_D[15:0] for reads. The basic DDR write timing is shown in the data sheet Fig 1. ES_LPC3250 . Â©   Rev. 9 â 1 June 2011 8 of 17  ES_LPC3250  LPC3250 EMC_CLK t t DSS DSH command WRITE tDQSS tDQSL tDQSH EMC_DQS[1:0] t t su(Q) h(Q) EMC_D[15:0], EMC_DQM[1:0] 002aae437 Fig 4. Basic DDR write timing  For DDR writes the LPC3250 drives the EMC_DQS[1:0] earlier in the data valid window than center aligned. With the EMC_CLK at 133 MHz this produces a minimum set-up time between the EMC_D[15:0] and EMC_DQS[1:0] of 600 ps across silicon process, voltage and temperature. Test conditions are with the EMC buffers set to fast slew rate driving 2 inches of 50 ï transmission line and 10 pF load capacitance. DDR memories specify EMC_D[15:0] to EMC_DQS[1:0] set-up time minimum as 400 ps. This leaves 200 ps set-up time margin due to customer specific load and PCB layout implementation. See the LPC3220_30_40_50 data sheet for the complete range of DDR data output set-up time, tsu(Q), and data output hold time th(Q) times. 			NXP
 Connecting the DDR device negative clock input (DDR_nCLK from the LPC3250) to the DDR Reference Voltage (Vref - the midpoint of the DDR signal voltage swing, which is generally VDDQ/2) avoids the clock skew problem, though it also eliminates the advantages of differential signaling. The LPC3250 DDR_nCLK output should be left unconnected. DDR Reference Voltage can be generated with a divide-by-two voltage divider. Standard DDR memories usually require a Vref input, so this DDR reference voltage should already be available. Mobile DDR devices typically do not have a Vref input, so the external voltage divider may need to be added to the design for this work-around. It is also possible to compensate for the 1.27 ns clock skew by adding an additional 7 inches of pcb trace length to the EMC_CLK signal. However, this could have unintentional consequences; such as increased Electro-Magnetic Interference. 	3.5 DDR.1: DDR interface has >1.2 ns clock skew 		ARM9			LPC3250		 DDR memory uses a differential clock which is generated by the LPC3250. The differential clock consists of two clock signals: EMC_CLK is the positive clock and DDR_nCLK is the negative clock.  There is approximately 1.27 ns of skew between the low transition of the DDR_nCLK and the high transition of the EMC_CLK. This can cause two problems: 1) Some DDR devices use this clock transition to drive a digital lock loop (DLL) in the DDR device. The DDR clock skew can cause the DDR device's internal DLL to loose lock, resulting in the wrong data being latched. 2) The DDR clock skew can also cause a reduced Data Valid Window (also called Data-Out Window) from a DDR device. However, the LPC3250 has a programmable DQS delay to achieve center alignment for accurate data reads. 			NXP
 When using external SDRAM for the LCD framebuffer, use a display size and color depth that reserves sufficient system bandwidth for the remaining peripherals in the application. For systems using LCD displays sizes greater than QVGA and high color we suggest the use of external SRAM. ES_LPC3250 . Â©   Rev. 9 â 1 June 2011 11 of 17  ES_LPC3250  LPC3250 	3.6 LCD.1: Low throughput when LCD controller accesses DDR/SDRAM 		ARM9			LPC3250		 The LCD controller is an AHB Master that uses an internal DMA controller to transfer frame data from memory to the LCD panel.  The time required to read data from either SDR or DDR SDRAM using the LCD DMA controller takes longer than expected. This issue has little effect when the LCD DMA controller reads frame data from IRAM or external SRAM. 			NXP
 There is no work-around for this problem. 	3.7 RTC.1: An RTC match doesnât drive the ONSW pin active (HIGH) 		ARM9			LPC3250		 An ONSW output pin (M15) is included in the LPC3250 to assist in waking up the chip after power is removed from all functions except the RTC and Battery RAM. When there is an active match condition the RTC will drive the ONSW pin HIGH. The RTC only drives the ONSW pin while the match is active, and after 1 second of active match, if the software has not accessed the RTC block, the ONSW pin will go low when the match is no longer active.  When power is removed from all functions except the RTC and Battery RAM, the RTC does NOT drive the ONSW pin HIGH when there is an active match condition. 			NXP
 There is no work-around for this problem. ES_LPC3250 . Â©   Rev. 9 â 1 June 2011 12 of 17  ES_LPC3250  LPC3250 	3.8 INT.1: GPI_08 does not generate an interrupt signal 		ARM9			LPC3250		 The LPC3250 contains 12 pins (GPI_00 - GPI_09, GPI_19, GPI_28 ) that function as dedicated General Purpose Inputs. Each of these pins can generate an individual interrupt for the input pin. Sub Interrupt Controller Register 1 (SIC1_ER) and Sub Interrupt Controller Register 2 (SIC2_ER) contains bits that allow enabling or disabling the interrupt for the associated pin.  When bit nine is set to one in the Sub Interrupt Controller 2 Enable register (SIC2_ER[9]) it does not enable the interrupt for the GPI_08 pin. All other General Purpose Input pins (GPI_00 - GPI_07, GPI_09, GPI_19, GPI_28) interrupts work correctly. 			NXP
 The GPIO interrupts1 need to be used instead of the MCPWM MCI0-2 pins. On the LPC3250, the GPIO interrupts can only be set to either trigger on the rising edge or on the falling edge. Therefore, in order to detect all six states of the connected hall sensor through an interrupt, the state of the pin needs to be determined and switch to rising or falling edge interrupt accordingly. 1. Available GPIO interrupt pins: GPIO_00 to GPIO_05, GPI_00 to GPI_09, GPI_19, GPI_28, and all port 0 and port 1 pins. ES_LPC3250 . Â©   Rev. 9 â 1 June 2011 13 of 17  ES_LPC3250  LPC3250 	3.9 MCPWM.1: Input pins (MCI0-2) on the Motor Control PWM peripheral are not functional 		ARM9			LPC3250		 On the LPC3250, the Motor Control PWM (MCPWM) peripheral is optimized for three-phase AC and DC motor control applications and can also be used in applications which require timing, counting, capture, and comparison. The MCPWM contains three input pins (MCI0-2) for PWM channels 0, 1, and 2. The inputs can be used as feedbacks for controlling brushless DC motors with Hall sensors, and also can be used to trigger a Timer/Counterâs (TC) capture or increment a channelâs TC when MCPWM is configured as a timer/counter. Note: MCI0-2 pins are also called MCFB0-2 (refer to LPC32x0 User manual for more details).  The input pins (MCI0-2) are not functional. 			NXP
 If all 7 UARTs aren't needed or 921.6 Kbps transfer rate isn't needed, use the standard UARTs instead of the high speed UARTs to avoid the issue altogether. For systems that require the HSUARTs, care must be taken to limit the exposure of the HSUART RX signal for the type of signal conditions that can cause the state to occur. There are several possible solutions that can help reduce the state from occurring. Whenever the HSUART is not in use, place the HSUART into loopback mode. When in loopback, the RX pin is connected internally to the HSUARTs TX pin and is isolated from the external RX input. While in this loopback state, the condition won't occur on the HSUART regardless of the signal on the RX input. The HSUART TX pin will remain in the idle state in loopback mode when no data is being sent from the HSUART. Optionally, if the HSUART is connected to a transceiver that supports enabling and disabling of the input signal from the transceiver RX input to the transceiver RX output to the HSUART RX input, disable it when not expecting a transmission. Regardless of how the transceiver is connected to the RX pin, the RX pin should be prevented from floating at power-up, reset, or when the transceiver is disabled. This can be done by adding a pull-up resistor to the HSUART RX pin. If using a system where the HSUART always need to be enabled, consider adding the capability to sense when the cable has been plugged into the connector and switch the HSUART out of loopback mode only once the cable has been installed to prevent cable insertion noise. ES_LPC3250 . Â©   Rev. 9 â 1 June 2011 14 of 17  ES_LPC3250  LPC3250 	3.10 HSUART.1: High speed UART receive FIFO and status can freeze 		ARM9			LPC3250		 The three high speed UART's (HSUART) receive (RX) FIFOs can sometimes enter a state where they no longer accept received data. When this state occurs, the HSUART's RX FIFO will no longer accept data regardless of RX FIFO fill status. The receive state of the HSUART may indicate a number of possible, but invalid, receive statuses. These invalid statuses may include RX FIFO or timeout interrupts pending with no receive data in the RX FIFO, invalid RX FIFO status, stuck RX interrupts, or other possible RX statuses. Once the HSUART enters this state, the state can only be cleared by a chip reset. This applies to the U1_RX, U2_RX, and U7_RX pins. The HSUART's transmit side is not affected by this issue and will work as normal when the HSUART receive side stops. The four standard UARTs do not exhibit this behavior.  It has been determined that this failed receive state can be entered by receiving a burst of high frequency noise into the HSUART RX pin. High frequency noise consists of pulsed or random toggling of the HSUART RX line at about 2.5 MHz or greater. The chance of the HSUART entering the state increases with the number of pulses and frequency of the pulses received. Generally, a single pulse won't cause the state to occur. During normal data transfer with transfer rates 2400 bps (416 uS) to 921.6 Kbps (1.085 uS), this state won't occur. However, conditions outside the transfer itself may cause the state to occur. It has been observed in some systems that insertion of the serial cable into the board's serial connector can cause connection noise or oscillations on the transceiver. This noise is driven onto the HSUART RX pin from the transceiver as a series of random pulses. 			NXP
 None. 4. AC/DC deviations detail 	3.11 USB.1: USB host controller hangs on a dribble bit 		ARM9			LPC3250		 Full-/low-speed signaling uses bit stuffing throughout the packet without exception. If the receiver sees seven consecutive ones anywhere in the packet, then a bit stuffing error has occurred and the packet should be ignored. The time interval just before an EOP is a special case. The last data bit before the EOP can become stretched by hub switching skews. This is known as dribble and can lead to a situation where dribble introduces a sixth bit that does not require a bit stuff. Therefore, the receiver must accept a packet for which there are up to six full bit times at the port with no transitions prior to the EOP.  The USB host controller will hang indefinitely if it sees a dribble bit on the USB bus. It will hang the first time a dribble bit is seen. Once it is in this state there is no recovery other than a hard chip reset. This problem has no effect on the USB device controller. 			NXP
 Observe proper ESD handling precautions for the RESET_N pin	4.1 ESD.1: Weak ESD protection on Reset_N pad 		ARM9			LPC3250		 The LPC3250 was designed to withstand electrostatic discharges up to 2000 V using the Human Body Model.  The RESET_N pad (pin M14) does not pass ESD tests above 1000 V. 			NXP
1. Cellular RAM is basically Mobile SDRAM with the exception of a NOR flash interface. MX21 has an SDRAM controller. System designers are advised to use Mobile SDRAM for its higher performance(133 MHz) and lower cost. 2. Recommend not to enable burst write and treat Cellular RAM as NOR flash burst interface.	EIM Cellular RAM support fails	 	ARM9	"1L45X2L45X0M55B1M55BM55B"	 	"MC9328MX21MC94MX21"	No fix solution is planned.	Details:  For Infineon Cellular RAM HYE18P32160AC(-/L) 12.5, burst writes  can work with the following constraints:  1. EW bit does not work correctlyâWhen the EW bit is set, failures  are found when WSC= 7 and Cellular RAM is set up for LAT2. It does  work when WSC=9 and Cellular RAM is set for LAT3. This greatly  effects burst writes and reads. EW=0 always works (as NOR flash end  current burst).  2. After performing a sync access (like burst read), the Infineon  Cellular RAM expects another rising clock edge when CS goes high  to terminate burstâIf the Cellular RAM is left idle after a burst read  and NO rising clock edge is detected, it is stuck in sync mode not  allowing internal refresh cycles to occurâthis will cause Cellular RAM  to lose data. This appears to be more of an Infineon issue as Micron  asserts the extra rising edge clock is not needed. Also, Infineon stated  that in their next generation Cellular RAM this extra rising edge clock  is not required.  3. BCS bits do not shift the burst clock correctlyâOnly BCS bit 0  (LSB) effects the shifting of burst clock, other bits do not effect burst  clock phase (though they still effect LBA assertion time).  4. Only async writes are possible to Cellular RAM BCR and RCRâIn  addition, when switching modes or re-programming the RCR/BCR,  the system must first be placed back into async mode.  5. When D cache is enabled and EIM is doing async writes to the Cellular RAM, the EIM will hold CS asserted (low) for >10usâThis causes a problem for Cellular RAM because it cannot perform an internal refresh operation. The work around is to set CSA to 1 to force CS assertion between writes to allow time for Cellular RAM to refresh or to place EIM and Cellular RAM in sync mode of operation (burst writes) whenever D cache is enabled.	EIM	 	NXP
 Add a logic gate on board between the PC_POE signal and the  PCMCIA buffer such that the buffer is disabled at boot time. An  additional GPIO is required to control the gate ON/OFF. 	 Inverted PC_POE causes possible  system boot up failure when  PCMCIA buffer is used	 	ARM9	"1L45X 2L45X 0M55B 1M55B M55B"	 	"MC9328MX21MC94MX21"	 No fix solution is planned	Details/Impact:  The PC_POE pin may cause system boot up failure when PCMCIA  interface buffer is connected directly. This is due to PC_POE pin  (muxed with NFCLE) driven low during initial boot (with/without NAND  Flash) which enables the external buffer and results in data bus  contention. This multiplexed signal can be re-programmed to perform  the PC_OE function after the system starts up, therefore, only boot  time is affected. 	 PCMCIA 	 	NXP
CF/CF+ card support: No workaround available to support WinCE OS. For other OS, basic functionality can be fulfilled by allocating 1 Kbyte to attribute memory and 1 Kbyte to I/O memory or common memory.	Cannot fully support CF/CF+ specification.	 	ARM9	"1L45X2L45X"	 	"MC9328MX21MC94MX21"	CF/CF+ support problem is fixed in masks 0M55B, 1M55B, and M55B. PCMCIA Base registers 0â4 are enhanced to hold base addresses PBA[14:4] in the same programmable bits position. Memory windows such as common memory space, I/O space, True IDE or attribute memory space can be defined in an extended 32K space. Please refer to MC9328MX21 Mask Differences Between 2L45X and M55B Reference Manual Addendum for MC9328MX21RM, for further information on PCMCIA changes.	Details: The PCMCIA controller only supports up to 2 Kbytes of total space to map the attribute memory, common memory, or I/O space. However, the CF/CF+ specification and operating systems such as WinCE/PPC, require them to locate at a separate space and beyond the 2 Kbyte range. Impact: CF/CF+ cannot be supported on WinCE/PPC. Possible difficulty in building drivers in other OS.	PCMCIA	 	NXP
No workaround is available.	Not fully compliant with PCMCIA Ver. 2.1.	 	ARM9	"1L45X2L45X0M55B1M55BM55B"	 	"MC9328MX21MC94MX21"	No fix solution is planned.	Details: A total of 26 address lines are needed to fully support the PCMCIA standard. The i.MX21 processor does not support this many address lines. Impact: PCMCIA cards cannot be supported.	PCMCIA	 	NXP
No workaround is available.	AC97 Mode cannot be supported.	 	ARM9	"1L45X2L45X0M55B1M55BM55B"	 	"MC9328MX21MC94MX21"	No fix solution is planned.	Details/Impact: In AC97 variable mode, the AC97 controller is required to process the SLOTREQ automatically and source data from the transmit FIFO. However, the SLOTREQ bits are not handled and no variable mode operation is possible.	SSI	 	NXP
System designer is advised to: 1. Wait for the TLS (Transmit Last Slot) interrupt before enabling the receiver, Or 2. Disable the transmitter, then enable both transmitter and receiver simultaneously.	SSI does not wait for frame sync to receive data when RE is enabled in sync mode.	 	ARM9	"1L45X2L45X"	 	"MC9328MX21MC94MX21"	This erratum is corrected in masks 0M55B, 1M55B, and M55B.	Details/Impact: When TE has been enabled and RE is enabled in the middle of a valid frame, the SSI starts to receive data immediately without synchronizing with the next frame sync event. This causes the receiver section to remain out-of-sync with the frame timing and results in incorrect data received.	SSI	 	NXP
If more than one compare event is needed in freerun mode, use software comparisons instead.	The GP timer counter is reset even in freerun mode whenever the compare register is written.	 	ARM9	"1L45X2L45X"	 	"MC9328MX21MC94MX21"	This erratum is corrected in masks 0M55B and 1M55B.	Details/Impact: The counter is enhanced to reset automatically in restart mode. However, the change also influences freerun mode. The counter is now reset whenever the compare register is written. Applications are affected that allow compare values to change from time to time.	GP Timer	 	NXP
No workaround is available.	RW assertion incorrectly influenced by RWN bit in EIM module when RWA = 0 and RWN â¥ 1.	 	ARM9	"1L45X2L45X0M55B1M55BM55B"	 	"MC9328MX21MC94MX21"	No fix solution is planned.	Details: In EIM Chip select control register, there are two bits controlling the RW assertion and deassertion (negation) time: RWA and RWN. It is found that RWN incorrectly influences the assertion of the RW signal when RWA = 0 and RWN â¥ 1. The RW signal assertion is delayed 1/2 HCLK later. The RW signals acts as though RWA is set to 1, even though RWA bit is cleared in software. Other settings work correctly. Impact: Minimal. A slight timing delay is introduced to RW signal assertion.	EIM	 	NXP
No workaround is available.	Standby current at QVDD and NVDD is higher than the typical value specified in data sheet.	 	ARM9	1L45X	 	"MC9328MX21MC94MX21"	Standby current has been improved on subsequent masks. Please refer to the MC9328MX21 data sheet for power figures.	Details/Impact: Standby current at QVDD and NVDD is higher than the typical value specified in data sheet.	Power	 	NXP
System designer is advised to define data transfer with a fixed burst length for reliable communication.	BMI Tx_Water_Mark bit = 0000 fails.	 	ARM9	"1L45X2L45X0M55B1M55BM55B"	 	"MC9328MX21MC94MX21"	No fix solution is planned.	Details/Impact: When setting BMI Tx_Water_Mark bit to 0000, TxF_EMPTY status bit will always be set. This makes detecting 16 empty slots in FIFO impossible and user will not be able to check if the last data has been transmitted. Therefore, variable burst transfer cannot be supported.	BMI	 	NXP
It is advised to program Powerdown Timout bits of SDCTL0 and SDCTL1 to ZERO when using both CSD0 and CSD1. This issue does not happen when single CSD0 or CSD1 is used.	SDRAM Power Down mode failing to support both CSD0 and CSD1 simultaneously.	 	ARM9	"1L45X2L45X0M55B1M55BM55B"	 	"MC9328MX21MC94MX21"	No fix solution is planned.	Details: Memory access may fail at the following condition: 1. Both CSD0 and CSD1 are used, and 2. Both Power-down time-out bits of SDCTL0 and SDCTL1 are programmed to non-zero. Impact: As SDRAM cannot be put to power down mode, a slightly higher operating power may result. This issue does not affect self refresh mode operation and no difference in sleep mode power will be seen.	SDRAMC	 	NXP
This can be accomplished through the use of an external AND gate, where the NFCE and NFRB signals of the i.MX21 are inputs to the AND gate and the output is connected to the CE_B input of the NAND Flash device.	Cannot support NAND Flash memory requiring CE_B pin held low during tR (data transfer from cell to register) period.	 	ARM9	"1L45X2L45X0M55B1M55BM55B"	 	"MC9328MX21MC94MX21"	No fix solution is planned.	Details/Impact: NAND Flash controller drives the NF_CE signal high in tR period. For NAND Flash memory that requires CE_B to be held low during the tR period, memory access failure may result.	NAND Flash Memory Controller	 	NXP
No workaround is available for multiple block transfers. It requires card manufacturers to modify their firmwire to use single block transfers if not currently supported.	Multiple block transfer support fails if no BUSY signal is detected.	 	ARM9	"1L45X2L45X0M55B1M55BM55B"	 	"MC9328MX21MC94MX21"	Multiple block transfers are supported in the following cases: â¢multi-block reads â¢operation in 1-bit mode â¢busy signal is supported â¢4-bit mode, when fast DMACLK (HCLK) is not used, see below Multiple block transfer are not supported when all of the following conditions apply: â¢multi-block writes, and â¢there is no busy signal between blocks, and â¢4-bit bus width, and â¢when DMACLK (HCLK) is faster than MMCCLK/0.216. For example, 20 MHz SDIO, cannot use DMACLK (HCLK) faster than 92.6 MHz, thus HCLK cannot be 133 MHz during SDIO 4-bit multi-block reads.	Details/Impact: After sending the first block of data, the SDIO controller operation will stop if there is no BUSY signal detected. Therefore, multiple block transfers without any BUSY signal responding from card cannot be supported.	SDIO Controller	 	NXP
No Workaround is available	NAND Flash warm reset delay	 	ARM9	0M55B	 	"MC9328MX21MC94MX21"	Fixed in 1M55B and M55B	Details: When the boot mode is set to NAND Flash boot-up, after the reset_in signal is asserted, the processor needs to wait about 10 seconds before continuing the boot-up process. Impact: During the NAND Flash boot-up process, there is a waiting loop that checks the transfer of boot code completion (bit 15 of NAND FLASH Operation and Configuration register 2, NAND_Flash_Config2). However, the bit will not set immediately because the NAND Flash controller will not transfer the whole code during reset_in assertion time. It is required to wait 10 seconds for the NAND Flash controller to reset when a soft reset (Reset_In or Watchdog reset) occurs.	NAND Flash Controller (NFC)	 	NXP
Must use SDRAM devices with 1 kilobyte or greater page sizes.	Cannot support SDRAMs with less than 1kilobyte page size.	 	ARM9	"1L45X2L45X0M55B1M55BM55B"	 	"MC9328MX21MC94MX21"	No fix solution is planned.	Impact: Not able to support single chip 4M x 16-bit (8Mbyte total size) SDRAM devices or devices with a page size of less than 1 kilobyte. A page size is defined as the number of bits in a row in the SDRAM device.	SDRAMC	 	NXP
For 64 Mbyte SDRAM devices the configuration of 16M x 32 or two 16M x 16-bit must be used to form a 32-bit data bus, where either configuration contains only 9 column addresses.	Cannot support SDRAMs with column address sizes of 10.	 	ARM9	"1L45X2L45X0M55B1M55BM55B"	 	"MC9328MX21MC94MX21"	No fix solution is planned.	Impact: Not able to support single chip 32M x 16-bit (64Mbyte total size) SDRAM devices or devices with a column address size of 10.	SDRAMC	 	NXP
"In general, when reading from Nand Flash, SW must turn off the code correction in HW (ECC) and perform the correction in SW (done by performing error check and correction at the end of each page). When booting from Nand Flash, the Nand Flash Controller (NFC) copies the first 2Kbytes to internal RAM and jumps to the beginning of the code. This is done with no option for SW intervention/modification, so the aforementioned general guideline could not be applied. Note: If the NAND flash requires Error Correction on the initial block, then the following procedure is required. Otherwise, apply the S/W ECC after boot up: Due to the nature of this bug, any single-bit error (if found) in the first 512 bytes (first page) is corrected properly, therefore, ""specialâ boot loader code must be placed in those first 512 bytes. The loader code, once executed, must then perform the following: 1. Turn off error correction in HW. 2. Re-load pages 2, 3, and 4 (which comprise the remaining 1.5 Kbytes of code). 3. For every page read, perform error correction in SW. 4. Continue normal execution."	NFC (Nand Flash Controller) fails to correct two single-bit errors if they occur on consecutive pages, on data read accesses.	 	ARM9	"1L45X2L45X0M55B1M55BM55B"	 	"MC9328MX21MC94MX21"	No fix solution is planned.	Details: In cases when there are single-bit errors in two consecutive page reads, then the error in the second page is not corrected by the NFC. Impact: NFC error correction logic is faulty on read accesses and errors in consecutive pages are not fixed. Thus, software must correct the errors in place of the hardware. Special care must be given when booting from a Nand Flash for both 512 bytes, and 2 Kbytes page boot optionsâsee details under Workaround.	NFC / System Boot	 	NXP
"Do not access the DISR register to clear DMA transfer interrupts. Instead clear the interrupt of each DMA being used by setting the SMOD bits of the DMA CCR register for the DMA channel being used. Software Example: // pointer to 32bit program register DMA_CCR0 volatile unsigned int * P_32_DMA_CCR0 ; int  tmp ; // save the old value of CCR tmp = *(P_32_DMA_CCR0+(0x40*channelID)) ; //Force DMA channel's source mode as reserved ""11"" to clear the DISR bit for the selected channel * (P_32_DMA_CCR0+(0x40*channelID)) = tmp | (0x3<<10); // restore the old value back into CCR"	The DMA DISR register may be cleared accidentally when trying to clear any interrupt in the DISR register	 	ARM9	"1L45X2L45X0M55B1M55BM55B"	 	"MC9328MX21MC94MX21"		Details: When doing single or multiple DMA transfers the action of clearing a single DMA bit from the DISR register can result in clearing the whole DISR register. Impact: If the DISR register cleared accidentally, then an interrupt for DMA transfers does not take place. This can be an issue when there are multiple DMA channels transferring data at the same time. The Interrupt Service routine can miss interrupt notifications that DMA transfers have happened.	DMA	 	NXP
Connect LSCLK directly with the LCD panel, if the LCD panel allows it.	LSCLK is missing.	 	ARM9		 	"MC9328MX21MC94MX21"	No fix solution is planned.	Details: In 4 bpp, 8 bpp, 18 bpp, and TFT modes, LSCLK is missed in these conditions: â¢One clock cycle before every OE_ACD assert timing â¢Every VSYNC rising timing â¢Every VSYNC falling timing Impact: If the user connects LSCLK directly with LCD panel and the LCD panel allows missing clock, there is no issue. However, if the user adds a serializer between LSCLK and LCD panel, the serializer may not work correctly because of the missing clock and the LCD panel may have noise.	LCDC	 	NXP
 Use the TIMER register to count 100 Î¼s to determine the time  period during which the user is not allowed to access the  SyncFlash. 	It is necessary to use a  separate timer to prevent access  to the SyncFlash immediately after  the SyncFlash is re-enabled from  deep low-power mode	 	ARM9	2L45N	 	MC9328MXS	 No metal-fix solution	Impact:  If SyncFlash channel is disabled, the SDRAMC puts the  syncflash into a mode called deep low-power mode. When  the SyncFlash is re-enabled, it requires a 100 Î¼s period to  initialize before allowing any access to it.  The current design does not have a built-in timer to prevent  access before 100 Î¼s has passed. Therefore, an access  occurring during this time period could return invalid data  from the SyncFlash. 	SDRAMC 	 	NXP
 Use a dummy DMA transfer to and from a dummy memory  space to force the MEMC to release the bus for other bus  masters. For more detailed information and code example,  please visit our website www.freescale.com/imx. 	The Memory Controller  arbiter (MEMC) does not break  and release the ARMâ¢ coreâs  back-to-back burst access to the  other (for example, LCDC, DMA,  and MMA) bus masters. In this  situation, the ARM coreâs back-toback access does not use an IDLE  cycle as a separator.	 	ARM9	2L45N	 	MC9328MXS	 No metal-fix solution	Impact:  Typically, the back-to-back burst access that does not use  the IDLE cycle as a separator occurs for operations such as  cache fill, miss, and burst operations by the ARM processor.  In cases such as this, the MEMC arbiter incorrectly treats the  back-to-back sequence as a single instruction process that  causes the other bus masters to wait longer to access the  bus. On the AHB bus, only the LCDC and MMA modules are  affected. Because the MMA is not a periodic and time critical  module with regards to requesting the grant of the bus, the  impact of this issue is minimal, although the LCDC frame  buffer refresh can be greatly impacted. 	LCDC 	 	NXP
 Two methods are used to prevent this limitation depending on  the data packet size:  1. For data packet sizes of less than 5 bytes:  After the short packet data transfer, software must poll the  USBD BYTE_COUNT==0 before initiating the next DMA  transfer. This ensures that FIFO can accept the next long  data packet of 64-bytes.  2. For data packet sizes of 5 bytes and greater:  Use a 32-byte FIFO instead of a 64-byte FIFO to ensure that  the DMA request is cleared. The granularity bits GR[2:0] must  be set to 111. 	Limitation on using DMA  for USBD IN data transfer.  There is a limitation on using DMA  to transfer continuous data from  memory to a 64-byte USBD FIFO  (FIFO1 and FIFO2) when using a  short packet (<37 bytes) followed  by a long packet (> 32 bytes).  For example: A 6 byte packet  followed by a 64 byte packet, or a  32 byte packet followed by a 40  byte packet such that the short  packet length + the long packet  length is greater than 64 bytes  (FIFO depth).	 	ARM9	2L45N	 	MC9328MXS	 No metal-fix solution	Impact:  The DMA request does not clear after the reception of a short  packet, causing a long packet to start filling in the FIFO  before the data in the short packet is moved out of the FIFO.  This causes the USBD FIFO to overflow and generate an  error that prevents a DMA interrupt DMA_ISR from being  generated.  This occurs because the ALARM bit (DMA request) being  cleared is based on the setting of the 4*GR[2:0] granularity  bits in USB_EPn_FCTRL register. The ALARM bit for IN  transfer is set when the amount of data bytes that remain in  the FIFO is below the alarm value (ALARM[5:0] in the  USB_Epn_FALARM register and cleared when there is less  than 4*GR[2:0] of free bytes that remain in the FIFO.  The Granularity bits GR[2:0] are fixed at 3 bits regardless of  the FIFO depth. For IN transfer, DMA requests are cleared  when FREE data bytes are 4*GR[3:0]. Because GR[2:0]=3 *  111 as a maximum value, there can only be 28 free bytes.  Therefore, a 6 byte short packet in the 64-byte FIFO will not  dessert the DMA request. 	USB Device Port 	 	NXP
Either set the seconds alarm register to an even value or, if set to an odd value, when the interrupt occurs, check the current time against the alarm time. If it does not match, then clear the interrupt and return. The actual interrupt will occur one second later.	An alarm set to an odd number of seconds results in a false interrupt one second before the actual alarm time, followed by the actual interrupt.	 	ARM9	2L45N	 	MC9328MXS	No metal-fix solution.	Impact: This double interrupt is the result of a glitch produced by the seconds counter bits 1 and 0. Bit 0 of the seconds counter has greater loading than bit position 1. Upon receiving a clock signal to update the seconds counter, the seconds counter bit 0 changes state to be slower than counter bit 1. This glitch causes the alarm to see a momentary match, triggering the interrupt one second early. When the seconds counter actually does match the alarm value, another interrupt is triggered (if it has not been disabled following the previous interrupt) at the correct time. For example: If you set the alarm to âxx : xx : xx : 15 secâ, when the second counter changes from 13(1101) to14(1110), the bit position 1 changes faster than bit position 0. The result is 13(1101) to 15(1111) to 14(1110). This 15(1111), the glitch, matches the alarm setting and triggers the interrupt.	RTC	 	NXP
 Attach a 1 KÎ© series resistor to each tied-low input pin. 	Power-up leakage during  the recommended power-up  sequence, NVDD>AVDD>QVDD.  In the normal configuration, the  maximum current leakage  occurring during the power-up  period can be up to 600mA	 	ARM9	2L45N	 	MC9328MXS	 No metal-fix solution	Impact:  Using the workaround, the power-up current can be  minimized to less than maximum specified operating current. 	IOPAD 	 	NXP
For a bus that is heavily loaded and that requires SDRAM access, a dynamic burst length is recommended: â¢fixed burst length = 0 â¢high mark = 3 â¢low mark = 8 For a very heavily loaded system, increasing the low mark value increases the chance of a bus grant of the system bus, at the expense of more frequent bus requests.	The LCD flicker issue is not completely resolved by the use of dummy DMA transfer (See Erratum number 7). The LCDC DMA high/low setting does not ensure that the next bus request is triggered in the event the current DMA burst is not completed. The problem occurs when the next bus request is initiated while the LCDC is waiting for the last data in the current DMA burst. This is because when the LCDC is waiting for the last data, it only expects an HREADY signal to be asserted. So, if the next bus request is triggered while the LCDC is waiting, the bus request will be missed. A data fetch can not be initiated while data in FIFO is being continuously drained so an under-run will eventually occur. In Summary: If the next bus request is issued when the LCDC is waiting for the last data in the current DMA burst it will not be recognized.	 	ARM9	2L45N	 	MC9328MXS	No metal-fix solution.	Impact: The low mark must never be set higher than 10 and the high mark must be set at 3.	MEMC/AHBC	 	NXP
DTACK mode (DTACK_SEL = 0): No workaround. WAIT mode (DTACK_SEL=1): In Wait mode the OE signal for read cycle is negated up to 1 system clock before a data latch occurs at the end of bus cycle, possibly causing incorrect data to be latched by the i.MXS because the external device releases the data bus after OE negates. The workaround is to use external logic (one D-flip flop and one OR-gate) to extend OE negation time until the CS cycle is completed (after or at CS5 rising edge). D-FF connection must be D=1, RST= /OE OR /CS5, CLK= CS5, Q=NewOE for DTACK device only. To avoid disrupting other devices using /OE, the NewOE signal only replaces the /OE signal going to a DTACK device. See Figure 1. /OE /CS5 rst1 /NewOE for device DQ using DTACK only /CS5 set 1. If using LCX logic from ON Semiconductor, expect propagation delays from /OE and /CS assertion to /newOE of 3.0 to 12.5 ns. Freescale Semiconductor cannot recommend one supplier over another and in no way suggests that ON Semiconductor is the only supplier of logic devices. Figure 1. D-FF Connection Workaround	CS5 fails read operation when using the DTACK function.	 	ARM9	2L45N	 	MC9328MXS	No metal-fix solution.	Impact: When CS5 is configured to an external input DTACK signal to terminate the bus cycle (for example WSC = 0x3F), using either DTACK mode (DTACK_SEL = 0) or WAIT mode (DTACK_SEL= 1), the CPU or DMA read cycles in CS5 memory space may terminate incorrectly. CS5 can function normally by using wait state control bus terminationâthat is, WSC is not set to 0x3F. All write cycles will function correctly.	EIM	 	NXP
 PA17 is restricted for the DTACK functionality only. Thus, in  any other situation when DTACK is not used, this pin must be  pulled up or tied high (may be done by simply setting the  corresponding PUEN bit, configuring it as an input, and  leaving the pin unconnected). If the DTACK functionality is  used, the pin will only toggle during CS5 accesses and  should not toggle during any non-CS5 access. 	Port A pin 17 (multiplexed  with DTACK) inadvertently affects  other chip-select functions when  DTACK is not used.	 	ARM9	2L45N	 	MC9328MXS	 No metal-fix solution	Impact:  When the DTACK signal is not used, toggling the GPIO pin  PA17 will adversely affect the other EIM chip-select functions. 	EIM 	 	NXP
Must use SDRAM devices with 1 kilobyte or greater page sizes.	Cannot support SDRAMs with less than 1kilobyte page size.	 	ARM9	2L45N	 	MC9328MXS	No metal fix is planned.	Impact: Not able to support single chip 4M x 16-bit (8 Mbyte total size) SDRAM devices or devices with a page size of less than 1 kilobyte. A page size is defined as the number of bits in a row in the SDRAM device.	SDRAMC	 	NXP
For 64 Mbyte SDRAM devices the configuration of 16 M x 32 or two 16M x 16-bit must be used to form a 32-bit data bus, where either configuration contains only 9 column addresses.	Cannot support SDRAMs with column address sizes of 10.	 	ARM9	2L45N	 	MC9328MXS	No metal fix is planned.	Impact: Not able to support single chip 32M x 16-bit (64 Mbyte total size) SDRAM devices or devices with a column address size of 10.	SDRAMC	 	NXP
 No workaround is available. Recommend system designer to  use 32-bit SDRAM if 8 Mbyte or 64 Mbyte memory  configuration is desired. 	In 16-bit mode, only  SDRAM device with 9 Cols are  supported	 	ARM9	2L45N	 	MC9328MXS	 No metal fix is planned	Impact:  In 16-bit mode, burst access is not guaranteed for SDRAM  with number of columns not equal to 9. Known impact is  failure to support following devices in 16-bit mode:  a. SDRAM with 12 Rows and 8 Cols  (4Mx16-bit, 8MB total size)  b. SDRAM with 13 Rows and 10 Cols  (32Mx16-bit, 64 Mbyte total size) 	SDRAMC 	 	NXP
 The ARM Realview 3.0 SP1 Build 617 compiler and linker  have a patch that addresses this issue. With this patch  applied, the compiler will not generate this LDM instruction.  The Build 617 patch is available to download from the ARM  website.  To use the patch, users must insert  â--branchpatch 920t-ldm2â  to the compiler and linker command lines.  For code compiled by a compiler other than the above stated  tool, a manual search and replace for the LDM instruction of  two values in assembly code can be done with multiple  options for equivalent code replacements.  Example 1:  LDMIA r0, {r1, r2}  is functionally IDENTICAL to:  LDR r1, [r0]  LDR r2, [r0, #4]  Example 2:  If updating the base register to a new value, such as:  LDMIA r0!, {r1, r2}  then this is functionally IDENTICAL to:  LDR r1, [r0], #4  LDR r2, [r0], #4 	LDM instruction fails to  load non-cached data from  memory	 	ARM9	2L45N	 	MC9328MXS	 No hardware fix planned	Impact:  When a load multiple (LDM) instruction is used to load two  specific registers from an un-cached region of memory, and  the load instruction begins immediately after a delayed  buffered write, then the LDM will not load the second register  correctly. 	ARM920T AHB  Wrapper 	 	NXP
 The following software solutions are recommended to be  used in Interrupt Service Routines (ISRs) to avoid the parity  bug. Polling can also be used instead of interrupts.  1. A maximum of 32 bytes can be written into the TxFIFO  when transmission is complete (USR2.TXDC = 1).  2. A maximum of 31 bytes can be written into the TxFIFO  when the TxFIFO is empty (USR2.TXFE = 1).  3. A maximum of 32 - n bytes, where n = UFCR.TXTL, can  be written into the TxFIFO when the data level in the TxFIFO  falls below the selected threshold (when USR1.TRDY = 1). 	 Parity bug in UART transmitter	 	ARM9	2L45N	 	MC9328MXS	 No hardware fix planned.	Impact:  A parity error in UART character transmissions may occur.  TxFIFO data being shifted out is not alterable after the start  bit is issued. However, the parity bit can change after the  start bit is issued and is not fixed until data Bit0 is issued. If  the TxFIFO is overwritten by the CPU during the interval from  the end of the start bit to the end of the data Bit0, there will be  a mismatch between the data shifted out and the parity bit. In  this case, a parity error may occur. 	 UART 	 	NXP
To ensure a gap of at least 2 bit-clock cycles between SSI_EN and TX/RX bit setting (only for External word-wide frame-sync patterns), here is an example code for this workaround. void ssi_transmit_receive_test() { //parameters defined here Statement1 (); //clock configuration here Statement2(); //AUDMUX configuration here Statement3(); //SSI configuration here Statement4(); //Enable SSI by programming SSI_SCR MEMWD(SSI2_SCR,scr_mask1); //delay some time for the SSI state machine to function //properly for(i=0;i<=5;i++); //Enable transmit and receive of SSI by programming //SSI_SCR MEMWD(SSI2_SCR,scr_mask2); ...... }	In word-wide frame-sync mode, if SSI_EN and TX/RX_EN are set near new frame start, SSI Receive and Transmit does not function properly and there is a chance of words getting missed/shifted or transmit data line being driven low for 1/2 clock cycles during the first frame.	 	ARM9	2L45N	 	MC9328MXS	No metal-fix solution planned.	Impact: Receive malfunction: Rx data is usually taken with the period of FS=H. However, in some special use cases, it is changed to period of FS=L. Once this occurs, this period never returns to the period of FS=H. The issue occurs in the following conditions: Normal mode Sync mode Slave mode Some additional conditions of this scenario are: TX and RX are used at the same time (full duplex) SYN=1,RXDIR=0,TXDIR=0,TFDIR=0 External clock is 2.048MHz Frame frequency is 8kHz Frame pulse width is 1 word (8 clock) SSI_EN and RE is set to 1 within latter 4 clocks of FS=H period (8 clocks) Transmit malfunction: TxData is changed to different value at only the first time of transmitting when TE bit is set just before FS signal or within FS timing.	SSI	 	NXP
No workaround	Video Codec module supporting MV and MVD ranges does not conform with standard.	bo57692	ARM9	0M72J	 	MCIMX27	No fix planned	Description: Video Codec module supporting MV and MVD ranges does not conform with the H.264 standard. â¢The standard specifies the range of MVD to be â4096 to 4095.75. However, the Video Codec module only supports up to â2048â2047.75. â¢The standard specifies that the range of horizontal MV to be â2048 to 2047.75. However, the Video Codec module only supports up to â1024 to 1023.75. Because the maximum image resolution in the i.MX27 device is 720 Ã 576, it is not likely to receive a bitstream with MV/MVD in such a large range in real codec applications; therefore, there is no real impact to applications.	â¢Video â¢Codec	3	NXP
No workaround	A remote wake-up can be interpreted as a disconnect.	bo58229	ARM9	0M72J	 	MCIMX27	No fix planned	Description: In Host mode in the ULPI core, a remote wake-up can be interpreted as a disconnect. This issue involves the latency when asserting in synchronous mode. In some instances, the host will not properly latch the K state. When this occurs, the core wakes up to a J state. Eventually the host will not resume, and will show an SE0 and assume a disconnect occurred.	USB	3	NXP
 Set EDC field to two breaks, which continues the burst access to  external memory. 	A burst write  access will miss the  first word when the  burst write follows  another burst  operation	bo57815	ARM9	0M72J	 	MCIMX27	 No fix planned	Description:  When a burst access to WEIM external memory is immediately  followed by another burst access, the first word may be missed at  write-burst access because the eb_b signal comes too late.  Reason:  The ecb_hburst_ecb_fw signal in the WEIM Bus Controller  module has an extra-high pulse, and only one high pulse is  required. 	 WEIM 	3	NXP
â¢Set the Latency Hiding Disable (LHD) bit in the ESDCTL DDR Controller ESDMISC register. This adds latency between DDR transactions, removing the ideal data throughput. This should only be done during MPEG-4 encoding and decoding. Note that this reduces performance. During MPEG-4 encoding/decoding, this degradation is acceptable. LHD should not be set during H.264 or H.263 operation. â¢Assign all buffers accessed by the video code into the same DRAM bank and ensure every buffer type has a size of integer number of pages. This ensures that there is a page miss between accesses of different sub-masters inside the VPU, increasing the delay. The DRAM is split into four equal sizes called banks, so the bank size is 1/4 of the DRAM size.	Lockup of Video Codec in MPEG-4 encode or decode Note: Applies only to silicon revision 2.0	bo93263	ARM9	0M72J	 	MCIMX27	Fixed in silicon revision 2.1	Description: During encoding or decoding MPEG-4, the Video Codec module can lock up. In the combined AXI to AHB and 32â64 gasket, there is a FIFO for read data, which buffers data that is coming from the 64-bit bus faster than the 32-bit bus can accept it. There is no logic to send a request to memory only when the FIFO has room for return data. In a case with ideal data throughput, this FIFO overruns and read data is corrupted. This ideal data throughput only happens during MPEG-4 encoding and decoding.	â¢Video â¢Codec	2	NXP
 None 	Boundary scan  fails because of an  internal timing issue.  Note: Applies only to  silicon revision  2.0	bo93708	ARM9	0M72J	 	MCIMX27	 Fixed in silicon revision 2.1	Description:  Timing is not properly extracted for the boundary scan circuitry so  post-layout gate-level simulations did not correctly simulate the  circuit. A race condition prevents proper shifting of data through  the Boundary Scan circuitry. 	 JTAG Controller 	3	NXP
It is recommended to power up and power-down the processor following the power-up and power-down sequence documented in the MCIMX27 Multimedia Applications Processor Data Sheet.	When the incorrect power-up or power-down sequence is used on the processor, unintentional programming of IIM fuses is possible, regardless of the set FuseVDD voltage, reconfiguring the part permanently.	bo95933	ARM9	0M72J	 	MCIMX27	No fix planned	Description: Internal fuses on the processor could be unintentionally programmed, regardless of the voltage level set for FuseVDD. Even if FuseVDD is set to 1.8 V (read-only voltage), some processors may be programmed at that voltage. This only happens when the incorrect power-up or power-down sequence is used on the processor.	IIM	2	NXP
Use software for horizontal resizing when the scale is bigger than two. For example, when the scale is 2.5 for both horizontal and vertical, software should be used to produce the horizontal resize with scale 2, and the Post Processor should do the vertical 2.5 and horizontal 1.25 resize.	Resize fails when the horizontal scale is bigger than two.	â	ARM9	0M72J	 	MCIMX27	No fix planned	Description: The gasket that is between the Post Processor and the EMI cannot support burst accesses when the burst length is equal to or over 16 words. However, the Post Processor will do the burst access over 16 words when it resizes with the horizontal scale over 2. In this case, the Post Processor's access misses the data or will be pending due to no response from the gasket.	eMMA PP (Post Processor)	2	NXP
 Set AUSx to 0, if address bit A[23] is needed to address the  external device. 	AUSx bits do not  work for address bit  A[23].  Note: The AUS feature  is not only for  ADDR[25:16]  (Address Bus  MSB), but also  for ADDR[15:0]  (Multiplexed  Address Bus  LSB)	ENGcm11270	ARM9	0M72J	 	MCIMX27	 No fix planned	Description:  The AUS bits in the WEIM Configuration Register (WCR) do not  work for the address bus bit A[23]. The WEIM address busâ most  significant bits (ADDR[25:16], Address Bus MSB) are used for  address bits [25:16]. If the corresponding AUSx bit (each WEIM  chip select has a corresponding AUS bit) is set to 1 in the WCR  register, then these MSB signals reflect the AHB address bits  [25:16]. If the AUSx bit is set to 0, then these signals should  represent AHB address bits [27:18] for word width memory,  [26:17] for half word width memory, and [25:16] for byte-width  memory. The error occurs when the AUSx bit is set to 1, which  causes the A[23] bit to not match the correct value of the  corresponding AHB address bit.  Reason:  This errata affects all Chip-Select regions (that is, CS0âCS5). You  cannot use the WEIM AUS feature to use un-shifted address  mode if address bit A[23] is needed to address the external  memory device. 	 WEIM 	3	NXP
 If external device asserts ECB_B signal during burst access in  FCE = 1 mode, use FCE = 0 mode instead. 	In FCE = 1  mode, WEIM cannot  correctly sample the  data if there is ECB  asserted during burst  access	ENGcm11409	ARM9	0M72J	 	MCIMX27	 No fix planned	Description:  End current burst (WAIT). This active-low input signal ECB is  asserted by external burst capable devices. It is serviced only in  synchronous mode (SYNC = 1).This signal can be used in the  following modes depending on the EW bit in the Chip Select  Control Register.  â¢ In the ECB mode (EW = 0), ECB indicates the end of the  current (continuous) burst sequence. Following assertion, the  WEIM terminates the current burst sequence and initiates a  new one.  â¢ In the WAIT mode (EW = 1), the memory device asserts this  signal to insert WAIT states during refresh collisions or during  a row boundary crossing. Following assertion, the WEIM does  not terminate the current burst sequence and continues it once  WAIT is negated.  FCE is a parameter in the register CSCRxA that is used to enable  or disable feedback clock:  â¢ If FCE = 0, WEIM samples the data by internal AHB bus clock.  â¢ If FCE = 1, WEIM samples the data by BCLK_FB signal that is  from PAD.  â¢ If FCE is configured to 1 and there is ECB assertion during  access, WEIM does not sample the correct data.  Reason:  You cannot use FCE = 1 mode when there is ECB assertion  during access. 	 WEIM 	2	NXP
 There are both a hardware and a software workaround. To  guarantee correct operation, the software workaround should  only be applied to devices that have had the new PLL test applied.  The test will be applied from a date code 1105:  â¢ Workaround 1âHardware:  Keep MPLLVDD < 200 mV during the initial part of the power-up  sequence and delay the MPLLVDD supply with respect to QVDD,  NVDD5, and AVDD. See Figure 1 for a recommended power-up  sequence. This workaround sets the uninitialized node to the  correct state enabling the appropriate 399 MHz clock output duty  cycle. For the clock switching errata workaround, the following  conditions must be satisfied:  â QVDD must be powered up before MPLLVDD.  â NVCC5 must be powered up before MPLLVDD. (This is  required for the POR_B signal to propagate to the clock  gating logic.)  â AVDD must be powered up before MPLLVDD. (This is  required for the POR_B signal to propagate to the clock  gating logic.)  â MPLLVDD must be driven to 0, not floating, before  powering up  A suggested delay circuit is described in Figure 2.  â¢ Workaround 2âSoftware:  Originally for the ARM clock to work at 400 MHz, the MPLL is  configured for 800-MHz operating frequency at the 2x Clock Port  (see Figure 3 and code that follows the figure), and the DIV2  divider is selected by software to achieve the 400-MHz operating  frequency at the ARM core. The default 266-MHz frequency is  achieved by using the DIV3 divider with an 800-MHz frequency at  the 2x Clock Port (so 400-MHz MPLL frequency).  The intent of this workaround is to reconfigure the 2x Clock Port  to 1.2 GHz (600-MHz MPLL frequency), and continue to use the  DIV3 divider in order to achieve the 400-MHz operating  frequency. This avoids switching to the DIV2 divider, which  introduced the problem. 	Boot problem  due to improper clock  duty cycle  Note: Systems that  use 266 MHz are  not affected by  this bug.	ENGcm11563	ARM9	0M72J	 	MCIMX27	 No fix planned.	Description:  There is a design errata in the i.MX27 PLL/DIV design, which  causes the ARM_CLK to have an incorrect duty cycle. The root  cause of this issue is due to an uninitialized node in the PLL, clock  gating, and divider circuitry, so the probability of this issue is  random. This error causes the ARMâ¢ and DDR clocks duty cycle  to be 66% when they are running at 266 MHz and 75% when at  399 MHz, instead of 50%.  Projected Impact:  The result of the incorrect duty cycle of the clock is that the ARM  core might halt. This issue affects systems that enable 399 MHz  for the ARM core. 	PLL 	2	NXP
The SPCTL0 register needs to be re-programmed after each read access: either with a new value, or with the same value that was just read.	Read access to Clock Controller SPCTL0 register clears it	TLSbo94561	ARM9	0M72J	 	MCIMX27	Fixed in silicon revision 2.1.	Description: Any read access from the Clock Controller Module SPCTL0 register will clear the contents of the register. Projected Impact: For silicon revision 2.0 and prior, any read access performed from the Clock Controller Module SPCTL0 register will clear the contents of the register.	CCM	2	NXP
Connect LSCLK directly with LCD panel, if the LCD panel allows it.	LSCLK is missing	TLSbo95476	ARM9	0M72J	 	MCIMX27	No fix scheduled.	Description: In 4 bpp, 8 bpp, 18 bpp, and TFT modes, LSCLK is missed in these conditions: â¢One clock cycle before every OE_ACD assert timing â¢Every VSYNC rising timing â¢Every VSYNC falling timing Projected Impact: If the user connects LSCLK directly with LCD panel and the LCD panel allows missing clock, then, there is no issue. However, if the user adds a serializer between LSCLK and LCD panel, then, the serializer may not work correctly because of missing clock and the LCD panel may have noise.	LCDC	2	NXP
 Make sure either of the following two conditions are satisfied  when MPLL is restarted:  â¢ ARMSRC == 1 and ARMDIV[1:0] == 00  or  â¢ ARMSRC == 0 and ARMDIV=[1:0] == 00 AND MPLL 2x 	MPLL restart  limitation. Applies only  to silicon rev. 2.2.	ENGcm12387	ARM9	0M72J	 	MCIMX27		Description:  There is a limitation in the i.MX27 CCM module of the latest i.  MX27 silicon (rev 2.2). This limitation requires that the MPLL can  only be restarted under the following conditions:  â¢ CSCR register bit fields: ARMSRC == 1 and ARMDIV[1:0] ==  00 (meaningARM_CLK is divided by 2 from MPLL_CLK)  or  â¢ CSCR register bit fields ARMSRC == 0 and ARMDIV[1:0] ==  00 (meaning ARM_CLK is divided by 3) and MPLL 2x output is  greater than 537 MHz.  The ARMSRC and ARMDIV bits can be configured to any value  required by the application immediately after the MPLL restart. 	PLL 	2	NXP
 1) Reconfigure the MPLL prior to a warm reset to avoid  exceeding the 1.2-GHz maximum MPLL output frequency. This  workaround only works when warm resets can be anticipated.  2) In applications that cannot anticipate a warm reset, as in the  case of RESET_IN from somewhere else in the system or a  watchdog timeout, the MPLL should be operated at a sufficiently  lower frequency so as to prevent a warm reset causing the MPLL  to exceed 1.2 GHz.  3) The CLKMODE[1:0] pads may be used to bypass the FPM and 	MPLL reference  clock source change  following a warm reset.	ENGcm12388	ARM9	0M72J	 	MCIMX27		Description:  A âwarmâ reset is a reset initiated by a watchdog timeout,  RESET_IN, or by software forcing a reset via the watchdog  module. Such a reset will reconfigure all the CCM registers to  their default values but it will not restart the MPLL, so the full CCM  configuration defined by the registers does not take effect. In  particular, MCU_SEL is cleared, selecting the internal FPM  output. Changes to ARMSRC and ARMDIV also take immediate  effect. As a consequence, if the external high frequency reference  clock is slower than the internal FPM output, and the MPLL has  been configured to operate at 1.2 GHz, the MPLL will exceed the  specified limite of 1.2 GHz. For example: Given an external high  frequency clock of 24 MHz, a low frequency clock of 32 kHz, and  the MPLL configured for 1.2 GHz (MF=50) using the external  24-MHz clock as the reference, the following will occur: After a  warm reset, the MPLL will continue using MF=50, because the  CCM registers are reset to default values but the PLLs are not  restarted. As a result, the MPLL will lock to the FPM output  (32.768 MHz, selected by the default value of MCU_SEL in  CSCR), driving MPLL output frequency to 1.64 GHz, which is  beyond the specified maximum. 	PLL 	2	NXP
"Always write the HW_PXP_CSCCOEFF2_C3 register with the expected value before using it. The PXP_CSCCOEFF2 register address is 0x8002A0F0."	"PXP: The HW_PXP_CSCCOEFF2_C3 register can not be reset correctly under some PVT corner"	ENGR116904	ARM9	 	 	IMX28	No fix scheduled	"The HW_PXP_CSCCOEFF2_C3 register does not receive the correct reset value after using the PXP software reset function or after power up.The PXP operates incorrectly with wrong coefficient setting."	PXP	 	NXP
Set SBUSCFG.AHBBRST of the USB register to a modes other than 0b010 or 0b011.	 USB: USB core INCR8 and INCR16 modes are inoperable	ENGR119650	ARM9	 	 	IMX28	No fix scheduled	"The USB controller may not operate properly when receiving a packet in INCR8 and INCR16 modes. The packet is completed correctly (ACK is sent) on the USB bus, but cannot be seen by software. This issue exists when all of following conditions are met: 1. Controller is receiving data (Host Bulk IN or Device Bulk OUT) 2. Primary INCR8/INCR16 mode is selected (SBUSCFG. AHBBRST of the USB register is set to 0b010 or 0b011) 3. Length of data received is less than the total_byte field in TD 4. Data length is not a multiple of the burst size and the remainder is a sub-burst. For example, if the data length is 32n + 16 bytes in INCR8 mode, or 64n + 16/32/48 in INCR16 mode, this errata is triggered. Projected Impact: This is a low severity bug because INCR8 and INCR16 are not mandatory modes. Other modes should be used."	USB	 	NXP
All USB register write operations must use the ARM SWP instruction.	USB: ARM to USB register error issue	ENGR119653	ARM9	 	 	IMX28	No fix scheduled	"The ARM writes a data error to the USB core register unless SRM SWP instruction is used. The issue occurs when all of the following conditions are met: 1. Last AHB access is to the non-USB AHB slave 2. Current AHB access is to the USB 3. These two accesses are back-to-back 4. The last data phase of the last AHB access has a wait state 5. Only happens when D-cache is enabled Projected Impact: The USB register does not get correct data when writing to the USB slave through the AHB bus when D-cache is enabled"	USB	 	NXP
"If the HSADC input clock is lower than the 24 MHz APBX bus clock the APBX bus clock should be set to a lower frequency before every write to the PWM register. When the write access finishes, the APBX clock can be set back to normal."	"PWM: Register write sync issue when HSADC clock frequency is lower than APBX clock frequency"	ENGR119657	ARM9	 	 	IMX28	No fix scheduled.	"The PWM channel might not generate the required output signal when in HSADC driving mode. When in HSADC mode, if the HSADC input clock is much lower than the APBX bus clock (for example APBX Bus clock is 24 MHz and HSADC input clock is 4 MHz) the write signal to the PWM registers is missed. Write access to the following registers has no effect after HSADC mode is enabled: â¢ PWM Control and Status Register â¢ PWM Channel Active Register â¢ PWM Channel Period Register As a result, dedicated PWM channel is not triggered. Projected Impact: HSADC or off chip linear sensor does not receive the required control signals."	PWM	 	NXP
"When communicating with the Ethernet controller, an additional byte-swap routine has to be called by the ARM core."	ENET: ENET big endian mode not compatible with ARM little endian	ENGR121613	ARM9	 	 	IMX28	No fix scheduled.	"The endian mode of the Ethernet controller is designed to be big-endian mode which is not compatible with the ARM core and reset sections of the device. Projected Impact: The ARM core cannot establish data communication correctly to/from the Ethernet controller without software endian conversion."	ENET	 	NXP
"Do not use DMA PIO operation to configure the associated peripheral when using channel freeze function. Use ARM PIO operation instead."	"DMA: APBH/APBX DMA channel can stall while waiting to access a APBH/APBX bus peripheral when the channel freeze bit is set"	ENGR121616	ARM9	 	 	IMX28	No fix scheduled	"When the channel freeze bit is set, the APBH/APBX DMA channel can stall while waiting to access a peripheral on the APBH/APBX bus. This occurs if the channel freeze bit is set exactly at the same time as when the channel internal state machine changes from the PIO_REQ state to the REQ_WAIT state. Projected Impact: The data communication with the APBH/APBX DMA channel associated peripheral is stalled."	DMA	 	NXP
"Instead of aborting the transmission, use deactivation instead. Note that there is a chance the deactivated TxMB can be transmitted without setting IFLAG and updating the CODE field if it is deactivated."	FlexCAN: Abort request blocks the CODE field	ERR002656	ARM9	 	 	IMX28	No fix scheduled	"An Abort request to a transmit message buffer (TxMB) can block any write operation into its CODE field. Therefore, the TxMB cannot be aborted or deactivated until it completes a valid transmission (by winning the CAN bus arbitration and transmitting the contents of the TxMB). Projected Impact: The TxMB cannot be aborted or deactivated until it completes a valid transmission."	FlexCAN	 	NXP
"It is recommended that one of the following actions be taken to avoid problems: â¢ Do not enable the RxFIFO. If CANx_MCR[FEN]=0 then the Rx FIFO is disabled and thus the masks RXGMASK, RX14MASK and RX15MASK do not affect it. â¢ Enable Rx Individual Mask Registers. If the Backwards Compatibility Configuration bit in the FlexCAN Module Configuration Register (CANx_MCR[BCC], bit 16) is set then the Rx Individual Mask Registers (RXIMR0-63) are enabled and thus the masks RXGMASK, RX14MASK and RX15MASK are not used. â¢ Do not use the masks RXGMASK, RX14MASK and RX15MASK (leave them in reset value which is 0xffff_ffff) when CANx_MCR[FEN]=1 and CANx_MCR[BCC]=0. In this case, filtering processes for both RxMBs and Rx FIFO are not affected by those masks. â¢ Do not configure any MB as Rx (leave all MBs as either Tx or inactive) when CANx_MCR[FEN]=1 and CANx_MCR[BCC]=0. In this case, the masks RXGMASK, RX14MASK and RX15MASK can be used to affect ID tables without affecting filtering process for RxMBs."	FlexCAN: Global Masks misalignment	ERR002360	ARM9	 	 	IMX28	No fix scheduled	"During CAN message reception by FlexCAN, the RXGMASK (Rx Global Mask) is used as an acceptance mask for most of the Rx message buffers (MB). When the FIFO Enable bit in the FlexCAN Module Configuration Register (CANx_MCR[FEN], bit 29) is set, the RXGMASK also applies to most of the elements of the ID filter table. However, there is a misalignment between the position of the ID field in the RxMB and that in the RXIDA, RXIDB and RXIDC fields of the ID tables. In fact, the RXIDA filter in the ID tables is shifted one bit to the left from the RxMBs ID position, as shown below: RxMB ID = bits 28-0 of ID word corresponding to message ID bits 28-0 RXIDA = bits 29-1 of ID Table corresponding to message ID bits 28-0 Note that the mask bits align to the ID filter bits, not to the incoming ID bits. For example, the bit 4 in RXGMASK masks bit 4 in RxMB ID, but it does not mask bit 4 in incoming message ID. This misalignment leads the RXGMASK to affect RxMB and Rx FIFO filtering in different ways. For example, if the user intends to mask out bit 4 of the ID filter of message buffer then the RXGMASK will be configured as 0xffff_ffef. As a result, bit 4 of the ID field of the incoming message is ignored during the filtering process for message buffers. This very same configuration of RXGMASK, which would lead bit 4 of RXIDA to be âdo not careâ and thus bit 3 of the ID field of the incoming message would be ignored during the filtering process for the Rx FIFO. Similarly, both RXIDB and RXIDC filters have multiple misalignments with regards to position of the ID field in the RxMBs, which can lead to erroneous masking during the filtering process for either Rx FIFO or MBs. RX14MASK (Rx 14 Mask) and RX15MASK (Rx 15 Mask) have the same structure as the RXGMASK. This includes the misalignment problem between the position of the ID field in the RxMBs and in the RXIDA, RXIDB and RXIDC fields of the ID Tables. Leading to mask misalignment between RxMB and Rx FIFO filtering."	FlexCAN	 	NXP
If cpu_ref is inactive, then activate the cpu_ref before attempting to switch to synchronous mode.	EMI Clock: Switching to synchronous mode error	2765	ARM9	 	 	IMX28	No fix scheduled	"In order to switch the EMI clock from asynchronous to synchronous mode, both the xtal_ref and the cpu_ref must be active, even if both BYPASS_CPU and BYPASS_EMI are set in the HW_CLKCTRL_CLKSEQ register. Projected Impact: The i.MX28 locks up."	EMI Clock	 	NXP
"Postpone freeing the current dTD; free it when its next dTD can be freed, so the last completed dTD (followed by an ACTIVE dTD) is always freed when the next IOC irq comes."	"USB controller may access a wrong address for the dTD (endpoint transfer descriptor) and then hangs"	2858	ARM9	 	 	IMX28	No fix scheduled	"Currently, software checks the active bit in dTD to see whether it is finished. If the Active bit is 0, then software frees the allocated memory for the dTD. The hardware sequence after all data of a dTD is transferred is as follows: 1. Update the dTD. This includes an AHB write access of three DWords. The active bit is cleared in the first DW write. 2. Update the qHead (this includes an AHB write access of three DWords). 3. Read the dTD again to check if software added a new dTD (this is a SINGLE AHB read). At the same time, send out an interrupt if needed. After step 1, if software finds the Active bit is cleared, then the dTD memory space is freed and may be allocated for another threadâs use. In step 3, hardware may get a wrong dTD. This issue does not occur if some delay is added before freeing the dTD memory space. This issue only occurs in USB INCR8 mode, because steps 1 and 2 have 6 SINGLE AHB transfers in INC8 mode, but only two burst AHB transfers in INCR mode. This issue only occurs when the dTD list is used; because if only one dTD is used, the software only checks the Active bit after an interrupt is received (step 3). However, when the dTD list is used, the software may check the entire list after the interrupt for the first dTD is received, when the hardware has just finished the transfer of the second dTD. Projected Impact: USB Controller may hang if dTD is freed too quickly."	USB	 	NXP
"In order to power down the system properly when 5 V is removed, set PWDN_5VBRNOUT bit in Register HW_POWER_5VCTRL."	"The DCDC converters unexpectedly turn on when 5 V is removed while the DCDC_XFER bit is clear"	2814	ARM9	 	 	IMX28	No fix scheduled	"If the DCDC_XFER bit is clear, the DCDC converter should not automatically turn on when 5 V is removed. Instead, a power-down should occur if 5 V is removed, when DCDC_XFER and ENABLE_DCDC are zero. Projected Impact: DCDC converter input source may switch to DCDC_BATT pin but no power source is present there. This may latch-up the DCDC converter circuit."	DCDC	 	NXP
"Use the VBUSVALID comparator for 5V plug/unplug detection. Actually, the VBUSVALID comparator is recommended in the reference manual, not VDD5V_GT_VDDIO. The VBUSVALID_5VDETECT bit in HW_POWER_5VCTRL should be set to â1â (itâs default value) and never cleared. The detection threshold can be changed in the VBUSVALID_TRSH bit field in HW_POWER_5VCTRL."	Unreliability of VDD5V_GT_VDDIO functionality	2811	ARM9	 	 	IMX28	No silicon fix scheduled.	"Due to unreliability of the VDD5V_GT_VDDIO functionality, the power supply should never be configured to be used as the 5-V plug/unplug detection method. Projected Impact: VDD5V_GT_VDDIO output may not change to â0â (and VDD5V_GT_VDDIO_IRQ may not be triggered) when 5 V is unplugged."	VDD5V_GT_VDDIO	 	NXP
"If tISU at SD/MMC/eMMC input is violated and write command error occurs during boot from SD/MMC/eMMC, a ROM patch of 1kByte size loaded from the EEPROM is required to fix this issue. Boot mode should be set to [0001] for the EEPROM on I2C0 or [1000] for the EEPROM on SPI3. The patch executes from the EEPROM, patches the ROM SSP driver code, and switches boot to either SSP0 or SSP1. There are separate patch binaries to boot from SSP0 and SSP1."	SSP0/1-SD/MMC/eMMC Boot: SSP_SCK polarity setup issue in ROM	TKT131240	ARM9	 	 	IMX28	No silicon fix scheduled.	"When boot mode is set as boot from SD/MMC/eMMC on SSP0/1, the SSP_SCK polarity is not correctly set up in ROM. The POLARITY bit in HW_SSP_CTRL1 register should be set to â1â (command and data output on falling edge of clock) according to SD/MMC/eMMC specification. However, the POLARITY bit is set to â0â in ROM in the existing silicon (TO1.2). As a result, input setup time (tISU) at SD/MMC/eMMC input may not be met. Projected Impact: Write command error may occur when booting from the SD/MMC/eMMC on SSP0/1 and result in boot failure."	SSP0/1-SD/MMC/eMMC Boot	 	NXP
"The sequence below is needed to work around this issue prior to setting the ENABLE_DCDC bit in HW_POWER_DCDC4P2: 1. Disable the power rail brownout interrupts (clear HW_POWER_CTRL VDDA, VDDD, VDDIO ENIRQ bits). 2. Set the HW_POWER_5VCTRL PWRUP_VBUS_CMPS bit. 3. Set the HW_POWER_5VCTRL VBUSVALID_TRSH to 0x0 (2.9 V). 4. Set the HW_POWER_5VCTRL VBUSVALID_5VDETECT bit to 1. 5. Disable VBUSDROOP status and interrupts (clear VDD5V_DROOP_IRQ). 6. Set the ENABLE_DCDC bit in HW_POWER_DCDC4P2. 7. Wait 100 Âµs 8. Check VBUSVALID_IRQ bit. If it is set, then set and clear the PWD_CHARGE_4P2 bit to repower on the 4P2 regulator because it is automatically shut off on a VBUSVALID false condition. It may be helpful to ramp up the CHARGE_4P2_ILIMIT value at this point to gradually draw power from 5 V rail. If HW_POWER_5VCTRL ENABLE_DCDC is already set, the DCDC will draw current from VDD4P2 as soon as PWD_CHARGE_4P2 is cleared. 9. Clear VBUSDROOP, VBUSVALID, and the output rails IRQ bits as needed. 10. Restore the output rail ENIRQ bits, the VBUSVALID_TRSH level, VBUSVALID_5VDETECT value, ENIRQ_VBUS_VALID, and ENIRQ_VDD5V_DROOP to their original values. The sequence below is needed to work-around this issue prior to setting the ENABLE_DCDC bit in HW_POWER_5VCTRL and HW_POWER_DCDC4P2. Note that the below workaround assumes the usual requirements for setting the HW_POWER_5VCTRL ENABLE_DCDC bit are met (that is, the hardware and/or software battery brownout protection mechanism is enabled to properly protect the system against the DCDC sourcing from the battery if the battery voltage is too low). 1. Disable the power rail brownout interrupts (clear HW_POWER_CTRL VDDA, VDDD, VDDIO ENIRQ bits). 2. Set the HW_POWER_5VCTRL PWRUP_VBUS_CMPS bit. 3. Set the HW_POWER_5VCTRL VBUSVALID_TRSH to 0x0 (2.9 V). 4. Set the HW_POWER_5VCTRL VBUSVALID_5VDETECT bit to 1. 5. Disable VBUSDROOP status and interrupts (clear VDD5V_DROOP_IRQ). 6. Set the ENABLE_DCDC bit in HW_POWER_5VCTRL. 7. Wait 100 Âµs. 8. Check VBUSVALID_IRQ bit. If it is set, and 5 V is present and the VDD4P2 rail was enabled, then repeat the sequence for enabling the 4P2 regulator and DCDC from VDD4P2. This bit indicates that the DCDC has tried to source from the battery, even if 4P2 sourcing is enabled. This is because a VBUSVALID false condition automatically disables the 4P2 regulator, so the DCDC then falls back to battery sourcing. 9. Clear VBUSDROOP, VBUSVALID, and the output rails IRQ bits as needed. 10. Restore the output rail ENIRQ bits, the VBUSVALID_TRSH level, VBUSVALID_5VDETECT value, ENIRQ_VBUS_VALID, and ENIRQ_VDD5V_DROOP to their original values."	Setting the ENABLE_DCDC bit in the HW_POWER_DCDC4P2 or HW_POWER_5VCTRL registers can result in false brownout Detection	5837	ARM9	 	 	IMX28	No silicon fix scheduled	"When the ENABLE_DCDC bit in HW_POWER_DCDC4P2 or HW_POWER_5V_CTRL is set, a glitch is propagated through the brownout comparators. If the glitch is sufficiently large, it can cause a false brownout detection. The VDDD, VDDA, VDDIO, and VBUSVALID comparators are all susceptible to the glitch. Projected Impact: Can result in a false brownout detection."	ENABLE_DCDC	 	NXP
"Contact ONFI NAND vendor to supply NAND device with the âsupports extended parameter pageâ bit set to â0â, so that the i.MX28 boot ROM will not treat it as BA-NAND."	ONFI 3.0 NAND boot-up issue	TKT140334	ARM9	 	 	IMX28	No silicon fix scheduled.	"ROM in existing silicon (TO1.2) supports ONFI BA-NAND boot-up. During boot-up it reads Bit 7 of Byte 6-7 (1=supports Block Abstracted access mode) in ONFI NAND deviceâs parameter page to determine if the NAND device is ONFI BA-NAND. BA-NAND memory devices are no longer part of the ONFI spec and memory vendors do not support these devices anymore. However in ONFI 3.0 Spec, that bit has been re-used to specify whether the NAND device supports extended parameter page. When a system is mounted with ONFI 3.0 NAND device with âsupports extended parameter pageâ bit set to â1â, the i.MX28 boot ROM will see it as BA-NAND and will use BA-NAND commands to access the NAND device. As a result, the system will fail to boot-up. Projected Impact: System mounted with ONFI 3.0 NAND device will fail to boot-up."	ONFI	 	NXP
"The Ethernet 1588 clock can be gated off by clearing the HW_CLKCTRL_ENET_DIV_TIME register. The HW_CLKCTRL_ENET_DIV_TIME register address is 0x80040140."	"CLKCTRL: ENET 1588 clock (CLK_ENET_TIME) is not under control of ENET disable control bit"	ENGR119956	ARM9	 	 	IMX28	No fix scheduled	The Ethernet 1588 clock (CLK_ENET_TIME) continues to toggle when the Ethernet module is disabled by setting ENET disable control bit in the HW_CLKCTRL_ENET register. The ethernet controller consumes 30 ?A on the 4.2 V power supply. Projected Impact: The Ethernet 1588 clock consumes 30 ?A on the 4.2 V power supply when the Ethernet module is disabled.	CLKCTRL	 	NXP
None	43.1.1.1 ADC: DRDY Bit Cleared	 	ARM9	 	 	SAM9260	Not fixed	The DRDY Flag should be clear only after a read of ADC_LCDR (Last Converted Data Register). A read of any ADC_CDRx (Channel Data Register) automatically clears the DRDY ï¬ag.	Analog-to-digital Converter (ADC)	 	Atmel
None	43.1.1.2 ADC: DRDY not Cleared on Disable	 	ARM9	 	 	SAM9260	Not fixed	When reading LCDR at the same instant as an end of conversion, with DRDY already active. DRDY is kept active regardless of the enable status of the current channel. This sets DRDY, whereas new data is not stored.	Analog-to-digital Converter (ADC)	 	Atmel
Use of DRDY functionality with access to CDR registers should be avoided.	43.1.1.3 ADC: DRDY Possibly Skipped due to CDR Read	 	ARM9	 	 	SAM9260	Not fixed	"Reading CDR for channel ""yâ at the same instant as an end of conversion on channel ""xâ with EOC[x] already active, leads to skipping to set the DRDY ï¬ag if channel ""x"" is enabled."	Analog-to-digital Converter (ADC)	 	Atmel
None.	43.1.1.4 ADC: Possible Skip on DRDY when Disabling a Channel	 	ARM9	 	 	SAM9260	Not fixed	I: u DRDY does not rise when disabling channel y at the same time as an end of âxâ channel conversion, although data is stored into CDRx and LCDR.	Analog-to-digital Converter (ADC)	 	Atmel
None 790 SAM926O [DATASHEET] AtmeL Almel-6221 M-ATARM-SAMQZSO-DatasheetJ 3-Jan-16	43.1.1.5 ADC: GOVRE Bit is Not Updated	 	ARM9	 	 	SAM9260	Not fixed	Read of the Status Register at the same instant as an end of conversion leads to skipping the update of the GOVRE (general overrun) ï¬ag. GOVRE is neither reset nor set. For example, if reading the status while an end of conversion is occurring and: 1. GOVRE is active but DRDY is inactive, does not correspond to a new general overrun condition but the GOVRE ï¬ag is not reset. 2. GOVRE is inactive but DRDY is active, does correspond to a new general overrun condition but the GOVRE ï¬ag is not set.	Analog-to-digital Converter (ADC)	 	Atmel
None	43.1.1.6 ADC: GOVRE Bit is Not Set when Reading CDR	 	ARM9	 	 	SAM9260	Not fixed	"When reading CDRy (Channel Data Register y) at the same instant as an end of conversion on channel ""xâ with the following conditions: 0 EOC[x] already active, 0 DRDY already active, 0 GOVRE inactive, 0 previous data stored in LCDR being neither data from channel â"",y nor data from channel âx"". GOVRE should be set but is not."	Analog-to-digital Converter (ADC)	 	Atmel
None	43.1.1.7 ADC: GOVRE Bit is Not Set when Disabling a Channel	 	ARM9	 	 	SAM9260	Not fixed	"When disabling channel ây"" at the same instant as an end of conversion on channel âxâ, EOC[x] and DRDY being already active, GOVRE does not rise. Note: OVRE[x] rises as expected."	Analog-to-digital Converter (ADC)	 	Atmel
None	43.1.1.8 ADC: OVRE Flag Behavior	 	ARM9	 	 	SAM9260	Not fixed	When the OVRE ï¬ag (on channel i) has been set but the related EOC status (of channel i) has been cleared (by a read of CDRi or LCDR), reading the Status register at the same instant as an end of conversion (causing the set of ECG status on channel i), does not lead to a reset of the OVRE ï¬ag (on channel i) as expected.	Analog-to-digital Converter (ADC)	 	Atmel
Do not take into account the E00 of a disabled channel	43.1.1.9 ADC: EOC Set Although Channel Disabled	 	ARM9	 	 	SAM9260	Not fixed	If a channel is disabled while a conversion is running and if a read of CDR is performed at the same time as an end of conversion of any channel occurs, the ECG of the channel with the conversion running may rise (whereas it has been disabled).	Analog-to-digital Converter (ADC)	 	Atmel
None.	43.1.1.10 ADC: Spurious Clear of EOC Flag	 	ARM9	 	 	SAM9260	Not fixed	"If âx"" and ""yâ are two successively converted channels and ""zâ is yet another enabled channel (""2â being neither âx"" n I: nor âyâ), reading CDR on channel â2"" at the same instant as an end of conversion on channel y automatically clears EOC[x] instead of EOC[z]."	Analog-to-digital Converter (ADC)	 	Atmel
To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit ï¬eld); to start an analog-toâdigital conversion, in order put ADC into sleep mode at the end of this conversion. AtmeL SAM926O [DATASHEET] 791 AtmeIâ6221M-ATARM-SAMQZSO-Datasheet_13-Jan-16 43.1.2 Boot ROM	43.1.1.11 ADC: Sleep Mode	 	ARM9	 	 	SAM9260	Not fixed	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	Analog-to-digital Converter (ADC)	 	Atmel
Use DataFlash Boot or external memory on EBI_NCSO.	43.1.2.1 NAND Flash Boot Does Not Work Correctly	 	ARM9	 	 	SAM9260	Not fixed	"The SMC_SETUP register for the NAND Flash Chip Select (NCS3) is not initialized correctly in the ROM code. NRD_SETUP is initialized to ""0"" which leads to a violation of parameters tAR and tCLR. The following commands are concerned; READ ID (0x90), READ STATUS (0x70), PAGE READ (0x00, 0x30) and RANDOM DATA READ (0x05, OxEO)."	Boot ROM	 	Atmel
Boot on an external memory connected on CSO (BMS = 0).	43.1.2.2 Problem with RTI'	 	ARM9	 	 	SAM9260	Not fixed	The Real-time Timer is reset by the BootROM after each power up. This prevents using the RTT as a backed up real-time clock.	Boot ROM	 	Atmel
Writing the URSTEN bit to 0 in RSTC_MR disables the User Reset trigger. 43.1.3 Bus Matrix	43.1.2.3 User Reset trigger is enabled by default	 	ARM9	 	 	SAM9260	Not fixed	The boot ROM program configures the NRST pin as an input, and programs the User Reset length. As RSTC registers are powered by VDDBU, the settings are saved and ovenNrite the user conï¬guration.	Boot ROM	 	Atmel
None. 43.1 .4 EMAC	43.1.3.1 Bus Matrix Master Conï¬guration Register 5	 	ARM9	 	 	SAM9260	Not fixed	MATRIX_MCFG5 is write-only. The value written is effective but not readable.	Bus Matrix	 	Atmel
Reduce re-arbitration time between RX & TX EMACB transfers by using internal SRAM (or another memory slave with a short access time) to transmit buffers and descriptors. 43.1.5 IIO Considerations	43.1.4.1 EMAC: TX Underrun May Occur in Some Cases	 	ARM9	 	 	SAM9260	Not fixed	"EMACB FIFO internal arbitration scheme is: 1. Receive buffer manager write Receive buffer manager read Transmit data DMA read Receive data DMA write Transmit buffer manager read 6. Transmit buffer manager write 91:59!"" EMACB master interface releases the AHB bus between two transfers. EMACB has the highest priority. If EMACB RX and TX FlFOs both have pending requests, the following sequence occurs: 1. EMACB RX FIFO write (burst 4) 2 EMACB releases the AHB bus 3. The AHB matrix can grant an another master (ARM | or D for example) 4 AHB matrix re-arbitration (finishes at least the current word/halfword/byte) 792 SAM926O [DATASHEET] AtmeL Almel-6221 M-ATARM-SAMQZSO-DatasheetJ 3-Jan-16 5. The AHB matrix grants the EMACB 6. The EMACB TX FIFO read (burst 4) In case of a slow memory and/or a special operation like SDRAM refresh or SDRAM bank opening, a TX underrun may occur. (latency min 960 ns)."	Bus Matrix	 	Atmel
It is strongly recommended: 0 to place the memories connected to the EBI as close as possible to the SAM9260 on the PCB o to route all the EBI signals with a series resistor, typical value 33 ohms o to adjust the series resistor value with tools taking into account the IBIS model of the pads and the characteristics of the wires of the PCB, in order to guarantee rise and fall times as long as timings permit. 43.1.6 MCI	43.1.5.1 IIO High Drive Strength	 	ARM9	 	 	SAM9260	Not fixed	The I/O output buffer drive is too high to guarantee the timings. This is applicable to the External Bus Interface signals and to the peripheral I/Os. This leads to fast rise and fall time when the signals change, causing high currents to be drawn on the power supply pins and leads to emission of high frequencies. This may affect the operation of the device and may result in the emission of radio-frequency signals, making EMC certiï¬cation difï¬cult.	IIO Considerations	 	Atmel
None	43.1.6.1 MCI: Busy Signal of R1b Responses is Not Taken in Account	 	ARM9	 	 	SAM9260	Not fixed	The busy status of the card during the response (R1b) is ignored for the commands CMD7, CMD28, CMD29, CMD38, CMD42, CMD56. Additionally, for commands CMD42 and CMD56 a conï¬ict can occur on data lineO if the MCI sends data to the card while the card is still busy. The behavior is correct for CMD12 command (STOP_TRANSFER).	MCI	 	Atmel
None	43.1.6.2 MCI: SDIO Interrupt Does Not Work With Slots Other Than A	 	ARM9	 	 	SAM9260	Not fixed	If there is 1-bit data bus width on slots other than slot A, the SDIO interrupt cannot be captured. The sample is made on the wrong data line.	MCI	 	Atmel
A STOP command must be sent with a software timeout.	43.1.6.3 MCI: Data Timeout Error Flag	 	ARM9	 	 	SAM9260	Not fixed	As the data Timeout error ï¬ag checking the Naac timing cannot rise, the MCI can be stalled waiting indeï¬nitely the Data start bit.	MCI	 	Atmel
The PDC counters must always be equal to 12 bytes for data transfers lower than 12 bytes. The BLKLEN or BCNT field are used to specify the real count number.	43.1.6.4 MCI: Data Write Operation and Number of Bytes	 	ARM9	 	 	SAM9260	Not fixed	The Data Write operation with a number of bytes less than 12 is impossible. AtmeL SAM9260 [DATASHEET] 793 AtmeIâ6221M-ATARM-SAMQZSO-Datasheet_13-Jan-16	MCI	 	Atmel
Enable the interrupts related to ENDRX, ENDTX, RXBUFF and TXBUFE only after enabling the PDC channel by writing PDC_TXTEN or PDC_RXTEN. 43.1.7 Reset Controller (RSTC)	43.1.6.5 MCI: Flag Reset is Not Correct in Half Duplex Mode	 	ARM9	 	 	SAM9260	Not fixed	In half duplex mode, the reset of the ï¬ags ENDRX, RXBUFF, ENDTX and TXBUFE can be incorrect. These ï¬ags are reset correctly after a PDC channel enable.	MCI	 	Atmel
1. Avoid user reset, watchdog reset, software reset to generate a system reset. 2. Trap the user reset, watchdog reset, software reset with an interrupt. In the interrupt routine, power down the SDRAM properly and perform Peripheral and Processor Reset with software in assembler. Example with IibV3. o The main code: //user reset interrupt setting // Configure AIC controller to handle System peripheral interrupts AT9lF_AIC_ConfigureIt ( AT91C_BASE_AIC, // AIC base address AT91C_ID_SYS, // System peripheral ID AT91C_AIC_PRIOR_HIGHEST, // Max priority AT9lC_AIC_SRCTYPE_INT_EDGE_TRIGGERED, // Level sensitive sysc_handler ); // Enable SYSC interrupt in AIC AT9lF_AIC_EnableIt(AT91C_BASE_AIC, AT91C_ID_SYS); *AT91C_RSTC_RMR = (0xA5<<24) | (Ox4<<8) | AT91C_RSTC_URSTIEN; o The C SYS handler: extern void soft_user_reset(void); void sysc_handler(void){ //check if interrupt comes from RSTC if( (*AT91C_RSTC_RSR & AT9lC_RSTC_URSTS ) == AT91C_RSTC_URSTS){ soft_user_reset(); //never reached 794 SAM9260 [DATASH EET] AtmeL Almel-6221 M-ATARM-SAMQZSO-DatasheetJ 3-Jan-16 while(l); } } 0 Assembly code is mandatory for the following sequence as ARM instructions need to be pipelined. The assembler routine: AREA TEST, CODE INCLUDE AT91$AM9xxx.inc EXPORTsoft_user_reset soft_user_reset ;disable IRQs MRS r0, CPSR ORR r0, r0, #0x80 MSR CPSR_c, r0 ;change refresh rate to block all data accesses LDR r0, =AT91C_SDRAMC_TR LDR r1, =1 STR r1, [r0] ;prepare power down command LDR r0, =AT9lC_SDRAMC_LPR LDR rl, =2 ;prepare proc_reset and periph_reset LDR r2, =AT91C_RSTC_RCR LDR r3, =0xA5000005 ;perform power down command STR r1, [r0] ;perform proc_reset and periph_reset (in the ARM pipeline) STR r3, [r2] END 43.1.8 Oscillators	43.1.7.1 RSTC: Reset during SDRAM Accesses	 	ARM9	 	 	SAM9260	Not fixed	When a user reset, watchdog reset, or software reset occurs during SDRAM read access, the SDRAM clock is turned off while data is ready to be read on the data bus. The SDRAM maintains the data until the clock restarts. If the user reset, watchdog reset, or software reset is programmed to assert a general reset, the data maintained by the SDRAM leads to a data bus conï¬ict and adversely affects the boot memories connected on the EBI: o NAND Flash boot functionality, if the system boots out of internal ROM. 0 NOR Flash boot, if the system boots on an external memory connected on the EBI CSO.	Reset Controller (RSTC)	 	Atmel
None	43.1.8.1 On-chip RC Startup Time	 	ARM9	 	 	SAM9260	Not fixed	When booting from the on-chip RC, the startup time is ï¬xed at 1200 ms and not 240 us as speciï¬ed in Table 5-1 on page 18.	Oscillators	 	Atmel
The ï¬rst power-up sequence requires both VDDBU and VDDCORE to correctly sample the OSCSEL signal. AtmeL SAM9260 [DATASHEET] 795 AtmeIâ6221M-ATARM-SAMQZSO-Datasheet_13âJan-16 43.1.9 SDRAM Controller	43.1.8.2 Bad Sampling of OSCSEL	 	ARM9	 	 	SAM9260	Not fixed	When VDDBU only is powered, either internal RC oscillator or external 32K osc may start regardless of the setting of the OSCSEL pin. The OSCSEL pin sampling is correct after applying VDDCORE power supply and remains correct if VDDCORE is removed.	Oscillators	 	Atmel
The following sequence stops the SDRAM clock. 1. Set the bit LPCB in the SDRAMC Low Power Register. 2. Write 0 in the SDRAMC Mode Register and perform a dummy write in SDRAM to complete.	43.1.9.1 SDCLK Clock Active After Reset	 	ARM9	 	 	SAM9260	Not fixed	After a reset, the SDRAM clock is always active leading to over consumption in the pad.	SDRAM Controller	 	Atmel
Mobile SDRAM initialization must be performed in internal SRAM.	43.1.9.2 Mobile SDRAM Device Initialization Constraint	 	ARM9	 	 	SAM9260	Not fixed	"Using Mobile SDRAM devices that need to have their DQMx level HIGH during Mobile SDRAM device initialization may lead to data bus contention and thus external memories on the same EBI must not be accessed. This does not apply to Mobile SDRAM devices whose DQMx level is âDon't care"" during this phase."	SDRAM Controller	 	Atmel
None. 43.1.10 Serial Peripheral Interface (SPI)	43.1.9.3 JEDEC Standard Compatibility	 	ARM9	 	 	SAM9260	Not fixed	In the current revision, SDCKE rises at the same time as SDCK while exiting self-refresh mode. To be fully compliant with the JEDEC standard, SDCK must be STABLE before the rising edge of SDCKE.	SDRAM Controller	 	Atmel
Do not use a multiple Chip Select conï¬guration where at least one SPI_CSRx register is conï¬gured with SCBR = 1 and the others differ from 1 if CPHA = 0 and CPOL = 1. If all chip selects are conï¬gured with SCBR = 1, the issue does not appear.	43.1.10.1 SPI: Bad Serial Clock Generation on Second chip_select when SCBR = 1, CPOL = 1 and NCPHA = 0	 	ARM9	 	 	SAM9260	Not fixed	If the SPI is used in the following conï¬guration: 0 Master mode 0 CPOL = 1 and NCPHA = 0 0 multiple chip selects used with one transfer with Baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR not equal to 1 o transmit with the slowest chip select and then with the fastest one then an additional pulse will be generated on output PSCK during the second transfer.	Serial Peripheral Interface (SPI)	 	Atmel
None. 796 SAM9260 [DATASHEET] AtmeL Almel-6221 M-ATARM-SAMQZSO-DatasheetJ 3-Jan-16	43.1.10.2 SPI: Baud Rate Set to 1	 	ARM9	 	 	SAM9260	Not fixed	When baud rate is set to 1 (i.e., when serial clock frequency equals the system clock frequency), and when the fields BITS (number of bits to be transmitted) equals an ODD value (in this case 9, 11, 13 or 15), an additional pulse is generated on output SPCK. No error occurs if BITS ï¬eld equals 8, 10, 12, 14 or 16 and SCBR = 1.	Serial Peripheral Interface (SPI)	 	Atmel
0 Add a timeout for the PDC transfer and check the value of the PDC transmit counter when the timeout has elapsed. Check the data integrity by a checksum. Avoid write access on the base address of peripherals during a PDC transfer.	43.1.10.3 SPI: PDC Data Loss	 	ARM9	 	 	SAM9260	Not fixed	One byte data can be lost when PDC transmits. This occurs when write accesses are performed on the base address of any peripheral, during the PDC transfer.	Serial Peripheral Interface (SPI)	 	Atmel
The SPI Control Register ï¬eld SWRST needs to be written twice to be correctly set. 43.1.11 Serial Synchronous Controller (SSC)	43.1.10.4 SPI: Software Reset Needs to be Written Twice	 	ARM9	 	 	SAM9260	Not fixed	If a software reset (SWRST in the SPI Control Register) is performed, the SPI may not work properly (the clock is enabled before the chip select).	Serial Peripheral Interface (SPI)	 	Atmel
Enable the pull-up on RK pin.	43.1.11.1 SSC: Unexpected RK Clock Cycle when RK Outputs a Clock During Data Transfer	 	ARM9	 	 	SAM9260	Not fixed	When the SSC receiver is used in the following conï¬guration: 0 the internal clock divider is used (CKS = 0 and DIV different from 0), o RK pin set as output and provides the clock during data transfer (CKO = 2) 0 data sampled on RK falling edge (CKI = 0) then, at the end of the data, the RK pin is set in high impedance which may be interpreted as an unexpected clock cycle.	Serial Synchronous Controller (SSC)	 	Atmel
None.	43.1.11.2 SSC: Incorrect ï¬rst RK Clock Cycle when RK Outputs a Clock During Data Transfer	 	ARM9	 	 	SAM9260	Not fixed	When the SSC receiver is used in the following conï¬guration: 0 RX clock is divided clock (CKS = 0 and DIV different from 0) o RK pin set as output and provides the clock during data transfer (CKO = 2) 0 data sampled on RK falling edge (CKI = 0) then the ï¬rst clock cycle time generated by the RK pin is equal to MCK/(2 x (DIV + 1)) instead of MCK/(2 x DIV).	Serial Synchronous Controller (SSC)	 	Atmel
None.	43.1.11.3 SSC: Transmitter Limitations in Slave Mode	 	ARM9	 	 	SAM9260	Not fixed	If TK is programmed as output and TF is programmed as input, it is impossible to emit data when start of edge (rising or falling) of synchro has a Start Delay equal to zero.	Serial Synchronous Controller (SSC)	 	Atmel
None. AtmeL SAM9260 [DATASHEET] 797 AtmeIâ6221M-ATARM-SAMQZSO-Datasheet_13âJan-16 43.1.12 Static Memory Controller (SMC)	43.1.11.4 SSC: Periodic Transmission Limitations in Master Mode	 	ARM9	 	 	SAM9260	Not fixed	If Least Significant Bit is sent ï¬rst (MSBF = 0) the ï¬rst TAG during the frame synchro is not sent.	Serial Synchronous Controller (SSC)	 	Atmel
The code used to modify the parameters of an SMC Chip Select can be executed from the internal RAM or from a memory connected to another Chip Select. 43.1.13 Shutdown Controller (SHDWC)	43.1.12.1 SMC: Chip Select Parameters Modification	 	ARM9	 	 	SAM9260	Not fixed	The user must not change the conï¬guration parameters of an SMC Chip Select (Setup, Pulse, Cycle, Mode) if accesses are performed on this CS during the modiï¬cation. For example, the modiï¬cation of the Chip Select 0 (080) parameters, while fetching the code from a memory connected on this CSO, may lead to unpredictable behavior.	Static Memory Controller (SMC)	 	Atmel
1. VDDCORE must be established within the delay corresponding to the startup time of the slow clock selected by OSCSEL. 2. Add a glue logic to latch the rising edge of the SHDN signal. The reset of the latch output (EN_REG) can be connected to a PIO and used to enter the shutdown mode. 43.1.14 System Controller	43.1.13.1 SHDWC: SHDN Signal may be Driven to Low Level Voltage During Device Power-on	 	ARM9	 	 	SAM9260	Not fixed	If only VDDBU is powered during boot sequence (No VDDCORE), the SHDN signal may be driven to low level voltage after a delay. This delay is linked to the startup time of the slow clock selected by OSCSEL signal. If SHDN pin is connected to the Enable pin (EN) of the VDDCORE regulator, VDDCORE establishment does not occur and the system does not start.	Shutdown Controller (SHDWC)	 	Atmel
The software must handle an RTT event as an interrupt and should not poll RTT_SR. 43.1.15 Two-wire Interface (TWI)	43.1.14.1 Possible Event Loss when Reading R1T_SR	 	ARM9	 	 	SAM9260	Not fixed	If an event (RTTINC or ALMS) occurs within the same slow clock cycle as when the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	System Controller	 	Atmel
Two workarounds are possible: 1. Perform a software reset before going to master mode (TWI must be reconï¬gured). or 2. Perform a slave read access before switching to master mode. 798 SAM9260 [DATASHEET] AtmeL Almel-6221 M-ATARM-SAMQZSO-DatasheetJ 3-Jan-16 43.1.16 UHP	43.1.15.1 TWI: Switch from Slave to Master Mode	 	ARM9	 	 	SAM9260	Not fixed	At the end of transfer in slave mode, the slave mode is disabled, the master mode is enabled and thus a transfer in master mode can be performed. In the current device, the start event is correctly generated but the SCL line is stuck at 1, so no transfer is possible.	Two-wire Interface (TWI)	 	Atmel
This problem can be avoided if the system guarantees that the status update can be completed within the same frame.	43.1.16.1 UHP: Non-ISO IN Transfers	 	ARM9	 	 	SAM9260	Not fixed	Conditions: Consider the following sequence: 1. The Host controller issues an IN token. 2 The Device provides the IN data in a short packet. 3. The Host controller writes the received data to the system memory. 4 The Host controller is now supposed to carry out two Write transactions (TD status write and TD retirement write) to the system memory in order to complete the status update. 5. The Host controller raises the request for the ï¬rst write transaction. By the time the transaction is completed, a frame boundary is crossed. 6. After completing the first write transaction, the Host controller skips the second write transaction. Consequence: When this error occurs, the Host controller tries the same IN token again.	UHP	 	Atmel
This problem can be avoided if the system can guarantee that no buffer underrun occurs during the transfer.	43.1.16.2 UHP: ISO OUT Transfers	 	ARM9	 	 	SAM9260	Not fixed	Conditions: Consider the following sequence: 1. The Host controller sends an ISO OUT token after fetching 16 bytes of data from the system memory. 2. When the Host controller is sending the ISO OUT data, because of system latencies, remaining bytes of the packet are not available. This results in a buffer underrun condition. 3. While there is an underrun condition, if the Host controller is in the process of bit-stufï¬ng, it causes the Host controller to hang. Consequence: After the failure condition, the Host controller stops sending the SOF. This causes the connected device to go into suspend state.	UHP	 	Atmel
Host stack can do a port resume after it sets the HcControl.HCFS to USBOPERATIONAL. AtmeL SAM9260 [DATASHEET] 799 AtmeIâ6221M-ATARM-SAMQZSO-Datasheet_13âJan-16 43.1 .17 USART	43.1.16.3 UHP: Remote Wakeup Event	 	ARM9	 	 	SAM9260	Not fixed	Conditions: When a Remote Wakeup event occurs on a downstream port, the OHCI Host controller begins sending resume signaling to the device. The Host controller is supposed to send this resume signaling for 20 ms. However, if the driver sets the HcControl.HCFS into USBOPERATIONAL state during the resume event, then the Host controller terminates sending the resume signal with an EOP to the device. Consequence: If the Device does not recognize the resume (< 20 ms) event, then the Device remains in suspend state.	UHP	 	Atmel
TXD is multiplexed with PIO which integrates a pull up resistor. This internal pull-up must be enabled.	43.1.17.1 USART: TXD Signal is Floating in Modern and Hardware Handshaking Mode.	 	ARM9	 	 	SAM9260	Not fixed	TXD signal should be pulled up in Modem and Hardware Handshaking mode.	UHP	 	Atmel
Add an inverter.	43.1.17.2 USART: DCD is Active High Instead of Low	 	ARM9	 	 	SAM9260	Not fixed	The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	UHP	 	Atmel
Constraints on the transmitter device connected to the SAM9260 USART receiver side. The transmitter may use the timeguard feature or send 2 STOP conditions. Only one STOP condition is taken into account by the receiver state machine. After this STOP condition, as there is no valid data the receiver state machine will go into idle mode and enable the RXBRK condition.	43.1.17.3 USART: RXBRK Flag Error in Asynchronous Mode	 	ARM9	 	 	SAM9260	Not fixed	In receiver mode, when two characters are consecutive (without timeguard in between) the RXBRK is not taken into account. As a result the RXBRK ï¬ag is not enabled correctly and the frame error flag is set.	UHP	 	Atmel
CTS must not go low during a time slot comprised between 2 Master Clock periods before the rising edge of the starting bit and 16 Master Clock periods after the rising edge of the starting bit.	43.1.17.4 USART: CTS Signal in Hardware Handshake	 	ARM9	 	 	SAM9260	Not fixed	When Hardware Handshaking is used and if CTS goes low near the end of the starting bit of the transmitter, a character is lost.	UHP	 	Atmel
None.	43.1.17.5 USART: RTS Not Expected Behavior	 	ARM9	 	 	SAM9260	Not fixed	1. Setting the receiver to hardware handshaking mode drops RTS line to low level even if the receiver is still turned off. USART needs to be completely configured and started before setting the receiver to hardware handshaking mode. 2. Disabling the receiver during a PDC transfer while RXBUFF ï¬ag is '0' has no effect on RTS. The only way to get the RTS line to rise to high level is to reset both PDMA buffers by writing the value '0' in both counter registers.	UHP	 	Atmel
None. 800 SAM9260 [DATASHEET] AtmeL Almel-6221 M-ATARM-SAMQZSO-DatasheetJ 3-Jan-16 43.1.18 Power Management Controller (PMC)	43.1.17.6 USART: Two Characters Sent if CTS Rises During Emission	 	ARM9	 	 	SAM9260	Not fixed	If CTS rises to 1 during a character transmit, the Transmit Holding Register is also transmitted if not empty.	UHP	 	Atmel
For each clock switching user must take care to: 0 change ï¬elds CSS, MDIV, PRES one by one o wait MCKRDY bit setting in PMC_SR before changing PMC_MCKR 0 ensure each transitory frequency value is in operational range for PCK and MCK AtmeL SAM9260 [DATASHEET] 801 AtmeIâ6221M-ATARM-SAMQZSO-Datasheet_13âJan-16 43.2 SAM9260 Errata - Revision âBâ Parts Refer to Section 43.1 âSAM9260 Errata - Revision âAâ Partsâ on page 790. 43.2.1 Analog-to-digital Converter (ADC)	43.1.18.1 PMC: PMC bad frequency after MDIV switching	 	ARM9	 	 	SAM9260	Not fixed	If MDIV and another ï¬eld (088 or PRES) are changed at the same, clock frequency may not be correct.	Power Management Controller (PMC)	 	Atmel
None	43.2.1.1 ADC: DRDY Bit Cleared	 	ARM9	 	 	SAM9260	Not fixed	The DRDY Flag should be clear only after a read of ADC_LCDR (Last Converted Data Register). A read of any ADC_CDRx (Channel Data Register) automatically clears the DRDY ï¬ag.	Analog-to-digital Converter (ADC)	 	Atmel
None	43.2.1.2 ADC: DRDY not Cleared on Disable	 	ARM9	 	 	SAM9260	Not fixed	When reading LCDR at the same instant as an end of conversion, with DRDY already active, DRDY is kept active regardless of the enable status of the current channel. This sets DRDY, whereas new data is not stored.	Analog-to-digital Converter (ADC)	 	Atmel
Use of DRDY functionality with access to CDR registers should be avoided.	43.2.1.3 ADC: DRDY Possibly Skipped due to CDR Read	 	ARM9	 	 	SAM9260	Not fixed	"Reading CDR for channel y at the same instant as an end of conversion on channel âx"" with EOC[x] already active, leads to skipping to set the DRDY ï¬ag if channel x is enabled."	Analog-to-digital Converter (ADC)	 	Atmel
None.	43.2.1.4 ADC: Possible Skip on DRDY when Disabling a Channel	 	ARM9	 	 	SAM9260	Not fixed	"DRDY does not rise when disabling channel y at the same time as an end of âx"" channel conversion, although data is stored into CDRx and LCDR."	Analog-to-digital Converter (ADC)	 	Atmel
None	43.2.1.5 ADC: GOVRE Bit is Not Updated	 	ARM9	 	 	SAM9260	Not fixed	Read of the Status Register at the same instant as an end of conversion leads to skipping the update of the GOVRE (general overrun) ï¬ag. GOVRE is neither reset nor set. For example, if reading the status while an end of conversion is occurring and: 1. GOVRE is active but DRDY is inactive, does not correspond to a new general overrun condition but the GOVRE ï¬ag is not reset. 2. GOVRE is inactive but DRDY is active, does correspond to a new general overrun condition but the GOVRE ï¬ag is not set.	Analog-to-digital Converter (ADC)	 	Atmel
None	43.2.1.6 ADC: GOVRE Bit is Not Set when Reading CDR	 	ARM9	 	 	SAM9260	Not fixed	"When reading CDRy (Channel Data Register y) at the same instant as an end of conversion on channel x with the following conditions: EOC[x] already active, 0 DRDY already active, 0 GOVRE inactive, 0 previous data stored in LCDR being neither data from channel â"",y nor data from channel ""xâ. 802 SAM9260 [DATASHEET] At m eL Almel-6221 M-ATARM-SAMQZSO-Datasheet_13-Jan-16 GOVRE should be set but is not."	Analog-to-digital Converter (ADC)	 	Atmel
None	43.2.1.7 ADC: GOVRE Bit is Not Set when Disabling a Channel	 	ARM9	 	 	SAM9260	Not fixed	"When disabling channel ây"" at the same instant as an end of conversion on channel âx"", EOC[x] and DRDY being already active, GOVRE does not rise. Note: OVRE[x] rises as expected."	Analog-to-digital Converter (ADC)	 	Atmel
None	43.2.1.8 ADC: OVRE Flag Behavior	 	ARM9	 	 	SAM9260	Not fixed	When the OVRE ï¬ag (on channel i) has been set but the related EOC status (of channel i) has been cleared (by a read of CDRi or LCDR), reading the Status register at the same instant as an end of conversion (causing the set of EOC status on channel i), does not lead to a reset of the OVRE ï¬ag (on channel i) as expected.	Analog-to-digital Converter (ADC)	 	Atmel
Do not take into account the EOC of a disabled channel	43.2.1.9 ADC: EOC Set Although Channel Disabled	 	ARM9	 	 	SAM9260	Not fixed	If a channel is disabled while a conversion is running and if a read of CDR is performed at the same time as an end of conversion of any channel occurs, the EOC of the channel with the conversion running may rise (whereas it has been disabled).	Analog-to-digital Converter (ADC)	 	Atmel
None.	43.2.1.10 ADC: Spurious Clear of EOC Flag	 	ARM9	 	 	SAM9260	Not fixed	"If âx"" and ""y"" are two successively converted channels and âz"" is yet another enabled channel (â2"" being neither âx"" nor ây""), reading CDR on channel â2â at the same instant as an end of conversion on channel âyâ automatically clears EOC[x] instead of EOC[z]."	Analog-to-digital Converter (ADC)	 	Atmel
To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit ï¬eld); to start an analog-toâdigital conversion, in order put ADC into sleep mode at the end of this conversion. 43.2.2 Bus Matrix	43.2.1.11 ADc: Sleep Mode	 	ARM9	 	 	SAM9260	Not fixed	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	Analog-to-digital Converter (ADC)	 	Atmel
None. AtmeL SAM9260 [DATASHEET] 803 AtmeIâ6221M-ATARM-SAMQZSO-Datasheet_13âJan-16 43.2.3 EMAC	43.2.2.1 Bus Matrix Master Conï¬guration Register 5	 	ARM9	 	 	SAM9260	Not fixed	MATRIX_MCFG5 is write-only. The value written is effective but not readable.	Bus Matrix	 	Atmel
Reduce re-arbitration time between RX & TX EMACB transfers by using internal SRAM (or another memory slave with a short access time) to transmit buffers and descriptors. 43.2.4 IIO Considerations	43.2.3.1 EMAC: TX Underrun May Occur in Some Cases	 	ARM9	 	 	SAM9260	Not fixed	"EMACB FIFO internal arbitration scheme is: 1. PIPE-9!â 6. Receive buffer manager write Receive buffer manager read Transmit data DMA read Receive data DMA write Transmit buffer manager read Transmit buffer manager write EMACB master interface releases the AHB bus between two transfers. EMACB has the highest priority. If EMACB RX and TX FIFOs both have pending requests, the following sequence occurs: 1. 9391??!"" EMACB RX FIFO write (burst 4) EMACB releases the AHB bus The AHB matrix can grant an another master (ARM I or D for example) AHB matrix re-arbitration (finishes at least the current word/halfword/byte) The AHB matrix grants the EMACB The EMACB TX FIFO read (burst 4) In case of a slow memory and/or a special operation like SDRAM refresh or SDRAM bank opening, a TX underrun may occur. (latency min 960 ns)."	EMAC	 	Atmel
It is strongly recommended: to place the memories connected to the EBI as close as possible to the SAM9260 on the PCB to route all the EBI signals with a series resistor, typical value 33 ohms to adjust the series resistor value with tools taking into account the IBIS model of the pads and the characteristics of the wires of the PCB, in order to guarantee rise and fall times as long as timings permit. 804 SAM9260 [DATASHEET] AtmeL Almel-6221 M-ATARM-SAMQZSO-Datasheet_13-Jan-16 43.2.5 MCI	43.2.4.1 IIO High Drive Strength	 	ARM9	 	 	SAM9260	Not fixed	The I/O output buffer drive is too high to guarantee the timings. This is applicable to the External Bus Interface signals and to the peripheral I/Os. This leads to fast rise and fall time when the signals change, causing high currents to be drawn on the power supply pins and leads to emission of high frequencies. This may affect the operation of the device and may result in the emission of radio-frequency signals, making EMC certiï¬cation difï¬cult.	IIO Considerations	 	Atmel
None	43.2.5.1 MCI: Busy Signal of R15 Responses is Not Taken in Account	 	ARM9	 	 	SAM9260	Not fixed	The busy status of the card during the response (R1 b) is ignored for the commands CMD7, CMD28, CMD29, CMD38, CMD42, CMD56. Additionally, for commands CMD42 and CMD56 a conï¬ict can occur on data Iine0 if the MCI sends data to the card while the card is still busy. The behavior is correct for CMD12 command (STOP_TRANSFER).	MCI	 	Atmel
None	43.2.5.2 MCI: SDIO Interrupt Does Not Work for Slot Different from A	 	ARM9	 	 	SAM9260	Not fixed	If the data bus width is 1 bit and slots other than slot A chosen, the SDIO interrupt can not be captured. The sample is made on the bad data line.	MCI	 	Atmel
A STOP command must be sent with a software timeout.	43.2.5.3 MCI: Data Timeout Error Flag	 	ARM9	 	 	SAM9260	Not fixed	As the data Timeout error ï¬ag checking the Naac timing cannot rise, the MCI can be stalled waiting indeï¬nitely the Data start bit.	MCI	 	Atmel
The PDC counters must always be equal to 12 bytes for data transfers lower than 12 bytes. The BLKLEN or BCNT field are used to specify the real count number.	43.2.5.4 MCI: Data Write Operation and Number of Bytes	 	ARM9	 	 	SAM9260	Not fixed	The Data Write operation with a number of bytes less than 12 is impossible.	MCI	 	Atmel
Enable the interrupts related to ENDRX, ENDTX, RXBUFF and TXBUFE only after enabling the PDC channel by writing PDC_TXTEN or PDC_RXTEN. 43.2.6 SDRAM Controller	43.2.5.5 MCI: Flag Reset is Not Correct in Half Duplex Mode	 	ARM9	 	 	SAM9260	Not fixed	In half duplex mode, the reset of the ï¬ags ENDRX, RXBUFF, ENDTX and TXBUFE can be incorrect. These ï¬ags are reset correctly after a PDC channel enable.	MCI	 	Atmel
The following sequence stops the SDRAM clock. 1. Set the bit LPCB in the SDRAMC Low Power Register. 2. Write 0 in the SDRAMC Mode Register and perform a dummy write in SDRAM to complete.	43.2.6.1 SDCLK Clock Active After Reset	 	ARM9	 	 	SAM9260	Not fixed	After a reset, the SDRAM clock is always active leading to over consumption in the pad.	SDRAM Controller	 	Atmel
Mobile SDRAM initialization must be performed in internal SRAM. 43.2.7 Reset Controller (RSTC)	43.2.6.2 Mobile SDRAM Device Initialization Constraint	 	ARM9	 	 	SAM9260	Not fixed	Using Mobile SDRAM devices that need to have their DQMx level HIGH during Mobile SDRAM device initialization may lead to data bus contention and thus external memories on the same EBI must not be accessed. AtmeL SAM9260 [DATASHEET] 805 AtmeIâ6221M-ATARM-SAMQZSO-Datasheet_13âJan-16 This does not apply to Mobile SDRAM devices whose DQMx level is âDonât careâ during this phase.	SDRAM Controller	 	Atmel
1. Avoid user reset, watchdog reset, software reset to generate a system reset. 2. Trap the user reset, watchdog reset, software reset with an interrupt. In the interrupt routine, power down the SDRAM properly and perform Peripheral and Processor Reset with software in assembler. Example with IibV3. o The main code: //user reset interrupt setting // Configure AIC controller to handle System peripheral interrupts AT9lF_AIC_ConfigureIt ( AT91C_BASE_AIC, // AIC base address AT91C_ID_SYS, // System peripheral ID AT91C_AIC_PRIOR_HIGHEST, // Max priority AT91C_AIC_SRCTYPE_INT_EDGE_TRIGGERED, // Level sensitive sysc_handler ); // Enable SYSC interrupt in AIC AT91F_AIC_EnableIt (AT91C_BASE_AIC, AT91C_ID_SYS) ; *AT91C_RSTC_RMR = (0xA5<<24) | (Ox4<<8) | AT91C_RSTC_URSTIEN; o The C SYS handler: extern void soft_user_reset(void); void sysc_handler(void){ //check if interrupt comes from RSTC if( (*AT91C_RSTC_RSR & AT91C_RSTC_URSTS ) == AT91C_RSTC_URSTS){ soft_user_reset(); //never reached while(l); } l 0 Assembly code is mandatory for the following sequence as ARM instructions need to be pipelined. The assembler routine: AREA TEST, CODE 806 SAM9260 [DATASHEET] AImeI-6221M-ATARM-SAMQZSO-DatasheetJ3-Jan-16 A t meL INCLUDE ATQlSAM9xxx.inc EXPORTsoft_user_reset soft_user_reset ;disable IRQs MRS r0, CPSR ORR r0, r0, #0x80 MSR CPSR_c, r0 ;change refresh rate to block all data accesses LDR r0, =AT91C_SDRAMC_TR LDR rl, =1 STR rl, [r0] ;prepare power down command LDR r0, =AT91C_SDRAMC_LPR LDR rl, =2 ;prepare proc_reset and periph_reset LDR r2 , =AT91C_RSTC_RCR LDR r3, =0xA5000005 ;perform power down command STR rl, [r0] ;perform proc_reset and periph_reset (in the ARM pipeline) STR r3, [r2] END 43.2.8 Serial Peripheral Interface (SPI)	43.2.7.1 RSTC: Reset during SDRAM Accesses	 	ARM9	 	 	SAM9260	Not fixed	When a user reset, watchdog reset, or software reset occurs during SDRAM read access, the SDRAM clock is turned off while data is ready to be read on the data bus. The SDRAM maintains the data until the clock restarts. If the user reset, watchdog reset, or software reset is programmed to assert a general reset, the data maintained by the SDRAM leads to a data bus conï¬ict and adversely affects the boot memories connected on the EBI: o NAND Flash boot functionality, if the system boots out of internal ROM. 0 NOR Flash boot, if the system boots on an external memory connected on the EBI CSO.	Reset Controller (RSTC)	 	Atmel
Do not use a multiple Chip Select conï¬guration where at least one SPI_CSRx register is conï¬gured with SCBR = 1 and the others differ from 1 if CPHA = 0 and CPOL = 1. If all chip selects are conï¬gured with SCBR = 1, the issue does not appear.	43.2.8.1 SPI: Bad Serial Clock Generation on Second chip_select when SCBR = 1, CPOL =1 and NCPHA = 0	 	ARM9	 	 	SAM9260	Not fixed	If the SPI is used in the following conï¬guration: 0 Master mode 0 CPOL = 1 and NCPHA = 0 0 multiple chip selects used with one transfer with baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR not equal to 1 o transmit with the slowest chip select and then with the fastest one then an additional pulse will be generated on output PSCK during the second transfer.	Serial Peripheral Interface (SPI)	 	Atmel
None. AtmeL SAM9260 [DATASHEET] 807 AtmeIâ6221M-ATARM-SAMQZSO-Datasheet_13âJan-16 43.2.9 Serial Synchronous Controller (SSC)	43.2.8.2 SPI: Baud Rate Set to 1	 	ARM9	 	 	SAM9260	Not fixed	When baud rate is set to 1 (i.e., when serial clock frequency equals the system clock frequency), and when the fields BITS (number of bits to be transmitted) equals an ODD value (in this case 9, 11, 13 or 15), an additional pulse is generated on output SPCK. No error occurs if BITS ï¬eld equals 8, 10, 12, 14 or 16 and SCBR = 1.	Serial Peripheral Interface (SPI)	 	Atmel
Enable the pull-up on RK pin.	43.2.9.1 SSC: Unexpected RK Clock Cycle when RK Outputs a Clock During Data Transfer	 	ARM9	 	 	SAM9260	Not fixed	When the SSC receiver is used in the following conï¬guration: 0 the internal clock divider is used (CKS = 0 and DIV different from 0), o RK pin set as output and provides the clock during data transfer (CKO = 2) 0 data sampled on RK falling edge (CKI = 0) then, at the end of the data, the RK pin is set in high impedance which may be interpreted as an unexpected clock cycle.	Serial Synchronous Controller (SSC)	 	Atmel
None.	43.2.9.2 SSC: Incorrect First RK Clock Cycle when RK Outputs a Clock During Data Transfer	 	ARM9	 	 	SAM9260	Not fixed	When the SSC receiver is used in the following conï¬guration: 0 RX clock is divided clock (CKS = 0 and DIV different from 0) o RK pin set as output and provides the clock during data transfer (CKO = 2) 0 data sampled on RK falling edge (CKI = 0) then the ï¬rst clock cycle time generated by the RK pin is equal to MCK/(2 >< (DIV + 1)) instead of MCK/(2 >< DIV).	Serial Synchronous Controller (SSC)	 	Atmel
None.	43.2.9.3 SSC: Transmitter Limitations in Slave Mode	 	ARM9	 	 	SAM9260	Not fixed	If TK is programmed as output and TF is programmed as input, it is impossible to emit data when start of edge (rising or falling) of synchro has a Start Delay equal to zero.	Serial Synchronous Controller (SSC)	 	Atmel
None. 43.2.10 Shutdown Controller (SHDWC)	43.2.9.4 SSC: Periodic Transmission Limitations in Master Mode	 	ARM9	 	 	SAM9260	Not fixed	If Least Significant Bit is sent ï¬rst (MSBF = 0) the ï¬rst TAG during the frame synchro is not sent.	Serial Synchronous Controller (SSC)	 	Atmel
1. VDDCORE must be established within the delay corresponding to the startup time of the slow clock selected by OSCSEL. 2. Add a glue logic to latch the rising edge of the SHDN signal. The reset of the latch output (EN_REG) can be connected to a PIO and used to enter the shutdown mode. 808 SAM9260 [DATASHEET] AtmeL AImeI-6221 M-ATARM-SAMQZSO-Datasheet_13-Jan-16 43.2.11 System Controller	43.2.10.1 SHDWC: SHDN Signal may be Driven to Low Level Voltage During Device Power-on	 	ARM9	 	 	SAM9260	Not fixed	If only VDDBU is powered during boot sequence (No VDDCORE), the SHDN signal may be driven to low level voltage after a delay. This delay is linked to the startup time of the slow clock selected by OSCSEL signal. If SHDN pin is connected to the Enable pin (EN) of the VDDCORE regulator, VDDCORE establishment does not occur and the system does not start.	Shutdown Controller (SHDWC)	 	Atmel
The software must handle an RTT event as an interrupt and should not poll RTT_SR. 43.2.12 Two-wire Interface (TWI)	43.2.11.1 Possible Event Loss when Reading R1T_SR	 	ARM9	 	 	SAM9260	Not fixed	If an event (RTTINC or ALMS) occurs within the same slow clock cycle as when the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	System Controller	 	Atmel
Two workarounds are possible: 1. Perform a software reset before going to master mode (TWI must be reconï¬gured). or 2. Perform a slave read access before switching to master mode. 43.2.13 UHP	43.2.12.1 TWI: Switch from Slave to Master Mode	 	ARM9	 	 	SAM9260	Not fixed	At the end of transfer in slave mode, the slave mode is disabled, the master mode is enabled and thus a transfer in master mode can be performed. In the current device, the start event is correctly generated but the SCL line is stuck at 1, so no transfer is possible.	Two-wire Interface (TWI)	 	Atmel
This problem can be avoided if the system guarantees that the status update can be completed within the same frame.	43.2.13.1 UHP: Non-ISO IN Transfers	 	ARM9	 	 	SAM9260	Not fixed	Conditions: Consider the following sequence: 1. The Host controller issues an IN token. 2 The Device provides the IN data in a short packet. 3. The Host controller writes the received data to the system memory. 4 The Host controller is now supposed to carry out two Write transactions (TD status write and TD retirement write) to the system memory in order to complete the status update. 5. The Host controller raises the request for the ï¬rst write transaction. By the time the transaction is completed, a frame boundary is crossed. 6. After completing the first write transaction, the Host controller skips the second write transaction. Consequence: When this error occurs, the Host controller tries the same IN token again.	UHP	 	Atmel
This problem can be avoided if the system can guarantee that no buffer underrun occurs during the transfer.	43.2.13.2 UHP: ISO OUT Transfers	 	ARM9	 	 	SAM9260	Not fixed	Conditions: Consider the following sequence: 1. The Host controller sends an ISO OUT token after fetching 16 bytes of data from the system memory. 2. When the Host controller is sending the ISO OUT data, because of system latencies, remaining bytes of the packet are not available. This results in a buffer underrun condition. 3. While there is an underrun condition, if the Host controller is in the process of bit-stufï¬ng, it causes the Host controller to hang. AtmeL SAM9260 [DATASHEET] 809 AtmeIâ6221M-ATARM-SAMQZSO-Datasheet_13âJan-16 Consequence: After the failure condition, the Host controller stops sending the SOF. This causes the connected device to go into suspend state.	UHP	 	Atmel
Host stack can do a port resume after it sets the HcControl.HCFS to USBOPERATIONAL. 43.2.14 USART	43.2.13.3 UHP: Remote Wakeup Event	 	ARM9	 	 	SAM9260	Not fixed	Conditions: When a Remote Wakeup event occurs on a downstream port, the OHCI Host controller begins sending resume signaling to the device. The Host controller is supposed to send this resume signaling for 20 ms. However, if the driver sets the HcControl.HCFS into USBOPERATIONAL state during the resume event, then the Host controller terminates sending the resume signal with an EOP to the device. Consequence: If the Device does not recognize the resume (< 20 ms) event, then the Device remains in suspend state.	UHP	 	Atmel
TXD is multiplexed with PIO which integrates a pull up resistor. This internal pull-up must be enabled.	43.2.14.1 USART: TXD Signal is ï¬oating in Modern and Hardware Handshaking Mode.	 	ARM9	 	 	SAM9260	Not fixed	TXD signal should be pulled up in Modern and Hardware Handshaking mode.	USART	 	Atmel
Add an inverter.	43.2.14.2 USART: DCD is Active High instead of Low	 	ARM9	 	 	SAM9260	Not fixed	The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	USART	 	Atmel
Constraints on the transmitter device connected to the SAM9260 USART receiver side. The transmitter may use the timeguard feature or send 2 STOP conditions. Only one STOP condition is taken into account by the receiver state machine. After this STOP condition, as there is no valid data the receiver state machine will go into idle mode and enable the RXBRK condition.	43.2.14.3 USART: RXBRK Flag Error in Asynchronous Mode	 	ARM9	 	 	SAM9260	Not fixed	In receiver mode, when two characters are consecutive (without timeguard in between) the RXBRK is not taken into account. As a result the RXBRK ï¬ag is not enabled correctly and the frame error flag is set.	USART	 	Atmel
None. 810 SAM9260 [DATASHEET] AtmeL AImeI-6221 M-ATARM-SAMQZSO-Datasheet_13-Jan-16 43.2.15 Power Management Controller (PMC)	43.2.14.4 USART: RTS not Expected Behavior	 	ARM9	 	 	SAM9260	Not fixed	1. Setting the receiver to hardware handshaking mode drops RTS line to low level even if the receiver is still turned off. USART needs to be completely conï¬gured and started before setting the receiver to hardware handshaking mode. 2. Disabling the receiver during a PDC transfer while RXBUFF ï¬ag is '0' has no effect on RTS. The only way to get the RTS line to rise to high level is to reset both PDMA buffers by writing the value '0' in both counter registers.	USART	 	Atmel
  Configure DMA and CPU requests to different priority levels. The CPU should not be set to priority level 7. There is no penalty for setting the IDMA and SDMA priorities equal to each other.  CPU request priority is programmed within the CPUARBU register:  /** Pseudo code only **/  Uint32 *CPUARBU;  CPUARBU = ( Uint32 * ) ( 0x01841000 );  /* Set priority different from IDMA/SDMA */  *CPUARBU = [CPU_PRIORITY];  8  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback   3.0 Usage Notes and Known Design Exceptions to Functional Specifications IDMA request priority is programmed within the IDMA1_COUNT register  /** Pseudo code only **/  Uint32 *IDMA1_SRC, *IDMA1_DST;  Uint32 *IDMA1_CNT;  IDMA1_SRC = ( Uint32 * ) ( 0x01820108 );  IDMA1_DST = ( Uint32 * ) ( 0x0182010C );  IDMA1_CNT = ( Uint32 * ) ( 0x01820110 );  *IDMA1_SRC = sourceAddress;  *IDMA1_DST = destinationAddress;  /* Set IDMA priority different from CPU */  *IDMA_CNT = ( [IDMA_PRI] << [IDMA_PRI_SHIFT] ) | buffSize ;  SDMA request priority is inherited from the MSTPRIn registers  /** Pseudo code only **/  Uint32 *MSTPRI1, *MSTPRI2;  MSTPRI1 = ( Uint32 * ) ( 0x01C14114 );  MSTPRI2 = ( Uint32 * ) ( 0x01C14118 );  /* Set SDMA master priorities different from CPU */  *MSTPRI1 = [MAST_PRI] << [MAST_SHIFT];  *MSTPRI2 = [MAST_PRI] << [MAST_SHIFT];  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  9  Submit Documentation Feedback   3.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      	 3.0.4   DMA Access to L2 RAM Can Stall When DMA and C674x CPU Command Priorities      are Equal   	 	ARM9	 	  3.0 and earlier      	OMAP-L137	 	   Note: DMA refers to all non-CPU requests. This includes Internal Direct Memory Access (IDMA) requests and all other system DMA master requests via the Slave Direct Memory Access (SDMA) port.  The C674x Megamodule uses a bandwidth management (BWM) system to arbitrate  between DMA and CPU requests issued to L2 RAM. See TMS320C674x DSP  Megamodule Reference Guide, Literature Number - SPRUFK5 for more information on  the BWM. BWM arbitration grants L2 bandwidth based on programmable priorities and  contention- cycle-counters. The contention-cycle-counters count the number of cycles for which the associated L2 requests are blocked by higher priority requests. When the  contention-cycle-counter reaches a programmed threshold (MAXWAIT), the associated  L2 request is granted a slice of L2 bandwidth. This prevents indefinite blocking of low priority requests when faced with the continuous presence of higher priority requests.  Ideally, the BWM arbitration will grant equal L2 bandwidth between equal priority DMA and CPU requests. Instead, when equal priority DMA and CPU requests arrive at the  BWM, bandwidth is always granted in favor of the CPU over DMA. In the case of  successive CPU requests, it is possible for the CPU to block all DMA requests until CPU  traffic subsides. Additionally, some command logic in the BWM uses priority level 7, which can also result in SDMA stalls when the CPU is also programmed to priority level 7. Figure 2 shows a high level diagram of the arbitration scheme used for L2 RAM  requests.  C674x Megamodule  EDMA  SHAREDRESOURCE  ExternalSystemMasters  Programmable Priority  ARBITRA  MasterPriority  C674x CPU  EMAC  ARBITRA  Programmable Priority  IDMA  L2 RAM  TION  LCDC  Inherit  TION  Priority  SDMA  UHPI  USB  Highest Priority Master Granted Access.  Contention counters implemented to not      starve low priority requestors   Figure 2. Priority Arbitration Scheme for L2 RAM  	 	 	TI
  Software must service every USB RESET interrupt received. Software should not  proceed on performing any other task, like initialization, until RESET duration has come to completion. The POWER[RESET] bit field will be cleared by the USB Controller when RESET signaling on the bus is removed by the Host. The USB Controller clearing the  POWER[RESET] bit field should be used by software as an indication for the completion of RESET signaling.  10  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback   3.0 Usage Notes and Known Design Exceptions to Functional Specifications 	 3.0.6   USB0: Extraneous RESET Interrupt  	 	ARM9	 	  3.0 and earlier      	OMAP-L137	 	   When the USB controller is operating as a device and an attached host resets the device after the completion of the “Device Attached” state by driving both differential data lines low, the USB controller operating as a device could receive multiple RESET interrupts for the single RESET signaling invoked by the host. The multiple interrupt generation only happens for the duration of the RESET signaling on the bus. RESET Interrupt is not generated before or after the completion of RESET.  	 	 	TI
  The EMIFB hardware automatically schedules refresh commands to the SDRAM  memory. Therefore, it is not possible for the user/application code to schedule EMIF  refresh commands to prevent them from being initiated during LCDC start up. This  means that it is not possible to prevent an EMIFB refresh occurrence during the start up of the LCDC.  Software should poll the FUF bit field in the LCD_STAT register to check if an error condition has occurred or service the interrupt if FUF_EN is enabled when FUF occurs. If the FUF bit field has been set to 1, this will indicate an underflow condition has occurred and then the software should execute a reset of the LCDC via the LPSC.  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  11  Submit Documentation Feedback   3.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      	 3.0.7      LCDC Underflow During Initialization   	 	ARM9	 	  3.0 and earlier      	OMAP-L137	 	   During LCDC initialization, there is the potential for a FIFO underflow condition to occur.  A FIFO underflow condition occurs when the input FIFO is completely empty and the  LCDC raster controller logic that drives data to the output pins attempts to fetch data from the FIFO. When a FIFO underflow condition occurs, incorrect data will be driven out on the LCDC data pins.  An underflow condition will occur if the EMIFB issues a refresh command to the SDRAM  memory during LCDC start up/initialization. The error condition will be captured in the LCD Status register (LCD_STAT) in the FIFO underflow status (FUF) bit field. If the  FUF_EN bit is enabled in Raster Control Register (RASTER_CTRL), the LCDC will send  an interrupt to the CPU.  The FIFO underflow described above is not expected to be a common occurrence  because of the unlikely alignment of events required to produce the underflow condition.  	 	 	TI
  If a time-out occurs, perform any of the following:  •  A dummy read to another asynchronous memory chip select that is not configured to  be in Extended Wait mode.  •  A dummy read to the same asynchronous memory chip select after disabling the  Extended Wait mode on that chip select.  •  A dummy read to SDRAM  12  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback   3.0 Usage Notes and Known Design Exceptions to Functional Specifications 	 3.0.13   EMIFA: Asynchronous Memory Timeout Error Persistence  	 	ARM9	 	  3.0 and earlier      	OMAP-L137	 	   In Extended Wait mode, during a read access to an asynchronous memory, if the WAIT  input does not go inactive within maximum extended wait cycles programmed in the  Async Wait Cycle Config register, the EMIFA will report a time-out error. The data  returned for this access will be all zeros. If this access is followed by a read to the EMIFA’s memory-mapped register (MMR) space, the EMIFA will still report a time-out  error but with the correct data for the MMR read. The EMIFA will hold the time-out error until another asynchronous access without a time-out error or an SDRAM access is  performed.  This issue is only applicable if all of the following are true:  •  The EMIFA is used for asynchronous memory accesses in Extended Wait mode.  •  There is a potential for a time-out error to occur, that is, the asynchronous memory will not de-assert the WAIT input.  •  If asynchronous memory read with time-out error is followed by an MMR read.  	 	 	TI
  The CPUINTn hardware interrupts can support both pulse and level interrupts so  CHIPINTn interrupts should be mapped directly to CPUINTn hardware interrupts.  Furthermore, if the ECM is used for other system interrupts, the CHIPINTn interrupts should be masked out in the EVTMASKn registers.  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  13  Submit Documentation Feedback   3.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      	 3.0.14  A Single CHIPINTn Interrupt Event Will Register Multiple Times in the DSP Event  Combiner Module (ECM)  	 	ARM9	 	  3.0 and earlier      	OMAP-L137	 	   The C674x DSP megamodule supports twelve maskable hardware interrupt signals  (CPUINT4 through CPUINT15). Single system interrupts may be mapped directly to a  CPUINTn hardware interrupt, or multiple system interrupts may be combined by the  ECM into a single signal before mapping to a CPUINTn interrupt. See SPRUFK5 -  TMS320C674x DSP Megamodule Reference Guide for more information on how DSP  interrupts are handled.  The ECM expects all incoming interrupts to be pulse interrupts, however the  [SYSCFG_CHIPSIG_]CHIPINTn interrupts are level interrupts. This mismatch in interrupt types will cause a single CHIPINTn interrupt event to register multiple times in the ECM.  	 	 	TI
  The reset timing violation can be avoided by providing the modified soft reset activation sequence outlined below:  1. Enable the USB controller module clock  2. Perform a soft USB reset  3. Wait for the USB soft reset bit to clear  4. Disable the USB controller module clock  5. Configure the USB PHY parameters  6. Enable the PHY  7. Enable the USB controller module clock  14  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback   3.0 Usage Notes and Known Design Exceptions to Functional Specifications 	 3.0.15   Potential USB2.0 Soft Reset Timing Violation  	 	ARM9	 	  3.0 and earlier      	OMAP-L137	 	   When a soft reset is invoked by setting the RESET bit of the USB CTRLR register (  CTRLR[RESET] = 1 ), the internal reset timing requirements may be violated. Although this timing violation has not been observed in practice, the potential for a timing violation exists.  USB resets initiated by system-reset and power-on-reset are immune from the timing  violation.  There is no plan to fix this issue in future silicon revisions because:  1. No functional problems have been observed to date  2. A software workaround has been developed to avoid the problem  	 	 	TI
  The desired value (even if it is the default value) should be written to the VSR prior to using the interrupt controller.  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  15  Submit Documentation Feedback   3.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      	 3.0.17  ARM Interrupt Controller Vector Size Register (VSR) Initialization  	 	ARM9	 	  3.0 and earlier      	OMAP-L137	 	   The VSR register in the ARM Interrupt Controller (AINTC) is not correctly initialized after reset. If this register is not explicitly configured, the AINTC will only allocate 1 byte per interrupt (instead of 4).  	 	 	TI
      Method 1   Do not execute the intended interrupt service routine code if the associated CHIPSIGn status flag is not set in the SYSCFG_CHIPSIG register. A cleared CHIPSIGn status flag indicates that the device is responding to a false interrupt. This method is easy to implement, but does not eliminate false interrupts.  /** Pseudo code only **/  void CHIPINT0_ISR(void) {  /* Exit immediately if CHIPSIG0 is not set */  if( (SYSCFG->CHIPSIG & 0x1) == 0 ) {  return;  }  /* Intended service routine code */  SYSCFG->CHIPSIG_CLR = 0x1;  printf(“Hello World!\n”);  }      Method 2   Do not clear the AINTC CHIPINTn status flag until the CHIPSIGn status has been  cleared. This method will eliminate false interrupts, but requires changes to the AINTC  interrupt dispatch code. Changing the dispatch code may introduce undesired behavior in the application.  /** Pseudo code only **/  /* Sequence that is susceptible to false CHIPINTn interrupts */  void AINTC_ISR_DISPATCH_1(void) {  Get_Interrupt_Information();  /* CHIPINTn interrupts continue to be generated after */  /* AINTC CHIPINTn flag is cleared.  */  Clear_AINTC_Interrupt_Flag();  /* CHIPINTn interrupts are only stopped after ISR clears */  /* the status flag.  */  Branch_To_ISR();  }  16  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback   3.0 Usage Notes and Known Design Exceptions to Functional Specifications  /* Sequence that is not susceptible to false CHIPINTn interrupts */  void AINTC_ISR_DISPATCH_2(void) {  Get_Interrupt_Information();  /* ISR will clear CHIPSIGn flag and discontinue CHIPINTn */  /* interrupts to AINTC.  */  Branch_To_ISR();  /* Ok to clear AINTC CHIPINTn flag now.  */  Clear_AINTC_Interrupt_Flag();  }  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  17  Submit Documentation Feedback   3.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      	 3.0.18   A Single CHIPINTn Interrupt Event Can Register Multiple Times in the AINTC  	 	ARM9	 	  3.0 and earlier      	OMAP-L137	 	   Interrupts destined for the ARM CPU are managed by the ARM Interrupt Controller  (AINTC). The AINTC detects, combines, and routes system interrupts to the two native ARM interrupt signals FIQ and IRQ. See the device Technical Reference Manual  SPRUH92 for additional information about the AINTC.  The AINTC module expects all incoming interrupts to be pulse interrupts, however the  [SYSCFG_CHIPSIG_]CHIPINTn interrupts are level interrupts. This mismatch in interrupt types will cause a single CHIPINTn interrupt event to register as multiple interrupt pulses in the AINTC. However, the AINTC does not have the capacity to count the number of  interrupt pulses received per system interrupt – it only maintains interrupt flags. A system interrupt is flagged as active until its status is cleared by the user through the AINTC, regardless of the number of interrupts detected.  If the status flag for AINTC CHIPINTn is cleared while the CHIPINTn interrupt is still active, the AINTC will continue to detect CHIPINTn interrupts and its status flag will be set again. This additional setting of the AINTC CHIPINTn status flag is false.  	 	 	TI
  Perform one of the following:  •  For the location of code where saturation results are monitored, do not mix datatypes so that 2 cycle and 4 cycle .M unit instructions are not issued together.  •  Do not mix floating point .M unit instruction with fixed point 2 cycle .M unit  instructions.  18  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback   3.0 Usage Notes and Known Design Exceptions to Functional Specifications 	 3.0.19   Incorrect Masking of the C674x CSR:SAT Bit  	 	ARM9	 	  3.0 and earlier      	OMAP-L137	 	   The C674x CPU supports a Saturation feature for key arithmetic operations. If an  operation results in saturation, the SAT (saturation) bit in the control status register (CSR) is set. In normal operation, one or more functional units can simultaneously  perform arithmetic operations that can result in saturation. In the case of simultaneous arithmetic operations, the SAT bit is set if at least one functional unit’s operation results in saturation. The saturation status register (SSR) provides saturation flags for each functional unit, making it possible for the program to distinguish between saturations caused by different instructions in the same execute packet. Also, there is no direct connection to the SAT bit in the control status register (CSR); writes to the SAT bit have no effect on SSR and writes to SSR have no effect on the SAT bit.  In the case where a 2 cycle .M unit instruction is in the delay slot of a 4 cycle instruction of the same .M unit, and if both instructions are expected to generate results in the same cycle, the CSR:SAT bit will be incorrectly masked. Ideally, the CSR:SAT bit should be set if any one of the two .M unit instruction causes a saturation. Instead, the arithmetic saturation result of the 2 cycle .M unit instruction will overwrite the CSR:SAT bit.  All of the following must take place in order for an application to be affected by this advisory:  1. A 2 cycle .M unit instruction and a 4 cycle .M unit instruction are issued  simultaneously  2. Both instructions are processed on the same side  3. The 2 cycle instruction is in the delay slot of the 4 cycle instruction so that the results of both instructions are generated in the same cycle  4. The saturation result of the 4 cycle .M unit instruction is different from the saturation result of the 2 cycle .M unit instruction  5. The application checks for the saturation flag and uses the saturation result of the 4  cycle instruction  	 	 	TI
  Method 1: Do not perform two CPU read operations in the same clock cycle. For C  code, use compiler flag (--c64p_dma_l1d_workaround) available in the C6000  Compiler (CodeGen) Tools version 7.0.2 and later. For assembly code, the --  c64p_dma_l1d_workaround flag will only issue a warning.  Method 2: In cases where buffer access will not be shared between CPU and SDMA, unintended CPU/SDMA cache-line sharing can be avoided by aligning CPU and SDMA  buffers to 64-byte boundaries. Aligning buffers to 64-byte boundaries will result in wasted space, however it ensures that the CPU and SDMA buffers will not have partial  segments which overlap into the same L1D cache line.  /** Pseudo code only **/  Uint8 *SDMA_BUFF, *CPU_BUFF;  /* 64-byte aligned allocation Option 1 */  SDMA_BUFF = malloc( (Int32) (( SDMA_BUFF_SIZE + 63)/64) * 64 );  CPU_BUFF = malloc( (Int32) ((CPU_BUFF_SIZE + 63)/64) * 64 );  SDMA_BUFF = (Uint8 *) ( (Int32) SDMA_BUFF & ~63 );  CPU_BUFF = (Uint8 *) ( (Int32) CPU_BUFF & ~63 );  /* 64-byte aligned allocation Option 2 with BIOS Call */  SDMA_BUFF = MEM_alloc( IRAM, SDMA_BUFF_SIZE, 64 );  CPU_BUFF = MEM_alloc( IRAM, CPU_BUFF_SIZE, 64 );  20  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback   3.0 Usage Notes and Known Design Exceptions to Functional Specifications Method 3 Manage access to a 64-byte boundary aligned buffer that is shared between CPU and SDMA by implementing a semaphore and forcing cache writeback operations if  there are CPU writes. With this method, the semaphore ensures that there is clear  ownership of the buffer between CPU and SDMA, and the CPU manages cache  coherence by using explicit cache writeback operations.  /** Pseudo code only **/  /* Example with EDMA as the external master */  EDMA_ISR() {  /* EDMA releases ownership of buffer */  SEM_post(SyncSemaphore);  return;  }  main() {  while(COND) {  /* CPU waits for ownership of buffer */  SEM_pend(SyncSemaphore);  /**********************/  /*** CPU Processing ***/  /**********************/  /* Cache writeback for shared block */  /* Buffer must be 64-byte aligned */  BCACHE_wbInv( blockPtr, blockSize, WAIT );  /* Initiate EDMA */  EDMA_Event_Generate();  }  }  Method 4 Do not allow SDMA to access L2 RAM. SDMA can use buffers in L1D RAM or Shared RAM instead of L2 RAM.  Method 5 Configure the entire L2 RAM as cache. Critical peripheral data can be accessed in L1D RAM or Shared RAM instead of L2 RAM.  Method 6 Configure the entire L2 RAM as normal SRAM (no cache).  Method 7 Configure the entire L1D RAM as normal SRAM (no cache).  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  21  Submit Documentation Feedback   3.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      	 3.0.21  SDMA Activity Can Corrupt L1D When L2 Is Configured as Mixed/C ache/SRAM  	 	ARM9	 	  3.0 and earlier      	OMAP-L137	 	   Note: SDMA refers to all non-CPU requests to the EMC SDMA (Slave Direct Memory Access) port (see Figure 3). SDMA requests are defined as external system bus master requests handled via this port.  The C674x Megamodule uses a two-way set associative cache for L1D. This means that  every physical memory location in the system has two possible set/way locations in the cache where it can reside. See TMS320C674x DSP Megamodule Reference Guide  (Literature Number SPRUFK5) for more information on the L1D cache architecture and  related terminology. Updated (dirty) values in L1D cache are not written back to external memory until cache activity evicts a cache-line (victim write-back) or a write-back is requested by software.  An L1D cache-line corruption event occurs when all of the conditions in the following steps are met (see Figure 3):  1. L1D cache Lines 1, 2, and 3 have the following characteristics:  •  Line 1 is associated with L2 SRAM (Line A in Figure 3), was previously read by  CPU, and is clean. (CPU has not updated the data.)  •  Line 2 is associated with L2 SRAM (Line B in Figure 3), was previously read by  CPU, and is clean. (CPU has not updated the data.)  •  Line 3 was previously read by the CPU and may be either clean or dirty.  2. SDMA receives updated data for L2 SRAM Lines A and B, which correspond to L1D  cache Lines 1 and 2.  3. A snoop write operation is initiated by the L2 to overwrite the L1D cache Lines 1 and 2 with updated L2 SRAM Lines A and B. Before the snoop write operation finishes,  the CPU performs two reads within the same clock cycle:  •  Line E in L2 cache is read as a cache hit. Line E is destined to replace Line 2 in  L1D Cache, which also has a snoop write pending for the updated Line B  content.  •  Line D in L2 SRAM is read. Line D will replace Line 3 in L1D cache.  4. When the snoop write operation completes, Line 2 in L1D cache now contains the  updated L2 SRAM Line B data instead of the L2 cache Line E data.  The correct behavior would have been to kill the pending snoop write initiated to update L1D cache Line 2 with the updated L2 SRAM Line B data in Step 3. The L1D cache  should have evicted Line B and replaced it with Line E data. Instead, the snoop write operation continues and does not complete until after the L1D cache Line 2 has already been replaced with L2 cache Line E data. The snoop write instruction overwrites the L1D  cache Line 2 (containing L2 cache Line E data) with the updated L2 SRAM Line B data.  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  19  Submit Documentation Feedback   3.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  Time Line  System View      Line A   Line E and Line B Map to  STEP 1  STEP 2  STEP 3  STEP 4  same L1D Cache line.  Line A  B  C674x subsystem  Line A  C  C6xCPU  Read Line D  L2  Line A  D  Activity  Read Line E  C6X CPU  Controller  L2 SRAM  SDMA  Write Line A Snoop Write  Line A  E  Activity  Write Line B  Initiated  L1D  EMC  L2 CACHE      L1D Cache   Clean Line A Clean Line A  IN FLUX  Clean Line A  Controller  SDMA PORT      Line 1   (New Data)      L1D Cache   Clean Line B Clean Line B  IN FLUX  CORRUPT  EMAC      Line 2   Line E replaces Line B due  Line      Line 1 A   [A]  PRU      L1D Cache   Clean/Dirty  Clean/Dirty  IN FLUX  Clean Line D  to CPU read.  Line 3  Line C  Line C  Line      Line 2 A   [B/E] Delayed snoop wrtie to Line  EDMA  SYSTEMMASTERS  Line      Line 3 A   [C/D] B corrupts Line E in L1D$  L1D  Corruption happens  CACHE  UHPI  because of this state      EXTERNAL   Figure 3. Example of L1D Cache Corruption  	 	 	TI
  None  22  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback   3.0 Usage Notes and Known Design Exceptions to Functional Specifications 	 3.0.22   USB 2.0 On-The-Go (OTG) Session Request Protocol (SRP) Is Not Supported  	 	ARM9	 	  3.0 and earlier      	OMAP-L137	 	   The USB 2.0 On-The-Go (OTG) Session Request Protocol (SRP) allows a USB-  peripheral to request the USB-host to enable Vbus and start a session. On this device, the SRP protocol is not supported.  The OTG Host Negotiation Protocol (HNP), which allows USB-devices to swap roles  between host and peripheral, is supported.  	 	 	TI
  When a break in transmission is detected, USB0 traffic can be recovered by a software reset of the USB0 PHY. A PHY reset implies recalibration of the PHY PLL at the reset temperature. The system has not been observed to reliably recover on its own. A PHY  reset also implies re-enumeration of all devices. There is no way to recalibrate the USB0  PHY without a re-enumeration.  In order to invoke the recovery mechanism (that is a USB0 PHY reset) one needs to  determine when the issue is present. One such approach is to look for an absence of  USB0 Core interrupts over a specified time window. This window should be optimized for the expected USB traffic based upon the application.  As an additional safeguard, an application can also intentionally schedule pre-  determined USB PHY resets at specific temperature points if operation over a broad  range is expected.  Here is an example of one way to power cycle the USB0 PHY via the Chip Configuration 2 Register in the System Configuration (SYSCFG) Module:  #define CFGCHIP2  *((volatile unsigned int *) 0x01C14184)  #define USBPHY_PHYPDWN 0x00000200  Void phy_reset(void) {  CFGCHIP2 |= USBPHY_PHYPDWN;  /* Power down the USB PHY */  mdelay(1);  /* Wait 500ms */  CFGCHIP2 &= ~USBPHY_PHYPDWN;  /* Power up the USB PHY */  }  24  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback   3.0 Usage Notes and Known Design Exceptions to Functional Specifications 	 3.0.24  USB0 PLL Mean Frequency Can Drift Across Large Temperature Swings  	 	ARM9	 	  3.0 and earlier      	OMAP-L137	 	   Under conditions in which the device is subjected to large variations in operating  temperatures, the USB0 PLL temperature compensation circuitry does not have enough  margin to guarantee compensation for PLL drift across all temperature ranges.  As a result, the mean frequency generated by the USB0 (USB 2.0 OTG) PHY PLL will  begin to drift (relative to the expected 480 Mbps) when the temperature of the device is subjected to large swing from the original temperature in which the USB0 PHY was most recently calibrated (initialized).  Once the onset of the PLL drift occurs, the mean frequency will continue to drift outside the expected frequency eventually resulting in failure of USB packet reception and/or transmission. This break in transmission will continue until the USB0 PHY is recalibrated during a USB0 PHY Reset.  If the device is not exposed to large variations in temperature relative to the temperature at which the USB0 PHY was most recently initialized, the temperature compensation  circuitry is expected to provide the proper compensation to prevent the mean PLL  frequency from losing lock and beginning to drift.  More specifically, this advisory is most applicable in applications where the device is expected to operate outside the commercial temperature space (0˚C-90˚C). TI has  identified a point-to-point device temperature range of 0˚C-65˚C in which there is very high confidence in which the compensation circuitry will properly compensate for all variations in temperature provided that the USB0 PHY was most recently initialized  (calibrated) within this same temperature range.  Operating outside the 0˚C-65˚C temperature range increases the susceptibility of the device to experience PLL drift, but does not mean that the application will always  experience a failure in USB transmission.      Root Cause   The Voltage Controlled Oscillator (VCO) Compensation circuitry local to the USB0 PHY  was not designed with a large enough range to compensate for all variations in  temperature across the specified operating range of the device.  How to Most Easily Reproduce the Issue: Reproduction of this issue can most easily be accomplished by the following steps:  1. Allowing the unit to soak in an ambient temperature of -35˚C until the device  temperature reaches approximately the same temperature.  2. Power up the device and provide the necessarily software programming in order to  invoke the USB Signal Quality Test Pattern.  3. Using a USB 2.0 Certified Test Platform, execute the USB signal quality test  procedure across the following temperature set points. -35˚C, 0˚C, +35˚C, +70˚C.  Record the measured mean frequency by the compliance software.  NOTE:  The set points can be varied to obtain finer temperature resolution of  when the PLL begins to drift a per platform basis. The above temperature  profile is provided for reference.  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  23  Submit Documentation Feedback   3.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  	 	 	TI
  Initialize the datalength descriptor field to zero. CPPI DMA updates this field after the completion of an RX DMA operation with the actual number of bytes received. In the ISR  (actually in a deferred call context), poll this field until it becomes a non-zero value to ensure data buffer has been updated with actual data. The descriptor buffer write is posted after the data buffer write, so waiting for the descriptor field to be updated ensures the data buffer has been updated. Since this workaround involves deferred  procedure calls (whose schedule can be delayed depending on OS load), the latency  sensitive application (like ISO Audio) might be affected by delay in notification to the application.  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  25  Submit Documentation Feedback   3.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      	 3.0.25  USB0: CPU gets Stale Receive Data from the Data Buffer located in External      Memory   	 	ARM9	 	  3.0 and earlier      	OMAP-L137	 	   When CPPI DMA completes a receive data transaction it posts a write to the Rx data  buffer located in external memory, posts a write to update the descriptor located in external memory, and raises an interrupt to CPU. When the system load is high, the  posted writes to DDR may not be complete before the CPU receives the interrupt. In this case, the CPU would fetch stale receive data from the Rx data buffer located in external memory.  	 	 	TI
  The workaround involves monitoring transfer data size before and after transferring and reconfiguring data transfer size by software if the before and after size is different.  Software must keep tracking every endpoint data transferring size. When DMA  completion interrupt is received, software checks size difference. If the size is not equal, software requests the remaining data.  26  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback   3.0 Usage Notes and Known Design Exceptions to Functional Specifications 	 3.0.26   USB0: Early DMA Completion in DMA Receive Mode and More Than One Endpoint      is Transferring Data   	 	ARM9	 	  3.0 and earlier      	OMAP-L137	 	   The erroneous short packet status can be detected on current endpoint and XDMA  closes the Rx transfer in current endpoint. When more than one endpoint have been  processed, if one of the endpoints has a short packet, then the short packet status is broadcasting to all endpoints.  This results in premature completion of a Rx descriptor in generic RNDIS CPPI DMA  mode.  	 	 	TI
  Software should make sure that DMA does not get to an unknown state during teardown  by disabling the DMAEN bit in the RXCSR register. After this the teardown procedure  can be initiated. Software should also add 250 ms delay during teardown.  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  27  Submit Documentation Feedback   2.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      3   Silicon Revision 2.1 Usage Notes and Known Design Exceptions to Functional      Specifications   This section describes the usage notes and advisories that apply to silicon revision 2.1 of the OMAP-L137.      3.1   Usage Notes for Silicon Revision 2.1  Usage notes highlight and describe particular situations where the device's behavior may not match presumed or documented behavior. This may include behaviors that affect device performance or functional correctness. These usage notes will be incorporated into future documentation updates for the device (such as the device-specific data sheet), and the behaviors they describe will not be altered in future silicon revisions.  Silicon revision 2.1 applicable usage notes have been found on a later silicon revision. For more details, see Section 2.1 Usage Notes for Silicon Revision 3.0.      3.2   Silicon Revision 2.1 Known Design Exceptions to Functional Specifications  Silicon revision 2.1 applicable advisories have been found on a later silicon revision. For more details, see Section 2.2 Silicon Revision 3.0 Known Design Exceptions to Functional Specifications Table 3. Silicon Revision 2.1 Advisory List  Title ................................      Page   	 3.0.27  USB0: DMA Hung up in Frequent Teardowns  	 	ARM9	 	  3.0 and earlier      	OMAP-L137	 	   Teardown receive DMA is not working perfectly. This happens when a teardown is  initiated by software during the endpoint is still active. Frequent teardown results in XDMA hung up situation.  	 	 	TI
"  The following methods should be used to prolong the lifetime of the device.      METHOD 1   The 3.3 V output signals should only toggle when required for system functionality. The options are to tristate output buffers when not in use, or to run at the minimum frequency required for the specific application.      METHOD 2   Reduce the I/O voltage, DVDD.  Note: Do not reduce I/O voltage on devices already deployed or showing premature aging effects. To see the effects of premature aging on output signals, See the IO Buffer Premature Aging Assessment Wiki page.  Examples of Representative Lifetimes (Power-On Hours) depicts the subsequent  performance improvements by reducing the I/O voltage.  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  29  Submit Documentation Feedback   2.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  Examples of Representative Lifetimes (Power-On Hours)      NOMINAL   I/O  LIFETIME ESTIMATES (YEARS)  FAIL  DVDD      SWITCHING   DPPM(1)      RATE   HOURS (HRS) PER DAY OF USE  PERIPHERAL  VOLTAGE  FREQUENCY      ESTIMATE   (%)  (V)  (MHz)  2 HRS  3 HRS  7 HRS  12 HRS      24 HRS   1000   0.1  > 15  > 15  7.7  4.5  2.2  3.15  133  2500  0.25  > 15  > 15  > 15  8.8  4.4  EMIFB  5000  0.5  > 15  > 15  > 15  12.9  6.4  1000  0.1  > 15  > 15  > 15  > 15  > 15  3.15  16.94  2500  0.25  > 15  > 15  > 15  > 15  > 15  McASP  5000  0.5  > 15  > 15  > 15  > 15  > 15  (1)  Defective parts per million.  The Recommended Operating Conditions range for DVDD Supply Voltage, I/O, 3.3V,  has been expanded to allow for a minimum voltage of 3.0V for Silicon Revision 2.1  and 2.0 parts with the ""3V"" marking only (for more details on the die symbolization and device revision codes, see Section 1.2, Package Symbolization and Revision  Identification).  Recommended Operating Conditions  MIN  NOM  MAX      UNIT   DVDD   Supply voltage, I/O, 3.3V      3.0   3.3  3.45  V  The Absolute Maximum Ratings requirement for the Input voltage ranges, V I/O, 3.3V  I  (Steady State) has been modified.  Absolute Maximum Ratings Over Operating Case Temperature Range  V I/O, 3.3V  I  Input voltage ranges  –0.3V to DVDD + 0.350V  (Steady State)  See the IO Buffer Premature Aging Assessment Wiki page for more details on the  implementation of the above workarounds.  30  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback   2.0 Usage Notes and Known Design Exceptions to Functional Specifications 4  Silicon Revision 2.0 Usage Notes and Known Design Exceptions to Functional      Specifications   This section describes the usage notes and advisories that apply to silicon revision 2.0 of the OMAP-L137.      4.1   Usage Notes for Silicon Revision 2.0  Usage notes highlight and describe particular situations where the device's behavior may not match presumed or documented behavior. This may include behaviors that affect device performance or functional correctness. These usage notes will be incorporated into future documentation updates for the device (such as the device-specific data sheet), and the behaviors they describe will not be altered in future silicon revisions.  Silicon revision 2.0 applicable usage notes have been found on a later silicon revision. For more details, see Section 2.1 Usage Notes for Silicon Revision 3.0.      4.2   Silicon Revision 2.0 Known Design Exceptions to Functional Specifications  Some silicon revision 2.0 applicable advisories have been found on a later silicon revision. For more details, see  •  Section 2.2, Silicon Revision 3.0 Known Design Exceptions to Functional Specifications  •  Section 3.2, Silicon Revision 2.1 Known Design Exceptions to Functional Specifications Table 4. Silicon Revision 2.0 Advisory List  Title ................................      Page   "	 2.1.23  Digital I/O Buffers Age Prematurely  	 	ARM9	 	  2.1 and earlier      	OMAP-L137	 	   The 3.3 V digital I/O buffers on the device exhibit accelerated aging under use conditions with heavy switching activity. As a result, the recommended Power-On Hours (POH)  listed in the device-specific data manual may not apply in all cases. For examples of representative lifetimes, see Examples of Representative Lifetimes (Power-On Hours) .  In a typical use case, the EMIFB clock pin (EMB_CLK) may be impacted due to the high switching rate and may eventually lead to SDRAM-related failures.  NOTE: The information in Examples of Representative Lifetimes (Power-On Hours) and Examples of Representative Lifetimes (Power-On Hours) is provided solely for user  convenience and does not extend or modify the warranty provided under any terms and conditions, including TI’s Standard Terms and Conditions of Sale for Semiconductor  Products.  Examples of Representative Lifetimes (Power-On Hours)      NOMINAL   I/O  LIFETIME ESTIMATES (YEARS)  FAIL  DVDD      SWITCHING   DPPM(1)      RATE   HOURS (HRS) PER DAY OF USE  PERIPHERAL  VOLTAGE  FREQUENCY      ESTIMATE   (%)  (V)  (MHz)  2 HRS  3 HRS  7 HRS  12 HRS      24 HRS   1000   0.1  8.9  5.9  2.5  1.5  0.7  3.30  133  2500  0.25  >15  11.7  5.0  2.9  1.5  EMIFB  5000  0.5  > 15  > 15  7.3  4.3  2.1  1000  0.1  > 15  > 15  > 15  11.6  5.8  3.30  16.94  2500  0.25  > 15  > 15  > 15  > 15  11.5  McASP  5000  0.5  > 15  > 15  > 15  > 15  > 15  (1)  Defective parts per million.  Accelerated aging of buffers depends on I/O switching frequency and I/O voltage.  Prolonged high frequency switching and operating at higher voltages causes buffer  performance to degrade more rapidly.  	 	 	TI
  Modify the target board so that the affected device is given a secondary reset on power-up as shown in Figure 6. Two example methods are described in the sections that  follow.  Although secondary resets are compatible with future silicon revisions, they are not required for devices where the root cause has been fixed via an updated DSP boot  ROM. In order to reduce BOM costs, board designers may want to route a reset signal  bypass path so that the workaround circuit can be depopulated on future PCB builds.  ❏ Use a reset supervisor device that includes a watchdog timeout function so that the reset supervisor will issue a secondary reset if the device fails to boot. The watchdog should be serviced with a device signal that is controlled by software. Options for  servicing the watchdog timeout include GPIO, unused clock sources such as  OBSCLK or a periodic output peripheral like TIMER and ePWM.  Some TPS382x reset supervisors include a watchdog function (shown in Figure 9).  34  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback  Copyright © 2008–2014, Texas Instruments Incorporated      www.ti.com  Silicon Revision 2.0 Usage Notes and Known Design Exceptions to Functional Specifications TPS3820      3.3V   OMAP-L137   VDD  DVDD  GND  GND  Board Reset  MR  WDI  GPIO  RESET      RESET   0-W      Not Populated   Figure 9. Reset Supervisor with Watchdog Function  The watchdog supervisor workaround is easy to implement, however the watchdog  timeout period may exceed application boot-up time requirements. For example, the  TPS3820 has a typical watchdog timeout period of 200ms. The second workaround can  speed up the reset process.  ❏ Implement a logic-based secondary reset circuit which is timed using RC  components. For the circuit shown in Figure 10, a single board reset control signal  can trigger three logic transitions in a dual XOR gate device.      Not Populated   0-W  1A  R1  1Y  1B  Board Reset  1  C1  1A  RESET  R2  1Y  1B  2  R3  SN74LVC2G86  C2  Dual XOR Gate  SN74LVC2G17      Dual Schmitt Buffer   Figure 10. RC-Timed Secondary Reset  This is possible because each RC load connected to the board reset control signal can output a different rising-edge waveform. With increasing RC load, the resulting control signal will reach the Schmitt buffers’ Vih level at a later point in time. Figure 11 shows the relationship between the board reset signal and the RESET signal produced by the circuit. The blue and green lines represent the voltage as seen by the Schmitt buffers.  The output voltage of a charging RC circuit is defined as: Vo = Vi * (1 - e^[-t / RC]) SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  35  Submit Documentation Feedback   2.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  R1C1  RESET  R2C2  Vih      Board Reset   Figure 11. RESET Signal vs Board Reset  Given ideal conditions, a 3.3V board reset signal, and an input buffer Vih of 1.4V, the following set of component values would generate an initial RESET high period (R1C1  region) of approximately 2ms and a RESET low period (R2C2 region) of approximately  0.5ms:  •  R1 = 36k, C1 = 100nF  •  R2 = 45k, C2 = 100nF  •  R3 = 450k  When implementing this workaround, some important aspects should be kept in mind:  (a) The dual Schmitt buffer is included because the dual XOR gate has an input rise-time requirement that is violated by the RC circuits.  (b) The Board Reset signal must meet the XOR gate input rise-time requirement and  must provide enough output current to charge the RC circuits to the target Vih level.  (c) It is critical for the Vih level of the two input buffers to be very close together so only single-device buffers should be considered for this circuit (such as the 2-in-1 dual Schmitt buffer device used in this example).  (d) Variations in the electrical characteristics of the circuit components may produce waveforms that deviate from ideal calculations.  (e) The sole purpose of the R3 pull-down resistor is to discharge the RC components  before the board reset signal is driven high. Therefore, the value selected for R3  should be sufficiently large enough to not interfere with the RC circuits as they are charging.  36  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback   1.1 Usage Notes and Known Design Exceptions to Functional Specifications 5  Silicon Revision 1.1 Usage Notes and Known Design Exceptions to Functional      Specifications   This section describes the usage notes and advisories that apply to silicon revision 1.1 of the OMAP-L137  device .      5.1   Usage Notes for Silicon Revision 1.1  Usage notes highlight and describe particular situations where the device's behavior may not match presumed or documented behavior. This may include behaviors that affect device performance or functional correctness. These usage notes will be incorporated into future documentation updates for the device (such as the device-specific data sheet), and the behaviors they describe will not be altered in future silicon revisions.  Silicon revision 1.1 applicable usage notes have been found on a later silicon revision. For more details, see Section 2.1, Usage Notes for Silicon Revision 3.0.      5.1.1   RTC Standby Power Consumption Is Elevated if the Module Is Not Configured Correctly On Silicon Revision 1.1 and earlier, the RTC module is designed with the ability to keep time while the rest of the device is power cycled off and on. This ability is achieved by placing the RTC in its own power domain and isolating it from the device reset signal.  When the CVDD supply is powered down, the RTC_CVDD supply will experience elevated standby power consumption because of leakage between the RTC and core power domains. The RTC module includes circuitry that eliminates the leakage paths between the two domains when the SPLITPOWER bit is set to 1  in the control register (CTRL). The SPLITPOWER bit is a write-only bit that will always read back 0.  Therefore, typical read-modify-write sequences should not be used when writing to the CTRL register because the SPLITPOWER bit will be cleared back to 0.  Also note that the SPLITPOWER bit has a default value of 0 after RTC module reset, and the only reset available to the RTC module is a software reset, therefore RTC is in an indeterminate state when the RTC_CVDD supply is first powered on. The RTC module should be reset, and the SPLITPOWER bit should be set to 1 before placing the device in a CVDD powered down standby state. The SPLITPOWER  bit is permanently set to 1 inside the RTC module beginning with Silicon Revision 2.0 of the device.      5.1.2   SYSCFG: Possible Race Condition When Using KICK Registers  On Silicon Revision 1.1 and earlier, when two or more threads are simultaneously accessing the SYSCFG  registers, there is the potential for one thread to lock the SYSCFG registers while another thread is still accessing them. There is no hardware semaphore to prevent this from occurring.  For example, the race condition can occur in the following situation  1. Thread 1 unlocks the SYSCFG register by writing to the KICK registers  2. An interrupt occurs and Thread 2 unlocks the SYSCFG registers as well  3. Thread 2 finishes and locks the SYSCFG registers  4. Thread 1 is locked out of the SYSCFG registers and is unable to complete its task To prevent the SYSCFG lockout race condition, the application should unlock the SYSCFG registers via the KICK registers and leave them permanently unlocked.  Starting with silicon revision 2.0, the KICK registers will be disabled and the SYSCFG registers will be permanently accessible. Writes to the disabled KICK registers will have no effect.      5.2   Silicon Revision 1.1 Known Design Exceptions to Functional Specifications  Some silicon revision 1.1 applicable advisories have been found on a later silicon revision. For more details, see  •  Section 2.2, Silicon Revision 3.0 Known Design Exceptions to Functional Specifications  •  Section 3.2, Silicon Revision 2.1 Known Design Exceptions to Functional Specifications SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  37  Submit Documentation Feedback   1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  •  Section 4.2, Silicon Revision 2.0 Known Design Exceptions to Functional Specifications Table 5. Silicon Revision 1.1 Advisory List  Title ................................      Page   	 2.0.20      Intermittent Boot Failures   	 	ARM9	 	  2.0 and earlier      	OMAP-L137	 	   For affected silicon revisions, the DSP initiates the system boot sequence when the  device is released from reset. To prepare the ARM for the user, the DSP will first  initialize the ARM reset vector table with an infinite “idle” loop.  The ARM reset vector table is located in the ARM’s local RAM, however the ARM local  RAM can only be accessed by two bus masters: ARM and PRU0. Therefore, the DSP  must program PRU0 to copy the desired reset vector table into the ARM’s local RAM.  The PRU instructions are located inside of an instruction RAM (IRAM) which is initialized by the DSP during ROM boot (see Figure 4). After the instructions are stored to IRAM, the PRU is reset and enabled to execute its instructions. In this case, the PRU is  instructed to initialize the ARM reset vector table.  Read  PRU Core  PRU IRAM  Write  Enable Bit Reset Bit      External Master   (DSP)  Figure 4. PRU and DSP Block Diagram  When the device is first powered-on, the read bus from the PRU IRAM is not initialized and will contain random values (see Figure 5). Under unpredictable circumstances, the random value on the read bus may resemble a reserved instruction which can be  interpreted by the PRU when the core is reset and not enabled.  If the PRU core executes this reserved instruction, it will not be able to properly execute the first functional op-code in the PRU IRAM when the core is later enabled. In this fail state, the PRU will never acknowledge to the DSP that the reset vector table was  successfully initialized and the DSP will be stuck in a polling loop waiting for the PRU to complete its task.  Read Rsvd Inst      PRU Core   Fail State!  PRU IRAM  Write  Enable Bit Reset Bit      External Master   (DSP)  Figure 5. Boot Failure on Power-On  Although the PRU core execution is stuck, the PRU IRAM read bus is now initialized with a non-reserved instruction that was fetched from the IRAM by the PRU core (see  32  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback   2.0 Usage Notes and Known Design Exceptions to Functional Specifications Figure 6). If a secondary reset is provided to the device (either POR or WARM), the PRU  will be able to execute its functional instructions as expected.  Read Good Inst      PRU Core   Pass State!  PRU IRAM  Write  Enable Bit Reset Bit      External Master   (DSP)      Figure 6. Secondary Reset   Note that in order to recover from this fail state with a secondary reset, the DSP must be allowed to execute its boot ROM up to the point where the PRU has fetched a known  instruction from the PRU IRAM. The approximate count of 15k cycles into the boot ROM  is sufficient.  The 15k clock cycle count does not include the 6192 clock cycles required to complete a device POR reset (see Figure 7). With a 24MHz crystal, the first RESET signal must be asserted high for at least 883us (or approximately 1ms).  Greater than 15k Cycles  RESET  RESETOUT      6192 Cycles   Figure 7. First POR Reset Timing  The long-term solution for this problem is to update the DSP boot ROM with a new PRU  initialization sequence that is immune to the described fail mode (see Figure 8):  1. Before resetting the PRU, the DSP will perform a read-back-verify of the PRU IRAM  so that the IRAM read bus will be initialized with a known and safe state.  2. The PRU will be reset and enabled in the same clock cycle by using a single register write so that the core does not have the opportunity to interpret reserved instructions.  3. The DSP will write additional, non-critical op-codes at the beginning of the PRU IRAM  so that the PRU can self-recover even if it interprets a reserved instruction.  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  33  Submit Documentation Feedback   2.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  Read Good Inst      PRU Core   Pass State!  PRU IRAM  Write  Enable Bit Reset Bit  DSP  Read      External Master   (DSP)      Figure 8. New Initialization Sequence   The following symptoms are all observable for this fail mode at power-on:  1. The RESETOUT signal toggles as expected 6192 cycles after the RESET signal is  asserted high.  2. The device produces no boot-mode related activity and the user’s boot program will not be loaded or executed.  3. Connecting to the DSP through JTAG emulation will show that the DSP is stuck in a loop inside of the DSP boot ROM (0x00700000 – 0x007FFFFF memory space).  4. A subsequent reset (either POR or WARM) which is initiated at least 1ms after the first POR reset is asserted high will always produce a successful boot.  5. Following a secondary reset, the device will function as expected without fail until the device is powered-off again.  	 	 	TI
  Only the Write-Through or Non-Cached mode can be used. Write-Through mode is preferred for better performance. The cache operation is controlled using the C and B  bits in page or section descriptors. For operation in Write-Through mode, the C and B  bits (bits 3:2 in the descriptor) must be set to a value of 10b.  The following is example code using a section descriptor to create a table entry for the first 1MB of external SDRAM on EMIFB as write-through cachable:  LDR  r1,  SDRAM0_ADDR  ; table offset for SDRAM0 region  LDR  r2,  SDRAM0_DATA  ; descriptor pattern for SDRAM0 region  STR  r2,  [r0, r1, LSL#2]  ; store the table entry at TTB base + table  offset * 4  SDRAM0_ADDR  .word  0x00000C00  SDRAM0_DATA  .word  0xC0000CFA  For more information on ARM data cache modes and how to configure them, refer to the ARM926EJ-S™ Technical Reference Manual available at www.arm.com/documentation.  Chapter 4 of the ARM926EJ-S™ Technical Reference Manual provides details about cache operations on the ARM926EJ-S processor.  Section descriptor: A section descriptor provides the base address of a 1MB block of memory. Figure 12 shows the format of a section descriptor.  31  20  19  12  11  10  9  8  5  4  3  2  1  0  section base address  AP  SBZ  AP  Domain  1  C  B  1  0      Figure 12. Section Descriptor   Table 6 shows the Section Descriptor bit assignments. Table 7 shows the Page Table C  and B bit settings for the DCache.  Table 6. Section Descriptor Bits  BITS      DESCRIPTION   31:20   Form the corresponding bits of the physical address for a section.  19:12  Always written as 0.  11:10  Specify the access permissions for this section.  9  Always written as 0.  Specify one of the 16 possible domains, held in the domain access control register, that contain the primary 8:5  access controls.  4  Should be written as 1, for backwards compatibility.  Indicate if the area of memory mapped by this section is treated as write-back cacheable, write-through 3:2  cacheable, noncached buffered, or noncached nonbuffered.  1:0  These bits must be 10 to indicate a section descriptor  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  39  Submit Documentation Feedback   1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  Table 7. Page Table C and B Bit Settings for the DCache  C BIT  B BIT      DESCRIPTION   ARM926EJ-S BEHAVIOR   DCache disabled. Read from external memory. Write as a nonbuffered  0  0  Noncacheable, nonbufferable  store(s) to external memory. DCache is not updated.  DCache disabled. Read from external memory. Write as a buffered  0  1  Noncacheable, bufferable  store(s) to external memory. DCache is not updated.  DCache enabled:  • Read hit - Read from DCache  • Read miss - Linefill  1  0  Write-through  • Write hit - Write to the DCache, and buffered store to external  memory  • Write miss - Buffered store to external memory  DCache enabled:  • Read hit - Read from DCache  1  1  Write-back  • Read miss - Linefill  • Write hit - Write to the DCache only  • Write miss - Buffered store to external memory  40  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback   1.1 Usage Notes and Known Design Exceptions to Functional Specifications 	 1.1.1  ARM Data Cache in Write-Back Mode Is Not Functional: Must Use Write-Through  or Non-Cached Mode  	 	ARM9	 	  1.1 and earlier      	OMAP-L137	 	   The ARM926 subsystem allows data memory regions to be write-back cachable, write-  through cachable, or non-cached. On this device revision, the Write-Back mode is not functional; therefore, Write-Through or Non-Cached mode must always be used.  	 	 	TI
  The user can remove the associated channel number entry from the DMA scheduler  Tables (scheduler array) for that endpoint when not expecting data from a host.  Whenever data transfer is initiated by the host, the endpoint interrupt will be generated by the USB controller, which can be used as an indication for an application to secure required resources prior to adding the DMA channel entry for the endpoint onto the  scheduler array.  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  41  Submit Documentation Feedback   1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      	 1.1.2  USB0: CPPI Receive Starvation Interrupt  	 	ARM9	 	  1.1 and earlier      	OMAP-L137	 	   When an endpoint is enabled for receive transfer(s) that will be serviced via DMA and data has been received prior to allocating DMA resource, the DMA will generate a  starvation interrupt to notify the application a lack of resource (starvation) in anticipation that the application will furnish the required resource. The CPPI DMA is supposed to generate a single interrupt. But, in this case it continues generating interrupt periodically, until application furnishes a resource. In some use cases, it has been observed that the application may desire to differ the time as to when to service the starvation request due to the CPU handling other urgent task(s). Since the DMA keeps on generating the  starvation interrupt periodically and there exists no capability to mask the starvation interrupt at the USB controller level, the CPU is forced either to fully service the DMA interrupt as it is received or disable all USB interrupt at the CPU level. Disabling the entire USB interrupt might not be the desired option since the CPU needs to be aware of other USB interrupts that are more critical.  	 	 	TI
  Use the SPIFMTn.PRESCALE with an odd value if possible.  42  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback   1.1 Usage Notes and Known Design Exceptions to Functional Specifications 	 1.1.3   SPI: Internally Generated SPI Clock Is Not 50% Duty Cycle  	 	ARM9	 	  1.1 and earlier      	OMAP-L137	 	   When the SPI is in master mode, the generated SPICLK signal is derived from the  internal SPI module clock. This SPICLK signal duty cycle is not 50% when the  SPIFMTn.PRESCALE is set to an even number.  With an even prescale value, the falling edge of the SPICLK is delayed 1-2 ns  regardless of the SPICLK frequency. Therefore, the high side is wider than the low side.  	 	 	TI
      Method 1   In cases where buffer access will not be shared between CPU and SDMA,  unintended CPU/SDMA cache-line sharing can be avoided by aligning CPU and  SDMA buffers to 64-byte boundaries. Aligning buffers to 64-byte boundaries will  result in wasted space, however it ensures that the CPU and SDMA buffers will not  have partial segments which overlap into the same L1D cache line.  /** Pseudo code only **/  Uint8 *SDMA_BUFF, *CPU_BUFF;  /* 64-byte aligned allocation Option 1 */  SDMA_BUFF = malloc( (Int32) (( SDMA_BUFF_SIZE + 63)/64) * 64 );  CPU_BUFF  = malloc( (Int32) ((CPU_BUFF_SIZE  + 63)/64) * 64 );  SDMA_BUFF = (Uint8 *) ( (Int32) SDMA_BUFF & ~63 );  CPU_BUFF  = (Uint8 *) ( (Int32) CPU_BUFF  & ~63 );  /* 64-byte aligned allocation Option 2 with BIOS Call */  SDMA_BUFF = MEM_alloc( IRAM, SDMA_BUFF_SIZE, 64 );  CPU_BUFF  = MEM_alloc( IRAM, CPU_BUFF_SIZE,  64 );      Method 2   Manage access to a 64-byte boundary aligned buffer that is shared between CPU  and SDMA by implementing a semaphore and forcing cache writeback operations  after CPU writes. With this method, the semaphore ensures that there is clear  ownership of the buffer between CPU and SDMA, and the CPU manages cache  coherence by using explicit cache writeback operations.  /** Pseudo code only **/  /* Example with EDMA as the external master */  EDMA_ISR() {  /* EDMA releases ownership of buffer */  SEM_post(SyncSemaphore);  return;  }  main() {  while(COND) {  /* CPU waits for ownership of buffer */  SEM_pend(SyncSemaphore);  /**********************/  /*** CPU Processing ***/  /**********************/  /* Cache writeback for shared block */  /* Buffer must be 64-byte aligned  */  BCACHE_wbInv( blockPtr, blockSize, WAIT );  /* Initiate EDMA */  EDMA_Event_Generate();  }  }      Method 3   Configure the entire L2 RAM as cache. Critical peripheral data can be accessed in  L1D RAM or L3 RAM instead of L2 RAM.      Method 4   Do not allow SDMA to access L2 RAM. SDMA can use buffers in L1D RAM or L3  RAM instead of L2 RAM.      Method 5   Do not configure L1D memory as cache - use the entire address space as RAM.  44  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback   1.1 Usage Notes and Known Design Exceptions to Functional Specifications 	 1.1.5  Under Specific Conditions, SDMA Activity Can Corrupt the L1D Cache and L2 RAM  	 	ARM9	 	  1.1 and earlier      	OMAP-L137	 	   Note: DMA refers to all non-CPU requests. SDMA refers to external system DMA master requests handled via the Slave Direct Memory Access port.  The C674x Megamodule uses a two-way set associative cache for L1D. This means that  every physical memory location in the system has two possible set/way locations in the cache where it can reside. See TMS320C674x DSP Megamodule Reference Guide,  Literature Number - SPRUFK5 for more information on the L1D cache architecture.  Updated (dirty) values in L1D cache are not written back to external memory until cache activity evicts a cache-line (victim write-back) or a write-back is requested by the application.  An L1D cache-line corruption event occurs when all of the following conditions are met: 1. L1D cache evicts a dirty line (Line A) while allocating a new line (Line B) in the same set/way (cache Lines A and B consist of 64-bytes each). In order for this to happen, the following will have taken place:  (a) Line A was previously read by CPU because L1D is a read-allocate cache,  (b) Line A is dirty because its value was modified by CPU, and  (c) Line B is read by CPU  2. Both Line A and Line B are associated with L2 RAM, and  3. While the original L1D victim write-back from condition (1) is in progress, the SDMA performs both:  (a) a read or write operation to Line A in L2 RAM and  (b) a write operation to Line B in L2 RAM.  If all of the above conditions are met, the L2 RAM data associated with the Line A victim writeback will become corrupt. Additionally, the Line B data originating from the SDMA write will also become corrupt in L1D cache. Figure 13 shows an example scenario of  L1D cache and L2 RAM corruption.  Line A and Line B Map to  LINE A  same L1D Cache line.  INITIAL  STEP 1  STEP 2  STEP 3  STATE  C674x Megamodule  LINE B  C674x CPU  CPU Request  Request  L2  C674x CPU  EXTERNAL  Activity  Line B  Pending  Controller  L2  SRAM  SDMA  SDMA Requests  Activity  Writes to both  LineA and LineB  L1D  EMC  L1D Cache  Dirty Line A      Dirty Line A   IN-FLUX   Corrupt  Controller  SDMA PORT  EDMA  SYSTEMMASTERS      Line Status   in L1D Cache in L1D Cache  Line A  Old Data  Old Data  Old Data  Corrupt  L2 SRAM  Line B tries to replace  EMAC  CACHE LINE  Line B  Old Data  Old Data  Old Data      NEW DATA   Dirty Line A in the L1D  L2 SRAM  Cache  L1D  CACHE  Corruption happens  because of this state  TIME LINE      SYSTEM VIEW   Figure 13. Example of L1D Cache and L2 RAM Corruption  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  43  Submit Documentation Feedback   1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  	 	 	TI
  The 15 KΩ pull downs should be added to the DP/DM lines externally to the device.  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  45  Submit Documentation Feedback   1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      	 1.1.8  USB 1.1 Phy Does Not Have Internal Pull Down on DP/DM Lines Enabled  	 	ARM9	 	  1.1 and earlier      	OMAP-L137	 	   USB 1.1 requires a 15 KΩ pull down on the DP/DM lines. The USB 1.1 Phy does not  include the internal pull down.  	 	 	TI
  To prevent a latch up condition from occurring over the life of the device, the following recommendations should be followed:  •  USB0_VDDA18 and USB1_VDDA18 power supply rails must have greater than 1ms  (10%-90%) slew  •  USB0_VDDA33 and USB1_VDDA33 power supply rails must have less than 100-mv  pk-pk noise  •  USB0_VBUS power supply rail must have less than 100-mv pk-pk noise sustained  and must have greater than 1ms (10%-90%) slew  46  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback   1.1 Usage Notes and Known Design Exceptions to Functional Specifications 	 1.1.9   USB2.0 (USB0) and USB1.1 (USB1) Power Supply  	 	ARM9	 	  1.1 and earlier      	OMAP-L137	 	   There is the potential for the 1.8V and 3.3V USB power supplies to experience a latchup condition. The potential for latchup on these supplies is related to the power-on voltage slew rate and the likelihood for latchup with a rapid voltage supply slew rate gradually increases over the device lifetime.  	 	 	TI
  During PCB board design and layout, the AC timings specified in Table 8 and Table 9  should be considered when designing interfaces to the EMIFB.  Table 8. Timing requirements Over Recommended Operating Conditions  NO.  PARAMETER  MIN  MAX      UNIT   Input setup time, read data valid on EMB_D[ 31  19  t  1.26  ns  su(DV-CLKH)  :0] before EMB_CLK rising  For the parameter t  , Table 9 and Table 10 are valid under the conditions  OH(CLKH-DQMIV)  described in their respective notes:  Table 9. Switching Characteristics Over Recommended Operating Conditions  NO.  PARAMETER  MIN  MAX      UNIT   Output hold time, EMB_CLK rising to  6  t  0.8(1) (2)  ns  OH(CLKH-DQMIV)  EMB_WE_DQM[3:2] invalid  (1)  This timing requires CVDD = 1.15V ± 1% and DVDD = 3.3V ± 2%.  (2)  This timing parameter ONLY applies to the signals EMB_WE_DQM[3:2]; EMB_WE_DQM [1:0] timings are as shown in the device data manual.  Table 10. Switching Characteristics Over Recommended Operating Conditions  NO.  PARAMETER  MIN  MAX      UNIT   Output hold time, EMB_CLK rising to  6  t  0.7(1) (2)  ns  OH(CLKH-DQMIV)  EMB_WE_DQM[3:2] invalid  (1)  This timing requires CVDD= 1.2V +/- 1% and DVDD= 3.3V +/- 2%.  (2)  This timing parameter ONLY applies to the signals EMB_WE_DQM[3:2]; EMB_WE_DQM [1:0] timings are as shown in the device data manual.  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  47  Submit Documentation Feedback   1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      	 1.1.10  EMIFB: AC Timings Differ From Data Manual Specifications  	 	ARM9	 	  1.1 and earlier      	OMAP-L137	 	   The timing parameters in Table 8 and Table 9 differ from those specified in the OMAP-L137 C6000 DSP+ARM Processor data manual (literature number SPRS563 or later).  Table 8 list the AC timing parameters that should be used on silicon revision 1.1 and earlier.  	 	 	TI
Workaround(s)	 1.1.11   Electrostatic Discharge Charged-Device Model Performance  	 	ARM9	 	 	OMAP-L137	  1.1 and earlier      	Details	 	   The ESD to Charge Device model (CDM) is rated as passing the 300V level instead of  the 500V level. The OSCOUT pin passed 300V testing but failed starting at 400V. The  RSV2 pin had marginality to 500V. All of the other pins are rated as passing the 500V  level.  48  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback   1.1 Usage Notes and Known Design Exceptions to Functional Specifications 	TI
  Although there is no specific workaround, the following recommendations can be used to help prevent this issue:  •  Minimize loads as much as possible, especially DC loads that could cause the Vil to  rise. Point-to-point (single-load) connections are unlikely to be affected.  •  Falling edges should transition as rapidly as possible (so the signal passes through the 0.2V point as early as possible). Heavily loaded nodes resulting in degraded fall times may require drivers to provide rapid input edges.  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  49  Submit Documentation Feedback   1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      	 1.1.16  Vil on 3.3V LVCMOS Input Buffers  	 	ARM9	 	  1.1 and earlier      	OMAP-L137	 	   The input buffers on the device have shown timing sensitivity to the logic-low input voltage that can cause changes to the AC input timings. Due to this issue, input voltages must be driven at or below 0.4V to limit impact on AC timings.  The timing effect on the input buffers is dependent on the Vil level:  •  Case 1: For signals driven with Vil < = 0.2V, the input timings will be unaffected.  •  For signals driven with 0.2V < Vil < = 0.4V, there may be as much as 0.5 ns degradation to input timings.  This issue applies only to 3.3V LVCMOS inputs or IOs used as inputs. Signals  operated at 1.8V are not affected.  	 	 	TI
  Entirely eliminate IDMA/SDMA stalling and potential for a deadlock condition using one of the following two methods:  1. Configure the entire L2 RAM as 100% cache (for example, move all data buffers from L2 to L1D or other memory). Note: Some throughput degradation is expected when  the buffers are moved out to external memo  2. Eliminate all IDMA/SDMA access to L2 RAM when IDMA/SDMA stalling would have  an impact by performing one of the following:  (a) Constrain each DMA master group to perform writes to either DSP memory space  or external memory space, but not to both, or  52  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback   1.1 Usage Notes and Known Design Exceptions to Functional Specifications (b) Force each DMA master group to complete pending write commands to either  DSP memory space or cacheable memory space before initiating writes to a  different destination. Pending write commands from DMA masters are forced to  complete when the DMA master initiates a read from the same destination  memory. Note that in the case of off-chip memory, a read command only forces  the completion of write commands within a 2KB-aligned window.  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  53  Submit Documentation Feedback   1.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      6   Silicon Revision 1.0 Usage Notes and Known Design Exceptions to Functional      Specifications   This section describes the usage notes and advisories that apply to silicon revision 1.0 of the OMAP-L137  device.      6.1   Usage Notes for Silicon Revision 1.0  Usage notes highlight and describe particular situations where the device's behavior may not match presumed or documented behavior. This may include behaviors that affect device performance or functional correctness. These usage notes will be incorporated into future documentation updates for the device (such as the device-specific data sheet), and the behaviors they describe will not be altered in future silicon revisions.  Silicon revision 1.0 applicable usage notes have been found on a later silicon revision. For more details, see Section 4.1, Usage Notes for Silicon Revision 3.0 and see Section 5.1, Usage Notes for Silicon Revision 1.1.      6.2   Silicon Revision 1.0 Known Design Exceptions to Functional Specifications  Some silicon revision 1.0 applicable advisories have been found on a later silicon revision. For more details, see  •  Section 2.2, Silicon Revision 3.0 Known Design Exceptions to Functional Specifications  •  Section 3.2, Silicon Revision 2.1 Known Design Exceptions to Functional Specifications  •  Section 4.2, Silicon Revision 2.0 Known Design Exceptions to Functional Specifications  •  Section 5.2, Silicon Revision 1.1 Known Design Exceptions to Functional Specifications Table 13. Silicon Revision 1.0 Advisory List  Title ................................      Page   	 1.1.17   DSP SDMA/IDMA: Unexpected Stalling and Potential Deadlock Condition  	 	ARM9	 	  1.1 and earlier      	OMAP-L137	 	"   Note: This advisory is not applicable if DSP L2 memory is configured as 100% cache or L2 RAM is not accessed by IDMA or SDMA during run-time.  The C674x Megamodule has a Master Direct Memory Access (MDMA) bus interface and  a Slave Direct Memory Access (SDMA) bus interface. The MDMA interface provides  DSP access to resources outside the C674x Megamodule.  The MDMA interface is typically used for CPU/cache accesses to memory beyond the  Level 2 (L2) memory level. These accesses include cache line allocates, write-backs, and non-cacheable loads and stores to/from system memories. The cacheable  memories external to the C674x Megamodule are listed in Table 11.  Table 11. Cacheable External Memory Resources  External Memory      Address Range   Shared Ram   0x8000 0000 – 0x8001 FFFF  EMIFA  0x4000 0000 – 0x67FF FFFF  EMIFB  0xC000 0000 – 0xCFFF FFFF  The SDMA interface allows other DMA master peripherals (listed in Table 12 ) to access Level 1 Data (L1D), Level 1 Program (L1P), and L2 RAM DSP memories.  Table 12. DMA Master Peripherals  Peripheral      Group   EDMA TC0 RD   A  EDMA TC0 WR  B  EDMA TC1 RD  C  EDMA TC1 WR  D  EMAC  E  USB1  E  USB0  F  UHPI  F  ARM  G  The C674x Megamodule has an L1D cache and L2 cache both implementing write-back  data caches– it keeps updated values for external memory in cache for as long as  possible. It writes these updated values, called ""victims"", to external memory when it needs to make room for new data or when requested to do so by the application. The  L1D sends its victims to L2. The caching architecture has pipelining, meaning multiple requests could be pending between L1, L2, and MDMA. For more details on the C674x  Megamodule and its MDMA and SDMA ports, see the TMS320C674x Megamodule  Reference Guide (literature number SPRUFK5).  Ideally, the MDMA (dashed-dotted line in Figure 14) and SDMA/IDMA paths (dashed  lines in Figure 14) operate independently with minimal interference. Normally MDMA  accesses may stall for extended periods of time due to expected system level delays (for example, bandwidth limitations). However, when using L2 as RAM, SDMA and IDMA  accesses to L2/L1 may experience unexpected stalling in addition to the normal stalls seen by the MDMA interface. For latency-sensitive traffic, the SDMA stall can result in missing real-time deadlines. In a more severe case, the SDMA stall can produce a  deadlock condition in the device. An IDMA stall cannot produce a deadlock condition.  50  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback   1.1 Usage Notes and Known Design Exceptions to Functional Specifications Note: SDMA/IDMA accesses to L1P/D will not experience an unexpected stall if there are no SDMA/IDMA accesses to L2. Unexpected SDMA/IDMA stalls to L1 happen only  when they are pipelined behind L2 accesses. Additionally, the deadlock scenario will be avoided if there are no SDMA accesses to L2.  Figure 14 is provided for illustrative purposes and is incomplete because of  simplification. The IDMA/SDMA (dashed-lines) path could also go to L1D/L1P memories, and IDMA can go to DSP CFG peripherals. MDMA transactions can originate also from  L1P or L1D through the L2 controller or directly from DSP).  32K bytes  256K bytes      1M bytes   L1P RAM/  L2 RAM  L2 ROM  cache  256  256  256  256  Cache control  Cache control  Memory protect L1P  Memory protect L2  Bandwidth Mgmt  Bandwidth Mgmt  256  256  256  Instruction fetch  256 Power down  C674x      Interrupt   Fixed/floating point CPU  Controller  Register  Register  IDMA  file A  file B  64  64  256  CFG  Bandwidth Mgmt  32  Configuration  EMC  Memory protect L1D  peripherals  Cache control  bus  MDMA  SDMA  8x32  64  64  64  64  32K bytes      High performance   L1D RAM/      switch fabric   SDMA/IDMA Paths      cache   (SCR1)  MDMA Path      Figure 14. C674x Megamodule   The duration of the SDMA/IDMA stalls depend on the quantity/characteristics of the  L1/L2 cache and the MDMA traffic in the system. Therefore, it is difficult to predict if stalling will occur and for how long.  IDMA/SDMA stalling and any system impact is most likely in systems with excessive  context switching, L1/L2 cache miss/victim traffic, and heavy access to external memory.  Use the following procedure to determine if SDMA/IDMA stalling is the cause of real-time deadline misses for existing applications. Situations where real-time deadlines may be missed include loss of McASP samples and poor peripheral throughput.  1. Determine if the transfer that is missing the real-time deadline is accessing L2 or L1D  memory. If not, then SDMA/IDMA stalling is not the source of the real-time deadline  miss.  2. Identify all SDMA transfers to/from L2 memory (for example, EDMA transfer to/from L2 from/to a UART, HPI block transfer to/from L2). If there are no SDMA transfers  to/from L2, then SDMA/IDMA stalling is not the source of the problem.  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  51  Submit Documentation Feedback   1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  3. Redirect all SDMA transfers to L2 memory to other memories using one of the  following methods:  (a) Temporarily transfer all the L2 SDMA transfers to L1D SRAM.  (b) If not all L2 SDMA transfers can be moved to L1D memory, temporarily direct  some of the transfers to memory in Table 1 and keep the rest in L1D memory.  There should be no L2 SDMA transfers.  If real-time deadline misses are solved using any of the options in Step 3, then  IDMA/SDMA stalling is likely the source of the problem.  A deadlock situation may arise if the following sequence of events occurs:  Step 1: A DMA master from any group (listed in Table 12) issues a write command to  the DSP’s SDMA, and a DMA master from the same group issues a subsequent write  command to cacheable memory outside of the C674x Megamodule (listed in Table 1).  All write commands pass through Switched Central Resource 1 (SCR1). For more  details on SCRs, see the device Technical Reference Guide SPRUH93.  Step 2: The DSP’s SDMA asserts itself as not ready and is unable to accept the write data from Step 1, and a cache line writeback is initiated from DSP memory to the same cacheable memory from Step 1. The cache line writeback command also passes  through SCR1.  With the above scenario, it is possible for SCR1 to order the write commands from Step 1 in front of the write commands from Step 2. Due to the MDMA/SDMA blocking  behavior, the SDMA commands from Step 2 will be waiting for the MDMA traffic from  Step 1 to finish, resulting in a deadlock situation at SCR1. Figure 15 is provided for illustrative purposes and is incomplete because of simplification.  DMA  Group A  C674x      SDMA   (L2/L1D)  DMA  Group B  SCR1      DMA   Group xx  Cacheable  Memory  C674x  MDMA      Figure 15. SCR1 System Interconnect   "	 	 	TI
  There is no recommended workaround.  Adjusting the following settings may allow you to find a working region:  •  Adjust the SPI settings of prescale, phase, and polarity  •  Increase the core VDD to a range between 1.25V and 1.32V  •  Decrease the CPU operating frequency  Increasing the core VDD or slowing down the CPU operating frequency is ideal to work across a variety of conditions. Although the adjustments recommended above may be  used to find a working setup and allow further development to take place, these  adjustments cannot be guaranteed to alleviate the issue across devices, hardware  platforms, and temperature.  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  55  Submit Documentation Feedback  Copyright © 2008–2014, Texas Instruments Incorporated      	 1.0.12  SPI Communication Failure for Data Receipt  	 	ARM9	 	  1.0      	OMAP-L137	 	   There is a potential SPI communication failure on data receipt. When the communication failure occurs, the data received in the SPIBUF register is not correct. The data error pattern is not consistent between failures. The failure impacts both master and slave mode.  This issue is caused by un-matched delays between the clock and data paths of the shift register. The non-matched delays cause the clock edge to be detected earlier than the appropriate data. This results in inconsistent/incorrect receive data being copied into the SPIBUF register.  	 	 	TI
  Configure DMA and CPU requests to different priority levels. There is no penalty for setting the IDMA and SDMA priorities equal to each other.  CPU request priority is programmed within the CPUARBU register:  /** Pseudo code only **/  Uint32 *CPUARBU;  CPUARBU = ( Uint32 * ) ( 0x01841000 );  /* Set priority different from IDMA/SDMA */  *CPUARBU = [CPU_PRIORITY];  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  9  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  IDMA request priority is programmed within the IDMA1_COUNT register  /** Pseudo code only **/  Uint32 *IDMA1_SRC, *IDMA1_DST;  Uint32 *IDMA1_CNT;  IDMA1_SRC = ( Uint32 * ) ( 0x01820108 );  IDMA1_DST = ( Uint32 * ) ( 0x0182010C );  IDMA1_CNT = ( Uint32 * ) ( 0x01820110 );  *IDMA1_SRC = sourceAddress;  *IDMA1_DST = destinationAddress;  /* Set IDMA priority different from CPU */  *IDMA_CNT = ( [IDMA_PRI] << [IDMA_PRI_SHIFT] ) | buffSize ;  SDMA request priority is inherited from the MSTPRIn registers  /** Pseudo code only **/  Uint32 *MSTPRI1, *MSTPRI2;  MSTPRI1 = ( Uint32 * ) ( 0x01C14114 );  MSTPRI2 = ( Uint32 * ) ( 0x01C14118 );  /* Set SDMA master priorities different from CPU */  *MSTPRI1 = [MAST_PRI] << [MAST_SHIFT];  *MSTPRI2 = [MAST_PRI] << [MAST_SHIFT];  10  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications 	 2.3.1  DMA Access to L2 RAM Can Stall When DMA and C674x CPU Command Priorities  Are Equal  	 	ARM9	 	      2.3 and earlier   	OMAP-L138	 	   Note: DMA refers to all non-CPU requests. This includes Internal Direct Memory Access (IDMA) requests and all other system DMA master requests via the Slave Direct Memory Access (SDMA) port.  The C674x Megamodule uses a bandwidth management (BWM) system to arbitrate  between DMA and CPU requests issued to L2 RAM. See TMS320C674x DSP  Megamodule Reference Guide, Literature Number - SPRUFK5 for more information on  the BWM. BWM arbitration grants L2 bandwidth based on programmable priorities and  contention- cycle-counters. The contention-cycle-counters count the number of cycles for which the associated L2 requests are blocked by higher priority requests. When the  contention-cycle-counter reaches a programmed threshold (MAXWAIT), the associated  L2 request is granted a slice of L2 bandwidth. This prevents indefinite blocking of low priority requests when faced with the continuous presence of higher priority requests.  Ideally, the BWM arbitration will grant equal L2 bandwidth between equal priority DMA and CPU requests. Instead, when equal priority DMA and CPU requests arrive at the  BWM, bandwidth is always granted in favor of the CPU over DMA. In the case of  successive CPU requests, it is possible for the CPU to block all DMA requests until CPU  traffic subsides. Additionally, some command logic in the BWM uses priority level 7, which can also result in SDMA stalls when the CPU is also programmed to priority level 7. Figure 3 shows a high level diagram of the arbitration scheme used for L2 RAM  requests.  C674x Megamodule  EDMA  SHAREDRESOURCE  ExternalSystemMasters  Programmable Priority  ARBITRA  MasterPriority  C674x CPU  EMAC  ARBITRA  Programmable Priority  IDMA  L2 RAM  TION  LCDC  Inherit  TION  Priority  SDMA  UHPI  USB  Highest Priority Master Granted Access.  Contention counters implemented to not  starve low priority requestors  Figure 3. Priority Arbitration Scheme for L2 RAM  	 	 	TI
  Software must service every USB RESET interrupt received. Software should not  proceed on performing any other task, like initialization, until RESET duration has come to completion. The POWER[RESET] bit field will be cleared by the USB Controller when RESET signaling on the bus is removed by the Host. The USB Controller clearing the  POWER[RESET] bit field should be used by software as an indication for the completion of RESET signaling.  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  11  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  	 2.3.3  USB0: Extraneous RESET Interrupt  	 	ARM9	 	      2.3 and earlier   	OMAP-L138	 	   When the USB controller is operating as a device and an attached host resets the device after the completion of the Device Attached state by driving both differential data lines low, the USB controller operating as a device could receive multiple RESET interrupts for the single RESET signaling invoked by the host. The multiple interrupt generation only happens for the duration of the RESET signaling on the bus. RESET Interrupt is not generated before or after the completion of RESET.  	 	 	TI
  If a time-out occurs, perform any of the following:  •  A dummy read to another asynchronous memory chip select that is not configured to  be in Extended Wait mode.  •  A dummy read to the same asynchronous memory chip select after disabling the  Extended Wait mode on that chip select.  •  A dummy read to SDRAM  12  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications 	 2.3.4  EMIFA: Asynchronous Memory Timeout Error Persistence  	 	ARM9	 	      2.3 and earlier   	OMAP-L138	 	   In Extended Wait mode, during a read access to an asynchronous memory, if the WAIT  input does not go inactive within maximum extended wait cycles programmed in the  Async Wait Cycle Config register, the EMIF will report a time-out error. The data  returned for this access will be all zeros. If this access is followed by a read to the EMIFA’s memory-mapped register (MMR) space, the EMIFA will still report a time-out  error but with the correct data for the MMR read. The EMIF will hold the time-out error until another asynchronous access without a time-out error or an SDRAM access is  performed.  This issue is only applicable if all of the following are true:  •  The EMIF is used for asynchronous memory accesses in Extended Wait mode.  •  There is a potential for a time-out error to occur, that is, the asynchronous memory will not de-assert the WAIT input.  •  If asynchronous memory read with time-out error is followed by an MMR read.  	 	 	TI
  The CPUINTn hardware interrupts can support both pulse and level interrupts so  CHIPINTn interrupts should be mapped directly to CPUINTn hardware interrupts.  Furthermore, if the ECM is used for other system interrupts, the CHIPINTn interrupts should be masked out in the EVTMASKn registers.  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  13  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  	 2.3.5  A Single CHIPINTn Interrupt Event Will Register Multiple Times in the DSP Event  Combiner Module (ECM)  	 	ARM9	 	      2.3 and earlier   	OMAP-L138	 	   The C674x DSP megamodule supports twelve maskable hardware interrupt signals  (CPUINT4 through CPUINT15). Single system interrupts may be mapped directly to a  CPUINTn hardware interrupt, or multiple system interrupts may be combined by the  ECM into a single signal before mapping to a CPUINTn interrupt. See [SPRUFK5;  TMS320C674x DSP Megamodule] for more information on how DSP interrupts are  handled.  The ECM expects all incoming interrupts to be pulse interrupts, however the  [SYSCFG_CHIPSIG_]CHIPINTn interrupts are level interrupts. This mismatch in interrupt types will cause a single CHIPINTn interrupt event to register multiple times in the ECM.  	 	 	TI
  The reset timing violation can be avoided by providing the modified soft reset activation sequence outlined below:  1. Enable the USB controller module clock through the Power and Sleep Controller  (PSC)      2. Perform a soft USB reset   3. Wait for the USB soft reset bit to clear  4. Disable the USB controller module clock through the PSC  5. Configure the USB PHY parameters      6. Enable the PHY   7. Enable the USB controller module clock through the PSC  14  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications 	 2.3.6  Potential USB2.0 Soft Reset Timing Violation  	 	ARM9	 	      2.3 and earlier   	OMAP-L138	 	   When a soft reset is invoked by setting the RESET bit of the USB CTRLR register (  CTRLR[RESET] = 1 ), the internal reset timing requirements may be violated. Although this timing violation has not been observed in practice, the potential for a timing violation exists.  USB resets initiated by system-reset and power-on-reset are immune from the timing  violation.  There is no plan to fix this issue in future silicon revisions because:  1. No functional problems have been observed to date  2. A software workaround has been developed to avoid the problem  	 	 	TI
  Although there is no specific workaround, the following recommendations can be used to help prevent this issue:  •  Minimize loads as much as possible, especially DC loads that could cause the Vil to rise. Point-to-point (single-load) connections are unlikely to be affected.  •  Falling edges should transition as rapidly as possible (so the signal passes through the 0.2V point as early as possible). Heavily loaded nodes resulting in degraded fall times may require drivers to provide rapid input edges.  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  17  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  	 2.3.9  Vil on Dual-Voltage LVCMOS Input Buffers Operated at 3.3V  	 	ARM9	 	      2.3 and earlier   	OMAP-L138	 	   The input buffers on the device have shown timing sensitivity to the logic-low input voltage that can cause changes to the AC input timings. Due to this issue, input voltages must be driven to 0.5V or below on all dual-voltage LVCMOS input signals (signals  associated with supplies DVDD1833_A, DVDD1833_B or DVDD1833_C).  Vil driven at or below 0.4V will cause no timing degradation. Vil driven up to 0.5V will cause up to 750 ps degradation in input timings.  The following datasheet parameters will be affected by Vil driven up to 0.5V. Their values adjusted for 0.75 ns degradation are shown.  Table 3. Timing Requirements for the EMIFA SDRAM Interface      1.2V   NO.  PARAMETER  UNIT  MIN  MAX  Input Setup time, read data valid on  19  t      2.75   ns   su(EMA_DV-EM_CLKH)  EMA_D[31:0]  Table 4. Timing Requirements for the EMIFA Asynchronous Memory Interface      1.2V   NO.  PARAMETER  UNIT  MIN  MAX  Setup time, EMA_D[31:0] valid before EMA_OE  12  t      3.75   ns   su(EMDV-EMOEH)  high  Table 5. Timing Requirements for McASP0      1.2V   NO.  PARAMETER  UNIT  MIN  MAX  AHCLKR/X ext input      1.15   Hold time, AFSR/X input after ACLKR/X  6  th(ACLKRX-AFSRX)  (1)  AHCLKR/X ext output      1.15   ns   AHCLKR/X ext input      1.15   Hold time, AXR0[n] input after  8  th(ACLKRX-AXR)  ACLKR/X (1) (2)  AHCLKR/X ext output      1.15   (1)  McASP0 ACLKXCTL.ASYNC=1: Receiver is clocked by its own ACLKR0  (2)  McASP0 ACLKXCTL.ASYNC=0: Receiver is clocked by transmitter's ACLKX0  Table 6. Switching Characteristics for McASP0      1.2V   NO.  PARAMETER  UNIT  MIN  MAX  ACLKR/X ext input      3.5   Delay time, ACLKR/X transmit edge to  13  td(ACLKRX-AFSRX)  AFSX/R output valid (1)  ACLKR/X ext output      3.5   ACLKR/X ext input      3.5   Delay time, ACLKX transmit edge to  14  td(ACLKX-AXRV)  ns  AXR output valid (1)  ACLKR/X ext output      3.5   Disable time, ACLKR/X transmit edge  15  t  to AXR high impedance following last  ACLKR/X ext      3.5   dis(ACLKX-AXRHZ)  data bit  (1)  McASP0 ACLKXCTL.ASYNC=1: Receiver is clocked by its own ACLKR0  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  15  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  Table 7. Timing Requirements for McBSP0      1.2V   NO.  PARAMETER  UNIT  MIN  MAX  Setup time, external FSR high before  5  t  CLKR ext      5.5   su(FRH-CKRL)  CLKR low  7  t  Setup time, DR valid before CLKR low  CLKR ext      5.5   ns   su(DRV-CKRL)  Setup time, external FSX high before  10  t  CLKR ext      5.5   su(FXH-CKXL)  CLKX low  Table 8. Switching Characteristics for McBSP0      1.2V   NO.  PARAMETER  UNIT  MIN  MAX  Delay time, CLKR high to internal FSR  4  t  CLKR ext      2.75   d(CKRH-FRV)  valid  Delay time, CLKX high to internal FSX  9  t  CLKR ext      2.75   ns   d(CKXH-FXV)  valid  2.75 + D1  13  t  Delay time, CLKX high to DX valid  CLKR ext  d(CKXH-DXV)  (1)  (1)  Extra delay from CLKX high to DX valid applies only to the first data bit of a device, if and only if DXENA = 1 in SPCR.  If DXENA = 0, then D1 = D2 = 0  If DXENA = 1, then D1 = 6P, D2 = 12P  Table 9. Switching Characteristics for McBSP1      1.2V   NO.  PARAMETER  UNIT  MIN  MAX  Delay time, CLKR high to internal FSR  4  t  CLKR ext      3.25   d(CKRH-FRV)  valid  Delay time, CLKX high to internal FSX  9  t  CLKR ext      3.25   ns   d(CKXH-FXV)  valid  3.25 + D1  13  t  Delay time, CLKX high to DX valid  CLKR ext  d(CKXH-DXV)  (1)  (1)  Extra delay from CLKX high to DX valid applies only to the first data bit of a device, if and only if DXENA = 1 in SPCR.  If DXENA = 0, then D1 = D2 = 0  If DXENA = 1, then D1 = 6P, D2 = 12P  Table 10. Timing Requirements for Universal Parallel Port (uPP)      1.2V   NO.  PARAMETER  UNIT  MIN  MAX  Setup time, CHn_START valid before CHn_CLK  4  t      4.75   su(STV-INCLKH)  high  Setup time, CHn_ENABLE valid before CHn_CLK  6  t      4.75   su(ENV-INCLKH)  high  Setup time, CHn_DATA/XDATA valid before  8  t      4.75   ns   su(DV-INCLKH)  CHn_CLK high  Setup time, CHn_DATA/XDATA valid before  10  t      4.75   su(DV-INCLKL)  CHn_CLK low  Setup time, CHn_WAIT valid before CHn_CLK  19  t      4.75   su(WTV-INCLKL)  high  16  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications Table 11. Timing Requirements for Video Port Interface (VPIF)      1.2V   NO.  PARAMETER  UNIT  MIN  MAX  Setup time, VP_DINx valid before VP_CLKIN0/1  1  t      4.75   ns   su(VDINV-VKIH)  high  	 	 	TI
  The desired value (even if it is the default value) should be written to the VSR prior to using the interrupt controller.  18  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications 	 2.3.10  ARM Interrupt Controller Vector Size Register (VSR) Initialization  	 	ARM9	 	      2.3 and earlier   	OMAP-L138	 	   The VSR register in the ARM Interrupt Controller (AINTC) is not correctly initialized after reset. If this register is not explicitly configured, the AINTC will only allocate 1 byte per interrupt (instead of 4).  	 	 	TI
"  Method 1  Do not execute the intended interrupt service routine code if the associated CHIPSIGn status flag is not set in the SYSCFG_CHIPSIG register. A cleared CHIPSIGn status flag indicates that the device is responding to a false interrupt. This method is easy to implement, but does not eliminate false interrupts.  /** Pseudo code only **/  void CHIPINT0_ISR(void) {  /* Exit immediately if CHIPSIG0 is not set */  if( (SYSCFG->CHIPSIG & 0x1) == 0 ) {  return;  }  /* Intended service routine code */  SYSCFG->CHIPSIG_CLR = 0x1;  printf(""Hello World!\n"");  }  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  19  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  Method 2  Do not clear the AINTC CHIPINTn status flag until the CHIPSIGn status has been  cleared. This method will eliminate false interrupts, but requires changes to the AINTC  interrupt dispatch code. Changing the dispatch code may introduce undesired behavior in the application.  /** Pseudo code only **/  /* Sequence that is susceptible to false CHIPINTn interrupts */  void AINTC_ISR_DISPATCH_1(void) {  Get_Interrupt_Information();  /* CHIPINTn interrupts continue to be generated after */  /* AINTC CHIPINTn flag is cleared.  */  Clear_AINTC_Interrupt_Flag();  /* CHIPINTn interrupts are only stopped after ISR clears */  /* the status flag.  */  Branch_To_ISR();  }  /* Sequence that is not susceptible to false CHIPINTn interrupts */  void AINTC_ISR_DISPATCH_2(void) {  Get_Interrupt_Information();  /* ISR will clear CHIPSIGn flag and discontinue CHIPINTn */  /* interrupts to AINTC.  */  Branch_To_ISR();  /* Ok to clear AINTC CHIPINTn flag now.  */  Clear_AINTC_Interrupt_Flag();  }  20  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications "	 2.3.12  A Single CHIPINTn Interrupt Event Can Register Multiple Times in the AINTC  	 	ARM9	 	      2.3 and earlier   	OMAP-L138	 	   Interrupts destined for the ARM CPU are managed by the ARM Interrupt Controller  (AINTC). The AINTC detects, combines, and routes system interrupts to the two native ARM interrupt signals FIQ and IRQ. See the device System Reference Guide for  additional information about the AINTC.  The AINTC module expects all incoming interrupts to be pulse interrupts, however the  [SYSCFG_CHIPSIG_]CHIPINTn interrupts are level interrupts. This mismatch in interrupt types will cause a single CHIPINTn interrupt event to register as multiple interrupt pulses in the AINTC. However, the AINTC does not have the capacity to count the number of  interrupt pulses received per system interrupt – it only maintains interrupt flags. A system interrupt is flagged as active until its status is cleared by the user through the AINTC, regardless of the number of interrupts detected.  If the status flag for AINTC CHIPINTn is cleared while the CHIPINTn interrupt is still active, the AINTC will continue to detect CHIPINTn interrupts and its status flag will be set again. This additional setting of the AINTC CHIPINTn status flag is false.  	 	 	TI
  Perform one of the following:  •  For the location of code where saturation results are monitored, do not mix datatypes so that 2 cycle and 4 cycle .M unit instructions are not issued together.  •  Do not mix floating point .M unit instruction with fixed point 2 cycle .M unit  instructions.  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  21  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  	 2.3.13  Incorrect Masking of the C674x CSR:SAT Bit  	 	ARM9	 	      2.3 and earlier   	OMAP-L138	 	   The C674x CPU supports a Saturation feature for key arithmetic operations. If an  operation results in saturation, the SAT (saturation) bit in the control status register (CSR) is set. In normal operation, one or more functional units can simultaneously  perform arithmetic operations that can result in saturation. In the case of simultaneous arithmetic operations, the SAT bit is set if at least one functional unit’s operation results in saturation. The saturation status register (SSR) provides saturation flags for each functional unit, making it possible for the program to distinguish between saturations caused by different instructions in the same execute packet. Also, there is no direct connection to the SAT bit in the control status register (CSR); writes to the SAT bit have no effect on SSR and writes to SSR have no effect on the SAT bit.  In the case where a 2 cycle .M unit instruction is in the delay slot of a 4 cycle instruction of the same .M unit, and if both instructions are expected to generate results in the same cycle, the CSR:SAT bit will be incorrectly masked. Ideally, the CSR:SAT bit should be set if any one of the two .M unit instruction causes a saturation. Instead, the arithmetic saturation result of the 2 cycle .M unit instruction will overwrite the CSR:SAT bit.  All of the following must take place in order for an application to be affected by this advisory:  1. A 2 cycle .M unit instruction and a 4 cycle .M unit instruction are issued  simultaneously  2. Both instructions are processed on the same side  3. The 2 cycle instruction is in the delay slot of the 4 cycle instruction so that the results of both instructions are generated in the same cycle  4. The saturation result of the 4 cycle .M unit instruction is different from the saturation result of the 2 cycle .M unit instruction  5. The application checks for the saturation flag and uses the saturation result of the 4  cycle instruction  	 	 	TI
  Method 1: Do not perform two CPU read operations in the same clock cycle. For C  code, use compiler flag (--c64p_dma_l1d_workaround) available in the C6000  Compiler (CodeGen) Tools version 7.0.2 and later. For assembly code, the --  c64p_dma_l1d_workaround flag will only issue a warning.  Method 2: In cases where buffer access will not be shared between CPU and SDMA, unintended CPU/SDMA cache-line sharing can be avoided by aligning CPU and SDMA  buffers to 64-byte boundaries. Aligning buffers to 64-byte boundaries will result in wasted space, however it ensures that the CPU and SDMA buffers will not have partial  segments which overlap into the same L1D cache line.  /** Pseudo code only **/  Uint8 *SDMA_BUFF, *CPU_BUFF;  /* 64-byte aligned allocation Option 1 */  SDMA_BUFF = malloc( (Int32) (( SDMA_BUFF_SIZE + 63)/64) * 64 );  CPU_BUFF = malloc( (Int32) ((CPU_BUFF_SIZE + 63)/64) * 64 );  SDMA_BUFF = (Uint8 *) ( (Int32) SDMA_BUFF & ~63 );  CPU_BUFF = (Uint8 *) ( (Int32) CPU_BUFF & ~63 );  /* 64-byte aligned allocation Option 2 with BIOS Call */  SDMA_BUFF = MEM_alloc( IRAM, SDMA_BUFF_SIZE, 64 );  CPU_BUFF = MEM_alloc( IRAM, CPU_BUFF_SIZE, 64 );  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  23  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  Method 3 Manage access to a 64-byte boundary aligned buffer that is shared between CPU and SDMA by implementing a semaphore and forcing cache writeback operations if  there are CPU writes. With this method, the semaphore ensures that there is clear  ownership of the buffer between CPU and SDMA, and the CPU manages cache  coherence by using explicit cache writeback operations.  /** Pseudo code only **/  /* Example with EDMA as the external master */  EDMA_ISR() {  /* EDMA releases ownership of buffer */  SEM_post(SyncSemaphore);  return;  }  main() {  while(COND) {  /* CPU waits for ownership of buffer */  SEM_pend(SyncSemaphore);  /**********************/  /*** CPU Processing ***/  /**********************/  /* Cache writeback for shared block */  /* Buffer must be 64-byte aligned */  BCACHE_wbInv( blockPtr, blockSize, WAIT );  /* Initiate EDMA */  EDMA_Event_Generate();  }  }  Method 4 Do not allow SDMA to access L2 RAM. SDMA can use buffers in L1D RAM or Shared RAM instead of L2 RAM.  Method 5 Configure the entire L2 RAM as cache. Critical peripheral data can be accessed in L1D RAM or Shared RAM instead of L2 RAM.  Method 6 Configure the entire L2 RAM as normal SRAM (no cache).  Method 7 Configure the entire L1D RAM as normal SRAM (no cache).  24  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications 	 2.3.17  SDMA Activity Can Corrupt L1D When L2 Is Configured as Mixed/Cache/SRAM  	 	ARM9	 	      2.3 and earlier   	OMAP-L138	 	   Note: SDMA refers to all non-CPU requests to the EMC SDMA (Slave Direct Memory Access) port (see Figure 4). SDMA requests are defined as external system bus master requests handled via this port.  The C674x Megamodule uses a two-way set associative cache for L1D. This means that  every physical memory location in the system has two possible set/way locations in the cache where it can reside. See TMS320C674x DSP Megamodule Reference Guide  (Literature Number SPRUFK5) for more information on the L1D cache architecture and  related terminology. Updated (dirty) values in L1D cache are not written back to external memory until cache activity evicts a cache-line (victim write-back) or a write-back is requested by software.  An L1D cache-line corruption event occurs when all of the conditions in the following steps are met (see Figure 4):  1. L1D cache Lines 1, 2, and 3 have the following characteristics:  •  Line 1 is associated with L2 SRAM (Line A in Figure 4), was previously read by  CPU, and is clean. (CPU has not updated the data.)  •  Line 2 is associated with L2 SRAM (Line B in Figure 4), was previously read by  CPU, and is clean. (CPU has not updated the data.)  •  Line 3 was previously read by the CPU and may be either clean or dirty.  2. SDMA receives updated data for L2 SRAM Lines A and B, which correspond to L1D  cache Lines 1 and 2.  3. A snoop write operation is initiated by the L2 to overwrite the L1D cache Lines 1 and 2 with updated L2 SRAM Lines A and B. Before the snoop write operation finishes,  the CPU performs two reads within the same clock cycle:  •  Line E in L2 cache is read as a cache hit. Line E is destined to replace Line 2 in  L1D Cache, which also has a snoop write pending for the updated Line B  content.  •  Line D in L2 SRAM is read. Line D will replace Line 3 in L1D cache.  4. When the snoop write operation completes, Line 2 in L1D cache now contains the  updated L2 SRAM Line B data instead of the L2 cache Line E data.  The correct behavior would have been to kill the pending snoop write initiated to update L1D cache Line 2 with the updated L2 SRAM Line B data in Step 3. The L1D cache  should have evicted Line B and replaced it with Line E data. Instead, the snoop write operation continues and does not complete until after the L1D cache Line 2 has already been replaced with L2 cache Line E data. The snoop write instruction overwrites the L1D  cache Line 2 (containing L2 cache Line E data) with the updated L2 SRAM Line B data.  22  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications Time Line  System View  Line A  Line E and Line B Map to  STEP 1  STEP 2  STEP 3  STEP 4  same L1D Cache line.  Line A  B  C674x subsystem  Line A  C  C6xCPU  Read Line D  L2  Line A  D  Activity  Read Line E  C6X CPU  Controller  L2 SRAM  SDMA  Write Line A Snoop Write  Line A  E  Activity  Write Line B  Initiated  L1D  EMC  L2 CACHE  L1D Cache  Clean Line A Clean Line A  IN FLUX  Clean Line A  Controller  SDMA PORT  Line 1  (New Data)  L1D Cache  Clean Line B Clean Line B  IN FLUX  CORRUPT  EMAC  Line 2  Line E replaces Line B due  Line  Line 1 A  [A]  PRU  L1D Cache  Clean/Dirty  Clean/Dirty  IN FLUX  Clean Line D  to CPU read.  Line 3  Line C  Line C  Line  Line 2 A  [B/E] Delayed snoop wrtie to Line  EDMA  SYSTEMMASTERS  Line  Line 3 A  [C/D] B corrupts Line E in L1D$  L1D  Corruption happens  CACHE  UHPI  because of this state  EXTERNAL  Figure 4. Example of L1D Cache Corruption  	 	 	TI
  1. Design simulation has indicated that under the worst-case  process/voltage/temperature conditions the maximum leakage current into the  DVDD18 supply due to this phenomenon will be 140 mA (the 140 mA is a cumulative  current generated by all of the dual-voltage IOs). So this error state can be prevented by ensuring that the load on the DVDD18 supply during the DVDD13318_x supply  ramp exceeds 140 mA. This can be achieved by any combination of the following as  long as they cumulatively produce >140 mA load on DVDD18 during the  DVDD3318_x ramp period:  (a) Maintain sufficient bulk capacitance on the DVDD18 supply such that the charging current for these capacitors provides all or part of the required >140 mA. Bulk  capacitance in this context means the total capacitance seen by the DVDD18  supply (filter capacitors, bypass capacitors, etc.). Capacitor charging current is  defined as I = C*(dV/dt). So the ramp rate of the DVDD3318_x supply and the  total bulk capacitance on the DVDD18 supply can be used to calculate the current  produced. This solution provides additional power supply filtering and little current leakage after the supplies are ramped (depending on the type of capacitors used).  The table below shows some examples of the bulk capacitance that would be  required to use this solution alone:  Table 12. Bulk Capacitance  DVDD3318_x ramp  dV/dt (in V per second)  Required capacitance to generate 140 mA  time for 3.3V  100 µs  33000  4.2 µF  250 µs  13200  10.6 µF  500 µs  6600  21.2 µF  1 ms  3300  42.4 µF  10 ms  330  424.2 µF  (b) Use an additional shunt regulator to control the voltage at DVDD18. The shunt  regulator is placed between DVDD18 and Vss. As an example, the TLVH431 can  provide up to 70 mA of additional load current to help maintain the DVDD18  voltage. When the voltage drops back to the normal 1.8V range, the current flow  through the shunt regulator drops into the <100 uA range. This solution requires the shunt regulator and two additional resistors to set the desired regulation  voltage.  (c) Use a resistor to provide additional load between DVDD18 and Vss. This solution is less desirable since it continues to draw power even after the supply ramp is  completed but would likely be the lowest cost. An improvement is to use a  FET/switch in series with the resistor between DVDD18 and Vss that can later be  turned off (by the RESET signal or a GPIO signal for example).  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  27  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      2.   Choose a regulator for the DVDD18 supply (or grouped 1.8V supplies) that is  capable of actively regulating voltage up and down. Many high-efficiency switching  regulators switch current into the load only when the voltage needs to be raised and rely on the load to pulldown the current. In this error condition, a regulator of this type will not be able to compensate for the leakage current described above.  Synchronous buck regulators use external inductance to pulldown the regulated  voltage when necessary.  28  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications 	 2.3.18  DVDD18 Can Pull Up to 2.7V When Using Dual-Voltage IOs at 3.3V  	 	ARM9	 	      2.3 and earlier   	OMAP-L138	 	   A condition can occur during the device power supply ramp in which the DVDD18  supply, which should be at 1.8V nominal, can be pulled up on-chip by the DVDD3318_A, DVDD3318_B or DVDD3318_C supplies operated at 3.3V. For the sake of this  description, DVDD3318_x means any combination of DVDD3318_A, DVDD3318_B or  DVDD3318_C.  Important Note: The 3.3V DVDD3318_x supplies must not be driven to 0V during zones A – E or high current capable of damaging the device may occur. The 3.3V  DVDD3318_x supplies should not be driven during this time.  A normal example power-supply ramp is shown below:  A  B  C  D  E  F  G      3.3V   VT   1.8V      1.2V   Figure 5. Normal power-supply ramp  •  A. All device supplies are undriven  •  B. The 1.2V supplies are ramped to their nominal levels  •  C. Potential delay between supply ramps (not required)  •  D. The 1.8V supplies (specifically DVDD18) are ramped to their nominal levels.  During the DVDD18 ramp there will be some minor drift up in the undriven  DVDD3318_x supplies. This is normal and is not a problem.  •  E. Potential delay between supply ramps (not required)  •  F. DVDD3318_x is ramping but is less than DVDD18 + VT  •  G. DVDD3318_x is ramping but is greater than DVDD18 + VT  When the fault condition occurs, the supplies behave as shown below:  A  B  C  D  E  F  G  3.3V      ~2.7V   VT   1.2V   Figure 6. Faulty power-supply ramp  The behavior is the same until zone G. When the DVDD3318_x supply exceeds  DVDD18 by a transistor V , the DVDD18 supply begins to be pulled up by the  T  DVDD3318_x supply and follows the DVDD3318_x supply by DVDD3318_x- V . Since  T  the DVDD18 supply is often connected to other 1.8V supplies in the design, these other supplies can be pulled up also.  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  25  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  The condition occurs because the dual-voltage IO buffers have voltage detection circuitry that monitors DVDD3318_x during reset and determines whether the applied supply  voltage is 1.8V or 3.3V. This detection circuitry then configures the IOs to operate at the appropriate voltage. As the DVDD3318_x supply ramps, there is a small range near  DVDD18 + V where the voltage detection circuit finds the state indeterminate and briefly T  turns on circuitry associated with both voltage options creating a current path between them. This current path can cause the DVDD18 supply to be pulled up. The mechanism  for this behavior is explained below:  DVDD3318_x  Dual-Voltage IO Buffer  Behavior of the IO buffer during Zone F:  As the DVDD3318_x supply ramps, but is not yet one V above the  T  DVDD18 supply, the comparator enables the 1.8V mode logic      3.3V Mode   section and disables the 3.3V mode logic section. No unexpected  Enable  Logic  +  current flows between the two sections.  DVDD18  -      1.8V Mode   Enable   Logic  Iload  External  Loads  Figure 7. Behavior of the IO buffer during Zone F  DVDD3318_x  Dual-Voltage IO Buffer  Error State of the IO buffer during Zone G:  As DVDD3318_x exceeds DVDD18+V , some of the circuitry  T  across the boundary of the two voltage domains will turn on and      3.3V Mode   DVDD18   Enable  causes a leakage current (in red) to flow between the two voltage  Logic  +  domains. This current pulls up the DVDD18 supply unless the  Ileakage  power source providing that supply can oppose it or unless the  -  load current is strong enough to counteract it.  Enable 1.8V Mode  Logic  If DVDD18 continues to rise as DVDD3318_x ramps, the  I  comparator never sees enough difference between the two  load  supplies to switch to 3.3V mode.  External  Loads  Figure 8. Error State of the IO buffer during Zone G  DVDD3318_x  Dual-Voltage IO Buffer  Recovered State of the IO buffer during Zone G:  If the load current is high enough or the DVDD18 power supply can  oppose the leakage current, then the DVDD18 voltage stays low      3.3V Mode   enough for:   Enable  Logic  +  DVDD18  • the comparator to recognize 3.3V mode  • the 1.8V mode logic is turned off  -      1.8V Mode   • the leakage stops  Enable  Logic  Iload  External  Loads  Figure 9. Recovered State of the IO buffer during Zone G  26  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications This error condition may occur when either of the following conditions are present:  •  The regulator used to control the DVDD18 supply can only regulate voltage up and  relies on the load to pull the output voltage down  •  There is low load on the DVDD18 supply during the DVDD3318_x power supply  ramp  This condition will not occur in designs where:  •  All DVDD3318_x supplies are operated at 1.8V, or  •  The regulator used to supply DVDD18 has the capability to actively regulate (drive) its output voltage up or down and doesn’t rely on system load to pull the voltage  down, or  •  The load on the DVDD18 supply during the DVDD3318_x power supply ramp is  sufficient to oppose the leakage current.  	 	 	TI
  None  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  29  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  	 2.3.19  USB 2.0 On-The-Go (OTG) Session Request Protocol (SRP) Is Not Supported  	 	ARM9	 	      2.3 and earlier   	OMAP-L138	 	   The USB 2.0 On-The-Go (OTG) Session Request Protocol (SRP) allows a USB-  peripheral to request the USB-host to enable Vbus and start a session. On this device, the SRP protocol is not supported.  The OTG Host Negotiation Protocol (HNP), which allows USB-devices to swap roles  between host and peripheral, is supported.  	 	 	TI
:  •  Use GEN2 or GEN1 maximum speed drives to avoid the issue  or  •  Use GEN3 drives with jumper restricting capabilities to restrict their speed to GEN2  or  •  The Host Application S/W can continually perform Port resets to restart the link  establishment eventually succeeding in establishing a link. Note: This is not a preferred method because an excessive amount of resets might be required to  establishment the link.  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  31  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  	 2.3.22  SATA: Link Establishment Fails With SATA GEN3 Capable Targets  	 	ARM9	 	:      2.3 and earlier   	OMAP-L138	 	:   When connecting a SATA GEN3 capable target, for example a Hard Disk Drive (HDD),  to a device with a SATA Host Subsystem (after power-up or reset) the speed negotiation fails between the two devices and no link is established.  Two different types of failure behaviors with the same results have been observed:  Losing Synchronization:  The Target (Device) always starts the speed negotiation at the highest speed supported, in this case GEN3, by sending an ALIGNp primitive data pattern to the Host SATA  subsystem. The Host SATA subsystem sends a continuous D10.2 Tone at GEN1 speed  (1.5 GBits/sec) and should ideally remain at this state until the Host recognizes the Targets' ALIGNp primitive data pattern [at GEN2 or GEN1 but not GEN3 speed]. While  the Target (Device) is still at GEN3, due to aliasing, etc., the Host SATA subsystem falsely responds back to the Device with an ALIGNp primitive data pattern at a different speed (GEN2 speed). The Host completes the speed negotiation at GEN2 speed and  transitions to a logical IDLE state (Non-ALIGNp primitive SYNCp) before the Target  (Device) timeout period expires (54.6 µs). Once the timeout period expires for GEN3  speed, the Target (Device) starts sending an ALIGNp primitive data pattern at GEN2  speed, expecting an ALIGNp primitive data pattern from the Host which never happens because the Host is in a logical IDLE state at GEN2 speed. Another timeout period  expires because the target (Device) did not receive the ALIGNp primitive data pattern at GEN2 speed. This forces the Target (Device) to drop its speed from GEN2 to GEN1 and attempt to establish a link at GEN1 speed. The Host still remains in a logical IDLE state at GEN2 speed. After the final timeout period expires, the Target (Device) requests a RESET (by sending COMINIT signal) to restart the link establishment process with the Host. This new link establishment results in the same outcome with the Host and Target always being out of sync.  Unknown State/Lock-up:  The Target (Device) always starts the speed negotiation at the highest speed supported, in this case GEN3, by sending an ALIGNp primitive data pattern to the Host SATA  subsystem. The Host SATA subsystem sends a continuous D10.2 Tone at GEN1 speed  (1.5 GBits/sec) and ideally should remains at this state until the Host recognizes the Targets' ALIGNp primitive data pattern [at GEN2 or GEN1 but not GEN3 speed]. While  the Target (Device) is still at GEN3, due to aliasing, etc., the Host SATA subsystem falsely responds back to the Target (Device) with an ALIGNp primitive data pattern at a different speed (GEN2 speed) and remains at this state (sending the GEN2 ALIGNp  primitive). The Target (Device) times out (54.6 µs) and starts sending an ALIGNp  primitive data pattern at GEN2 speed. Target (Device) now recognizes the Host GEN2  ALIGNp primitive data pattern and responds with a logical IDLE state (Non-ALIGNp  primitive SYNCp) completing the link establishment from the Target (Device)  perspective. However, the Host is stuck in an unknown state sending GEN2 ALIGNp  primitive and never completes the link establishment. Both the Host and Target (Device) remain at this state until a higher Host SATA Controller application (User S/W) performs a Reset.  Note: This issue does not apply to Target devices with maximum speed capability of GEN2 or GEN1 speed.  30  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications 	 	 	TI
:  One of the following Workarounds must be implemented to ensure that the boot pins are always latched correctly:  Method 1  Use strong external pull resistors on BOOT[7:0] pins. Since either the internal pullup or pulldown resistors could be enabled after every power-on, the external resistors must be strong enough to oppose the internal pulls in either case.  Section 4, Device Operating Conditions, of the device datasheet shows the electrical characteristics information which can be used to calculate the maximum external pull resistance required. The value is dependent on the DVDD3318_C I/O supply level.  For BOOT pins which need to be sampled as logical low, the external pulldown  resistance (R  ) must be selected by assuming the internal pullup is enabled. The  PDmax  calculation is shown in Table 13.  32  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications Table 13. Required Pulldown Resistance (R  ) for Logical Low BOOT Pins  PDmax  æ V ö  IL  ç  ÷  DVDD3318_C  I  V  I  IL  è I  R  I ø  PDmax      3.3 V   310 µA      0.80 V   2.58 kΩ      1.8 V   310 µA      0.80 V   2.03 kΩ  For BOOT pins which need to be sampled as logical high, the external pullup resistance (R  ) must be selected by assuming the internal pulldown is enabled. The calculation  PUmax  is shown in Table 2.  Table 14. Required Pullup Resistance (R  ) for Logical High BOOT Pins  PUmax  æ DVDD 3318 _ C - V  ö  IH  ç  ÷  DVDD3318_C  I  V  I  IH  I  è  I  ø  RPUmax      3.3 V   270 µA      2.00 V   4.81 kΩ      1.8 V   270 µA      1.17 V   2.33 kΩ  Method 2  For applications that have already implemented the Secondary Reset Workaround  described in 	 2.3.23  BOOT: Internal Pullup Resistors for BOOT[7:0] Pins Are Sometimes Enabled  During Reset, Leading to Boot Failures  	 	ARM9	 	      2.3 and earlier   	OMAP-L138	 	:   The PUPD_SEL[29] register does not get initialized when the device is first powered on and in Reset. This register controls the internal pullup and pulldown resistors for the BOOT[7:0] pins. The contents of the PUPD_SEL[29] register at this state are  unpredictable and may contain random values. These random values can result in the  internal pullups being enabled for some or all of the BOOT[7:0] pins during reset after every power-on, which conflicts with the datasheet claim that the internal pulldowns are enabled during reset.  Internal pullups being enabled on the BOOT[7:0] pins may result in boot failures. If weak external pulldown resistors are used on the PCB to select the boot mode, they may not be able to overpower the internal pullups. This can result in the wrong boot mode being latched in the BOOTCFG[7:0] register when coming out of Reset.  Once the device is out of Reset, the PUPD_SEL[29] register is initialized, and the  internal pulldown resistors for the BOOT[7:0] pins are all enabled. Issuing a second Power-On Reset (POR) results in the intended boot mode being latched, since the pins are internally pulled down as expected.  Figure 10 shows the behavior of the PUPD_SEL[29] register before and after reset.  Assuming weak or no external pull resistors are on the BOOT[7:0] pins, the BOOTCFG  register will latch the unknown values after the device initially comes out of Reset. Note that, TRST must always be low in order to issue a POR and latch the boot pin values --  the boot pins are not latched after a Warm Reset.  RESET  TRST  PUPD_SEL[29] Register  0h  BOOTCFG[7:0] Registers  Figure 10. Initialization of PUPD_SEL[29] and BOOTCFG[7:0] Registers with Weak or No External Pull Resistors on BOOT[7:0] Pins  Other device pins with configurable internal pullup or pulldown resistors are always internally pulled down during reset and are not affected by this advisory.  	 	 	TI
Workaround(s)	 2.0.20, no additional modifications are required as a fix for this Advisory.  As shown in Figure 10, issuing a second POR will always latch the BOOT pins while the internal pulldown resistors enabled.  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  33  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  	 	ARM9	 	Revision(s) Affected	OMAP-L138	 	Details	 	 	TI
":  The workaround ignores errors in ECC data (these errors do not need to be corrected) so that the boot process can continue, correcting errors in the user data (up to 4 bit errors total), as necessary. The workaround also includes a mechanism to restart the NAND read process from the next good block if an uncorrectable error (more than 4 bit errors) is detected on any page of a good block.  This workaround is implemented using a software patch that is loaded in device RAM at boot time and is designed to change the default behavior of the ECC Correct and Read functions in the RBL. The patch binary replaces function pointers to the ECC Correct and Read functions in the ROM function table, (defined in device internal memory),  during boot. The patch binary will reside in page0 of the NAND block and so will be applied only after the page0 of a good block has been read.  Once the patch is read, all subsequent page reads in the block will use the new ECC  Correct and Read functions. ECC data errors on any page (other than page0) are  ignored, any user data error (up to 4 bit errors total) is corrected and the boot process continues. If an uncorrectable error is detected on any page, the block is skipped and the boot process is restarted on the next good block. The behavior of the device boot from the NAND after application of the patch is shown in Figure 12.  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  35  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated    Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  (1)  All pages marked in green are good and all pages marked in red have ""uncorrectable"" errors.  Figure 12. D800K008 ROM Behavior With Software Patch Applied(1)  The software patch is available as a pre-built file with the latest version of the AIS tool that is used to generate the NAND flash boot image. The Using the OMAP-L132/L138  Bootloader Application Report (Literature number: SPRAB41) provides a link to the install package for the AIS tool which includes the following in the install directory: prebuilt patch files, the GUI AIS generation tool (AISGEN.exe, version 1.11 or later), command-line AIS generation tool and an example INI file.  Application of the Software Patch to NAND Boot Images:  •  For the GUI tool, AISGEN.exe version 1.11 or later (found in the install directory), the patch integrates the modified ECC Correct function into the user application file to generate one binary AIS file.  •  For the Command line AIS tool, HEXAIS_OMAP_L138.exe users (found in the install  directory), the patch can be integrated into the user application file to generate one binary AIS file by inserting lines below to the end of the INI configuration file.  The patch name is: ARM_nand_ecc_patch_OMAP-L138.out  36  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications  [INPUTFILE] ; get the NAND ECC patch file  FILENAME=Patch_name.out  ; patch the NAND ECC handling routine  [AIS_Jump]  LOCATION=_NAND_ECC_patchApply  •  The patch will be burnt on page0, as it is in the head of AIS file. Once page0 has  been read successfully, the AIS set command will overwrite the function pointer in the RBL with the modified function pointer and the modified function will be applied to the later pages read. Memory usage of the patch at boot time is as follows:  –  500 bytes at location 0xFFFF 0B00  Recommendations to Improve Robustness:  •  Page0 should be stored on multiple blocks as backup to take advantage of the safety mechanism built into Silicon Revision 2.1 to cycle to the next block when a page0  read fails in a good block.  •  Maintain backup boot images in multiple blocks. The patch to the Abort function  reinitializes the boot process and forces the boot to cycle to the next good block and restart the boot process by reading from it.  •  Silicon Revision 2.1 supports booting from Block 0 of the flash which many NAND  manufacturers guarantee as a “more reliable” block than all other blocks. Hence,  setting up boot to start from that Block 0 could help improve the reliability of boot.  This is a hardware change, requiring the bootmode pins BOOT[6:5] = 1x.  For more details on the bootmode pins, see the Using the OMAP-L132/L138  Bootloader Application Report (Literature number: SPRAB41), NAND-Boot Modes.  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  37  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  "	 2.3.24  Boot: ECC Data Error in Spare Area Causes NAND Boot Failure  	 	ARM9	 	  2.3 and 2.1 (ROM Versions D800K008)  	OMAP-L138	 	":  The ROM bootloader (RBL) reads a NAND page in segments of 512 bytes (user data)  over the External Memory Interface A (EMIFA). The EMIF also reads the associated  ECC data which is stored in the spare area of the flash (as shown in Figure 11). The ECC Correct function in the RBL can correct up to 4 bit errors in the user data and/or ECC data by using the syndrome generated from the ECC data and the parity of the  user data calculated by the EMIFA module.  However, over the life span of the NAND flash, ECC data stored in the spare area can develop errors due to bit flips. When the calculated syndrome indicates an error in the ECC data, the ECC Correct and Read functions of the RBL abort the read process even though, it is possible to correct up to 4 bit errors combined in user and ECC data.  Consequently the device fails to boot.  Explanation of Current ROM Bootloader Behavior:  The RBL implements a search mechanism to look for the boot image in NAND flash by  using an Open function and a Read function. The Open function includes a bad block  check where the RBL skips to the next block (shown as (A) in Figure 11) if the block under consideration is marked as ""bad"" (in the spare area). On finding a good block, the RBL attempts to read page0 (the first page) in that block.  If page0 of the good block has an ECC data error or an uncorrectable error (more than 4  bit errors combined), the RBL skips to the next block (shown as (B) in Figure 11). This bad block check mechanism enables the device to check up to the first 32 blocks in the NAND flash for booting (the boot process will fail if all 32 blocks have uncorrectable or ECC data errors in page0). Note that the RBL does not abort on detecting an error in ECC data on page0.  Once the RBL finds a good block with a good page0, it continues to read subsequent  pages in that block. If an uncorrectable or ECC error is detected in subsequent pages, the RBL will abort with a boot error (shown as (C) in Figure 11). The workaround,  described below, enables the boot process to continue for both types of errors (ECC  data and uncorrectable errors).  34  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated    www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications (1)  All pages marked in green are good and all pages marked in red have ""uncorrectable"" errors.  Figure 11. D800K008 ROM Behavior Before Application of Software Patch(1)  "	 	 	TI
  Initialize the datalength descriptor field to zero. CPPI DMA updates this field after the completion of an RX DMA operation with the actual number of bytes received. In the ISR  (actually in a deferred call context), poll this field until it becomes a non-zero value to ensure data buffer has been updated with actual data. The descriptor buffer write is posted after the data buffer write, so waiting for the descriptor field to be updated ensures the data buffer has been updated. Since this workaround involves deferred  procedure calls (whose schedule can be delayed depending on OS load), the latency  sensitive application (like ISO Audio) might be affected by delay in notification to the application.  38  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications 	 2.3.25  USB0: CPU gets Stale Receive Data from the Data Buffer located in External  Memory  	 	ARM9	 	      2.3 and earlier   	OMAP-L138	 	   When CPPI DMA completes a receive data transaction it posts a write to the Rx data  buffer located in external memory, posts a write to update the descriptor located in external memory, and raises an interrupt to CPU. When the system load is high, the  posted writes to DDR may not be complete before the CPU receives the interrupt. In this case, the CPU would fetch stale receive data from the Rx data buffer located in external memory.  	 	 	TI
  The workaround involves monitoring transfer data size before and after transferring and reconfiguring data transfer size by software if the before and after size is different.  Software must keep tracking every endpoint data transferring size. When DMA  completion interrupt is received, software checks size difference. If the size is not equal, software requests the remaining data.  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  39  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  	 2.3.26  USB0: Early DMA Completion in DMA Receive Mode and More Than One Endpoint  is Transferring Data  	 	ARM9	 	      2.3 and earlier   	OMAP-L138	 	   The erroneous short packet status can be detected on current endpoint and XDMA  closes the Rx transfer in current endpoint. When more than one endpoint have been  processed, if one of the endpoints has a short packet, then the short packet status is broadcasting to all endpoints.  This results in premature completion of a Rx descriptor in generic RNDIS CPPI DMA  mode.  	 	 	TI
  Software should make sure that DMA does not get to an unknown state during teardown by disabling the DMAEN bit in the RXCSR register. After this the teardown procedure can be initiated. Software should also add 250 ms delay during teardown.  40  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.1 Usage Notes and Known Design Exceptions to Functional Specifications 3  Silicon Revision 2.1 Usage Notes and Known Design Exceptions to Functional  Specifications  This section describes the usage notes and advisories that apply to silicon revision 2.1 and earlier of the device.      3.1   Usage Notes for Silicon Revision 2.1  Usage notes highlight and describe particular situations where the device's behavior may not match presumed or documented behavior. This may include behaviors that affect device performance or functional correctness. These usage notes will be incorporated into future documentation updates for the device (such as the device-specific data sheet), and the behaviors they describe will not be altered in future silicon revisions.  Silicon revision 2.0 applicable usage notes have been found on a later silicon revision. For more details, see Section 2.2, Silicon Revision 2.3 Known Design Exceptions to Functional Specifications.      3.2   Silicon Revision 2.1 Known Design Exceptions to Functional Specifications  The advisories are not enumerated in sequential order and hence some numbers may not appear in the document  Table 15. Silicon Revision 2.1 Advisory List  Title ................................  Page  	 2.3.27  USB0: DMA Hung up in Frequent Teardowns  	 	ARM9	 	      2.3 and earlier   	OMAP-L138	 	   Teardown receive DMA is not working perfectly. This happens when a teardown is  initiated by software during the endpoint is still active. Frequent teardown results in XDMA hung up situation.  	 	 	TI
  When a break in transmission is detected, USB0 traffic can be recovered by a software reset of the USB0 PHY. A PHY reset implies recalibration of the PHY PLL at the reset temperature. The system has not been observed to reliably recover on its own. A PHY  reset also implies re-enumeration of all devices. There is no way to recalibrate the USB0  PHY without a re-enumeration.  In order to invoke the recovery mechanism (that is a USB0 PHY reset) one needs to  determine when the issue is present. One such approach is to look for an absence of USB0 Core interrupts over a specified time window. This window should be optimized for the expected USB traffic based upon the application.  As an additional safeguard, an application can also intentionally schedule pre-  determined USB PHY resets at specific temperature points if operation over a broad  range is expected.  Here is an example of one way to power cycle the USB0 PHY via the Chip Configuration 2 Register in the System Configuration (SYSCFG) Module:  #define CFGCHIP2  *((volatile unsigned int *) 0x01C14184)  #define USBPHY_PHYPDWN 0x00000200  Void phy_reset(void) {  CFGCHIP2 |= USBPHY_PHYPDWN;  /* Power down the USB PHY */  mdelay(1);  /* Wait 500ms */  CFGCHIP2 &= ~USBPHY_PHYPDWN;  /* Power up the USB PHY */  }  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  43  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 2.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  4  Silicon Revision 2.0 Usage Notes and Known Design Exceptions to Functional  Specifications  This section describes the usage notes and advisories that apply to silicon revision 2.0 of the device.      4.1   Usage Notes for Silicon Revision 2.0  Usage notes highlight and describe particular situations where the device's behavior may not match presumed or documented behavior. This may include behaviors that affect device performance or functional correctness. These usage notes will be incorporated into future documentation updates for the device (such as the device-specific data sheet), and the behaviors they describe will not be altered in future silicon revisions.  Silicon revision 2.0 applicable usage notes have been found on a later silicon revision. For more details, see Section 2.2, Silicon Revision 2.3 Known Design Exceptions to Functional Specifications.      4.2   Silicon Revision 2.0 Known Design Exceptions to Functional Specifications  Table 16. Silicon Revision 2.0 Advisory List  Title ................................  Page  	 2.1.21  USB0 PLL Mean Frequency Can Drift Across Large Temperature Swings  	 	ARM9	 	      2.1 and earlier   	OMAP-L138	 	   Under conditions in which the device is subjected to large variations in operating  temperatures, the USB0 PLL temperature compensation circuitry does not have enough  margin to guarantee compensation for PLL drift across all temperature ranges.  As a result, the mean frequency generated by the USB0 (USB 2.0 OTG) PHY PLL will  begin to drift (relative to the expected 480 Mbps) when the temperature of the device is subjected to large swing from the original temperature in which the USB0 PHY was most recently calibrated (initialized).  Once the onset of PLL drift occurs, the mean frequency will continue to drift outside the expected frequency and will eventually cause the PLL to lose lock resulting in failure of USB packet reception and/or transmission. This break in transmission will continue until the USB0 PHY is recalibrated during a USB0 PHY Reset.  If the device is not exposed to large variations in temperature relative to the temperature at which the USB0 PHY was most recently initialized, the temperature compensation  circuitry is expected to provide the proper compensation to prevent the mean PLL  frequency from losing lock and beginning to drift.  More specifically, this advisory is most applicable in applications where the device is expected to operate outside the commercial temperature range of 0˚C to 90˚C. TI has identified a point-to-point device temperature range in which there is a very high  confidence the compensation circuitry will properly compensate for all temperature  variations, provided the USB0 PHY was most recently initialized (calibrated) within this same temperature range.  Operating outside the 0˚C-65˚C temperature range increases the susceptibility of the device to experience PLL drift, but does not mean that the application will always  experience a failure in USB transmission.  Root Cause  The Voltage Controlled Oscillator (VCO) Compensation circuitry local to the USB0 PHY  was not designed with a large enough range to compensate for all variations in  temperature across the specified operating range of the device.  How to Most Easily Reproduce the Issue: Reproduction of this issue can most easily be accomplished by the following steps:  1. Allowing the unit to soak in an ambient temperature of -35˚C until the device  temperature reaches approximately the same temperature.  2. Power up the device and provide the necessarily software programming in order to invoke the USB Signal Quality Test Pattern.  3. Using a USB 2.0 Certified Test Platform, execute the USB signal quality test  procedure across the following temperature set points. -35˚C, 0˚C, +35˚C, +70˚C.  Record the measured mean frequency by the compliance software.  NOTE:  The set points can be varied to obtain finer temperature resolution of  when the PLL begins to drift a per platform basis. The above temperature  profile is provided for reference.  42  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.1 Usage Notes and Known Design Exceptions to Functional Specifications 	 	 	TI
  Modify the target board so that the affected device is given a secondary reset on power-up as shown in Figure 16. Two example methods are described in the sections that  follow.  Although secondary resets are compatible with future silicon revisions, they are not required for devices where the root cause has been fixed via an updated DSP boot  ROM. In order to reduce BOM costs, board designers may want to route a reset signal bypass path so that the workaround circuit can be depopulated on future PCB builds.  ❏ Use a reset supervisor device that includes a watchdog timeout function so that the reset supervisor will issue a secondary reset if the device fails to boot. The watchdog should be serviced with a device signal that is controlled by software. Options for servicing the watchdog timeout include GPIO, unused clock sources such as  CLKOUT or a periodic output peripheral like TIMER and ePWM.  46  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated      www.ti.com  Silicon Revision 2.0 Usage Notes and Known Design Exceptions to Functional Specifications Potential reset supervisors are TPS382x for 3.3V IOs (shown in Figure 17) and TPS312x for 1.8V IOs.  TPS3820      3.3V   OMAP-L138   VDD  DVDD3318  GND  GND  Board Reset  MR  WDI  CLKOUT  RESET  RESET  0-W  Not Populated  Figure 17. Reset Supervisor with Watchdog Function  The watchdog supervisor workaround is easy to implement, however the watchdog  timeout period may exceed application boot-up time requirements. For example, the  TPS3820 has a typical watchdog timeout period of 200ms. The second workaround can  speed up the reset process.  ❏ Implement a logic-based secondary reset circuit which is timed using RC  components. For the circuit shown in Figure 18, a single board reset control signal can trigger three logic transitions in a dual XOR gate device.  Not Populated  0-W  1A  R1  1Y  1B  Board Reset  1  C1  1A  RESET  R2  1Y  1B  2  R3  SN74LVC2G86  C2  Dual XOR Gate  SN74LVC2G17  Dual Schmitt Buffer  Figure 18. RC-Timed Secondary Reset  This is possible because each RC load connected to the board reset control signal can output a different rising-edge waveform. With increasing RC load, the resulting control signal will reach the Schmitt buffers’ Vih level at a later point in time. Figure 19 shows the relationship between the board reset signal and the RESET signal produced by the circuit. The blue and green lines represent the voltage as seen by the Schmitt buffers.  The output voltage of a charging RC circuit is defined as: Vo = Vi * (1 - e^[-t / RC]) SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  47  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 2.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  R1C1  RESET  R2C2  Vih  Board Reset  Figure 19. RESET Signal vs Board Reset  Given ideal conditions, a 3.3V board reset signal, and an input buffer Vih of 1.4V, the following set of component values would generate an initial RESET high period (R1C1  region) of approximately 2ms and a RESET low period (R2C2 region) of approximately  0.5ms:  •  R1 = 36k, C1 = 100nF,  •  R2 = 45k, C2 = 100nF,  •  R3 = 450k  When implementing this workaround, some important aspects should be kept in mind:  (a) The dual Schmitt buffer is included because the dual XOR gate has an input rise-time requirement that is violated by the RC circuits,  (b) The Board Reset signal must meet the XOR gate input rise-time requirement and  must provide enough output current to charge the RC circuits to the target Vih level, (c) It is critical for the Vih level of the two input buffers to be very close together so only single-device buffers should be considered for this circuit (such as the 2-in-1 dual Schmitt buffer device used in this example),  (d) Variations in the electrical characteristics of the circuit components may produce waveforms that deviate from ideal calculations, and  (e) The sole purpose of the R3 pulldown resistor is to discharge the RC components  before the board reset signal is driven high. Therefore, the value selected for R3  should be sufficiently large enough to not interfere with the RC circuits as they are charging.  48  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 1.1 Usage Notes and Known Design Exceptions to Functional Specifications 5  Silicon Revision 1.1 Usage Notes and Known Design Exceptions to Functional  Specifications  This section describes the usage notes and advisories that apply to silicon revision 1.1 of the device.      5.1   Usage Notes for Silicon Revision 1.1  Usage notes highlight and describe particular situations where the device's behavior may not match presumed or documented behavior. This may include behaviors that affect device performance or functional correctness. These usage notes will be incorporated into future documentation updates for the device (such as the device-specific data sheet), and the behaviors they describe will not be altered in future silicon revisions.  Silicon revision 1.1 applicable usage notes have been found on a later silicon revision. For more details, see Section 2.2, Silicon Revision 2.3 Known Design Exceptions to Functional Specifications.  5.1.1  RTC Standby Power Consumption Is Elevated if the Module Is Not Configured Correctly The RTC module is designed with the ability to keep time while the rest of the device is power cycled off and on. This ability is achieved by placing the RTC in its own power domain and isolating it from the device reset signal.  When the CVDD supply is powered down, the RTC_CVDD supply will experience elevated standby power consumption because of leakage between the RTC and core power domains. The RTC module includes circuitry that eliminates the leakage paths between the two domains when the SPLITPOWER bit is set to 1  in the control register (CTRL). The SPLITPOWER bit is a write-only bit that will always read back 0.  Therefore, typical read-modify-write sequences should not be used when writing to the CTRL register because the SPLITPOWER bit will be cleared back to 0.  Also note that the SPLITPOWER bit has a default value of 0 after RTC module reset, and the only reset available to the RTC module is a software reset, therefore RTC is in an indeterminate state when the RTC_CVDD supply is first powered on. The RTC module should be reset, and the SPLITPOWER bit should be set to 1 before placing the device in a CVDD powered down standby state.  The SPLITPOWER bit is permanently set to 1 inside the RTC module beginning with Silicon Revision 2.0  of the device.  5.1.2  SYSCFG: Possible Race Condition When Using KICK Registers  When two or more threads are simultaneously accessing the SYSCFG registers, there is the potential for one thread to lock the SYSCFG registers while another thread is still accessing them. There is no hardware semaphore to prevent this from occurring.  For example, the race condition can occur in the following situation  1. Thread 1 unlocks the SYSCFG register by writing to the KICK registers  2. An interrupt occurs and Thread 2 unlocks the SYSCFG registers as well  3. Thread 2 finishes and locks the SYSCFG registers  4. Thread 1 is locked out of the SYSCFG registers and is unable to complete its task To prevent the SYSCFG lockout race condition, the application should unlock the SYSCFG registers via the KICK registers and leave them permanently unlocked.  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  49  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  5.1.3  SATA & USB Digital Supplies Must Be Powered for Proper Device Operation  For silicon revisions prior to 2.0, the SATA and USB digital supply pins must be powered up. These supplies provide power to logic that is critical for device initialization during reset. A bad initialization sequence will cause the device boot process to fail. Another symptom of a bad initialization sequence is that the DIEIDRx registers (0x01C14008h – 0x01C14017h) will appear as all zeros.  Starting with silicon revision 2.0, the affected logic will be powered by the CVDD core supply instead of the USB and SATA supplies.  The following is a list of the supply pins affected:  Table 17. Supply Pins Affected  Digital Supply  Pin  SATA_VDD  M2  SATA_VDD  N4  SATA_VDD  P1  SATA_VDD  P2  USB_CVDD  M12      5.2   Silicon Revision 1.1 Known Design Exceptions to Functional Specifications  Silicon revision 1.1 applicable advisories have been found on a later silicon revision. For more details, see Section 2.2, Silicon Revision 2.3 Known Design Exceptions to Functional Specifications The advisories are not enumerated in sequential order and hence some numbers may not appear in the document.  Table 18. Silicon Revision 1.1 Advisory List  Title ................................  Page  	 2.0.20  Intermittent Boot Failures  	 	ARM9	 	      2.0 and earlier   	OMAP-L138	 	   For affected silicon revisions, the DSP initiates the system boot sequence when the device is released from reset. Before the ARM can take control of the user boot mode, the DSP must first initialize the ARM reset vector table so that the ARM will execute from its boot ROM.  The ARM reset vector table is located in the ARM’s local RAM, however the ARM local RAM can only be accessed by two bus masters: ARM and PRU0. Therefore, the DSP  must program PRU0 to copy the desired reset vector table into the ARM’s local RAM.  The PRU instructions are located inside of an instruction RAM (IRAM) which is initialized by the DSP during ROM boot (see Figure 13). After the instructions are stored to IRAM, the PRU is reset and enabled to execute its instructions. In this case, the PRU is  instructed to initialize the ARM reset vector table.  Read  PRU Core  PRU IRAM  Write  Enable Bit Reset Bit  External Master  (DSP)  Figure 13. PRU and DSP Block Diagram  When the device is first powered-on, the read bus from the PRU IRAM is not initialized and will contain random values (see Figure 14). Under unpredictable circumstances, the random value on the read bus may resemble a reserved instruction which can be  interpreted by the PRU when the core is reset and not enabled.  If the PRU core executes this reserved instruction, it will not be able to properly execute the first functional op-code in the PRU IRAM when the core is later enabled. In this fail state, the PRU will never acknowledge to the DSP that the reset vector table was  successfully initialized and the DSP will be stuck in a polling loop waiting for the PRU to complete its task.  Read Rsvd Inst  PRU Core  Fail State!  PRU IRAM  Write  Enable Bit Reset Bit  External Master  (DSP)  Figure 14. Boot Failure on Power-On  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  45  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 2.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  Although the PRU core execution is stuck, the PRU IRAM read bus is now initialized with a non-reserved instruction that was fetched from the IRAM by the PRU core (see  Figure 15). If a secondary reset is provided to the device (either POR or WARM), the PRU will be able to execute its functional instructions as expected.  Read Good Inst  PRU Core  Pass State!  PRU IRAM  Write  Enable Bit Reset Bit  External Master  (DSP)  Figure 15. Secondary Reset  Note that in order to recover from this fail state with a secondary reset, the DSP must be allowed to execute its boot ROM up to the point where the PRU has fetched a known  instruction from the PRU IRAM. The approximate count of 15k cycles into the boot ROM  is sufficient.  The 15k clock cycle count does not include the 6192 clock cycles required to complete a device POR reset (see Figure 16). With a 24MHz crystal, the first RESET signal must be asserted high for at least 883us (or approximately 1ms).  Greater than 15k Cycles  RESET  RESETOUT  6192 Cycles  Figure 16. First POR Reset Timing  	 	 	TI
  Method 1  In cases where buffer access will not be shared between CPU and SDMA,  unintended CPU/SDMA cache-line sharing can be avoided by aligning CPU and  SDMA buffers to 64-byte boundaries. Aligning buffers to 64-byte boundaries will  result in wasted space, however it ensures that the CPU and SDMA buffers will not  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  51  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  have partial segments which overlap into the same L1D cache line.  /** Pseudo code only **/  Uint8 *SDMA_BUFF, *CPU_BUFF;  /* 64-byte aligned allocation Option 1 */  SDMA_BUFF = malloc( (Int32) (( SDMA_BUFF_SIZE + 63)/64) * 64 );  CPU_BUFF  = malloc( (Int32) ((CPU_BUFF_SIZE  + 63)/64) * 64 );  SDMA_BUFF = (Uint8 *) ( (Int32) SDMA_BUFF & ~63 );  CPU_BUFF  = (Uint8 *) ( (Int32) CPU_BUFF  & ~63 );  /* 64-byte aligned allocation Option 2 with BIOS Call */  SDMA_BUFF = MEM_alloc( IRAM, SDMA_BUFF_SIZE, 64 );  CPU_BUFF  = MEM_alloc( IRAM, CPU_BUFF_SIZE,  64 );  Method 2  Manage access to a 64-byte boundary aligned buffer that is shared between CPU  and SDMA by implementing a semaphore and forcing cache writeback operations  after CPU writes. With this method, the semaphore ensures that there is clear  ownership of the buffer between CPU and SDMA, and the CPU manages cache  coherence by using explicit cache writeback operations.  /** Pseudo code only **/  /* Example with EDMA as the external master */  EDMA_ISR() {  /* EDMA releases ownership of buffer */  SEM_post(SyncSemaphore);  return;  }  main() {  while(COND) {  /* CPU waits for ownership of buffer */  SEM_pend(SyncSemaphore);  /**********************/  /*** CPU Processing ***/  /**********************/  /* Cache writeback for shared block */  /* Buffer must be 64-byte aligned  */  BCACHE_wbInv( blockPtr, blockSize, WAIT );  /* Initiate EDMA */  EDMA_Event_Generate();  }  }  Method 3  Configure the entire L2 RAM as cache. Critical peripheral data can be accessed in  L1D RAM or L3 RAM instead of L2 RAM.  Method 4  Do not allow SDMA to access L2 RAM. SDMA can use buffers in L1D RAM or L3  RAM instead of L2 RAM.  52  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 1.1 Usage Notes and Known Design Exceptions to Functional Specifications Method 5  Do not configure L1D memory as cache - use the entire address space as RAM.  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  53  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  	 1.1.2  Under Specific Conditions, SDMA Activity Can Corrupt the L1D Cache and L2 RAM  	 	ARM9	 	      1.1 and earlier   	OMAP-L138	 	   Note: DMA refers to all non-CPU requests. SDMA refers to external system DMA master requests handled via the Slave Direct Memory Access port.  The C674x Megamodule uses a two-way set associative cache for L1D. This means that  every physical memory location in the system has two possible set/way locations in the cache where it can reside. See TMS320C674x DSP Megamodule Reference Guide,  Literature Number - SPRUFK5 for more information on the L1D cache architecture.  Updated (dirty) values in L1D cache are not written back to external memory until cache activity evicts a cache-line (victim write-back) or a write-back is requested by the application.  An L1D cache-line corruption event occurs when all of the following conditions are met: 1. L1D cache evicts a dirty line (Line A) while allocating a new line (Line B) in the same set/way (cache Lines A and B consist of 64-bytes each). In order for this to happen, the following will have taken place:  (a) Line A was previously read by CPU because L1D is a read-allocate cache,  (b) Line A is dirty because its value was modified by CPU, and  (c) Line B is read by CPU  2. Both Line A and Line B are associated with L2 RAM, and  3. While the original L1D victim write-back from condition (1) is in progress, the SDMA performs both:  (a) a read or write operation to Line A in L2 RAM and  (b) a write operation to Line B in L2 RAM.  If all of the above conditions are met, the L2 RAM data associated with the Line A victim writeback will become corrupt. Additionally, the Line B data originating from the SDMA write will also become corrupt in L1D cache. Figure 20 shows an example scenario of L1D cache and L2 RAM corruption.  Line A and Line B Map to  LINE A  same L1D Cache line.  INITIAL  STEP 1  STEP 2  STEP 3  STATE  C674x Megamodule  LINE B  C674x CPU  CPU Request  Request  L2  C674x CPU  EXTERNAL  Activity  Line B  Pending  Controller  L2  SRAM  SDMA  SDMA Requests  Read/Write to Line A  Activity  & Write to Line B  L1D  EMC  L1D Cache  Dirty Line A  Dirty Line A  IN-FLUX  Corrupt  Controller  SDMA PORT  EDMA  SYSTEMMASTERS  Line Status  in L1D Cache in L1D Cache  Line A  Old Data  Old Data  Old Data  Corrupt  L2 SRAM  Line B tries to replace  EMAC  CACHE LINE  Line B  Old Data  Old Data  Old Data  NEW DATA  Dirty Line A in the L1D  L2 SRAM  Cache  L1D  CACHE  Corruption happens  because of this state  TIME LINE  SYSTEM VIEW  Figure 20. Example of L1D Cache and L2 RAM Corruption  	 	 	TI
  None  54  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 1.1 Usage Notes and Known Design Exceptions to Functional Specifications 	 1.1.7  Low Voltage Operating Points (1.1V, 1.0V) Not Supported  	 	ARM9	 	      1.1 and earlier   	OMAP-L138	 	   The low-voltage operating points are not supported on revisions 1.1 and earlier. The support of these operating points is planned for revision 2.0.  	 	 	TI
  Limit the number of hardware reset to within the limits listed above.  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  55  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  	 1.1.11  Hardware RESET Reliability Lifetime  	 	ARM9	 	      1.1 and earlier   	OMAP-L138	 	   A potential reliability issue has been discovered when hardware resets (RESET pin high-to-low transitions) occur. If any of the dual-voltage LVCMOS IOs on the device are being operated at 3.3V nominal and a hardware reset occurs, some 1.8V transistors in the IOs buffers are briefly exposed to 3.3V. This exposure to high voltage has the potential to degrade the gate oxide integrity of the transistors over repeated resets.  This issue does not occur during a power-up condition where the RESET pin is held low.  This issue does not occur with software resets or watchdog timer induced resets.  This issue does not occur if all dual-voltage LVCMOS IO buffers are being operated at 1.8V nominal.  Reliability estimates have been made to determine a budget for the number of resets in a product lifetime to maintain the reliability of the device under 50 FIT.  •  At a junction temperature of 105°C, the total number of hardware resets in the  product lifetime should not exceed 125,000 hardware resets.  •  At a junction temperature of 90°C, the total number of hardware resets in the product lifetime should not exceed 250,000 hardware resets.  	 	 	TI
  When developing DSP software, the affected peripherals can be removed from halted  states by either free-running the ARM CPU or by setting the peripheral-specific  emulation mode to FREE. The affected peripherals can be placed into halted states by halting the ARM CPU.  Code Composer Studio (CCS) allows the user to set Global Breakpoints such that the  DSP and ARM CPUs will both halt at the same time on a given breakpoint. CCS also  includes the ability to simultaneously set debug states (such as RUN and HALT) across multiple processors. When the ARM and DSP both run and halt at the same time, the  peripherals will appear as if their suspend source is the DSP.  56  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 1.1 Usage Notes and Known Design Exceptions to Functional Specifications 	 1.1.14  SYSCFG SUSPSRC Bits Not Functional for McBSP0, McBSP1, TIMER2, and VPIF  	 	ARM9	 	      1.1 and earlier   	OMAP-L138	 	   Device peripherals often include an emulation suspend function that gracefully halts peripheral activity. This function is activated when the target CPU is halted through emulator debug. While halted, the control and status registers for the module can be viewed and manipulated for debug purposes.  In a multicore device, it is desirable to choose a single CPU to master the emulation suspend function. Typically, the CPU that configures a module is chosen to be its  suspend source CPU (ARM or DSP). The SUSPSRC register in the SYSCFG module  allows the user to choose which CPU controls the emulation suspend function for each peripheral.  For the affected silicon revisions, the SUSPSRC fields MCBSP0SRC, MCBSP1SRC,  TIMER64P_2SRC, and VPIFSRC are not functional. The ARM will always be the  suspend source regardless of the bit settings. If the ARM is connected and halted  through emulator debug, the affected peripherals will appear to be halted as observed by the DSP. Similarly, if the ARM is free-running, the affected peripherals will never halt when the DSP is halted.  The described condition is only present during emulation debug – the peripherals will function as expected when the device is free-running in an application.  	 	 	TI
  Entirely eliminate IDMA/SDMA stalling and potential for a deadlock condition using one of the following two methods:  1. Configure the entire L2 RAM as 100% cache (for example, move all data buffers from L2 to L1D or other memory). Note: Some throughput degradation is expected when  the buffers are moved out to external memo  2. Eliminate all IDMA/SDMA access to L2 RAM when IDMA/SDMA stalling would have  an impact by performing one of the following:  (a) Constrain each DMA master group to perform writes to either DSP memory space  or external memory space, but not to both, or  (b) Force each DMA master group to complete pending write commands to either  DSP memory space or cacheable memory space before initiating writes to a  different destination. Pending write commands from DMA masters are forced to  complete when the DMA master initiates a read from the same destination  memory. Note that in the case of off-chip memory, a read command only forces  the completion of write commands within a 2KB-aligned window.  60  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 1.0 Usage Notes and Known Design Exceptions to Functional Specifications 6  Silicon Revision 1.0 Usage Notes and Known Design Exceptions to Functional  Specifications  This section describes the usage notes and advisories that apply to silicon revision 1.0 of the devices.      6.1   Usage Notes for Silicon Revision 1.0  Silicon revision 1.0 applicable usage notes have been found on a later silicon revision. For more details, see Section 2.2, Silicon Revision 2.3 Known Design Exceptions to Functional Specifications.      6.2   Silicon Revision 1.0 Known Design Exceptions to Functional Specifications  Silicon revision 1.0 applicable advisories have been found on a later silicon revision. For more details, see Section 2.2, Silicon Revision 2.3 Known Design Exceptions to Functional Specifications.  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  61  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated      	 1.1.16  DSP SDMA/IDMA: Unexpected Stalling and Potential Deadlock Condition  	 	ARM9	 	      1.1 and earlier   	OMAP-L138	 	"   Note: This advisory is not applicable if DSP L2 memory is configured as 100% cache or L2 RAM is not accessed by IDMA or SDMA during run-time.  The C674x Megamodule has a Master Direct Memory Access (MDMA) bus interface and  a Slave Direct Memory Access (SDMA) bus interface. The MDMA interface provides  DSP access to resources outside the C674x Megamodule.  The MDMA interface is typically used for CPU/cache accesses to memory beyond the  Level 2 (L2) memory level. These accesses include cache line allocates, write-backs, and non-cacheable loads and stores to/from system memories. The cacheable  memories external to the C674x Megamodule are listed in Table 19.  Table 19. Cacheable External Memory Resources  External Memory  Address Range  Shared Ram  0x8000 0000 – 0x8001 FFFF  EMIFA  0x4000 0000 – 0x67FF FFFF  DDR2/mDDR  0xC000 0000 – 0xCFFF FFFF  The SDMA interface allows other DMA master peripherals (listed in Table 20 ) to access Level 1 Data (L1D), Level 1 Program (L1P), and L2 RAM DSP memories.  Table 20. DMA Master Peripherals  Peripheral  Group  EDMA0 TC0 RD  A  EDMA0 TC0 WR  B  EDMA0 TC1 RD  C  EDMA0 TC1 WR  D  EDMA1 TC0 RD  E  EDMA1 TC0 WR  F  UHPI  G  USB0  G  USB1  G  EMAC  G  PRU  H  SATA  I  UPP  I  VPIF  I  ARM  J  The C674x Megamodule has an L1D cache and L2 cache both implementing write-back  data caches– it keeps updated values for external memory in cache for as long as  possible. It writes these updated values, called ""victims"", to external memory when it needs to make room for new data or when requested to do so by the application. The  L1D sends its victims to L2. The caching architecture has pipelining, meaning multiple requests could be pending between L1, L2, and MDMA. For more details on the C674x  Megamodule and its MDMA and SDMA ports, see the TMS320C674x Megamodule  Reference Guide (literature number SPRUFK5).  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  57  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  Ideally, the MDMA (dashed-dotted line in Figure 21) and SDMA/IDMA paths (dashed  lines in Figure 21) operate independently with minimal interference. Normally MDMA  accesses may stall for extended periods of time due to expected system level delays (for example, bandwidth limitations). However, when using L2 as RAM, SDMA and IDMA  accesses to L2/L1 may experience unexpected stalling in addition to the normal stalls seen by the MDMA interface. For latency-sensitive traffic, the SDMA stall can result in missing real-time deadlines. In a more severe case, the SDMA stall can produce a  deadlock condition in the device. An IDMA stall cannot produce a deadlock condition.  Note: SDMA/IDMA accesses to L1P/D will not experience an unexpected stall if there are no SDMA/IDMA accesses to L2. Unexpected SDMA/IDMA stalls to L1 happen only  when they are pipelined behind L2 accesses. Additionally, the deadlock scenario will be avoided if there are no SDMA accesses to L2.  Figure 21 is provided for illustrative purposes and is incomplete because of  simplification. The IDMA/SDMA (dashed-lines) path could also go to L1D/L1P memories, and IDMA can go to DSP CFG peripherals. MDMA transactions can originate also from  L1P or L1D through the L2 controller or directly from DSP).  32K bytes  256K bytes  1M bytes  L1P RAM/  L2 RAM  L2 ROM  cache  256  256  256  256  Cache control  Cache control  Memory protect L1P  Memory protect L2  Bandwidth Mgmt  Bandwidth Mgmt  256  256  256  Instruction fetch  256 Power down  C674x  Interrupt  Fixed/floating point CPU  Controller  Register  Register  IDMA  file A  file B  64  64  256  CFG  Bandwidth Mgmt  32  Configuration  EMC  Memory protect L1D  peripherals  Cache control  bus  MDMA  SDMA  8x32  64  64  64  64  32K bytes  High performance  L1D RAM/  switch fabric  SDMA/IDMA Paths  cache  (SCR1)  MDMA Path  Figure 21. C674x Megamodule  The duration of the SDMA/IDMA stalls depend on the quantity/characteristics of the  L1/L2 cache and the MDMA traffic in the system. Therefore, it is difficult to predict if stalling will occur and for how long.  IDMA/SDMA stalling and any system impact is most likely in systems with excessive  context switching, L1/L2 cache miss/victim traffic, and heavy access to external memory.  58  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 1.1 Usage Notes and Known Design Exceptions to Functional Specifications Use the following procedure to determine if SDMA/IDMA stalling is the cause of real-time deadline misses for existing applications. Situations where real-time deadlines may be missed include loss of McASP samples and poor peripheral throughput.  1. Determine if the transfer that is missing the real-time deadline is accessing L2 or L1D  memory. If not, then SDMA/IDMA stalling is not the source of the real-time deadline miss.  2. Identify all SDMA transfers to/from L2 memory (for example, EDMA transfer to/from L2 from/to a UART, HPI block transfer to/from L2). If there are no SDMA transfers  to/from L2, then SDMA/IDMA stalling is not the source of the problem.  3. Redirect all SDMA transfers to L2 memory to other memories using one of the  following methods:  (a) Temporarily transfer all the L2 SDMA transfers to L1D SRAM.  (b) If not all L2 SDMA transfers can be moved to L1D memory, temporarily direct  some of the transfers to memory in Table 1 and keep the rest in L1D memory.  There should be no L2 SDMA transfers.  If real-time deadline misses are solved using any of the options in Step 3, then  IDMA/SDMA stalling is likely the source of the problem.  A deadlock situation may arise if the following sequence of events occurs:  Step 1: A DMA master from any group (listed in Table 2) issues a write command to the DSP’s SDMA, and a DMA master from the same group issues a subsequent write  command to cacheable memory outside of the C674x Megamodule (listed in Table 1).  All write commands pass through Switched Central Resource 1 (SCR1). For more  details on SCRs, see the device System Reference Guide SPRUG84.  Step 2: The DSP’s SDMA asserts itself as not ready and is unable to accept the write data from Step 1, and a cache line writeback is initiated from DSP memory to the same cacheable memory from Step 1. The cache line writeback command also passes  through SCR1.  With the above scenario, it is possible for SCR1 to order the write commands from Step 1 in front of the write commands from Step 2. Due to the MDMA/SDMA blocking  behavior, the SDMA commands from Step 2 will be waiting for the MDMA traffic from  Step 1 to finish, resulting in a deadlock situation at SCR1. Figure 22 is provided for illustrative purposes and is incomplete because of simplification.  DMA  Group A  C674x  SDMA  (L2/L1D)  DMA  Group B  SCR1  DMA  Group xx  Cacheable  Memory  C674x  MDMA  Figure 22. SCR1 System Interconnect  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  59  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  "	 	 	TI
  Configure DMA and CPU requests to different priority levels. There is no penalty for setting the IDMA and SDMA priorities equal to each other.  CPU request priority is programmed within the CPUARBU register:  /** Pseudo code only **/  Uint32 *CPUARBU;  CPUARBU = ( Uint32 * ) ( 0x01841000 );  /* Set priority different from IDMA/SDMA */  *CPUARBU = [CPU_PRIORITY];  8  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  SPRZ317G – August 2011 – Revised March 2014  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications IDMA request priority is programmed within the IDMA1_COUNT register  /** Pseudo code only **/  Uint32 *IDMA1_SRC, *IDMA1_DST;  Uint32 *IDMA1_CNT;  IDMA1_SRC = ( Uint32 * ) ( 0x01820108 );  IDMA1_DST = ( Uint32 * ) ( 0x0182010C );  IDMA1_CNT = ( Uint32 * ) ( 0x01820110 );  *IDMA1_SRC = sourceAddress;  *IDMA1_DST = destinationAddress;  /* Set IDMA priority different from CPU */  *IDMA_CNT = ( [IDMA_PRI] << [IDMA_PRI_SHIFT] ) | buffSize ;  SDMA request priority is inherited from the MSTPRIn registers  /** Pseudo code only **/  Uint32 *MSTPRI1, *MSTPRI2;  MSTPRI1 = ( Uint32 * ) ( 0x01C14114 );  MSTPRI2 = ( Uint32 * ) ( 0x01C14118 );  /* Set SDMA master priorities different from CPU */  *MSTPRI1 = [MAST_PRI] << [MAST_SHIFT];  *MSTPRI2 = [MAST_PRI] << [MAST_SHIFT];  SPRZ317G – August 2011 – Revised March 2014  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  9  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      	 2.3.1   DMA Access to L2 RAM Can Stall When DMA and C674x CPU Command Priorities      Are Equal   	 	ARM9	 	  2.3 and earlier      	OMAP-L132	 	   Note: DMA refers to all non-CPU requests. This includes Internal Direct Memory Access (IDMA) requests and all other system DMA master requests via the Slave Direct Memory Access (SDMA) port.  The C674x Megamodule uses a bandwidth management (BWM) system to arbitrate  between DMA and CPU requests issued to L2 RAM. See TMS320C674x DSP  Megamodule Reference Guide, Literature Number - SPRUFK5 for more information on the BWM. BWM arbitration grants L2 bandwidth based on programmable priorities and contention- cycle-counters. The contention-cycle-counters count the number of cycles for which the associated L2 requests are blocked by higher priority requests. When the contention-cycle-counter reaches a programmed threshold (MAXWAIT), the associated L2 request is granted a slice of L2 bandwidth. This prevents indefinite blocking of low priority requests when faced with the continuous presence of higher priority requests.  Ideally, the BWM arbitration will grant equal L2 bandwidth between equal priority DMA and CPU requests. Instead, when equal priority DMA and CPU requests arrive at the BWM, bandwidth is always granted in favor of the CPU over DMA. In the case of  successive CPU requests, it is possible for the CPU to block all DMA requests until CPU  traffic subsides. Additionally, some command logic in the BWM uses priority level 7, which can also result in SDMA stalls when the CPU is also programmed to priority level 7. Figure 3 shows a high level diagram of the arbitration scheme used for L2 RAM  requests.  C674x Megamodule  EDMA  SHAREDRESOURCE  ExternalSystemMasters  Programmable Priority  ARBITRA  MasterPriority  C674x CPU  EMAC  ARBITRA  Programmable Priority  IDMA  L2 RAM  TION  Inherit  TION  Priority  SDMA  USB  Highest Priority Master Granted Access.  Contention counters implemented to not      starve low priority requestors   Figure 3. Priority Arbitration Scheme for L2 RAM  	 	 	TI
  Software must service every USB RESET interrupt received. Software should not  proceed on performing any other task, like initialization, until RESET duration has come to completion. The POWER[RESET] bit field will be cleared by the USB Controller when RESET signaling on the bus is removed by the Host. The USB Controller clearing the POWER[RESET] bit field should be used by software as an indication for the completion of RESET signaling.  10  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  SPRZ317G – August 2011 – Revised March 2014  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications 	 2.3.3   USB0: Extraneous RESET Interrupt  	 	ARM9	 	  2.3 and earlier      	OMAP-L132	 	   When the USB controller is operating as a device and an attached host resets the device after the completion of the Device Attached state by driving both differential data lines low, the USB controller operating as a device could receive multiple RESET interrupts for the single RESET signaling invoked by the host. The multiple interrupt generation only happens for the duration of the RESET signaling on the bus. RESET Interrupt is not generated before or after the completion of RESET.  	 	 	TI
  If a time-out occurs, perform any of the following:  •  A dummy read to another asynchronous memory chip select that is not configured to be in Extended Wait mode.  •  A dummy read to the same asynchronous memory chip select after disabling the  Extended Wait mode on that chip select.  •  A dummy read to SDRAM  SPRZ317G – August 2011 – Revised March 2014  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  11  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      	 2.3.4  EMIFA: Asynchronous Memory Timeout Error Persistence  	 	ARM9	 	  2.3 and earlier      	OMAP-L132	 	   In Extended Wait mode, during a read access to an asynchronous memory, if the WAIT  input does not go inactive within maximum extended wait cycles programmed in the Async Wait Cycle Config register, the EMIF will report a time-out error. The data returned for this access will be all zeros. If this access is followed by a read to the EMIFA’s memory-mapped register (MMR) space, the EMIFA will still report a time-out error but with the correct data for the MMR read. The EMIF will hold the time-out error until another asynchronous access without a time-out error or an SDRAM access is performed.  This issue is only applicable if all of the following are true:  •  The EMIF is used for asynchronous memory accesses in Extended Wait mode.  •  There is a potential for a time-out error to occur, that is, the asynchronous memory will not de-assert the WAIT input.  •  If asynchronous memory read with time-out error is followed by an MMR read.  	 	 	TI
  The CPUINTn hardware interrupts can support both pulse and level interrupts so CHIPINTn interrupts should be mapped directly to CPUINTn hardware interrupts.  Furthermore, if the ECM is used for other system interrupts, the CHIPINTn interrupts should be masked out in the EVTMASKn registers.  12  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  SPRZ317G – August 2011 – Revised March 2014  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications 	 2.3.5   A Single CHIPINTn Interrupt Event Will Register Multiple Times in the DSP Event  Combiner Module (ECM)  	 	ARM9	 	  2.3 and earlier      	OMAP-L132	 	   The C674x DSP megamodule supports twelve maskable hardware interrupt signals  (CPUINT4 through CPUINT15). Single system interrupts may be mapped directly to a CPUINTn hardware interrupt, or multiple system interrupts may be combined by the ECM into a single signal before mapping to a CPUINTn interrupt. See [SPRUFK5;  TMS320C674x DSP Megamodule] for more information on how DSP interrupts are  handled.  The ECM expects all incoming interrupts to be pulse interrupts, however the  [SYSCFG_CHIPSIG_]CHIPINTn interrupts are level interrupts. This mismatch in interrupt types will cause a single CHIPINTn interrupt event to register multiple times in the ECM.  	 	 	TI
  The reset timing violation can be avoided by providing the modified soft reset activation sequence outlined below:  1. Enable the USB controller module clock through the Power and Sleep Controller (PSC)  2. Perform a soft USB reset  3. Wait for the USB soft reset bit to clear  4. Disable the USB controller module clock through the PSC  5. Configure the USB PHY parameters  6. Enable the PHY  7. Enable the USB controller module clock through the PSC  SPRZ317G – August 2011 – Revised March 2014  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  13  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      	 2.3.6  Potential USB2.0 Soft Reset Timing Violation  	 	ARM9	 	  2.3 and earlier      	OMAP-L132	 	   When a soft reset is invoked by setting the RESET bit of the USB CTRLR register (  CTRLR[RESET] = 1 ), the internal reset timing requirements may be violated. Although this timing violation has not been observed in practice, the potential for a timing violation exists.  USB resets initiated by system-reset and power-on-reset are immune from the timing violation.  There is no plan to fix this issue in future silicon revisions because:  1. No functional problems have been observed to date  2. A software workaround has been developed to avoid the problem  	 	 	TI
  Although there is no specific workaround, the following recommendations can be used to help prevent this issue:  •  Minimize loads as much as possible, especially DC loads that could cause the Vil to rise. Point-to-point (single-load) connections are unlikely to be affected.  •  Falling edges should transition as rapidly as possible (so the signal passes through the 0.2V point as early as possible). Heavily loaded nodes resulting in degraded fall times may require drivers to provide rapid input edges.  SPRZ317G – August 2011 – Revised March 2014  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  15  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      	 2.3.9   Vil on Dual-Voltage LVCMOS Input Buffers Operated at 3.3V  	 	ARM9	 	  2.3 and earlier      	OMAP-L132	 	   The input buffers on the device have shown timing sensitivity to the logic-low input voltage that can cause changes to the AC input timings. Due to this issue, input voltages must be driven to 0.5V or below on all dual-voltage LVCMOS input signals (signals associated with supplies DVDD1833_A, DVDD1833_B or DVDD1833_C).  Vil driven at or below 0.4V will cause no timing degradation. Vil driven up to 0.5V will cause up to 750 ps degradation in input timings.  The following datasheet parameters will be affected by Vil driven up to 0.5V. Their values adjusted for 0.75 ns degradation are shown.  Table 3. Timing Requirements for the EMIFA SDRAM Interface  1.2V  NO.  PARAMETER  UNIT  MIN      MAX   Input Setup time, read data valid on  19  t  2.75  ns  su(EMA_DV-EM_CLKH)  EMA_D[31:0]  Table 4. Timing Requirements for the EMIFA Asynchronous Memory Interface  1.2V  NO.  PARAMETER  UNIT  MIN      MAX   Setup time, EMA_D[31:0] valid before EMA_OE  12  t  3.75  ns  su(EMDV-EMOEH)  high  Table 5. Timing Requirements for McASP0  1.2V  NO.  PARAMETER  UNIT  MIN      MAX   AHCLKR/X ext input  1.15  Hold time, AFSR/X input after ACLKR/X  6  th(ACLKRX-AFSRX)  (1)  AHCLKR/X ext output  1.15  ns  AHCLKR/X ext input  1.15  Hold time, AXR0[n] input after  8  th(ACLKRX-AXR)  ACLKR/X (1) (2)  AHCLKR/X ext output  1.15  (1)  McASP0 ACLKXCTL.ASYNC=1: Receiver is clocked by its own ACLKR0  (2)  McASP0 ACLKXCTL.ASYNC=0: Receiver is clocked by transmitter's ACLKX0  Table 6. Switching Characteristics for McASP0  1.2V  NO.  PARAMETER  UNIT  MIN      MAX   ACLKR/X ext input  3.5  Delay time, ACLKR/X transmit edge to  13  td(ACLKRX-AFSRX)  AFSX/R output valid (1)  ACLKR/X ext output  3.5  ACLKR/X ext input  3.5  Delay time, ACLKX transmit edge to  14  td(ACLKX-AXRV)  ns  AXR output valid (1)  ACLKR/X ext output  3.5  Disable time, ACLKR/X transmit edge  15  t  to AXR high impedance following last  ACLKR/X ext  3.5  dis(ACLKX-AXRHZ)  data bit  (1)  McASP0 ACLKXCTL.ASYNC=1: Receiver is clocked by its own ACLKR0  14  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  SPRZ317G – August 2011 – Revised March 2014  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications Table 7. Timing Requirements for McBSP0  1.2V  NO.  PARAMETER  UNIT  MIN      MAX   Setup time, external FSR high before  5  t  CLKR ext  5.5  su(FRH-CKRL)  CLKR low  7  t  Setup time, DR valid before CLKR low  CLKR ext  5.5  ns  su(DRV-CKRL)  Setup time, external FSX high before  10  t  CLKR ext  5.5  su(FXH-CKXL)  CLKX low  Table 8. Switching Characteristics for McBSP0  1.2V  NO.  PARAMETER  UNIT  MIN      MAX   Delay time, CLKR high to internal FSR  4  t  CLKR ext  2.75  d(CKRH-FRV)  valid  Delay time, CLKX high to internal FSX  9  t  CLKR ext  2.75  ns  d(CKXH-FXV)  valid  2.75 + D1  13  t  Delay time, CLKX high to DX valid  CLKR ext  d(CKXH-DXV)  (1)  (1)  Extra delay from CLKX high to DX valid applies only to the first data bit of a device, if and only if DXENA = 1 in SPCR.  If DXENA = 0, then D1 = D2 = 0  If DXENA = 1, then D1 = 6P, D2 = 12P  Table 9. Switching Characteristics for McBSP1  1.2V  NO.  PARAMETER  UNIT  MIN      MAX   Delay time, CLKR high to internal FSR  4  t  CLKR ext  3.25  d(CKRH-FRV)  valid  Delay time, CLKX high to internal FSX  9  t  CLKR ext  3.25  ns  d(CKXH-FXV)  valid  3.25 + D1  13  t  Delay time, CLKX high to DX valid  CLKR ext  d(CKXH-DXV)  (1)  (1)  Extra delay from CLKX high to DX valid applies only to the first data bit of a device, if and only if DXENA = 1 in SPCR.  If DXENA = 0, then D1 = D2 = 0  If DXENA = 1, then D1 = 6P, D2 = 12P  	 	 	TI
  The desired value (even if it is the default value) should be written to the VSR prior to using the interrupt controller.  16  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  SPRZ317G – August 2011 – Revised March 2014  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications 	 2.3.10   ARM Interrupt Controller Vector Size Register (VSR) Initialization  	 	ARM9	 	  2.3 and earlier      	OMAP-L132	 	   The VSR register in the ARM Interrupt Controller (AINTC) is not correctly initialized after reset. If this register is not explicitly configured, the AINTC will only allocate 1 byte per interrupt (instead of 4).  	 	 	TI
"      Method 1   Do not execute the intended interrupt service routine code if the associated CHIPSIGn status flag is not set in the SYSCFG_CHIPSIG register. A cleared CHIPSIGn status flag indicates that the device is responding to a false interrupt. This method is easy to implement, but does not eliminate false interrupts.  /** Pseudo code only **/  void CHIPINT0_ISR(void) {  /* Exit immediately if CHIPSIG0 is not set */  if( (SYSCFG->CHIPSIG & 0x1) == 0 ) {  return;  }  /* Intended service routine code */  SYSCFG->CHIPSIG_CLR = 0x1;  printf(""Hello World!\n"");  }  SPRZ317G – August 2011 – Revised March 2014  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  17  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      Method 2   Do not clear the AINTC CHIPINTn status flag until the CHIPSIGn status has been cleared. This method will eliminate false interrupts, but requires changes to the AINTC  interrupt dispatch code. Changing the dispatch code may introduce undesired behavior in the application.  /** Pseudo code only **/  /* Sequence that is susceptible to false CHIPINTn interrupts */  void AINTC_ISR_DISPATCH_1(void) {  Get_Interrupt_Information();  /* CHIPINTn interrupts continue to be generated after */  /* AINTC CHIPINTn flag is cleared.  */  Clear_AINTC_Interrupt_Flag();  /* CHIPINTn interrupts are only stopped after ISR clears */  /* the status flag.  */  Branch_To_ISR();  }  /* Sequence that is not susceptible to false CHIPINTn interrupts */  void AINTC_ISR_DISPATCH_2(void) {  Get_Interrupt_Information();  /* ISR will clear CHIPSIGn flag and discontinue CHIPINTn */  /* interrupts to AINTC.  */  Branch_To_ISR();  /* Ok to clear AINTC CHIPINTn flag now.  */  Clear_AINTC_Interrupt_Flag();  }  18  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  SPRZ317G – August 2011 – Revised March 2014  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications "	 2.3.12  A Single CHIPINTn Interrupt Event Can Register Multiple Times in the AINTC  	 	ARM9	 	  2.3 and earlier      	OMAP-L132	 	   Interrupts destined for the ARM CPU are managed by the ARM Interrupt Controller (AINTC). The AINTC detects, combines, and routes system interrupts to the two native ARM interrupt signals FIQ and IRQ. See the device System Reference Guide for  additional information about the AINTC.  The AINTC module expects all incoming interrupts to be pulse interrupts, however the  [SYSCFG_CHIPSIG_]CHIPINTn interrupts are level interrupts. This mismatch in interrupt types will cause a single CHIPINTn interrupt event to register as multiple interrupt pulses in the AINTC. However, the AINTC does not have the capacity to count the number of interrupt pulses received per system interrupt – it only maintains interrupt flags. A system interrupt is flagged as active until its status is cleared by the user through the AINTC, regardless of the number of interrupts detected.  If the status flag for AINTC CHIPINTn is cleared while the CHIPINTn interrupt is still active, the AINTC will continue to detect CHIPINTn interrupts and its status flag will be set again. This additional setting of the AINTC CHIPINTn status flag is false.  	 	 	TI
  Perform one of the following:  •  For the location of code where saturation results are monitored, do not mix datatypes so that 2 cycle and 4 cycle .M unit instructions are not issued together.  •  Do not mix floating point .M unit instruction with fixed point 2 cycle .M unit instructions.  SPRZ317G – August 2011 – Revised March 2014  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  19  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      	 2.3.13  Incorrect Masking of the C674x CSR:SAT Bit  	 	ARM9	 	  2.3 and earlier      	OMAP-L132	 	   The C674x CPU supports a Saturation feature for key arithmetic operations. If an operation results in saturation, the SAT (saturation) bit in the control status register (CSR) is set. In normal operation, one or more functional units can simultaneously perform arithmetic operations that can result in saturation. In the case of simultaneous arithmetic operations, the SAT bit is set if at least one functional unit’s operation results in saturation. The saturation status register (SSR) provides saturation flags for each functional unit, making it possible for the program to distinguish between saturations caused by different instructions in the same execute packet. Also, there is no direct connection to the SAT bit in the control status register (CSR); writes to the SAT bit have no effect on SSR and writes to SSR have no effect on the SAT bit.  In the case where a 2 cycle .M unit instruction is in the delay slot of a 4 cycle instruction of the same .M unit, and if both instructions are expected to generate results in the same cycle, the CSR:SAT bit will be incorrectly masked. Ideally, the CSR:SAT bit should be set if any one of the two .M unit instruction causes a saturation. Instead, the arithmetic saturation result of the 2 cycle .M unit instruction will overwrite the CSR:SAT bit.  All of the following must take place in order for an application to be affected by this advisory:  1. A 2 cycle .M unit instruction and a 4 cycle .M unit instruction are issued  simultaneously  2. Both instructions are processed on the same side  3. The 2 cycle instruction is in the delay slot of the 4 cycle instruction so that the results of both instructions are generated in the same cycle  4. The saturation result of the 4 cycle .M unit instruction is different from the saturation result of the 2 cycle .M unit instruction  5. The application checks for the saturation flag and uses the saturation result of the 4  cycle instruction  	 	 	TI
  Method 1: Do not perform two CPU read operations in the same clock cycle. For C  code, use compiler flag (--c64p_dma_l1d_workaround) available in the C6000  Compiler (CodeGen) Tools version 7.0.2 and later. For assembly code, the --  c64p_dma_l1d_workaround flag will only issue a warning.  Method 2: In cases where buffer access will not be shared between CPU and SDMA, unintended CPU/SDMA cache-line sharing can be avoided by aligning CPU and SDMA buffers to 64-byte boundaries. Aligning buffers to 64-byte boundaries will result in wasted space, however it ensures that the CPU and SDMA buffers will not have partial  segments which overlap into the same L1D cache line.  /** Pseudo code only **/  Uint8 *SDMA_BUFF, *CPU_BUFF;  /* 64-byte aligned allocation Option 1 */  SDMA_BUFF = malloc( (Int32) (( SDMA_BUFF_SIZE + 63)/64) * 64 );  CPU_BUFF = malloc( (Int32) ((CPU_BUFF_SIZE + 63)/64) * 64 );  SDMA_BUFF = (Uint8 *) ( (Int32) SDMA_BUFF & ~63 );  CPU_BUFF = (Uint8 *) ( (Int32) CPU_BUFF & ~63 );  /* 64-byte aligned allocation Option 2 with BIOS Call */  SDMA_BUFF = MEM_alloc( IRAM, SDMA_BUFF_SIZE, 64 );  CPU_BUFF = MEM_alloc( IRAM, CPU_BUFF_SIZE, 64 );  SPRZ317G – August 2011 – Revised March 2014  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  21  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  Method 3 Manage access to a 64-byte boundary aligned buffer that is shared between CPU and SDMA by implementing a semaphore and forcing cache writeback operations if there are CPU writes. With this method, the semaphore ensures that there is clear ownership of the buffer between CPU and SDMA, and the CPU manages cache  coherence by using explicit cache writeback operations.  /** Pseudo code only **/  /* Example with EDMA as the external master */  EDMA_ISR() {  /* EDMA releases ownership of buffer */  SEM_post(SyncSemaphore);  return;  }  main() {  while(COND) {  /* CPU waits for ownership of buffer */  SEM_pend(SyncSemaphore);  /**********************/  /*** CPU Processing ***/  /**********************/  /* Cache writeback for shared block */  /* Buffer must be 64-byte aligned */  BCACHE_wbInv( blockPtr, blockSize, WAIT );  /* Initiate EDMA */  EDMA_Event_Generate();  }  }  Method 4 Do not allow SDMA to access L2 RAM. SDMA can use buffers in L1D RAM  instead of L2 RAM.  Method 5 Configure the entire L2 RAM as cache. Critical peripheral data can be accessed in L1D RAM instead of L2 RAM.  Method 6 Configure the entire L2 RAM as normal SRAM (no cache).  Method 7 Configure the entire L1D RAM as normal SRAM (no cache).  22  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  SPRZ317G – August 2011 – Revised March 2014  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications 	 2.3.17   SDMA Activity Can Corrupt L1D When L2 Is Configured as Mixed/Cache/SRAM  	 	ARM9	 	  2.3 and earlier      	OMAP-L132	 	   Note: SDMA refers to all non-CPU requests to the EMC SDMA (Slave Direct Memory Access) port (see Figure 4). SDMA requests are defined as external system bus master requests handled via this port.  The C674x Megamodule uses a two-way set associative cache for L1D. This means that every physical memory location in the system has two possible set/way locations in the cache where it can reside. See TMS320C674x DSP Megamodule Reference Guide  (Literature Number SPRUFK5) for more information on the L1D cache architecture and related terminology. Updated (dirty) values in L1D cache are not written back to external memory until cache activity evicts a cache-line (victim write-back) or a write-back is requested by software.  An L1D cache-line corruption event occurs when all of the conditions in the following steps are met (see Figure 4):  1. L1D cache Lines 1, 2, and 3 have the following characteristics:  •  Line 1 is associated with L2 SRAM (Line A in Figure 4), was previously read by CPU, and is clean. (CPU has not updated the data.)  •  Line 2 is associated with L2 SRAM (Line B in Figure 4), was previously read by CPU, and is clean. (CPU has not updated the data.)  •  Line 3 was previously read by the CPU and may be either clean or dirty.  2. SDMA receives updated data for L2 SRAM Lines A and B, which correspond to L1D  cache Lines 1 and 2.  3. A snoop write operation is initiated by the L2 to overwrite the L1D cache Lines 1 and 2 with updated L2 SRAM Lines A and B. Before the snoop write operation finishes, the CPU performs two reads within the same clock cycle:  •  Line E in L2 cache is read as a cache hit. Line E is destined to replace Line 2 in L1D Cache, which also has a snoop write pending for the updated Line B  content.  •  Line D in L2 SRAM is read. Line D will replace Line 3 in L1D cache.  4. When the snoop write operation completes, Line 2 in L1D cache now contains the updated L2 SRAM Line B data instead of the L2 cache Line E data.  The correct behavior would have been to kill the pending snoop write initiated to update L1D cache Line 2 with the updated L2 SRAM Line B data in Step 3. The L1D cache should have evicted Line B and replaced it with Line E data. Instead, the snoop write operation continues and does not complete until after the L1D cache Line 2 has already been replaced with L2 cache Line E data. The snoop write instruction overwrites the L1D  cache Line 2 (containing L2 cache Line E data) with the updated L2 SRAM Line B data.  20  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  SPRZ317G – August 2011 – Revised March 2014  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications Time Line  System View      Line A   Line E and Line B Map to  STEP 1  STEP 2  STEP 3  STEP 4  same L1D Cache line.  Line A  Line B  C674x subsystem  Line A  Line C  C6xCPU  Read Line D  L2  Line A  Line D  Activity  Read Line E  C6X CPU  Controller  L2 SRAM  SDMA  Write Line A Snoop Write  Line A  Line E  Activity  Write Line B  Initiated  L1D  EMC  L2 CACHE      L1D Cache   Clean Line A Clean Line A  IN FLUX  Clean Line A  Controller  SDMA PORT      Line 1   (New Data)      L1D Cache   Clean Line B Clean Line B  IN FLUX  CORRUPT  EMAC      Line 2   Line E replaces Line B due      Line A   Line 1 [A]  PRU      L1D Cache   Clean/Dirty  Clean/Dirty  IN FLUX  Clean Line D  to CPU read.  Line 3  Line C  Line C  SYSTEM MASTERS      Line A   Line 2 [B/E] Delayed snoop wrtie to Line  EDMA      Line A   Line 3 [C/D] B corrupts Line E in L1D$  L1D  Corruption happens  CACHE  EXTERNAL      because of this state   Figure 4. Example of L1D Cache Corruption  	 	 	TI
  1. Design simulation has indicated that under the worst-case  process/voltage/temperature conditions the maximum leakage current into the  DVDD18 supply due to this phenomenon will be 140 mA (the 140 mA is a cumulative current generated by all of the dual-voltage IOs). So this error state can be prevented by ensuring that the load on the DVDD18 supply during the DVDD13318_x supply  ramp exceeds 140 mA. This can be achieved by any combination of the following as long as they cumulatively produce >140 mA load on DVDD18 during the  DVDD3318_x ramp period:  (a) Maintain sufficient bulk capacitance on the DVDD18 supply such that the charging current for these capacitors provides all or part of the required >140 mA. Bulk capacitance in this context means the total capacitance seen by the DVDD18  supply (filter capacitors, bypass capacitors, etc.). Capacitor charging current is defined as I = C*(dV/dt). So the ramp rate of the DVDD3318_x supply and the  total bulk capacitance on the DVDD18 supply can be used to calculate the current produced. This solution provides additional power supply filtering and little current leakage after the supplies are ramped (depending on the type of capacitors used).  The table below shows some examples of the bulk capacitance that would be  required to use this solution alone:  Table 10. Bulk Capacitance      DVDD3318_x ramp   dV/dt (in V per second)  Required capacitance to generate 140 mA      time for 3.3V   100 µs  33000  4.2 µF  250 µs  13200  10.6 µF  500 µs  6600  21.2 µF  1 ms  3300  42.4 µF  10 ms  330  424.2 µF  (b) Use an additional shunt regulator to control the voltage at DVDD18. The shunt regulator is placed between DVDD18 and Vss. As an example, the TLVH431 can  provide up to 70 mA of additional load current to help maintain the DVDD18  voltage. When the voltage drops back to the normal 1.8V range, the current flow through the shunt regulator drops into the <100 uA range. This solution requires the shunt regulator and two additional resistors to set the desired regulation voltage.  (c) Use a resistor to provide additional load between DVDD18 and Vss. This solution is less desirable since it continues to draw power even after the supply ramp is completed but would likely be the lowest cost. An improvement is to use a  FET/switch in series with the resistor between DVDD18 and Vss that can later be turned off (by the RESET signal or a GPIO signal for example).  SPRZ317G – August 2011 – Revised March 2014  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  25  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  2.  Choose a regulator for the DVDD18 supply (or grouped 1.8V supplies) that is  capable of actively regulating voltage up and down. Many high-efficiency switching regulators switch current into the load only when the voltage needs to be raised and rely on the load to pulldown the current. In this error condition, a regulator of this type will not be able to compensate for the leakage current described above.  Synchronous buck regulators use external inductance to pulldown the regulated  voltage when necessary.  26  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  SPRZ317G – August 2011 – Revised March 2014  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications 	 2.3.18  DVDD18 Can Pull Up to 2.7V When Using Dual-Voltage IOs at 3.3V  	 	ARM9	 	  2.3 and earlier      	OMAP-L132	 	   A condition can occur during the device power supply ramp in which the DVDD18  supply, which should be at 1.8V nominal, can be pulled up on-chip by the DVDD3318_A, DVDD3318_B or DVDD3318_C supplies operated at 3.3V. For the sake of this  description, DVDD3318_x means any combination of DVDD3318_A, DVDD3318_B or  DVDD3318_C.  Important Note: The 3.3V DVDD3318_x supplies must not be driven to 0V during zones A – E or high current capable of damaging the device may occur. The 3.3V  DVDD3318_x supplies should not be driven during this time.  A normal example power-supply ramp is shown below:  A  B  C  D  E  F  G  3.3V  VT  1.8V      1.2V   Figure 5. Normal power-supply ramp  •  A. All device supplies are undriven  •  B. The 1.2V supplies are ramped to their nominal levels  •  C. Potential delay between supply ramps (not required)  •  D. The 1.8V supplies (specifically DVDD18) are ramped to their nominal levels.  During the DVDD18 ramp there will be some minor drift up in the undriven  DVDD3318_x supplies. This is normal and is not a problem.  •  E. Potential delay between supply ramps (not required)  •  F. DVDD3318_x is ramping but is less than DVDD18 + VT  •  G. DVDD3318_x is ramping but is greater than DVDD18 + VT  When the fault condition occurs, the supplies behave as shown below:  A  B  C  D  E  F  G      3.3V   ~2.7V  VT      1.2V   Figure 6. Faulty power-supply ramp  The behavior is the same until zone G. When the DVDD3318_x supply exceeds  DVDD18 by a transistor V , the DVDD18 supply begins to be pulled up by the  T  DVDD3318_x supply and follows the DVDD3318_x supply by DVDD3318_x- V . Since  T  the DVDD18 supply is often connected to other 1.8V supplies in the design, these other supplies can be pulled up also.  SPRZ317G – August 2011 – Revised March 2014  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  23  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  The condition occurs because the dual-voltage IO buffers have voltage detection circuitry that monitors DVDD3318_x during reset and determines whether the applied supply voltage is 1.8V or 3.3V. This detection circuitry then configures the IOs to operate at the appropriate voltage. As the DVDD3318_x supply ramps, there is a small range near DVDD18 + V where the voltage detection circuit finds the state indeterminate and briefly T  turns on circuitry associated with both voltage options creating a current path between them. This current path can cause the DVDD18 supply to be pulled up. The mechanism for this behavior is explained below:      DVDD3318_x   Dual-Voltage IO Buffer   Behavior of the IO buffer during Zone F:  As the DVDD3318_x supply ramps, but is not yet one V above the      T   DVDD18 supply, the comparator enables the 1.8V mode logic      3.3V Mode   section and disables the 3.3V mode logic section. No unexpected  Enable      Logic   +  current flows between the two sections.      DVDD18   -   1.8V Mode  Enable  Logic  Iload  External      Loads   Figure 7. Behavior of the IO buffer during Zone F      DVDD3318_x   Dual-Voltage IO Buffer   Error State of the IO buffer during Zone G:  As DVDD3318_x exceeds DVDD18+V , some of the circuitry      T   across the boundary of the two voltage domains will turn on and  3.3V Mode  DVDD18      Enable   causes a leakage current (in red) to flow between the two voltage      Logic   +  domains. This current pulls up the DVDD18 supply unless the      Ileakage   power source providing that supply can oppose it or unless the  -  load current is strong enough to counteract it.  Enable 1.8V Mode      Logic   If DVDD18 continues to rise as DVDD3318_x ramps, the      I   comparator never sees enough difference between the two      load   supplies to switch to 3.3V mode.  External      Loads   Figure 8. Error State of the IO buffer during Zone G      DVDD3318_x   Dual-Voltage IO Buffer   Recovered State of the IO buffer during Zone G:  If the load current is high enough or the DVDD18 power supply can  oppose the leakage current, then the DVDD18 voltage stays low      3.3V Mode   enough for:   Enable      Logic   +      DVDD18   • the comparator to recognize 3.3V mode  • the 1.8V mode logic is turned off  -      1.8V Mode   • the leakage stops  Enable  Logic  Iload  External      Loads   Figure 9. Recovered State of the IO buffer during Zone G  24  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  SPRZ317G – August 2011 – Revised March 2014  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications This error condition may occur when either of the following conditions are present:  •  The regulator used to control the DVDD18 supply can only regulate voltage up and relies on the load to pull the output voltage down  •  There is low load on the DVDD18 supply during the DVDD3318_x power supply  ramp  This condition will not occur in designs where:  •  All DVDD3318_x supplies are operated at 1.8V, or  •  The regulator used to supply DVDD18 has the capability to actively regulate (drive) its output voltage up or down and doesn’t rely on system load to pull the voltage down, or  •  The load on the DVDD18 supply during the DVDD3318_x power supply ramp is  sufficient to oppose the leakage current.  	 	 	TI
  None  SPRZ317G – August 2011 – Revised March 2014  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  27  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      	 2.3.19  USB 2.0 On-The-Go (OTG) Session Request Protocol (SRP) Is Not Supported  	 	ARM9	 	  2.3 and earlier      	OMAP-L132	 	   The USB 2.0 On-The-Go (OTG) Session Request Protocol (SRP) allows a USB-  peripheral to request the USB-host to enable Vbus and start a session. On this device, the SRP protocol is not supported.  The OTG Host Negotiation Protocol (HNP), which allows USB-devices to swap roles between host and peripheral, is supported.  	 	 	TI
:  The following Workaround must be implemented to ensure that the boot pins are always latched correctly:  Use strong external pull resistors on BOOT[7:0] pins. Since either the internal pullup or pulldown resistors could be enabled after every power-on, the external resistors must be strong enough to oppose the internal pulls in either case.  Section 4, Device Operating Conditions, of the device datasheet shows the electrical characteristics information which can be used to calculate the maximum external pull resistance required. The value is dependent on the DVDD3318_C I/O supply level.  For BOOT pins which need to be sampled as logical low, the external pulldown  resistance (R  ) must be selected by assuming the internal pullup is enabled. The  PDmax  calculation is shown in Table 11.  28  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  SPRZ317G – August 2011 – Revised March 2014  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications Table 11. Required Pulldown Resistance (R  ) for Logical Low BOOT Pins      PDmax   æ V ö  IL  ç  ÷  DVDD3318_C  I  V  I      IL   è I      R   I ø      PDmax   3.3 V  310 µA  0.80 V  2.58 kΩ  1.8 V  310 µA  0.80 V  2.03 kΩ  For BOOT pins which need to be sampled as logical high, the external pullup resistance (R  ) must be selected by assuming the internal pulldown is enabled. The calculation PUmax  is shown in Table 2.  Table 12. Required Pullup Resistance (R  ) for Logical High BOOT Pins      PUmax   æ DVDD 3318 _ C - V  ö  IH  ç  ÷  DVDD3318_C  I  V  I      IH   I   è  I  ø      RPUmax   3.3 V  270 µA  2.00 V  4.81 kΩ  1.8 V  270 µA  1.17 V  2.33 kΩ  SPRZ317G – August 2011 – Revised March 2014  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  29  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      	 2.3.23   BOOT: Internal Pullup Resistors for BOOT[7:0] Pins Are Sometimes Enabled  During Reset, Leading to Boot Failures  	 	ARM9	 	  2.3 and earlier  	OMAP-L132	 	:  The PUPD_SEL[29] register does not get initialized when the device is first powered on and in Reset. This register controls the internal pullup and pulldown resistors for the BOOT[7:0] pins. The contents of the PUPD_SEL[29] register at this state are  unpredictable and may contain random values. These random values can result in the internal pullups being enabled for some or all of the BOOT[7:0] pins during reset after every power-on, which conflicts with the datasheet claim that the internal pulldowns are enabled during reset.  Internal pullups being enabled on the BOOT[7:0] pins may result in boot failures. If weak external pulldown resistors are used on the PCB to select the boot mode, they may not be able to overpower the internal pullups. This can result in the wrong boot mode being latched in the BOOTCFG[7:0] register when coming out of Reset.  Once the device is out of Reset, the PUPD_SEL[29] register is initialized, and the internal pulldown resistors for the BOOT[7:0] pins are all enabled. Issuing a second Power-On Reset (POR) results in the intended boot mode being latched, since the pins are internally pulled down as expected.  Figure 10 shows the behavior of the PUPD_SEL[29] register before and after reset.  Assuming weak or no external pull resistors are on the BOOT[7:0] pins, the BOOTCFG  register will latch the unknown values after the device initially comes out of Reset. Note that, TRST must always be low in order to issue a POR and latch the boot pin values --  the boot pins are not latched after a Warm Reset.  RESET  TRST  PUPD_SEL[29] Register  0h  BOOTCFG[7:0] Registers  Figure 10. Initialization of PUPD_SEL[29] and BOOTCFG[7:0] Registers with Weak or No External Pull Resistors on BOOT[7:0] Pins  Other device pins with configurable internal pullup or pulldown resistors are always internally pulled down during reset and are not affected by this advisory.  	 	 	TI
":  The workaround ignores errors in ECC data (these errors do not need to be corrected) so that the boot process can continue, correcting errors in the user data (up to 4 bit errors total), as necessary. The workaround also includes a mechanism to restart the NAND read process from the next good block if an uncorrectable error (more than 4 bit errors) is detected on any page of a good block.  This workaround is implemented using a software patch that is loaded in device RAM at boot time and is designed to change the default behavior of the ECC Correct and Read functions in the RBL. The patch binary replaces function pointers to the ECC Correct and Read functions in the ROM function table, (defined in device internal memory), during boot. The patch binary will reside in page0 of the NAND block and so will be applied only after the page0 of a good block has been read.  Once the patch is read, all subsequent page reads in the block will use the new ECC  Correct and Read functions. ECC data errors on any page (other than page0) are ignored, any user data error (up to 4 bit errors total) is corrected and the boot process continues. If an uncorrectable error is detected on any page, the block is skipped and the boot process is restarted on the next good block. The behavior of the device boot from the NAND after application of the patch is shown in Figure 12.  SPRZ317G – August 2011 – Revised March 2014  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  31  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated    Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  (1)  All pages marked in green are good and all pages marked in red have ""uncorrectable"" errors.  Figure 12. D800K008 ROM Behavior With Software Patch Applied(1)  The software patch is available as a pre-built file with the latest version of the AIS tool that is used to generate the NAND flash boot image. The Using the OMAP-L132/L138  Bootloader Application Report (Literature number: SPRAB41) provides a link to the install package for the AIS tool which includes the following in the install directory: prebuilt patch files, the GUI AIS generation tool (AISGEN.exe, version 1.11 or later), command-line AIS generation tool and an example INI file.  Application of the Software Patch to NAND Boot Images:  •  For the GUI tool, AISGEN.exe version 1.11 or later (found in the install directory), the patch integrates the modified ECC Correct function into the user application file to generate one binary AIS file.  •  For the Command line AIS tool, HEXAIS_OMAP_L138.exe users (found in the install directory), the patch can be integrated into the user application file to generate one binary AIS file by inserting lines below to the end of the INI configuration file.  The patch name is: ARM_nand_ecc_patch_OMAP-L138.out  32  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  SPRZ317G – August 2011 – Revised March 2014  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications  [INPUTFILE] ; get the NAND ECC patch file  FILENAME=Patch_name.out  ; patch the NAND ECC handling routine  [AIS_Jump]  LOCATION=_NAND_ECC_patchApply  •  The patch will be burnt on page0, as it is in the head of AIS file. Once page0 has been read successfully, the AIS set command will overwrite the function pointer in the RBL with the modified function pointer and the modified function will be applied to the later pages read. Memory usage of the patch at boot time is as follows:  –  500 bytes at location 0xFFFF 0B00  Recommendations to Improve Robustness:  •  Page0 should be stored on multiple blocks as backup to take advantage of the safety mechanism built into Silicon Revision 2.1 to cycle to the next block when a page0  read fails in a good block.  •  Maintain backup boot images in multiple blocks. The patch to the Abort function reinitializes the boot process and forces the boot to cycle to the next good block and restart the boot process by reading from it.  •  Silicon Revision 2.1 supports booting from Block 0 of the flash which many NAND  manufacturers guarantee as a “more reliable” block than all other blocks. Hence, setting up boot to start from that Block 0 could help improve the reliability of boot.  This is a hardware change, requiring the bootmode pins BOOT[6:5] = 1x.  For more details on the bootmode pins, see the Using the OMAP-L132/L138  Bootloader Application Report (Literature number: SPRAB41), NAND-Boot Modes.  SPRZ317G – August 2011 – Revised March 2014  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  33  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      "	 2.3.24   Boot: ECC Data Error in Spare Area Causes NAND Boot Failure  	 	ARM9	 	  2.3 and 2.1 (ROM Versions D800K008)  	OMAP-L132	 	":  The ROM bootloader (RBL) reads a NAND page in segments of 512 bytes (user data) over the External Memory Interface A (EMIFA). The EMIF also reads the associated ECC data which is stored in the spare area of the flash (as shown in Figure 11). The ECC Correct function in the RBL can correct up to 4 bit errors in the user data and/or ECC data by using the syndrome generated from the ECC data and the parity of the user data calculated by the EMIFA module.  However, over the life span of the NAND flash, ECC data stored in the spare area can develop errors due to bit flips. When the calculated syndrome indicates an error in the ECC data, the ECC Correct and Read functions of the RBL abort the read process even though, it is possible to correct up to 4 bit errors combined in user and ECC data.  Consequently the device fails to boot.  Explanation of Current ROM Bootloader Behavior:  The RBL implements a search mechanism to look for the boot image in NAND flash by using an Open function and a Read function. The Open function includes a bad block check where the RBL skips to the next block (shown as (A) in Figure 11) if the block under consideration is marked as ""bad"" (in the spare area). On finding a good block, the RBL attempts to read page0 (the first page) in that block.  If page0 of the good block has an ECC data error or an uncorrectable error (more than 4  bit errors combined), the RBL skips to the next block (shown as (B) in Figure 11). This bad block check mechanism enables the device to check up to the first 32 blocks in the NAND flash for booting (the boot process will fail if all 32 blocks have uncorrectable or ECC data errors in page0). Note that the RBL does not abort on detecting an error in ECC data on page0.  Once the RBL finds a good block with a good page0, it continues to read subsequent pages in that block. If an uncorrectable or ECC error is detected in subsequent pages, the RBL will abort with a boot error (shown as (C) in Figure 11). The workaround, described below, enables the boot process to continue for both types of errors (ECC  data and uncorrectable errors).  30  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  SPRZ317G – August 2011 – Revised March 2014  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated    www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications (1)  All pages marked in green are good and all pages marked in red have ""uncorrectable"" errors.  Figure 11. D800K008 ROM Behavior Before Application of Software Patch(1)  "	 	 	TI
  Initialize the datalength descriptor field to zero. CPPI DMA updates this field after the completion of an RX DMA operation with the actual number of bytes received. In the ISR  (actually in a deferred call context), poll this field until it becomes a non-zero value to ensure data buffer has been updated with actual data. The descriptor buffer write is posted after the data buffer write, so waiting for the descriptor field to be updated ensures the data buffer has been updated. Since this workaround involves deferred procedure calls (whose schedule can be delayed depending on OS load), the latency sensitive application (like ISO Audio) might be affected by delay in notification to the application.  34  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  SPRZ317G – August 2011 – Revised March 2014  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications 	 2.3.25   USB0: CPU gets Stale Receive Data from the Data Buffer located in External      Memory   	 	ARM9	 	  2.3 and earlier      	OMAP-L132	 	   When CPPI DMA completes a receive data transaction it posts a write to the Rx data buffer located in external memory, posts a write to update the descriptor located in external memory, and raises an interrupt to CPU. When the system load is high, the posted writes to DDR may not be complete before the CPU receives the interrupt. In this case, the CPU would fetch stale receive data from the Rx data buffer located in external memory.  	 	 	TI
  The workaround involves monitoring transfer data size before and after transferring and reconfiguring data transfer size by software if the before and after size is different.  Software must keep tracking every endpoint data transferring size. When DMA  completion interrupt is received, software checks size difference. If the size is not equal, software requests the remaining data.  SPRZ317G – August 2011 – Revised March 2014  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  35  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      	 2.3.26  USB0: Early DMA Completion in DMA Receive Mode and More Than One Endpoint      is Transferring Data   	 	ARM9	 	  2.3 and earlier      	OMAP-L132	 	   The erroneous short packet status can be detected on current endpoint and XDMA closes the Rx transfer in current endpoint. When more than one endpoint have been processed, if one of the endpoints has a short packet, then the short packet status is broadcasting to all endpoints.  This results in premature completion of a Rx descriptor in generic RNDIS CPPI DMA mode.  	 	 	TI
  Software should make sure that DMA does not get to an unknown state during teardown by disabling the DMAEN bit in the RXCSR register. After this the teardown procedure can be initiated. Software should also add 250 ms delay during teardown.  36  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  SPRZ317G – August 2011 – Revised March 2014  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.1 Usage Notes and Known Design Exceptions to Functional Specifications 3  Silicon Revision 2.1 Usage Notes and Known Design Exceptions to Functional      Specifications   This section describes the usage notes and advisories that apply to silicon revision 2.1 and earlier of the device.      3.1   Usage Notes for Silicon Revision 2.1  Usage notes highlight and describe particular situations where the device's behavior may not match presumed or documented behavior. This may include behaviors that affect device performance or functional correctness. These usage notes will be incorporated into future documentation updates for the device (such as the device-specific data sheet), and the behaviors they describe will not be altered in future silicon revisions.  Silicon revision 2.0 applicable usage notes have been found on a later silicon revision. For more details, see Section 2.2, Silicon Revision 2.3 Known Design Exceptions to Functional Specifications.      3.2   Silicon Revision 2.1 Known Design Exceptions to Functional Specifications  The advisories are not enumerated in sequential order and hence some numbers may not appear in the document  Table 13. Silicon Revision 2.1 Advisory List  Title ................................      Page   	 2.3.27   USB0: DMA Hung up in Frequent Teardowns  	 	ARM9	 	  2.3 and earlier      	OMAP-L132	 	   Teardown receive DMA is not working perfectly. This happens when a teardown is initiated by software during the endpoint is still active. Frequent teardown results in XDMA hung up situation.  	 	 	TI
  When a break in transmission is detected, USB0 traffic can be recovered by a software reset of the USB0 PHY. A PHY reset implies recalibration of the PHY PLL at the reset temperature. The system has not been observed to reliably recover on its own. A PHY  reset also implies re-enumeration of all devices. There is no way to recalibrate the USB0  PHY without a re-enumeration.  In order to invoke the recovery mechanism (that is a USB0 PHY reset) one needs to determine when the issue is present. One such approach is to look for an absence of USB0 Core interrupts over a specified time window. This window should be optimized for the expected USB traffic based upon the application.  As an additional safeguard, an application can also intentionally schedule pre-determined USB PHY resets at specific temperature points if operation over a broad range is expected.  Here is an example of one way to power cycle the USB0 PHY via the Chip Configuration 2 Register in the System Configuration (SYSCFG) Module:  #define CFGCHIP2  *((volatile unsigned int *) 0x01C14184)  #define USBPHY_PHYPDWN 0x00000200  Void phy_reset(void) {  CFGCHIP2 |= USBPHY_PHYPDWN;  /* Power down the USB PHY */  mdelay(1);  /* Wait 500ms */  CFGCHIP2 &= ~USBPHY_PHYPDWN;  /* Power up the USB PHY */  }  SPRZ317G – August 2011 – Revised March 2014  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  39  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated      	 2.1.21   USB0 PLL Mean Frequency Can Drift Across Large Temperature Swings  	 	ARM9	 	  2.1      	OMAP-L132	 	   Under conditions in which the device is subjected to large variations in operating temperatures, the USB0 PLL temperature compensation circuitry does not have enough margin to guarantee compensation for PLL drift across all temperature ranges.  As a result, the mean frequency generated by the USB0 (USB 2.0 OTG) PHY PLL will begin to drift (relative to the expected 480 Mbps) when the temperature of the device is subjected to large swing from the original temperature in which the USB0 PHY was most recently calibrated (initialized).  Once the onset of PLL drift occurs, the mean frequency will continue to drift outside the expected frequency and will eventually cause the PLL to lose lock resulting in failure of USB packet reception and/or transmission. This break in transmission will continue until the USB0 PHY is recalibrated during a USB0 PHY Reset.  If the device is not exposed to large variations in temperature relative to the temperature at which the USB0 PHY was most recently initialized, the temperature compensation circuitry is expected to provide the proper compensation to prevent the mean PLL  frequency from losing lock and beginning to drift.  More specifically, this advisory is most applicable in applications where the device is expected to operate outside the commercial temperature range of 0˚C to 90˚C. TI has identified a point-to-point device temperature range in which there is a very high confidence the compensation circuitry will properly compensate for all temperature variations, provided the USB0 PHY was most recently initialized (calibrated) within this same temperature range.  Operating outside the 0˚C-65˚C temperature range increases the susceptibility of the device to experience PLL drift, but does not mean that the application will always experience a failure in USB transmission.      Root Cause   The Voltage Controlled Oscillator (VCO) Compensation circuitry local to the USB0 PHY  was not designed with a large enough range to compensate for all variations in temperature across the specified operating range of the device.  How to Most Easily Reproduce the Issue: Reproduction of this issue can most easily be accomplished by the following steps:  1. Allowing the unit to soak in an ambient temperature of -35˚C until the device temperature reaches approximately the same temperature.  2. Power up the device and provide the necessarily software programming in order to invoke the USB Signal Quality Test Pattern.  3. Using a USB 2.0 Certified Test Platform, execute the USB signal quality test procedure across the following temperature set points. -35˚C, 0˚C, +35˚C, +70˚C.  Record the measured mean frequency by the compliance software.  NOTE:  The set points can be varied to obtain finer temperature resolution of  when the PLL begins to drift a per platform basis. The above temperature  profile is provided for reference.  38  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  SPRZ317G – August 2011 – Revised March 2014  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.1 Usage Notes and Known Design Exceptions to Functional Specifications 	 	 	TI
