(lp0
(dp1
S'Errata ID'
p2
S''
p3
sS'Workaround'
p4
S' In a system that does not use Thumb state, there will be no problem. In a system that uses Thumb state but does not use data aborts, or does not try to use data aborts in a recoverable manner, there will be no problem. Otherwise the workaround is to ensure that a STR, STMIA or PUSH cannot precede a PC-relative load. One method for this is to add a NOP before any PC-relative load instruction. However this is would have to be done manually. ES_LPC2102 . \xc2\xa9   Rev. 2 \xe2\x80\x94 1 March 2011 4 of 13  ES_LPC2102  LPC2102 '
p5
sS'Fix Status'
p6
g3
sS'Masks Affected'
p7
g3
sS'Details'
p8
S' If the processor is in Thumb state and executing the code sequence STR, STMIA or PUSH followed by a PC relative load, and the STR, STMIA or PUSH is aborted, the PC is saved to the abort link register.  In this situation the PC is saved to the abort link register in word resolution, instead of half-word resolution. Conditions: The processor must be in Thumb state, and the following sequence must occur: <any instruction> <STR, STMIA, PUSH> <---- data abort on this instruction LDR rn, [pc,#offset] In this case the PC is saved to the link register R14_abt in only word resolution, not half-word resolution. The effect is that the link register holds an address that could be #2 less than it should be, so any abort handler could return to one instruction earlier than intended. '
p9
sS'Core'
p10
S'ARM7'
p11
sS'Criticality'
p12
g3
sS'Chip'
p13
S'LPC2102'
p14
sS'Revisions Impacted'
p15
g3
sS'Module'
p16
g3
sS'Failure'
p17
S'3.1 Core.1: Incorrect update of the Abort Link register in Thumb state '
p18
sS'Manufacturer'
p19
S'NXP'
p20
sa(dp21
g2
g3
sg4
S' User code should enable the MAM after Reset and before any RAM accesses; this means MAMTIM and MAMCR should be set as follows: MAMTIM: For CPU clock frequencies slower than 20 MHz, set MAMTIM to 0x01. For CPU clock frequencies between 20 MHz and 40 MHz, set MAMTIM to 0x02, and for values above 40 MHz set MAMTIM to 0x03. MAMCR: Set MAMCR to 0x02 (MAM functions fully enabled) MAMTIM should be written before MAMCR. '
p22
sg6
g3
sg7
g3
sg8
S' The Memory Accelerator Module (MAM) provides accelerated execution from the on-chip flash at higher frequencies.  If code is running from on-chip Flash, a write to an SRAM location followed by an immediate read from the same SRAM location corrupts the data been read. For instance, a stack push operation immediately followed by a stack pop operation. '
p23
sg10
g11
sg12
g3
sg13
g14
sg15
g3
sg16
g3
sg17
S'3.2 MAM.1: Incorrect read of data from SRAM after Reset and MAM is not enabled or partially enabled '
p24
sg19
g20
sa(dp25
g2
g3
sg4
S' If the above problem is encountered then Mode 2 should not be used. Instead, partially enable the MAM using Mode 1. ES_LPC2102 . \xc2\xa9   Rev. 2 \xe2\x80\x94 1 March 2011 5 of 13  ES_LPC2102  LPC2102 '
p26
sg6
g3
sg7
g3
sg8
S' The MAM block maximizes the performance of the ARM processor when it is running code in Flash memory. It includes three 128-bit buffers called the Prefetch Buffer, the Branch Trail Buffer and the data buffer. It can operate in 3 modes; Mode 0 (MAM off), Mode 1 (MAM partially enabled) and Mode 2 (MAM fully enabled).  Under certain conditions when the MAM is fully enabled (Mode 2) code execution from internal Flash can fail. The conditions under which the problem can occur is dependent on the code itself along with its positioning within the Flash memory. '
p27
sg10
g11
sg12
g3
sg13
g14
sg15
g3
sg16
g3
sg17
S'3.3 MAM.2: Under certain conditions in MAM Mode 2 code execution out of internal Flash can fail '
p28
sg19
g20
sa(dp29
g2
g3
sg4
S' There are two possible workarounds: 1. Use CPHA=1. 2. If the data is shifted incorrectly when CPHA is set to 0 then delaying the write to SPDR after the half SCK cycle of the last sampling clock would resolve this issue. ES_LPC2102 . \xc2\xa9   Rev. 2 \xe2\x80\x94 1 March 2011 6 of 13  ES_LPC2102  LPC2102 '
p30
sg6
g3
sg7
g3
sg8
S' In slave mode, the SPI can set the clock phase (CPHA) to 0 or 1.  Consider the following conditions: 1. SPI is configured as a slave (with CPHA=0). 2. SPI is running at a low frequency. In slave mode, the SPIF (SPI Transfer Complete Flag) bit is set on the last sampling edge of SCK. If CPHA is set to 0 then the last sampling edge of SCK would be the rising edge. Under the above conditions, if the SPI Data Register (SPDR) is written to less than a half SCLK cycle after the SPIF bit is set (this would happen if the SPI frequency is low) then the SPDR will shift data one clock early for the upcoming transfers. Lowering the SPI frequency would increase the likelihood of the SPDR write happening in the first half SCK cycle of the last sampling clock. '
p31
sg10
g11
sg12
g3
sg13
g14
sg15
g3
sg16
g3
sg17
S'3.4 SPI.1: Incorrect shifting of data in slave mode at lower frequencies '
p32
sg19
g20
sa(dp33
g2
g3
sg4
S' None. ES_LPC2102 . \xc2\xa9   Rev. 2 \xe2\x80\x94 1 March 2011 7 of 13  ES_LPC2102  LPC2102 '
p34
sg6
g3
sg7
g3
sg8
S' The SSP is a Synchronous Serial Port (SSP) controller capable of operation on a SPI, 4-wire SSI or a Microwire bus. The SSP can operate at a maximum speed of 30MHz and it referred to as SPI1 in the device documentation.  At high SSP frequencies, it is found that the first four pulses are shorter than the subsequent pulses. At 30 MHz, the first pulse can be expected to be approximately 10 ns shorter and the second pulse around 5 ns shorter. The remaining two pulses are around 2 ns shorter than subsequent pulses. At 25 MHz, the length of the first pulse would be around 7 ns shorter. The subsequent three pulses are around 2 ns shorter. At 20 MHz only the first pulse is affected and it is around 2 ns shorter. All subsequent pulses are fine. The deviation of the initial data bits/clocks will decrease as the SSP frequency decreases. '
p35
sg10
g11
sg12
g3
sg13
g14
sg15
g3
sg16
g3
sg17
S'3.5 SSP.1: Initial data bits/clocks of the SSP transmission are shorter than subsequent pulses at higher frequencies '
p36
sg19
g20
sa(dp37
g2
g3
sg4
S' There are two possible workarounds: 1. Combine the Timer Counter reset feature with the \xe2\x80\x9cinterrupt on match\xe2\x80\x9d feature. The interrupt on match occurs on the correct incoming edge. In the ISR, the Timer Counter register can also be reset. This solution can only work if no edges are expected during the duration of the ISR. 2. In this solution, the \xe2\x80\x9cinterrupt on match\xe2\x80\x9d feature is not used. Instead, the following specific initialization can achieve the counting operation: a. Initialize the Timer Counter register to 0xFFFFFFFF. b. If \xe2\x80\x9cn\xe2\x80\x9d edges have to be counted then initialize the corresponding Match register with value n-1. For instance, if 2 edges need to be counted then load the Match register with value 1. More details on the above example: 1. Edge 1 - Timer overflows and Timer Counter (TC) is set to 0. 2. Edge 2 - TC = 1. Match takes place. 3. Edge 3 - TC = 0. 4. Edge 4 - TC = 1. Match takes place. 5. Edge 5 - TC = 0. ES_LPC2102 . \xc2\xa9   Rev. 2 \xe2\x80\x94 1 March 2011 8 of 13  ES_LPC2102  LPC2102 '
p38
sg6
g3
sg7
g3
sg8
S' Timer0 and Timer1 can be used in a counter mode. In this mode, the Timer Counter register can be incremented on rising, falling or both edges which occur on a selected CAP input pin. This counter mode can be combined with the match functionality to provide additional features. One of the features would be to reset the Timer Counter register on a match. The same would also apply for Timer1.  The Timer Counter reset does not trigger on the same incoming edge when the match takes place between the corresponding Match register and the Timer Counter register. The Timer Counter register will be reset only on the next incoming edge. '
p39
sg10
g11
sg12
g3
sg13
g14
sg15
g3
sg16
g3
sg17
S'3.6 Timer.1: In counter mode, the Timer Counter reset does not occur on the correct incoming edge '
p40
sg19
g20
sa(dp41
g2
g3
sg4
S' Increase the voltage on Vdd1V8 to 1.95 V. It is not harmful to the device if this voltage reaches 2 V. '
p42
sg6
g3
sg7
g3
sg8
S' From the Vdd1V8 pin to the ARM7 core, there is a voltage drop. This voltage drop increases with higher currents (or higher power consumption). Higher system frequency and/or faster peripherals increase power consumption thereby increasing the voltage drop from the Vdd1V8 pin to the core.  Under increased power consumption conditions, the device may not work properly. The likelihood of the problem showing up increases if the device is run at higher speeds (approaching 70MHz) and/or if the peripherals are running at close to system frequency speed (i.e If the APBDIV register is set to a value lower than 4 which would imply that the peripherals are run faster than 1/4 of the system frequency). Also, having a lower voltage on Vdd1V8 pin (e.g. below 1.8 V) can cause this issue to surface. '
p43
sg10
g11
sg12
g3
sg13
g14
sg15
g3
sg16
g3
sg17
S'3.7 Vdd.1: Device may not work properly under increased power consumption conditions '
p44
sg19
g20
sa(dp45
g2
g3
sg4
S' None. ES_LPC2102 . \xc2\xa9   Rev. 2 \xe2\x80\x94 1 March 2011 9 of 13  ES_LPC2102  LPC2102 '
p46
sg6
g3
sg7
g3
sg8
S' There are two I2C interfaces, I2C0 and I2C1. I2C0 functions are shared as alternate functions on port pins P0.2 and P0.3. I2C1 functions are shared on port pins P0.17 and P0.18.  I2C1 pins are currently open-drain output pins but they should be regular bi-directional GPIO pins. I2C0 pins are configured as open-drain output pins (for I2C bus compliance). '
p47
sg10
g11
sg12
g3
sg13
g14
sg15
g3
sg16
g3
sg17
S'3.8 I2C1.1: I2C1 pins are not bi-directional GPIO pins '
p48
sg19
g20
sa(dp49
g2
g3
sg4
S' In software-controlled mode (BURST bit is 0), the START conversion options (bits 26:24 set to 0x1 or 0x4 or 0x5 or 0x6 or 0x7) can be used. The user can also start a conversion by connecting an external trigger signal to a capture input pin (CAPx) from a Timer peripheral to generate an interrupt. The timer interrupt routine can then start the ADC conversion by setting the START bits (26:24) to 0x1. The trigger can also be generated from a timer match register. ES_LPC2102 . \xc2\xa9   Rev. 2 \xe2\x80\x94 1 March 2011 10 of 13  ES_LPC2102  LPC2102 4. AC/DC deviations detail '
p50
sg6
g3
sg7
g3
sg8
S' In software-controlled mode (BURST bit is 0), the 10-bit ADC can start conversion by using the following options in the A/D Control Register: Fig 1. A/D control register options  The external start conversion feature, AD0CR:START = 0x2 or 0x3, may not work reliably and ADC external trigger edges on P0.16 or P0.22 may be missed. The occurrence of this problem is peripheral clock (pclk) dependent. The probability of error (missing an ADC trigger from GPIO) is estimated as follows: \xe2\x80\xa2 For PCLK_ADC = 72 MHz, probability error = 12 % \xe2\x80\xa2 For PCLK_ADC = 50 MHz, probability error = 6 % \xe2\x80\xa2 For PCLK_ADC = 12 MHz, probability error = 1.5 % The probability of error is not affected by the frequency of ADC start conversion edges. '
p51
sg10
g11
sg12
g3
sg13
g14
sg15
g3
sg16
g3
sg17
S'3.9 ADC.1: External sync inputs not operational '
p52
sg19
g20
sa(dp53
g2
g3
sg4
S' Observe proper ESD handling precautions for the RTCX1 pin. '
p54
sg6
g3
sg7
g3
sg8
S' The LPC2102 is rated for 2 kV ESD.The RTCX1 pin is the input pin for the RTC oscillator circuit.  The LPC2102 does not meet the required 2 kV ESD specified. '
p55
sg10
g11
sg12
g3
sg13
g14
sg15
g3
sg16
g3
sg17
S'4.1 ESD.1: The device does not meet the 2 kV ESD requirements on the RTCX1 pin '
p56
sg19
g20
sa(dp57
g2
g3
sg4
S' VDD(1V8) core pin must always be connected to its power supply or to ground.'
p58
sg6
g3
sg7
g3
sg8
S' The LPC2102 has a VDD(1V8) core pin which provides power to the internal circuitry and also, has a VBAT pin which provides power only to the RTC (Real Time Clock). VBAT pin can be to an external battery or to the 3.3 V I/O port supply (VDD(3V3) pin) used by the device.  When the VDD(1V8) core pin is floated, power consumption increases on the VBAT pin. '
p59
sg10
S'ARM9'
p60
sg12
g3
sg13
g14
sg15
g3
sg16
g3
sg17
S'4.2 VBAT.1: Increased power consumption on the VBAT pin when the VDD(1V8) core pin is left floating '
p61
sg19
g20
sa(dp62
g2
g3
sg4
S' 1. The on-chip boot-loader software can be updated via ISP to correct this issue. The boot loader update files can be downloaded here: http://www.nxp.com/files/products/standard/microcontrollers/utilities/lpc2000_bl_update.zip The boot-loader version can be read out using the NXP Flash ISP Utility which can be found here: http://www.nxp.com/files/products/standard/microcontrollers/utilities/lpc2000_flash_utility.zip 2. Limiting the external clock frequency to 12 MHz AND making sure the on-chip PLL is turned OFF while programming any part of the Flash memory reduces the likelihood of the occurrence significantly. During In-System-Programming the PLL is turned off by default. ES_LPC2114_24_00 . \xc2\xa9   Rev. 3 \xe2\x80\x94 1 April 2011 5 of 22  ES_LPC2114/24; LPC2114/24/00  LPC2114/24, LPC2114/00, LPC2124/00 '
p63
sg6
g3
sg7
g3
sg8
S' The Flash memory on the LPC2114/24 offers In-Application Programming (IAP) functionality. The IAP routines are part of the on-chip boot loader software, which controls the interface between the digital logic and the Flash memory. Please note that all programming methods (JTAG, ISP, IAP) use IAP calls.  Due to a timing problem in the interface between the Flash block and the digital logic the following problem may occur: If the boot loader revision in the device is previous to V1.63 then in up to 10% of the devices the Flash memory interface, at some point during an IAP programming or erase operation, may never return from the IAP call. Please note that devices that pass the IAP programming are functional and do not suffer from any long-term reliability problems. Devices with a date code prior to 0425 (manufactured before week 25 in 2004) are generally affected by this problem unless you receive devices with updated boot loader software from your distributor. Parts marked with date code 0425 or later are not affected by this problem. Please refer to page 3 of this document for details on how to identify the date code. '
p64
sg10
g11
sg12
g3
sg13
S'LPC2114'
p65
sg15
g3
sg16
g3
sg17
S'3.1 IAP.1: Flash memory programming interface timing problem '
p66
sg19
g20
sa(dp67
g2
g3
sg4
S' Ignore the first conversion, always check the CHN bits to confirm the channel converted. '
p68
sg6
g3
sg7
g3
sg8
S' In burst mode the A/D converter does repeated conversions at the rate selected by the CLKS field in the ADCR, scanning (if necessary) through the pins selected by 1s in the SEL field. The first conversion after the start corresponds to the least-significant 1 in the SEL field, then higher numbered 1-bits (pins) if applicable. Repeated conversions can be terminated by clearing this bit.  In burst conversion mode, the first two conversions (after setting the mode) will be of the same, lowest-numbered, of the selected channels. '
p69
sg10
g11
sg12
g3
sg13
g65
sg15
g3
sg16
g3
sg17
S'3.2 ADC.1: First two ADC conversions in burst mode from same channel '
p70
sg19
g20
sa(dp71
g2
g3
sg4
S' Set the BURST/START bit(s) after setting the SEL bits. ES_LPC2114_24_00 . \xc2\xa9   Rev. 3 \xe2\x80\x94 1 April 2011 6 of 22  ES_LPC2114/24; LPC2114/24/00  LPC2114/24, LPC2114/00, LPC2124/00 '
p72
sg6
g3
sg7
g3
sg8
S' The ADCR SFR contains bits to enable the ADC burst mode (BURST), start the conversion in software control mode (START), and to select the channel to begin converting (SEL).  In burst mode, If the BURST bit is set before or simultaneously to (using the STR instruction for example), the SEL bits, then the first channel converted will correspond to the previous SEL bit settings. In software control mode (only when using external trigger), if the START bits are set before or simultaneously to (using the STR instruction for example) the SEL bits, then the first channel converted will correspond to the previous SEL bit settings. '
p73
sg10
g11
sg12
g3
sg13
g65
sg15
g3
sg16
g3
sg17
S'3.3 ADC.2: First conversion from channel specified by previous SEL setting '
p74
sg19
g20
sa(dp75
g2
g3
sg4
S' None. Do not use the sampling patterns \xe2\x80\x98channel 2 only\xe2\x80\x99 or \xe2\x80\x98channels 1 and 2\xe2\x80\x99. This problem has no effect on software conversion, nor on any other patterns other than the two noted above. '
p76
sg6
g3
sg7
g3
sg8
S' In hardware scan mode multiple ADC channels may be selected as part of the scan by selecting the appropriate bits in the SEL field in the ADCR register.  Certain hardware scanning patterns for the A/D Converter do not operate properly. Selecting channel 2 only leads to alternate sampling of channels 2 and 3. Selecting channels 1 and 2 leads to sampling channel 1 for the first conversion, then sampling channel 2 on every subsequent conversion. '
p77
sg10
g11
sg12
g3
sg13
g65
sg15
g3
sg16
g3
sg17
S'3.4 ADC.3: Incorrect scan pattern '
p78
sg19
g20
sa(dp79
g2
g3
sg4
S' Clear the PDN bit in the ADCR SFR to turn off the ADC prior to setting the PD bit in PCON. ES_LPC2114_24_00 . \xc2\xa9   Rev. 3 \xe2\x80\x94 1 April 2011 7 of 22  ES_LPC2114/24; LPC2114/24/00  LPC2114/24, LPC2114/00, LPC2124/00 '
p80
sg6
g3
sg7
g3
sg8
S' Setting the PD bit (bit 1) in PCON stops all clocks and powers down the peripherals. The ADC is powered down by clearing the PDN bit (bit 21) in the ADCR register, setting the bit powers up (enables) the ADC.  If the PDN in ADCR is set, setting the PD bit in PCON will not power down the ADC. '
p81
sg10
g11
sg12
g3
sg13
g65
sg15
g3
sg16
g3
sg17
S'3.5 ADC.4: Global power down does not power down the ADC '
p82
sg19
g20
sa(dp83
g2
g3
sg4
S' Clear the selected CAP/MAT signal for EDGE = 0 or set the selected CAP/MAT signal for EDGE = 1 before writing 010-111 to START field. Alternatively, discard the first conversion after writing to the start bits. '
p84
sg6
g3
sg7
g3
sg8
S' When the START field of the ADCR register contains 010-111 the EDGE bit in ADCR will determine whether a conversion is started on a rising or falling edge of the selected CAP/MAT signal. EDGE=0 selects rising edge detection, EDGE=1 selects falling edge detection (On CAP/MAT pin).  If the state of the selected CAP/MAT signal is 1 and EDGE is set to detect rising edges (EDGE = 0) or, if detection of falling edges is selected (EDGE = 1) and the state of the selected CAP/MAT signal is 0, an ADC conversion will immediately be initiated when the START bits are written to. So the first conversion behaves as a level triggered event rather than edge triggered. '
p85
sg10
g11
sg12
g3
sg13
g65
sg15
g3
sg16
g3
sg17
S'3.6 ADC.5: Edge triggered ADC conversion start error '
p86
sg19
g20
sa(dp87
g2
g3
sg4
S' Do not write to ADCR until the conversion is complete. '
p88
sg6
g3
sg7
g3
sg8
S' Writing to ADCR while a conversion is in progress should set the DONE bit and start a new conversion.  In actuality, if the ADCR is written to within 2.5 ADC_clock cycles, a new conversion is started but the DONE bit is not set. If the ADCR is written to after 2.5 ADC_clocks, but within a conversion time, the DONE bit is set within one ADC_clock and a new conversion is started. '
p89
sg10
g11
sg12
g3
sg13
g65
sg15
g3
sg16
g3
sg17
S'3.7 ADC.6: Writing to ADCR while conversion in progress '
p90
sg19
g20
sa(dp91
g2
g3
sg4
S' Avoid writing to SPI registers while transmissions are in progress or while SPI interrupts are pending. ES_LPC2114_24_00 . \xc2\xa9   Rev. 3 \xe2\x80\x94 1 April 2011 8 of 22  ES_LPC2114/24; LPC2114/24/00  LPC2114/24, LPC2114/00, LPC2124/00 '
p92
sg6
g3
sg7
g3
sg8
S' The SPI interrupt flag is set by the SPI interface to generate an interrupt. It is cleared by writing a 1 to this bit.  A write to any register associated with the SPI peripheral will clear the SPI interrupt register. '
p93
sg10
g11
sg12
g3
sg13
g65
sg15
g3
sg16
g3
sg17
S'3.8 SPI.1: Unintentional clearing of SPI interrupt flag '
p94
sg19
g20
sa(dp95
g2
g3
sg4
S' There are two possible workarounds: 1. Use CPHA=1. 2. If the data is shifted incorrectly when CPHA is set to 0 then delaying the write to SPDR after the half SCK cycle of the last sampling clock would resolve this issue. '
p96
sg6
g3
sg7
g3
sg8
S' In slave mode, the SPI can set the clock phase (CPHA) to 0 or 1.  Consider the following conditions: 1. SPI is configured as a slave (with CPHA=0). 2. SPI is running at a low frequency. In slave mode, the SPIF (SPI Transfer Complete Flag) bit is set on the last sampling edge of SCK. If CPHA is set to 0 then the last sampling edge of SCK would be the rising edge. Under the above conditions, if the SPI Data Register (SPDR) is written to less than a half SCLK cycle after the SPIF bit is set (this would happen if the SPI frequency is low) then the SPDR will shift data one clock early for the upcoming transfers. Lowering the SPI frequency would increase the likelihood of the SPDR write happening in the first half SCK cycle of the last sampling clock. '
p97
sg10
g11
sg12
g3
sg13
g65
sg15
g3
sg16
g3
sg17
S'3.9 SPI.2: Incorrect shifting of data in slave mode at lower frequencies '
p98
sg19
g20
sa(dp99
g2
g3
sg4
S' If VPBDIV is non-zero, write all zeroes to VPBDIV before reading or writing EXTMODE or EXTPOLAR, then write the proper value back to VPBDIV. In most applications this is a known and fixed value, but if there is a possibility of dynamic changes in VPBDIV, software will need to read VPBDIV, write zero to VPBDIV, read or write EXTMODE and/or EXTPOLAR, and then rewrite the value previously read from VPBDIV. ES_LPC2114_24_00 . \xc2\xa9   Rev. 3 \xe2\x80\x94 1 April 2011 9 of 22  ES_LPC2114/24; LPC2114/24/00  LPC2114/24, LPC2114/00, LPC2124/00 '
p100
sg6
g3
sg7
g3
sg8
S' The VPBDIV register controls the rate of the VPB clock in relation to the processor clock. EXTPOLAR and EXTMODE determine the operating parameters of the external interrupts.  A write to either the external interrupt polarity register (EXTPOLAR) or the external interrupt mode register (EXTMODE) will corrupt the VPBDIV register. A read of either EXTPOLAR or EXTMODE will be corrupted BY the VPBDIV register. If VPBDIV is \xe2\x80\x9c1\xe2\x80\x9d or \xe2\x80\x9c2\xe2\x80\x9d prior to any write to EXTPOLAR or EXTMODE, the CPU will hang up on the write to EXTPOLAR or EXTMODE. '
p101
sg10
g11
sg12
g3
sg13
g65
sg15
g3
sg16
g3
sg17
S'3.10 EXTINT.1: Corruption of VPBDIV via EXTPOLAR or EXTMODE '
p102
sg19
g20
sa(dp103
g2
g3
sg4
S' This problem is related to EXTINT.1 and hence the same workaround applies with an additional step. The steps involved in the configuration of the EXTMODE and/or EXTPOLAR would be as follows: 1. Write 0x0 to VPBDIV 2. Write the desired value to EXTMODE or EXTPOLAR register 3. Write the same value to VPBDIV (additional step) 4. Restore the VPBDIV to the previously saved value or simply write to the register again with the desired value. Code sample for setting EXTMODE and EXTPOLAR to 0x1: VPBDIV = 0x0; /* EXTMODE */ EXTMODE = 0x1; VPBDIV = 0x1; VPBDIV = 0x0; /* EXTPOLAR */ EXTPOLAR = 0x1; VPBDIV = 0x1; VPBDIV = 0x0; /* Setting VPBDIV */ Note: While testing this in a debugger environment, please don\xe2\x80\x99t single-step through these steps. A breakpoint could be placed after Step 4 and you would see the EXTMODE and EXTPOLAR registers reflecting the correct values. '
p104
sg6
g3
sg7
g3
sg8
S' EXTPOLAR and EXTMODE determine the operating parameters of the external interrupts.  As an illustration, trying to set EXTMODE to 0x1 or 0xd would result in EXTMODE to be set to 0x0 instead. '
p105
sg10
g11
sg12
g3
sg13
g65
sg15
g3
sg16
g3
sg17
S'3.11 EXTINT.2: Incorrect setting of EXTMODE and/or EXTPOLAR register while trying to set them to desired value '
p106
sg19
g20
sa(dp107
g2
g3
sg4
S' To use P0.21 as capture 1.3, PINSEL(7:6) must also be set to \xe2\x80\x9811\xe2\x80\x99 which means that P0.19 must be selected as capture input 1.2. ES_LPC2114_24_00 . \xc2\xa9   Rev. 3 \xe2\x80\x94 1 April 2011 10 of 22  ES_LPC2114/24; LPC2114/24/00  LPC2114/24, LPC2114/00, LPC2124/00 '
p108
sg6
g3
sg7
g3
sg8
S' P0.21 and P0.19 may be configured as capture inputs via the PINSEL register.  When PINSEL(11:10) is set to \xe2\x80\x9911\xe2\x80\x99 P0.21 is not internally connected as capture 1.3 '
p109
sg10
g11
sg12
g3
sg13
g65
sg15
g3
sg16
g3
sg17
S'3.12 CAP.1: Problem when selecting P0.21 as a capture 1.3 input (timer1) '
p110
sg19
g20
sa(dp111
g2
g3
sg4
S' Performing two consecutive reads of the VPBDIV assures that the correct value is returned. '
p112
sg6
g3
sg7
g3
sg8
S' The Peripheral Bus Divider (VPBDIV) divides the processor clock (CCLK) by one, two, or four. This is the clock that is provided to the peripheral bus.  Reading the VPBDIV register may return an incorrect value. '
p113
sg10
g11
sg12
g3
sg13
g65
sg15
g3
sg16
g3
sg17
S'3.13 VPBDIV.1: Incorrect read of VPBDIV '
p114
sg19
g20
sa(dp115
g2
g3
sg4
S' In a system that does not use Thumb state, there will be no problem. In a system that uses Thumb state but does not use data aborts, or does not try to use data aborts in a recoverable manner, there will be no problem. Otherwise the workaround is to ensure that a STR, STMIA or PUSH cannot precede a PC-relative load. One method for this is to add a NOP before any PC-relative load instruction. However this would have to be done manually. ES_LPC2114_24_00 . \xc2\xa9   Rev. 3 \xe2\x80\x94 1 April 2011 11 of 22  ES_LPC2114/24; LPC2114/24/00  LPC2114/24, LPC2114/00, LPC2124/00 '
p116
sg6
g3
sg7
g3
sg8
S' If the processor is in Thumb state and executing the code sequence STR, STMIA or PUSH followed by a PC relative load, and the STR, STMIA or PUSH is aborted, the PC is saved to the abort link register.  In this situation the PC is saved to the abort link register in word resolution, instead of half-word resolution. Conditions: The processor must be in Thumb state, and the following sequence must occur: <any instruction> <STR, STMIA, PUSH> <---- data abort on this instruction LDR rn, [pc,#offset] In this case the PC is saved to the link register R14_abt in only word resolution, not half-word resolution. The effect is that the link register holds an address that could be #2 less than it should be, so any abort handler could return to one instruction earlier than intended. '
p117
sg10
g11
sg12
g3
sg13
g65
sg15
g3
sg16
g3
sg17
S'3.14 Core.1: Incorrect update of the Abort Link register in Thumb state '
p118
sg19
g20
sa(dp119
g2
g3
sg4
S' There is no clear workaround for this problem but some of the below mentioned solutions could work with some applications. Possible work-around\xe2\x80\x99s for Match functionality: 1. If the application only needs two Match registers then distribute them between Timer 0 and Timer 1 to avoid this problem. 2. Stop the timer before accessing the Interrupt register for clearing the interrupt and then start timer again after the access is completed. 3. Polling for interrupt: Supposing that there are two Match events (Match X and Match Y). At the end of the Interrupt Service Routine (ISR) for Match X, compare the Timer Counter value with the Match Register Y value. If the Timer Counter value is more than the Match Register Y value then it is possible that this event might have been missed. In this case jump to the ISR directly and service Match event Y. Possible workarounds for Capture functionality: 1. Try to spread the capture events between both timers if there are two capture events. If the application also has a match event then one of the capture events may suffer. 2. Polling for Capture: At the end of a Match interrupt ISR or Capture event ISR compare the previous Capture value with the current Capture value. If the Capture value has changed then the Capture event might have been missed. In this case, jump to the ISR directly and service the Capture event. '
p120
sg6
g3
sg7
g3
sg8
S' The Timers may be configured so that events such as Match and Capture, cause interrupts. Bits in the Interrupt Register (IR) indicate the source of the interrupt, whether from Capture or Match.  If more than one interrupt for multiple Match events using the same Timer are enabled, it is possible that one of the match interrupts may not be recognized. If this occurs no more interrupts from that specific match register will be recognized. This could happen in a scenario where the match events are very close to each other. This issue also affects the Capture functionality. Specific details: Suppose that two match events are very close to each other (Say Match0 and Match1). Also assume that the Match0 event occurs first. When the Match0 interrupt occurs the 0th bit of the Interrupt Register will be set. To exit the Interrupt Service Routine of Match0, this bit has to be cleared in the Interrupt Register. The clearing of this bit might be done by using the following statement: T0_IR = 0x1; It is possible that software will be writing a 1 to bit 0 of the Interrupt Register while a Match1 event occurs, meaning that hardware needs to set the bit 1 of the Interrupt Register. In this case, since hardware is accessing the register at the same time as software, bit 1 for Match1 never gets set, causing the interrupt to be missed. In summary, while software is writing to the Interrupt Register, any Match or Capture event (which are configured to interrupt the core) occurring at the same time may result in the subsequent interrupt not being recognized. Similarly for the Capture event, if a capture event occurs while a Match event is being is serviced then the Capture event might be missed if the software and hardware accesses coincide. Affected features: 1. Interrupt on Match for Timer0/1. 2. Interrupt on Capture for Timer0/1. 3. These same features will be affected when using PWM. ES_LPC2114_24_00 . \xc2\xa9   Rev. 3 \xe2\x80\x94 1 April 2011 12 of 22  ES_LPC2114/24; LPC2114/24/00  LPC2114/24, LPC2114/00, LPC2124/00 '
p121
sg10
g11
sg12
g3
sg13
g65
sg15
g3
sg16
g3
sg17
S'3.15 TIMER.1: Missed Interrupt Potential '
p122
sg19
g20
sa(dp123
g2
g3
sg4
g3
sg6
g3
sg7
g3
sg8
g3
sg10
g11
sg12
g3
sg13
g65
sg15
g3
sg16
g3
sg17
S'3.16 PWM.1: Missed Interrupt Potential for the Match functionality. The description is the same as above.'
p124
sg19
g20
sa(dp125
g2
g3
sg4
S' Only P0.27 can be used for Match 0.1. ES_LPC2114_24_00 . \xc2\xa9   Rev. 3 \xe2\x80\x94 1 April 2011 13 of 22  ES_LPC2114/24; LPC2114/24/00  LPC2114/24, LPC2114/00, LPC2124/00 '
p126
sg6
g3
sg7
g3
sg8
S' Timer0 has four external match outputs corresponding to match registers with various capabilities. Match 0.0 can be configured as an alternate function on P0.3 and P0.22. Match 0.1 can be configured as an alternate function on Port 0.5 and P0.27. The alternate functions can be configured by using the respective PINSELx register.  Match 0.0 should have been only connected to P0.3 and P0.22 but it is also connected to P0.5. Match 0.1 is only connected to P0.27. Hence if the application configures the External Match alternate function on both P0.3 (Match 0.0) and P0.5 (Match 0.1) then the Match 0.0 output can be seen on two port pins, namely P0.3 and P0.5. '
p127
sg10
g11
sg12
g3
sg13
g65
sg15
g3
sg16
g3
sg17
S'3.17 Timer0.1: Match 0.1 output cannot be seen on port pin P0.5 if configured as an alternate function. '
p128
sg19
g20
sa(dp129
g2
g3
sg4
S' IIR reading: The IIR bug can be worked around by disabling the modem status interrupt effectively making THRE the lowest priority interrupt. The work-around does not work in software interrupt polling mode. Modem status has to be handled by software polling MSR. Now there are two cases: 1. A THRE interrupt is pending, software responds to the interrupt by reading the IIR while another, higher priority interrupt is set (e.g. RDA). In this case software will read the THRE status although the status will not be cleared where it should have been. After handling the THRE and RDA interrupt another dummy THRE interrupt may occur, unless in the meantime software has filled THR. This is considered an error although not fatal. ES_LPC2114_24_00 . \xc2\xa9   Rev. 3 \xe2\x80\x94 1 April 2011 14 of 22  ES_LPC2114/24; LPC2114/24/00  LPC2114/24, LPC2114/00, LPC2124/00 2. A high priority interrupt is pending, software responds to the interrupt by reading the IIR register while a THRE interrupt is set. In this case, software will read the higher priority interrupt and the THRE interrupt will be handled later. This behavior is as expected. LSR reading: A work-around for this problem is to service the OE/PE/FE/BI condition before another character is received which will trigger an LSR update. So basically, service the interrupt in one-character time. MSR reading: The MSR bug can be worked-around by not using the Delta DCD/Trailing Edge RI/Delta DSR/Delta CTS bits in the MSR but instead use the DCD/TRI/DSR/CTS bits in the same register. To prevent, a transition from being missed software should poll the register\xe2\x80\x99s value at a sufficiently high rate. ES_LPC2114_24_00 . \xc2\xa9   Rev. 3 \xe2\x80\x94 1 April 2011 15 of 22  ES_LPC2114/24; LPC2114/24/00  LPC2114/24, LPC2114/00, LPC2124/00 3.19 Reset.1: Device does not power up correctly under certain internal conditions Problem: If certain rare chip-internal conditions are met, the device will not start up correctly when executing a power-on reset. The crystal oscillator will be running but the device will not execute code. Work-around: Apply a second (warm) reset pulse (without power-on cycle). The minimum time requirement between the first (unsuccessful) reset and the second reset is 4105 external oscillator clock cycles, which means that the assertion of the second reset should occur 4105 cycles or more after the deassertion of the first reset. For example, at 10 MHz, this is equal to 411 \xef\x81\xads; at 20 MHz, this is equal to 206 \xef\x81\xads.This can be achieved by using an external watchdog timer or by any other circuitry in the application that is able to assert a second reset pulse. The root cause for this problem has been identified and will be fixed from Revision B of this device onwards. This problem will also be fixed in the LPC21x4/00 version of this device which will have a dedicated order number (LPC21x4FBD64/00). ES_LPC2114_24_00 . \xc2\xa9   Rev. 3 \xe2\x80\x94 1 April 2011 16 of 22  ES_LPC2114/24; LPC2114/24/00  LPC2114/24, LPC2114/00, LPC2124/00 3.20 ADC.7: External sync inputs not operational Introduction: In software-controlled mode (BURST bit is 0), the 10-bit ADC can start conversion by using the following options in the A/D Control Register: Fig 1. A/D control register options Problem: The external start conversion feature, ADCR:START = 0x2 or 0x3, may not work reliably and ADC external trigger edges on P0.16 or P0.22 may be missed. The occurrence of this problem is peripheral clock (pclk) dependent. The probability of error (missing a ADC trigger from GPIO) is estimated as follows: \xe2\x80\xa2 For PCLK_ADC = 60 MHz, probability error = 12 % \xe2\x80\xa2 For PCLK_ADC = 50 MHz, probability error = 6 % \xe2\x80\xa2 For PCLK_ADC = 12 MHz, probability error = 1.5 % The probability of error is not affected by the frequency of ADC start conversion edges. Work-around: In software-controlled mode (BURST bit is 0), the START conversion options (bits 26:24 set to 0x1 or 0x4 or 0x5 or 0x6 or 0x7) can be used. The user can also start a conversion by connecting an external trigger signal to a capture input pin (CAPx) from a Timer peripheral to generate an interrupt. The timer interrupt routine can then start the ADC conversion by setting the START bits (26:24) to 0x1. The trigger can also be generated from a timer match register. ES_LPC2114_24_00 . \xc2\xa9   Rev. 3 \xe2\x80\x94 1 April 2011 17 of 22  ES_LPC2114/24; LPC2114/24/00  LPC2114/24, LPC2114/00, LPC2124/00 4. AC/DC deviations detail '
p130
sg6
g3
sg7
g3
sg8
S' Reading the contents of the IIR,LSR and MSR registers will clear certain bits in the register. 1. Reading the IIR should clear the THRE status if THRE is the highest priority pending interrupt (Only affects UART1). 2. Reading LSR should clear the OE/PE/FE/BI bits (affects both UART0 and UART1). 3. Reading MSR should clear the Delta DCD/Trailing Edge RI/Delta DSR/Delta CTS bits (Only affects UART1).  If hardware is setting one of these above bits while the software is reading the contents of the register the reading process clears all bits in the register including the bit that got set by hardware. The software reads the old value though and the bit that got set by hardware is lost. Specific details: Suppose IIR has a modem status interrupt while the other interrupts are inactive and software reads the IIR value (polling) while hardware sets the THRE interrupt then software will read the Modem Interrupt value while the THRE interrupt is cleared i.e the THRE interrupt is lost. Suppose the LSR is all zeros and software is reading the register while hardware is generating a parity error then the parity error bit is cleared while the software reads the old value (all zeros) i.e. the parity error is lost. Suppose MSR is all zeros and software is polling the value of the register while the value of CTS is changing then the change in CTS value should result in the Delta CTS bit getting set. Instead software will read all zeros and the Delta CTS bit in the MSR register will be cleared i.e. the Delta CTS status is lost. '
p131
sg10
g11
sg12
g3
sg13
g65
sg15
g3
sg16
g3
sg17
S'3.18 UART.1: Coinciding VPB read and hardware register update '
p132
sg19
g20
sa(dp133
g2
g3
sg4
S' Make sure that high logic levels are at least 2.4 V at these pins. '
p134
sg6
g3
sg7
g3
sg8
S' The specified, minimum, value for VIH is 2.0 V.  Any pin associated with either an external interrupt input or an analog to digital converter (ADC) input has a VIH of 2.4 V, not 2.0 V. The pins that are affected are the ones that can be configured as either an ADC input or and external interrupt input, not just the ones that are configured as such. '
p135
sg10
g11
sg12
g3
sg13
g65
sg15
g3
sg16
g3
sg17
S'4.1 VIH.1: Incompatibility of actual VIH levels as compared to those specified '
p136
sg19
g20
sa(dp137
g2
g3
sg4
S' None.'
p138
sg6
g3
sg7
g3
sg8
S' V3 is the power supply voltage for the I/O ports. External interrupt pins are general purpose interrupt pins which are level and edge sensitive. They can optionally wake up the device from power down mode. The ADC block can produce 10-bit samples with conversion time as low as 2.44 us.  If the external interrupt and/or ADC pins are pulled higher than 1.8 V then it will lead to increased current consumption from V3. If V3 is 3.0 V and V1.8 is 1.8 V then the leakage current will increase to a typical number of 200 uA (per pin). Note: The ADC pins won\xe2\x80\x99t contribute to the leakage if they are not configured as digital inputs using the PINSELx register. External interrupt pins will contribute to the leakage irrespective of their pin configuration. '
p139
sg10
g60
sg12
g3
sg13
g65
sg15
g3
sg16
g3
sg17
S'4.2 V3.1: Leakage current on V3 due to External Interrupt and/or Analog to Digital Converter (ADC) pins. '
p140
sg19
g20
sa(dp141
g2
g3
sg4
S' In a system that does not use Thumb state, there will be no problem. In a system that uses Thumb state but does not use data aborts, or does not try to use data aborts in a recoverable manner, there will be no problem. Otherwise the workaround is to ensure that a STR, STMIA or PUSH cannot precede a PC-relative load. One method for this is to add a NOP before any PC-relative load instruction. However this would have to be done manually. ES_LPC2220 . \xc2\xa9   Rev. 2 \xe2\x80\x94 1 April 2011 4 of 11  ES_LPC2220  LPC2220 '
p142
sg6
g3
sg7
g3
sg8
S' If the processor is in Thumb state and executing the code sequence STR, STMIA or PUSH followed by a PC relative load, and the STR, STMIA or PUSH is aborted, the PC is saved to the abort link register.  In this situation the PC is saved to the abort link register in word resolution, instead of half-word resolution. Conditions: The processor must be in Thumb state, and the following sequence must occur: <any instruction> <STR, STMIA, PUSH> <---- data abort on this instruction LDR rn, [pc,#offset] In this case the PC is saved to the link register R14_abt in only word resolution, not half-word resolution. The effect is that the link register holds an address that could be #2 less than it should be, so any abort handler could return to one instruction earlier than intended. '
p143
sg10
g11
sg12
g3
sg13
S'LPC2220'
p144
sg15
g3
sg16
g3
sg17
S'3.1 Core.1: Incorrect update of the Abort Link register in Thumb state '
p145
sg19
g20
sa(dp146
g2
g3
sg4
S' There are two possible workarounds: 1. Use CPHA=1. 2. If the data is shifted incorrectly when CPHA is set to 0 then delaying the write to SPDR after the half SCK cycle of the last sampling clock would resolve this issue. ES_LPC2220 . \xc2\xa9   Rev. 2 \xe2\x80\x94 1 April 2011 5 of 11  ES_LPC2220  LPC2220 '
p147
sg6
g3
sg7
g3
sg8
S' In slave mode, the SPI can set the clock phase (CPHA) to 0 or 1.  Consider the following conditions: 1. SPI is configured as a slave (with CPHA=0). 2. SPI is running at a low frequency. In slave mode, the SPIF (SPI Transfer Complete Flag) bit is set on the last sampling edge of SCK. If CPHA is set to 0 then the last sampling edge of SCK would be the rising edge. Under the above conditions, if the SPI Data Register (SPDR) is written to less than a half SCLK cycle after the SPIF bit is set (this would happen if the SPI frequency is low) then the SPDR will shift data one clock early for the upcoming transfers. Lowering the SPI frequency would increase the likelihood of the SPDR write happening in the first half SCK cycle of the last sampling clock. '
p148
sg10
g11
sg12
g3
sg13
g144
sg15
g3
sg16
g3
sg17
S'3.2 SPI.1: Incorrect shifting of data in slave mode at lower frequencies '
p149
sg19
g20
sa(dp150
g2
g3
sg4
S' None. '
p151
sg6
g3
sg7
g3
sg8
S' The SSP is a Synchronous Serial Port (SSP) controller capable of operation on a SPI, 4-wire SSI or a Microwire bus. The SSP can operate at a maximum speed of 30 MHz and it referred to as SPI1 in the device documentation.  At high SSP frequencies, it is found that the first four pulses are shorter than the subsequent pulses. At 30 MHz, the first pulse can be expected to be approximately 10 ns shorter and the second pulse around 5 ns shorter. The remaining two pulses are around 2 ns shorter than subsequent pulses. At 25 MHz, the length of the first pulse would be around 7 ns shorter. The subsequent three pulses are around 2 ns shorter. At 20 MHz only the first pulse is affected and it is around 2 ns shorter. All subsequent pulses are fine. The deviation of the initial data bits/clocks will decrease as the SSP frequency decreases. '
p152
sg10
g11
sg12
g3
sg13
g144
sg15
g3
sg16
g3
sg17
S'3.3 SSP.1: Initial data bits/clocks of the SSP transmission are shorter than subsequent pulses at higher frequencies '
p153
sg19
g20
sa(dp154
g2
g3
sg4
S' Only P0.27 can be used for Match 0.1. ES_LPC2220 . \xc2\xa9   Rev. 2 \xe2\x80\x94 1 April 2011 6 of 11  ES_LPC2220  LPC2220 '
p155
sg6
g3
sg7
g3
sg8
S' Timer0 has four external match outputs corresponding to match registers with various capabilities. Match 0.0 can be configured as an alternate function on P0.3 and P0.22. Match 0.1 can be configured as an alternate function on Port 0.5 and P0.27. The alternate functions can be configured by using the respective PINSELx register.  Match 0.0 should have been only connected to P0.3 and P0.22 but it is also connected to P0.5. Match 0.1 is only connected to P0.27. Hence if the application configures the External Match alternate function on both P0.3 (Match 0.0) and P0.5 (Match 0.1) then the Match 0.0 output can be seen on two port pins, namely P0.3 and P0.5. '
p156
sg10
g11
sg12
g3
sg13
g144
sg15
g3
sg16
g3
sg17
S'3.4 Timer0.1: Match 0.1 output cannot be seen on port pin P0.5 if configured as an alternate function '
p157
sg19
g20
sa(dp158
g2
g3
sg4
g3
sg6
g3
sg7
g3
sg8
g3
sg10
g11
sg12
g3
sg13
g144
sg15
g3
sg16
g3
sg17
S'3.5 Timer.1: In counter mode, the Timer Counter reset does not occur on the correct incoming edge Problem: Timer0 and Timer1 can be used in a counter mode. In this mode, the Timer Counter register can be incremented on rising, falling or both edges which occur on a selected CAP input pin. This counter mode can be combined with the match functionality to provide additional features. One of the features would be to reset the Timer Counter register on a match. The same would also apply for Timer1. Work-around: There are two possible workarounds: 1. Combine the Timer Counter reset feature with the \xe2\x80\x9cinterrupt on match\xe2\x80\x9d feature. The interrupt on match occurs on the correct incoming edge. In the ISR, the Timer Counter register can also be reset. This solution can only work if no edges are expected during the duration of the ISR. 2. In this solution, the \xe2\x80\x9cinterrupt on match\xe2\x80\x9d feature is not used. Instead, the following specific initialization can achieve the counting operation: a. Initialize the Timer Counter register to 0xFFFFFFFF. b. If \xe2\x80\x9cn\xe2\x80\x9d edges have to be counted then initialize the corresponding Match register with value n-1. For instance, if 2 edges need to be counted then load the Match register with value 1. More details on the above example: 1. Edge 1 - Timer overflows and Timer Counter (TC) is set to 0. 2. Edge 2 - TC=1. Match takes place. 3. Edge 3 - TC=0. 4. Edge 4 - TC=1. Match takes place. 5. Edge 5 - TC=0. ES_LPC2220 . \xc2\xa9   Rev. 2 \xe2\x80\x94 1 April 2011 7 of 11  ES_LPC2220  LPC2220'
p159
sg19
g20
sa(dp160
g2
g3
sg4
S' In software-controlled mode (BURST bit is 0), the START conversion options (bits 26:24 set to 0x1 or 0x4 or 0x5 or 0x6 or 0x7) can be used. The user can also start a conversion by connecting an external trigger signal to a capture input pin (CAPx) from a Timer peripheral to generate an interrupt. The timer interrupt routine can then start the ADC conversion by setting the START bits (26:24) to 0x1. The trigger can also be generated from a timer match register'
p161
sg6
g3
sg7
g3
sg8
S' In software-controlled mode (BURST bit is 0), the 10-bit ADC can start conversion by using the following options in the A/D Control Register: Fig 1. A/D control register options  The external start conversion feature, ADCR:START = 0x2 or 0x3, may not work reliably and ADC external trigger edges on P0.16 or P0.22 may be missed. The occurrence of this problem is peripheral clock (pclk) dependent. The probability of error (missing a ADC trigger from GPIO) is estimated as follows: \xe2\x80\xa2 For PCLK_ADC = 60 MHz, probability error = 12 % \xe2\x80\xa2 For PCLK_ADC = 50 MHz, probability error = 6 % \xe2\x80\xa2 For PCLK_ADC = 12 MHz, probability error = 1.5 % The probability of error is not affected by the frequency of ADC start conversion edges. '
p162
sg10
g11
sg12
g3
sg13
g144
sg15
g3
sg16
g3
sg17
S'3.6 ADC.1: External sync inputs not operational '
p163
sg19
g20
sa(dp164
g2
g3
sg4
g3
sg6
g3
sg7
g3
sg8
g3
sg10
g11
sg12
g3
sg13
g144
sg15
g3
sg16
g3
sg17
g3
sg19
g20
sa(dp165
g2
g3
sg4
g3
sg6
g3
sg7
g3
sg8
g3
sg10
g11
sg12
g3
sg13
g144
sg15
g3
sg16
g3
sg17
g3
sg19
g20
sa(dp166
g2
g3
sg4
g3
sg6
g3
sg7
g3
sg8
g3
sg10
g11
sg12
g3
sg13
g144
sg15
g3
sg16
g3
sg17
g3
sg19
g20
sa(dp167
g2
g3
sg4
g3
sg6
g3
sg7
g3
sg8
g3
sg10
g11
sg12
g3
sg13
g144
sg15
g3
sg16
g3
sg17
g3
sg19
g20
sa(dp168
g2
g3
sg4
g3
sg6
g3
sg7
g3
sg8
g3
sg10
g60
sg12
g3
sg13
g144
sg15
g3
sg16
g3
sg17
g3
sg19
g20
sa(dp169
g2
g3
sg4
S' For software controlled mode or burst mode with only one channel selected, the DONE bit in the A/D Global Data Register (located at 0xE003 4004) can be used instead of the individual ADDRx result register with no impact on performance. For burst mode with multiple channels selected, the DONE bit together with the CHN field in the A/D Global Data Register can be used with some impact on throughput. ES_LPC2378_88 . \xc2\xa9 NXP B.V. 2012. All rights reserved.  Rev. 6.1 \xe2\x80\x94 1 July 201'
p170
sg6
g3
sg7
g3
sg8
S' The LPC2378/88 has a 10-bit ADC, which can be used to measure analog signals and convert the signals into a 10-bit digital result. There are eight A/D channels and each channel has its own individual A/D Data Register (ADDR0 to ADDR7). The A/D Data Register holds the result when an A/D conversion is complete, and also includes the flags that indicate when a conversion has been completed (DONE bit) and when a conversion overrun has occurred. The DONE bit is cleared when the respective A/D Data Register is read.  If a software read of ADDRx conflicts with the hardware setting of the DONE bit in the same register (once a conversion is completed) then the DONE bit gets cleared automatically, thereby clearing the indication that a conversion was completed. '
p171
sg10
g11
sg12
g3
sg13
S'LPC2378'
p172
sg15
g3
sg16
g3
sg17
S'3.1 ADC.1: ADDRx read conflicts with hardware setting of the DONE bit '
p173
sg19
g20
sa(dp174
g2
g3
sg4
g3
sg6
g3
sg7
g3
sg8
g3
sg10
g11
sg12
g3
sg13
g172
sg15
g3
sg16
g3
sg17
g3
sg19
g20
sa(dp175
g2
g3
sg4
g3
sg6
g3
sg7
g3
sg8
g3
sg10
g11
sg12
g3
sg13
g172
sg15
g3
sg16
g3
sg17
g3
sg19
g20
sa(dp176
g2
g3
sg4
g3
sg6
g3
sg7
g3
sg8
g3
sg10
g11
sg12
g3
sg13
g172
sg15
g3
sg16
g3
sg17
g3
sg19
g20
sa(dp177
g2
g3
sg4
g3
sg6
g3
sg7
g3
sg8
g3
sg10
g11
sg12
g3
sg13
g172
sg15
g3
sg16
g3
sg17
g3
sg19
g20
sa(dp178
g2
g3
sg4
g3
sg6
g3
sg7
g3
sg8
g3
sg10
g11
sg12
g3
sg13
g172
sg15
g3
sg16
g3
sg17
g3
sg19
g20
sa(dp179
g2
g3
sg4
g3
sg6
g3
sg7
g3
sg8
g3
sg10
g11
sg12
g3
sg13
g172
sg15
g3
sg16
g3
sg17
g3
sg19
g20
sa(dp180
g2
g3
sg4
g3
sg6
g3
sg7
g3
sg8
g3
sg10
g11
sg12
g3
sg13
g172
sg15
g3
sg16
g3
sg17
g3
sg19
g20
sa(dp181
g2
g3
sg4
g3
sg6
g3
sg7
g3
sg8
g3
sg10
g11
sg12
g3
sg13
g172
sg15
g3
sg16
g3
sg17
g3
sg19
g20
sa(dp182
g2
g3
sg4
g3
sg6
g3
sg7
g3
sg8
g3
sg10
g11
sg12
g3
sg13
g172
sg15
g3
sg16
g3
sg17
g3
sg19
g20
sa(dp183
g2
g3
sg4
g3
sg6
g3
sg7
g3
sg8
g3
sg10
g11
sg12
g3
sg13
g172
sg15
g3
sg16
g3
sg17
g3
sg19
g20
sa(dp184
g2
g3
sg4
g3
sg6
g3
sg7
g3
sg8
g3
sg10
g11
sg12
g3
sg13
g172
sg15
g3
sg16
g3
sg17
g3
sg19
g20
sa(dp185
g2
g3
sg4
g3
sg6
g3
sg7
g3
sg8
g3
sg10
g11
sg12
g3
sg13
g172
sg15
g3
sg16
g3
sg17
g3
sg19
g20
sa(dp186
g2
g3
sg4
g3
sg6
g3
sg7
g3
sg8
g3
sg10
g11
sg12
g3
sg13
g172
sg15
g3
sg16
g3
sg17
g3
sg19
g20
sa(dp187
g2
g3
sg4
g3
sg6
g3
sg7
g3
sg8
g3
sg10
g11
sg12
g3
sg13
g172
sg15
g3
sg16
g3
sg17
g3
sg19
g20
sa(dp188
g2
g3
sg4
g3
sg6
g3
sg7
g3
sg8
g3
sg10
g11
sg12
g3
sg13
g172
sg15
g3
sg16
g3
sg17
g3
sg19
g20
sa(dp189
g2
g3
sg4
g3
sg6
g3
sg7
g3
sg8
g3
sg10
g11
sg12
g3
sg13
g172
sg15
g3
sg16
g3
sg17
g3
sg19
g20
sa(dp190
g2
g3
sg4
g3
sg6
g3
sg7
g3
sg8
g3
sg10
g11
sg12
g3
sg13
g172
sg15
g3
sg16
g3
sg17
g3
sg19
g20
sa(dp191
g2
g3
sg4
g3
sg6
g3
sg7
g3
sg8
g3
sg10
g11
sg12
g3
sg13
g172
sg15
g3
sg16
g3
sg17
g3
sg19
g20
sa(dp192
g2
g3
sg4
g3
sg6
g3
sg7
g3
sg8
g3
sg10
g11
sg12
g3
sg13
g172
sg15
g3
sg16
g3
sg17
g3
sg19
g20
sa(dp193
g2
g3
sg4
g3
sg6
g3
sg7
g3
sg8
g3
sg10
g11
sg12
g3
sg13
g172
sg15
g3
sg16
g3
sg17
g3
sg19
g20
sa(dp194
g2
g3
sg4
g3
sg6
g3
sg7
g3
sg8
g3
sg10
g11
sg12
g3
sg13
g172
sg15
g3
sg16
g3
sg17
g3
sg19
g20
sa(dp195
g2
g3
sg4
g3
sg6
g3
sg7
g3
sg8
g3
sg10
g11
sg12
g3
sg13
g172
sg15
g3
sg16
g3
sg17
g3
sg19
g20
sa(dp196
g2
g3
sg4
g3
sg6
g3
sg7
g3
sg8
g3
sg10
g60
sg12
g3
sg13
g172
sg15
g3
sg16
g3
sg17
g3
sg19
g20
sa(dp197
g2
g3
sg4
S' 1. The on-chip boot-loader software can be updated via ISP to correct this issue. The boot loader update files can be downloaded here: http://www.nxp.com/files/products/standard/microcontrollers/utilities/lpc2000_bl_update.zip The boot-loader version can be read out using the NXP Flash ISP Utility which can be found here: http://www.nxp.com/files/products/standard/microcontrollers/utilities/lpc2000_flash_utility.zip 2. Limiting the external clock frequency to 12 MHz AND making sure the on-chip PLL is turned OFF while programming any part of the Flash memory reduces the likelihood of the occurrence significantly. During In-System-Programming the PLL is turned off by default. ES_LPC2109_19_29_00 . \xc2\xa9   Rev. 3 \xe2\x80\x94 1 April 2011 5 of 25  ES_LPC21x9; LPC21x9/00  LPC21x9; LPC21x9/00 '
p198
sg6
g3
sg7
g3
sg8
S' The Flash memory on the LPC2119/29 offers In-Application Programming (IAP) functionality. The IAP routines are part of the on-chip boot loader software, which controls the interface between the digital logic and the Flash memory. Please note that all programming methods (JTAG, ISP, IAP) use IAP calls.  Due to a timing problem in the interface between the Flash block and the digital logic the following problem may occur: If the boot loader revision in the device is previous to V1.63 then in up to 10 % of the devices the Flash memory interface, at some point during an IAP programming or erase operation, may never return from the IAP call. Please note that devices that pass the IAP programming are functional and do not suffer from any long-term reliability problems. LPC2119 devices with a date code prior to 0423 (manufactured before week 23 in 2004) or LPC2129 devices with a date code prior to 0425 (manufactured before week 25 in 2004) are generally affected by this problem unless you receive devices with updated boot loader software from your distributor. Parts marked with a date code later than 0423 (LPC2119) or 0425 (LPC2129) are not affected by this problem. Please refer to page 3 of this document for details on how to identify the date code. '
p199
sg10
g11
sg12
g3
sg13
S'LPC2119'
p200
sg15
g3
sg16
g3
sg17
S'3.1 IAP.1: Flash memory programming interface timing problem '
p201
sg19
g20
sa(dp202
g2
g3
sg4
S' Ignore the first conversion, always check the CHN bits to confirm the channel converted. '
p203
sg6
g3
sg7
g3
sg8
S' In burst mode the A/D converter does repeated conversions at the rate selected by the CLKS field in the ADCR, scanning (if necessary) through the pins selected by 1s in the SEL field. The first conversion after the start corresponds to the least-significant 1 in the SEL field, then higher numbered 1-bits (pins) if applicable. Repeated conversions can be terminated by clearing this bit.  In burst conversion mode, the first two conversions (after setting the mode) will be of the same, lowest-numbered, of the selected channels. '
p204
sg10
g11
sg12
g3
sg13
g200
sg15
g3
sg16
g3
sg17
S'3.2 ADC.1: First two ADC conversions in burst mode from same channel '
p205
sg19
g20
sa(dp206
g2
g3
sg4
S' Set the BURST/START bit(s) after setting the SEL bits. ES_LPC2109_19_29_00 . \xc2\xa9   Rev. 3 \xe2\x80\x94 1 April 2011 6 of 25  ES_LPC21x9; LPC21x9/00  LPC21x9; LPC21x9/00 '
p207
sg6
g3
sg7
g3
sg8
S' The ADCR SFR contains bits to enable the ADC burst mode (BURST), start the conversion in software control mode (START), and to select the channel to begin converting (SEL).  In burst mode, If the BURST bit is set before or simultaneously to (using the STR instruction for example), the SEL bits, then the first channel converted will correspond to the previous SEL bit settings. In software control mode (only when using external trigger), if the START bits are set before or simultaneously to (using the STR instruction for example) the SEL bits, then the first channel converted will correspond to the previous SEL bit settings. '
p208
sg10
g11
sg12
g3
sg13
g200
sg15
g3
sg16
g3
sg17
S'3.3 ADC.2: First conversion from channel specified by previous SEL setting '
p209
sg19
g20
sa(dp210
g2
g3
sg4
S' None. Do not use the sampling patterns \xe2\x80\x98channel 2 only\xe2\x80\x99 or \xe2\x80\x98channels 1 and 2\xe2\x80\x99. This problem has no effect on software conversion, nor on any other patterns other than the two noted above. '
p211
sg6
g3
sg7
g3
sg8
S' In hardware scan mode multiple ADC channels may be selected as part of the scan by selecting the appropriate bits in the SEL field in the ADCR register.  Certain hardware scanning patterns for the A/D Converter do not operate properly. Selecting channel 2 only leads to alternate sampling of channels 2 and 3. Selecting channels 1 and 2 leads to sampling channel 1 for the first conversion, then sampling channel 2 on every subsequent conversion. '
p212
sg10
g11
sg12
g3
sg13
g200
sg15
g3
sg16
g3
sg17
S'3.4 ADC.3: Incorrect scan pattern '
p213
sg19
g20
sa(dp214
g2
g3
sg4
S' Clear the PDN bit in the ADCR SFR to turn off the ADC prior to setting the PD bit in PCON. ES_LPC2109_19_29_00 . \xc2\xa9   Rev. 3 \xe2\x80\x94 1 April 2011 7 of 25  ES_LPC21x9; LPC21x9/00  LPC21x9; LPC21x9/00 '
p215
sg6
g3
sg7
g3
sg8
S' Setting the PD bit (bit 1) in PCON stops all clocks and powers down the peripherals. The ADC is powered down by clearing the PDN bit (bit 21) in the ADCR register, setting the bit powers up (enables) the ADC.  If the PDN in ADCR is set, setting the PD bit in PCON will not power down the ADC. '
p216
sg10
g11
sg12
g3
sg13
g200
sg15
g3
sg16
g3
sg17
S'3.5 ADC.4: Global power down does not power down the ADC '
p217
sg19
g20
sa(dp218
g2
g3
sg4
S' Clear the selected CAP/MAT signal for EDGE = 0 or set the selected CAP/MAT signal for EDGE = 1 before writing 010-111 to START field. Alternatively, discard the first conversion after writing to the start bits. '
p219
sg6
g3
sg7
g3
sg8
S' When the START field of the ADCR register contains 010-111 the EDGE bit in ADCR will determine whether a conversion is started on a rising or falling edge of the selected CAP/MAT signal. EDGE=0 selects rising edge detection, EDGE=1 selects falling edge detection (On CAP/MAT pin).  If the state of the selected CAP/MAT signal is 1 and EDGE is set to detect rising edges (EDGE = 0) or, if detection of falling edges is selected (EDGE = 1) and the state of the selected CAP/MAT signal is 0, an ADC conversion will immediately be initiated when the START bits are written to. So the first conversion behaves as a level triggered event rather than edge triggered. '
p220
sg10
g11
sg12
g3
sg13
g200
sg15
g3
sg16
g3
sg17
S'3.6 ADC.5: Edge triggered ADC conversion start error '
p221
sg19
g20
sa(dp222
g2
g3
sg4
S' Do not write to ADCR until the conversion is complete. '
p223
sg6
g3
sg7
g3
sg8
S' Writing to ADCR while a conversion is in progress should set the DONE bit and start a new conversion.  In actuality, if the ADCR is written to within 2.5 ADC_clock cycles, a new conversion is started but the DONE bit is not set. If the ADCR is written to after 2.5 ADC_clocks, but within a conversion time, the DONE bit is set within one ADC_clock and a new conversion is started. '
p224
sg10
g11
sg12
g3
sg13
g200
sg15
g3
sg16
g3
sg17
S'3.7 ADC.6: Writing to ADCR while conversion in progress '
p225
sg19
g20
sa(dp226
g2
g3
sg4
S' Avoid writing to SPI registers while transmissions are in progress or while SPI interrupts are pending. ES_LPC2109_19_29_00 . \xc2\xa9   Rev. 3 \xe2\x80\x94 1 April 2011 8 of 25  ES_LPC21x9; LPC21x9/00  LPC21x9; LPC21x9/00 '
p227
sg6
g3
sg7
g3
sg8
S' The SPI interrupt flag is set by the SPI interface to generate an interrupt. It is cleared by writing a 1 to this bit.  A write to any register associated with the SPI peripheral will clear the SPI interrupt register. '
p228
sg10
g11
sg12
g3
sg13
g200
sg15
g3
sg16
g3
sg17
S'3.8 SPI.1: Unintentional clearing of SPI interrupt flag '
p229
sg19
g20
sa(dp230
g2
g3
sg4
S' There are two possible workarounds: 1. Use CPHA=1. 2. If the data is shifted incorrectly when CPHA is set to 0 then delaying the write to SPDR after the half SCK cycle of the last sampling clock would resolve this issue. '
p231
sg6
g3
sg7
g3
sg8
S' In slave mode, the SPI can set the clock phase (CPHA) to 0 or 1.  Consider the following conditions: 1. SPI is configured as a slave (with CPHA=0). 2. SPI is running at a low frequency. In slave mode, the SPIF (SPI Transfer Complete Flag) bit is set on the last sampling edge of SCK. If CPHA is set to 0 then the last sampling edge of SCK would be the rising edge. Under the above conditions, if the SPI Data Register (SPDR) is written to less than a half SCLK cycle after the SPIF bit is set (this would happen if the SPI frequency is low) then the SPDR will shift data one clock early for the upcoming transfers. Lowering the SPI frequency would increase the likelihood of the SPDR write happening in the first half SCK cycle of the last sampling clock. '
p232
sg10
g11
sg12
g3
sg13
g200
sg15
g3
sg16
g3
sg17
S'3.9 SPI.2: Incorrect shifting of data in slave mode at lower frequencies '
p233
sg19
g20
sa(dp234
g2
g3
sg4
S' If VPBDIV is non-zero, write all zeroes to VPBDIV before reading or writing EXTMODE or EXTPOLAR, then write the proper value back to VPBDIV. In most applications this is a known and fixed value, but if there is a possibility of dynamic changes in VPBDIV, software will need to read VPBDIV, write zero to VPBDIV, read or write EXTMODE and/or EXTPOLAR, and then rewrite the value previously read from VPBDIV. ES_LPC2109_19_29_00 . \xc2\xa9   Rev. 3 \xe2\x80\x94 1 April 2011 9 of 25  ES_LPC21x9; LPC21x9/00  LPC21x9; LPC21x9/00 '
p235
sg6
g3
sg7
g3
sg8
S' The VPBDIV register controls the rate of the VPB clock in relation to the processor clock. EXTPOLAR and EXTMODE determine the operating parameters of the external interrupts.  A write to either the external interrupt polarity register (EXTPOLAR) or the external interrupt mode register (EXTMODE) will corrupt the VPBDIV register. A read of either EXTPOLAR or EXTMODE will be corrupted BY the VPBDIV register. If VPBDIV is \xe2\x80\x9c1\xe2\x80\x9d or \xe2\x80\x9c2\xe2\x80\x9d prior to any write to EXTPOLAR or EXTMODE, the CPU will hang up on the write to EXTPOLAR or EXTMODE. '
p236
sg10
g11
sg12
g3
sg13
g200
sg15
g3
sg16
g3
sg17
S'3.10 EXTINT.1: Corruption of VPBDIV via EXTPOLAR or EXTMODE '
p237
sg19
g20
sa(dp238
g2
g3
sg4
S' This problem is related to EXTINT.1 and hence the same workaround applies with an additional step. The steps involved in the configuration of the EXTMODE and/or EXTPOLAR would be as follows: 1. Write 0x0 to VPBDIV 2. Write the desired value to EXTMODE or EXTPOLAR register 3. Write the same value to VPBDIV (additional step) 4. Restore the VPBDIV to the previously saved value or simply write to the register again with the desired value. Code sample for setting EXTMODE and EXTPOLAR to 0x1: VPBDIV = 0x0; /* EXTMODE */ EXTMODE = 0x1; VPBDIV = 0x1; VPBDIV = 0x0; /* EXTPOLAR */ EXTPOLAR = 0x1; VPBDIV = 0x1; VPBDIV = 0x0; /* Setting VPBDIV */ Note: While testing this in a debugger environment, please don\xe2\x80\x99t single-step through these steps. A breakpoint could be placed after Step 4 and you would see the EXTMODE and EXTPOLAR registers reflecting the correct values. '
p239
sg6
g3
sg7
g3
sg8
S' EXTPOLAR and EXTMODE determine the operating parameters of the external interrupts.  As an illustration, trying to set EXTMODE to 0x1 or 0xd would result in EXTMODE to be set to 0x0 instead. '
p240
sg10
g11
sg12
g3
sg13
g200
sg15
g3
sg16
g3
sg17
S'3.11 EXTINT.2: Incorrect setting of EXTMODE and/or EXTPOLAR register while trying to set them to desired value '
p241
sg19
g20
sa(dp242
g2
g3
sg4
S' To use P0.21 as capture 1.3, PINSEL(7:6) must also be set to \xe2\x80\x9811\xe2\x80\x99 which means that P0.19 must be selected as capture input 1.2. ES_LPC2109_19_29_00 . \xc2\xa9   Rev. 3 \xe2\x80\x94 1 April 2011 10 of 25  ES_LPC21x9; LPC21x9/00  LPC21x9; LPC21x9/00 '
p243
sg6
g3
sg7
g3
sg8
S' P0.21 and P0.19 may be configured as capture inputs via the PINSEL register.  When PINSEL(11:10) is set to \xe2\x80\x9911\xe2\x80\x99 P0.21 is not internally connected as capture 1.3 '
p244
sg10
g11
sg12
g3
sg13
g200
sg15
g3
sg16
g3
sg17
S'3.12 CAP.1: Problem when selecting P0.21 as a capture 1.3 input (timer1) '
p245
sg19
g20
sa(dp246
g2
g3
sg4
S' Performing two consecutive reads of the VPBDIV assures that the correct value is returned. '
p247
sg6
g3
sg7
g3
sg8
S' The Peripheral Bus Divider (VPBDIV) divides the processor clock (CCLK) by one, two, or four. This is the clock that is provided to the peripheral bus.  Reading the VPBDIV register may return an incorrect value. '
p248
sg10
g11
sg12
g3
sg13
g200
sg15
g3
sg16
g3
sg17
S'3.13 VPBDIV.1: Incorrect read of VPBDIV '
p249
sg19
g20
sa(dp250
g2
g3
sg4
S' In a system that does not use Thumb state, there will be no problem. In a system that uses Thumb state but does not use data aborts, or does not try to use data aborts in a recoverable manner, there will be no problem. Otherwise the workaround is to ensure that a STR, STMIA or PUSH cannot precede a PC-relative load. One method for this is to add a NOP before any PC-relative load instruction. However this would have to be done manually. ES_LPC2109_19_29_00 . \xc2\xa9   Rev. 3 \xe2\x80\x94 1 April 2011 11 of 25  ES_LPC21x9; LPC21x9/00  LPC21x9; LPC21x9/00 '
p251
sg6
g3
sg7
g3
sg8
S' If the processor is in Thumb state and executing the code sequence STR, STMIA or PUSH followed by a PC relative load, and the STR, STMIA or PUSH is aborted, the PC is saved to the abort link register.  In this situation the PC is saved to the abort link register in word resolution, instead of half-word resolution. Conditions: The processor must be in Thumb state, and the following sequence must occur: <any instruction> <STR, STMIA, PUSH> <---- data abort on this instruction LDR rn, [pc,#offset] In this case the PC is saved to the link register R14_abt in only word resolution, not half-word resolution. The effect is that the link register holds an address that could be #2 less than it should be, so any abort handler could return to one instruction earlier than intended. '
p252
sg10
g11
sg12
g3
sg13
g200
sg15
g3
sg16
g3
sg17
S'3.14 Core.1: Incorrect update of the Abort Link register in Thumb state '
p253
sg19
g20
sa(dp254
g2
g3
sg4
S' There is no clear workaround for this problem but some of the below mentioned solutions could work with some applications. Possible work-around\xe2\x80\x99s for Match functionality: 1. If the application only needs two Match registers then distribute them between Timer 0 and Timer 1 to avoid this problem. 2. Stop the timer before accessing the Interrupt register for clearing the interrupt and then start timer again after the access is completed. 3. Polling for interrupt: Supposing that there are two Match events (Match X and Match Y). At the end of the Interrupt Service Routine (ISR) for Match X, compare the Timer Counter value with the Match Register Y value. If the Timer Counter value is more than the Match Register Y value then it is possible that this event might have been missed. In this case jump to the ISR directly and service Match event Y. Possible workarounds for Capture functionality: 1. Try to spread the capture events between both timers if there are two capture events. If the application also has a match event then one of the capture events may suffer. 2. Polling for Capture: At the end of a Match interrupt ISR or Capture event ISR compare the previous Capture value with the current Capture value. If the Capture value has changed then the Capture event might have been missed. In this case, jump to the ISR directly and service the Capture event. '
p255
sg6
g3
sg7
g3
sg8
S' The Timers may be configured so that events such as Match and Capture, cause interrupts. Bits in the Interrupt Register (IR) indicate the source of the interrupt, whether from Capture or Match.  If more than one interrupt for multiple Match events using the same Timer are enabled, it is possible that one of the match interrupts may not be recognized. If this occurs no more interrupts from that specific match register will be recognized. This could happen in a scenario where the match events are very close to each other. This issue also affects the Capture functionality. Specific details: Suppose that two match events are very close to each other (Say Match0 and Match1). Also assume that the Match0 event occurs first. When the Match0 interrupt occurs the 0th bit of the Interrupt Register will be set. To exit the Interrupt Service Routine of Match0, this bit has to be cleared in the Interrupt Register. The clearing of this bit might be done by using the following statement: T0_IR = 0x1; It is possible that software will be writing a 1 to bit 0 of the Interrupt Register while a Match1 event occurs, meaning that hardware needs to set the bit 1 of the Interrupt Register. In this case, since hardware is accessing the register at the same time as software, bit 1 for Match1 never gets set, causing the interrupt to be missed. In summary, while software is writing to the Interrupt Register, any Match or Capture event (which are configured to interrupt the core) occurring at the same time may result in the subsequent interrupt not being recognized. Similarly for the Capture event, if a capture event occurs while a Match event is being is serviced then the Capture event might be missed if the software and hardware accesses coincide. Affected features: 1. Interrupt on Match for Timer0/1. 2. Interrupt on Capture for Timer0/1. 3. These same features will be affected when using PWM. ES_LPC2109_19_29_00 . \xc2\xa9   Rev. 3 \xe2\x80\x94 1 April 2011 12 of 25  ES_LPC21x9; LPC21x9/00  LPC21x9; LPC21x9/00 '
p256
sg10
g11
sg12
g3
sg13
g200
sg15
g3
sg16
g3
sg17
S'3.15 TIMER.1: Missed Interrupt Potential '
p257
sg19
g20
sa(dp258
g2
g3
sg4
g3
sg6
g3
sg7
g3
sg8
g3
sg10
g11
sg12
g3
sg13
g200
sg15
g3
sg16
g3
sg17
S'3.16 PWM.1: Missed Interrupt Potential for the Match functionality. The description is the same as above.'
p259
sg19
g20
sa(dp260
g2
g3
sg4
S' Only P0.27 can be used for Match 0.1. ES_LPC2109_19_29_00 . \xc2\xa9   Rev. 3 \xe2\x80\x94 1 April 2011 13 of 25  ES_LPC21x9; LPC21x9/00  LPC21x9; LPC21x9/00 '
p261
sg6
g3
sg7
g3
sg8
S' Timer0 has four external match outputs corresponding to match registers with various capabilities. Match 0.0 can be configured as an alternate function on P0.3 and P0.22. Match 0.1 can be configured as an alternate function on Port 0.5 and P0.27. The alternate functions can be configured by using the respective PINSELx register.  Match 0.0 should have been only connected to P0.3 and P0.22 but it is also connected to P0.5. Match 0.1 is only connected to P0.27. Hence if the application configures the External Match alternate function on both P0.3 (Match 0.0) and P0.5 (Match 0.1) then the Match 0.0 output can be seen on two port pins, namely P0.3 and P0.5. '
p262
sg10
g11
sg12
g3
sg13
g200
sg15
g3
sg16
g3
sg17
S'3.17 Timer0.1: Match 0.1 output cannot be seen on port pin P0.5 if configured as an alternate function. '
p263
sg19
g20
sa(dp264
g2
g3
sg4
S' IIR reading: The IIR bug can be worked around by disabling the modem status interrupt effectively making THRE the lowest priority interrupt. The work-around does not work in software interrupt polling mode. Modem status has to be handled by software polling MSR. Now there are two cases: 1. A THRE interrupt is pending, software responds to the interrupt by reading the IIR while another, higher priority interrupt is set (e.g. RDA). In this case software will read the THRE status although the status will not be cleared where it should have been. After handling the THRE and RDA interrupt another dummy THRE interrupt may occur, unless in the meantime software has filled THR. This is considered an error although not fatal. ES_LPC2109_19_29_00 . \xc2\xa9   Rev. 3 \xe2\x80\x94 1 April 2011 14 of 25  ES_LPC21x9; LPC21x9/00  LPC21x9; LPC21x9/00 2. A high priority interrupt is pending, software responds to the interrupt by reading the IIR register while a THRE interrupt is set. In this case, software will read the higher priority interrupt and the THRE interrupt will be handled later. This behavior is as expected. LSR reading: A work-around for this problem is to service the OE/PE/FE/BI condition before another character is received which will trigger an LSR update. So basically, service the interrupt in one-character time. MSR reading: The MSR bug can be worked-around by not using the Delta DCD/Trailing Edge RI/Delta DSR/Delta CTS bits in the MSR but instead use the DCD/TRI/DSR/CTS bits in the same register. To prevent, a transition from being missed software should poll the register\xe2\x80\x99s value at a sufficiently high rate. '
p265
sg6
g3
sg7
g3
sg8
S' Reading the contents of the IIR,LSR and MSR registers will clear certain bits in the register. 1. Reading the IIR should clear the THRE status if THRE is the highest priority pending interrupt (Only affects UART1). 2. Reading LSR should clear the OE/PE/FE/BI bits (affects both UART0 and UART1). 3. Reading MSR should clear the Delta DCD/Trailing Edge RI/Delta DSR/Delta CTS bits (Only affects UART1).  If hardware is setting one of these above bits while the software is reading the contents of the register the reading process clears all bits in the register including the bit that got set by hardware. The software reads the old value though and the bit that got set by hardware is lost. Specific details: Suppose IIR has a modem status interrupt while the other interrupts are inactive and software reads the IIR value (polling) while hardware sets the THRE interrupt then software will read the Modem Interrupt value while the THRE interrupt is cleared i.e the THRE interrupt is lost. Suppose the LSR is all zeros and software is reading the register while hardware is generating a parity error then the parity error bit is cleared while the software reads the old value (all zeros) i.e. the parity error is lost. Suppose MSR is all zeros and software is polling the value of the register while the value of CTS is changing then the change in CTS value should result in the Delta CTS bit getting set. Instead software will read all zeros and the Delta CTS bit in the MSR register will be cleared i.e. the Delta CTS status is lost. '
p266
sg10
g11
sg12
g3
sg13
g200
sg15
g3
sg16
g3
sg17
S'3.18 UART.1: Coinciding VPB read and hardware register update '
p267
sg19
g20
sa(dp268
g2
g3
sg4
S' CAN bus pins may be tied to external interrupt inputs which will wake the part from power-down. '
p269
sg6
g3
sg7
g3
sg8
S' The CAN interface may be configured such that activity on the CAN bus lines will wake the part from power-down mode.  CAN bus activity fails to wake the part from power-down. '
p270
sg10
g11
sg12
g3
sg13
g200
sg15
g3
sg16
g3
sg17
S'3.19 CAN.1: CAN bus activity does not wake from power-down mode '
p271
sg19
g20
sa(dp272
g2
g3
sg4
S' None, the SM bit cannot be used as a source of CAN wakeup. ES_LPC2109_19_29_00 . \xc2\xa9   Rev. 3 \xe2\x80\x94 1 April 2011 15 of 25  ES_LPC21x9; LPC21x9/00  LPC21x9; LPC21x9/00 '
p273
sg6
g3
sg7
g3
sg8
S' The CAN Controller will enter sleep mode if the SM bit in the CAN Mode register is set to 1, no CAN interrupt is pending, and there is no activity on the CAN bus. The CAN Controller wakes up (and sets the WUI bit in the CAN Interrupt register if the WUIE bit in the CAN Interrupt Enable register is set to 1), in response to a dominant bit on the CAN bus or software clearing the SM bit in the CAN Mode register.  Clearing the SM bit does not cause the CAN module to wakeup from CAN sleep mode. '
p274
sg10
g11
sg12
g3
sg13
g200
sg15
g3
sg16
g3
sg17
S'3.20 CAN.2: No wake-up from CAN sleep mode using SM bit '
p275
sg19
g20
sa(dp276
g2
g3
sg4
S' 1. The CPU should not access the LUT during operation. Since the FullCAN mode would cause the CPU to access the LUT during operation, the problem does not occur when the FullCAN mode is not used. 2. Do not enable/disable the Message Identifiers in the LUT while the CAN module is enabled. '
p277
sg6
g3
sg7
g3
sg8
S' In FullCAN mode, CAN messages are automatically stored in a special section of the LUT RAM. In the Acceptance filter Look-Up Table, CAN message identifiers can be enabled/disabled by clearing/setting the Message Disable bit.  When the CPU accesses the LUT while a message is being received, the Acceptance Filter may not work correctly and messages can be lost. '
p278
sg10
g11
sg12
g3
sg13
g200
sg15
g3
sg16
g3
sg17
S'3.21 CAN.3: Shared access for Identifier Look-Up Table (LUT) '
p279
sg19
g20
sa(dp280
g2
g3
sg4
S' Use any one Transmit buffer only (Use either Transmit Buffer 1, Transmit Buffer 2 or Transmit Buffer 3 exclusively). The buffer you decided to use should be loaded only when there is no pending transmission. '
p281
sg6
g3
sg7
g3
sg8
S' The CAN block provides three transmit buffers. Each of them has a length of four 32-bit words and is able to store one complete CAN message.  The Triple Transmit Buffer function cannot be used. '
p282
sg10
g11
sg12
g3
sg13
g200
sg15
g3
sg16
g3
sg17
S'3.22 CAN.4: Triple Transmit Buffer function not working correctly '
p283
sg19
g20
sa(dp284
g2
g3
sg4
S' Two possible workarounds are possible: ES_LPC2109_19_29_00 . \xc2\xa9   Rev. 3 \xe2\x80\x94 1 April 2011 16 of 25  ES_LPC21x9; LPC21x9/00  LPC21x9; LPC21x9/00 1. After exiting the Reset Mode, before sending the first actual message, a dummy message should be transmitted with identifier 0x0 (Standard Frame Format). This message should be transmitted by setting both the Self Reception Request bit and the Abort Transmission bit in the Command register simultaneously. (Note: CAN Identifier 0x0 should not be used in the application) 2. If CAN Identifier 0x0 is used by the application then the above workaround cannot be used. This second workaround is not applicable to CAN Controller 1 since this solution needs the TDx pin to be shared with a port pin. Before normal operation is started: 1. Initialize the CAN Controller and Acceptance Filter. 2. Load CAN Transmit Buffer with a CAN message. Make sure that the Acceptance filter is configured to receive this message. 3. Switch P0.xx/TD pin to Port function by configuring the appropriate bits in the PINSELx register. 4. Start transmission of a message with the Single Shot Transmission and Self Reception Command (Command=0x12). 5. Wait until message is received (configure Receive Interrupt). 6. Switch P0.xx/TD pin function back to TD function. Continue with normal operation. Please note that the Transmit Buffer used for initial message must be used for all further CAN transmissions (see CAN.4). '
p285
sg6
g3
sg7
g3
sg8
S' In Reset Mode, the CAN operations are disabled and writable registers can be written. If an Abort Transmission command is issued then a pending transmission request is cancelled if not already in progress.  Normal operation cannot be resumed after reset or abort transmission without using one of the workarounds below. '
p286
sg10
g11
sg12
g3
sg13
g200
sg15
g3
sg16
g3
sg17
S'3.23 CAN.5: Handling Reset Mode and Abort Transmission '
p287
sg19
g20
sa(dp288
g2
g3
sg4
S' Add two disabled dummy message identifiers to the last possible address of the 2K LUT RAM (address 0xE003 87FC). Also, if an explicit Standard Frame Format section is enabled, add two disabled dummy message identifiers at the end of that section. '
p289
sg6
g3
sg7
g3
sg8
S' When a syntax error in the LUT is encountered, the LUT address of the incorrect line is reported in the LUTerrAd register  If there is a syntax error then the address line is not reported and the acceptance filtering is disabled. '
p290
sg10
g11
sg12
g3
sg13
g200
sg15
g3
sg16
g3
sg17
S'3.24 CAN.6: Look-up Table Error Address (LUTerrAd) register does not function. '
p291
sg19
g20
sa(dp292
g2
g3
sg4
S' Use the Self Reception Request command instead of the Transmission Request command. However, it has to be taken into account that now all transmitted messages may be received if not prevented by appropriate Acceptance Filter settings. (Don\xe2\x80\x99t set up Acceptance Filter Message Identifiers for the messages you are transmitting yourself.) ES_LPC2109_19_29_00 . \xc2\xa9   Rev. 3 \xe2\x80\x94 1 April 2011 18 of 25  ES_LPC21x9; LPC21x9/00  LPC21x9; LPC21x9/00 '
p293
sg6
g3
sg7
g3
sg8
S' The CAN module can lose arbitration to another CAN node during an attempt to transmit a CAN message. The message of the CAN node the arbitration was lost to is supposed to be received correctly by the CAN module.  ES_LPC2109_19_29_00 . \xc2\xa9   Rev. 3 \xe2\x80\x94 1 April 2011 17 of 25  ES_LPC21x9; LPC21x9/00  LPC21x9; LPC21x9/00 Messages might not be received correctly if during a CAN Transmission the CAN bus arbitration is lost to another CAN node. '
p294
sg10
g11
sg12
g3
sg13
g200
sg15
g3
sg16
g3
sg17
S'3.25 CAN.7: Receiving messages while arbitration is lost. '
p295
sg19
g20
sa(dp296
g2
g3
sg4
g3
sg6
g3
sg7
g3
sg8
g3
sg10
g11
sg12
g3
sg13
g200
sg15
g3
sg16
g3
sg17
S'3.26 Reset.1: Device does not power up correctly under certain internal conditions Problem: If certain rare chip-internal conditions are met, the device will not start up correctly when executing a power-on reset. The crystal oscillator will be running but the device will not execute code. Work-around: Apply a second (warm) reset pulse (without power-on cycle). The minimum time requirement between the first (unsuccessful) reset and the second reset is 4105 external oscillator clock cycles, which means that the assertion of the second reset should occur 4105 cycles or more after the deassertion of the first reset. For example, at 10 MHz, this is equal to 411 \xef\x81\xads; at 20 MHz, this is equal to 206 \xef\x81\xads. This can be achieved by using an external watchdog timer or by any other circuitry in the application that is able to assert a second reset pulse. The root cause for this problem has been identified and will be fixed from Revision B of this device onwards. This problem will also be fixed in the LPC21x9/00 version of this device which will have a dedicated order number (LPC21x9FBD64/00). ES_LPC2109_19_29_00 . \xc2\xa9   Rev. 3 \xe2\x80\x94 1 April 2011 19 of 25  ES_LPC21x9; LPC21x9/00  LPC21x9; LPC21x9/00'
p297
sg19
g20
sa(dp298
g2
g3
sg4
S' In software-controlled mode (BURST bit is 0), the START conversion options (bits 26:24 set to 0x1 or 0x4 or 0x5 or 0x6 or 0x7) can be used. The user can also start a conversion by connecting an external trigger signal to a capture input pin (CAPx) from a Timer peripheral to generate an interrupt. The timer interrupt routine can then start the ADC conversion by setting the START bits (26:24) to 0x1. The trigger can also be generated from a timer match register. ES_LPC2109_19_29_00 . \xc2\xa9   Rev. 3 \xe2\x80\x94 1 April 2011 20 of 25  ES_LPC21x9; LPC21x9/00  LPC21x9; LPC21x9/00 4. AC/DC deviations detail '
p299
sg6
g3
sg7
g3
sg8
S' In software-controlled mode (BURST bit is 0), the 10-bit ADC can start conversion by using the following options in the A/D Control Register: Fig 1. A/D control register options  The external start conversion feature, ADCR:START = 0x2 or 0x3, may not work reliably and ADC external trigger edges on P0.16 or P0.22 may be missed. The occurrence of this problem is peripheral clock (pclk) dependent. The probability of error (missing a ADC trigger from GPIO) is estimated as follows: \xe2\x80\xa2 For PCLK_ADC = 60 MHz, probability error = 12 % \xe2\x80\xa2 For PCLK_ADC = 50 MHz, probability error = 6 % \xe2\x80\xa2 For PCLK_ADC = 12 MHz, probability error = 1.5 % The probability of error is not affected by the frequency of ADC start conversion edges. '
p300
sg10
g11
sg12
g3
sg13
g200
sg15
g3
sg16
g3
sg17
S'3.27 ADC.7: External sync inputs not operational '
p301
sg19
g20
sa(dp302
g2
g3
sg4
S' Make sure that high logic levels are at least 2.4 V at these pins. '
p303
sg6
g3
sg7
g3
sg8
S' The specified, minimum, value for VIH is 2.0 V.  Any pin associated with either an external interrupt input or an analog to digital converter (ADC) input has a VIH of 2.4 V, not 2.0 V. The pins that are affected are the ones that can be configured as either an ADC input or and external interrupt input, not just the ones that are configured as such. '
p304
sg10
g11
sg12
g3
sg13
g200
sg15
g3
sg16
g3
sg17
S'4.1 VIH.1: Incompatibility of actual VIH levels as compared to those specified '
p305
sg19
g20
sa(dp306
g2
g3
sg4
S' None.'
p307
sg6
g3
sg7
g3
sg8
S' V3 is the power supply voltage for the I/O ports. External interrupt pins are general purpose interrupt pins which are level and edge sensitive. They can optionally wake up the device from power down mode. The ADC block can produce 10-bit samples with conversion time as low as 2.44 us.  If the external interrupt and/or ADC pins are pulled higher than 1.8 V then it will lead to increased current consumption from V3. If V3 is 3.0 V and V1.8 is 1.8 V then the leakage current will increase to a typical number of 200 uA (per pin). Note: The ADC pins won\xe2\x80\x99t contribute to the leakage if they are not configured as digital inputs using the PINSELx register. External interrupt pins will contribute to the leakage irrespective of their pin configuration. '
p308
sg10
g60
sg12
g3
sg13
g200
sg15
g3
sg16
g3
sg17
S'4.2 V3.1: Leakage current on V3 due to External Interrupt and/or Analog to Digital Converter (ADC) pins. '
p309
sg19
g20
sa(dp310
g2
g3
sg4
S' In software-controlled mode (BURST bit is 0), the START conversion options (bits 26:24 set to 0x1 or 0x4 or 0x5 or 0x6 or 0x7) can be used. The user can also start a conversion by connecting an external trigger signal to a capture input pin (CAPx) from a Timer peripheral to generate an interrupt. The timer interrupt routine can then start the ADC conversion by setting the START bits (26:24) to 0x1. The trigger can also be generated from a timer match register. ES_LPC2470_78 . \xc2\xa9 NXP B.V. 2012. All rights reserved.  Rev. 8.1 \xe2\x80\x94 1 July 2012 5 of 13  ES_LPC2470_78  LPC2470/78 '
p311
sg6
g3
sg7
g3
sg8
S' In software-controlled mode (BURST bit is 0), the 10-bit ADC can start conversion by using the following options in the A/D Control Register: Fig 1. A/D control register options  The external start conversion feature, AD0CR:START = 0x2 or 0x3, may not work reliably and ADC external trigger edges on P2.10 or P1.27 may be missed. The occurrence of this problem is peripheral clock (pclk) dependent. The probability of error (missing a ADC trigger from GPIO) is estimated as follows: \xe2\x80\xa2 For PCLK_ADC = 72 MHz, probability error = 12 % \xe2\x80\xa2 For PCLK_ADC = 50 MHz, probability error = 6 % \xe2\x80\xa2 For PCLK_ADC = 12 MHz, probability error = 1.5 % The probability of error is not affected by the frequency of ADC start conversion edges. '
p312
sg10
g11
sg12
g3
sg13
S'LPC2470'
p313
sg15
g3
sg16
g3
sg17
S'3.1 ADC.1: External sync inputs not operational '
p314
sg19
g20
sa(dp315
g2
g3
sg4
S' In a system that does not use Thumb state, there will be no problem. In a system that uses Thumb state but does not use data aborts, or does not try to use data aborts in a recoverable manner, there will be no problem. Otherwise the workaround is to ensure that a STR, STMIA or PUSH cannot precede a PC-relative load. One method for this is to add a NOP before any PC-relative load instruction. However this would have to be done manually. ES_LPC2470_78 . \xc2\xa9 NXP B.V. 2012. All rights reserved.  Rev. 8.1 \xe2\x80\x94 1 July 2012 6 of 13  ES_LPC2470_78  LPC2470/78 '
p316
sg6
g3
sg7
g3
sg8
S' If the processor is in Thumb state and executing the code sequence STR, STMIA or PUSH followed by a PC relative load, and the STR, STMIA or PUSH is aborted, the PC is saved to the abort link register.  In this situation the PC is saved to the abort link register in word resolution, instead of half-word resolution. Conditions: The processor must be in Thumb state, and the following sequence must occur: <any instruction> <STR, STMIA, PUSH> <---- data abort on this instruction LDR rn, [pc,#offset] In this case the PC is saved to the link register R14_abt in only word resolution, not half-word resolution. The effect is that the link register holds an address that could be #2 less than it should be, so any abort handler could return to one instruction earlier than intended. '
p317
sg10
g11
sg12
g3
sg13
g313
sg15
g3
sg16
g3
sg17
S'3.2 Core.1: Incorrect update of the Abort Link register in Thumb state '
p318
sg19
g20
sa(dp319
g2
g3
sg4
S' Software can correct this situation in many ways; for example, sending a dummy frame after initialization. ES_LPC2470_78 . \xc2\xa9 NXP B.V. 2012. All rights reserved.  Rev. 8.1 \xe2\x80\x94 1 July 2012 7 of 13  ES_LPC2470_78  LPC2470/78 '
p320
sg6
g3
sg7
g3
sg8
S' The transmit consume index register defines the descriptor that is going to be transmitted next by the hardware transmit process. After a frame has been transmitted hardware increments the index, wrapping the value to 0 once the value of TxDescriptorNumber has been reached. If the TxConsumeIndex equals TxProduceIndex the descriptor array is empty and the transmit channel will stop transmitting until software produces new descriptors.  The TxConsumeIndex register is not updated correctly (from 0 to 1) after the first frame is sent. After the next frame sent, the TxConsumeIndex register is updated by two (from 0 to 2). This only happens the very first time, so subsequent updates are correct (even those from 0 to 1, after wrapping the value to 0 once the value of TxDescriptorNumber has been reached) '
p321
sg10
g11
sg12
g3
sg13
g313
sg15
g3
sg16
g3
sg17
S'3.3 Ethernet.1: Ethernet TxConsumeIndex register does not update correctly after the first frame is sent '
p322
sg19
g20
sa(dp323
g2
g3
sg4
S' None. ES_LPC2470_78 . \xc2\xa9 NXP B.V. 2012. All rights reserved.  Rev. 8.1 \xe2\x80\x94 1 July 2012 8 of 13  ES_LPC2470_78  LPC2470/78 '
p324
sg6
g3
sg7
g3
sg8
S' Full-/low-speed signaling uses bit stuffing throughout the packet without exception. If the receiver sees seven consecutive ones anywhere in the packet, then a bit stuffing error has occurred and the packet should be ignored. The time interval just before an EOP is a special case. The last data bit before the EOP can become stretched by hub switching skews. This is known as dribble and can lead to a situation where dribble introduces a sixth bit that does not require a bit stuff. Therefore, the receiver must accept a packet for which there are up to six full bit times at the port with no transitions prior to the EOP.  The USB host controller will hang indefinitely if it sees a dribble bit on the USB bus. It will hang the first time a dribble bit is seen. Once it is in this state there is no recovery other than a hard chip reset. This problem has no effect on the USB device controller. '
p325
sg10
g11
sg12
g3
sg13
g313
sg15
g3
sg16
g3
sg17
S'3.4 USB.1: USB host controller hangs on a dribble bit '
p326
sg19
g20
sa(dp327
g2
g3
sg4
S' The VBAT should be connected to a battery or the same supply used by rest of the device (VDD(3V3) pin, VDD(DCDC)(3V3) pin). ES_LPC2470_78 . \xc2\xa9 NXP B.V. 2012. All rights reserved.  Rev. 8.1 \xe2\x80\x94 1 July 2012 9 of 13  ES_LPC2470_78  LPC2470/78 4. AC/DC deviations detail '
p328
sg6
g3
sg7
g3
sg8
S' The device has a VBAT pin which provides power only to the Real Time Clock (RTC) and Battery RAM. VBAT can be connected to a battery or the same supply used by rest of the device (VDD(3V3) pin, VDD(DCDC)(3V3) pin). The input voltage range on the VBAT pin is 2.0 V minimum to 3.6 V maximum for temperature \xef\x80\xad40 \xef\x82\xb0C to +85 \xef\x82\xb0C. Normally, if the RTC and the Battery RAM are not used, the VBAT pin can be left floating.  If the VBAT pin is left floating, the internal reset signal within the RTC domain may get corrupted and as a result, prevents the device from starting-up. '
p329
sg10
g11
sg12
g3
sg13
g313
sg15
g3
sg16
g3
sg17
S'3.5 VBAT.1: The VBAT pin cannot be left floating '
p330
sg19
g20
sa(dp331
g2
g3
sg4
S" None ES_LPC2470_78 . \xc2\xa9 NXP B.V. 2012. All rights reserved.  Rev. 8.1 \xe2\x80\x94 1 July 2012 10 of 13  ES_LPC2470_78  LPC2470/78 4.2 IRC.2: Accuracy of the Internal RC Oscillator (IRC) frequency for devices only with date codes 0949 and before are outside of the 4 MHz +/\xef\x80\xad 1 % specification only at temperatures between \xef\x80\xad20 \xef\x82\xb0C and \xef\x80\xad40 \xef\x82\xb0C Introduction: The device has a 4 MHz internal RC oscillator (IRC) which can be optionally used as the clock source for the Watch Dog Timer (WDT), and/or as the clock that drives the PLL and subsequently the CPU. The IRC frequency spec is 4 MHz +/\xef\x80\xad 1 % accuracy over the entire voltage and temperature range. During In-System Programming (ISP), the auto-baud routine is expecting the IRC frequency to be 4 MHz +/\xef\x80\xad 1 % and is used to synchronize with the host via serial port 0. Problem: On the LPC247X Rev D device (only with date codes 0949 and before), the accuracy of internal RC oscillator (IRC) frequency does not meet the 4 MHz +/\xef\x80\xad 1 % specification for temperatures between \xef\x80\xad20 \xef\x82\xb0C and \xef\x80\xad40 \xef\x82\xb0C and the accuracy of internal RC oscillator (IRC) frequency is 4 MHz +/\xef\x80\xad 5 % instead. As a result, only at these temperatures, this may affect the auto-baud routine's ability to synchronize with the host via serial port 0 during In-System Programming (ISP) at higher baud rates. For temperatures above \xef\x80\xad20 \xef\x82\xb0C, the accuracy of internal RC oscillator (IRC) frequency meets the 4 MHz +/\xef\x80\xad 1 % specification. Work-around: None 5. Errata notes detail 5.1 Note.1 On each of the following port pins P0.23, P0.24, P0.25, P0.26, P1.30, P1.31, P0.12, and P0.13 (when configured as general purpose input pin (s)), leakage current increases when the input voltage is Vi \xef\x82\xb3 VDD I/O + 0.5 V. Care must be taken to limit the current to less than 4 mA by using a series limiting resistor. 5.2 Note.2 On the LPC2470/78 Rev D, design changes to the Memory Accelerator Module were made to enhance timing and general performance. Design changes are intended to enhance performance in general and will result in minor differences in the code execution timing between the previous device revisions and rev D. Actual performance impact is code dependent, some code sequences may speed up while other code sequences may slow down between the previous device revisions and rev D. This might be observed when using software delays and in such cases, a hardware timer should be used to generate a delay instead of a software delay. ES_LPC2470_78 . \xc2\xa9 NXP B.V. 2012. All rights reserved.  Rev. 8.1 \xe2\x80\x94 1 July 2012 11 of 13"
p332
sg6
g3
sg7
g3
sg8
S" The device has a 4 MHz internal RC oscillator (IRC) which can be optionally used as the clock source for the Watch Dog Timer (WDT), and/or as the clock that drives the PLL and subsequently the CPU. The IRC frequency spec is 4 MHz +/\xef\x80\xad 1 % accuracy over the entire voltage and temperature range. During In-System Programming (ISP), the auto-baud routine is expecting the IRC frequency to be 4 MHz +/\xef\x80\xad 1 % and is used to synchronize with the host via serial port 0.  On the LPC247X Rev C device only, the accuracy of internal RC oscillator (IRC) frequency meets 4 MHz +/\xef\x80\xad 1 % specification only at room temperature however, at extreme temperatures, the accuracy of internal RC oscillator (IRC) frequency may be 4 MHz +/\xef\x80\xad 10 %. As a result, at extreme temperatures, this may affect the auto-baud routine's ability to synchronize with the host via serial port 0 during In-System Programming (ISP) at higher baud rates. "
p333
sg10
g60
sg12
g3
sg13
g313
sg15
g3
sg16
g3
sg17
S'4.1 IRC.1: Accuracy of the Internal RC oscillator (IRC) frequency may be outside of the 4 MHz +/\xef\x80\xad 1 % specification only at extreme temperatures '
p334
sg19
g20
sa(dp335
g2
g3
sg4
S' In a system that does not use Thumb state, there will be no problem. In a system that uses Thumb state but does not use data aborts, or does not try to use data aborts in a recoverable manner, there will be no problem. Otherwise the workaround is to ensure that a STR, STMIA or PUSH cannot precede a PC-relative load. One method for this is to add a NOP before any PC-relative load instruction. However this would have to be done manually. ES_LPC21X9/01 . \xc2\xa9   Rev. 3 \xe2\x80\x94 1 October 2011 4 of 9  ES_LPC21x9/01  LPC2109/01, LPC2119/01, LPC2129/01 '
p336
sg6
g3
sg7
g3
sg8
S' If the processor is in Thumb state and executing the code sequence STR, STMIA or PUSH followed by a PC relative load, and the STR, STMIA or PUSH is aborted, the PC is saved to the abort link register.  In this situation the PC is saved to the abort link register in word resolution, instead of half-word resolution. Conditions: The processor must be in Thumb state, and the following sequence must occur: <any instruction> <STR, STMIA, PUSH> <---- data abort on this instruction LDR rn, [pc,#offset] In this case the PC is saved to the link register R14_abt in only word resolution, not half-word resolution. The effect is that the link register holds an address that could be #2 less than it should be, so any abort handler could return to one instruction earlier than intended. '
p337
sg10
g11
sg12
g3
sg13
S'LPC2109'
p338
sg15
g3
sg16
g3
sg17
S'3.1 CORE.1: Incorrect update of the Abort Link register in Thumb state '
p339
sg19
g20
sa(dp340
g2
g3
sg4
S' 1. Recovering from this situation is only possible with a soft reset to the CAN controller. 2. If software cannot read all messages in time before a third message comes in, it is recommend to change the acceptance filtering by adding further acceptance filter group(s) for messages, which are normally rejected. With this approach, the third incoming message is accepted and the Data Overrun condition is avoided. These additional messages are received with the corresponding group index number can be easily identified and rejected by software. ES_LPC21X9/01 . \xc2\xa9   Rev. 3 \xe2\x80\x94 1 October 2011 5 of 9  ES_LPC21x9/01  LPC2109/01, LPC2119/01, LPC2129/01 '
p341
sg6
g3
sg7
g3
sg8
S' Each CAN controller provides a double Receive Buffer (RBX) per CAN channel to store incoming messages until they are processed by the CPU. Software task should read and save received data as soon as a message reception is signaled. In cases where both receive buffers are filled and the contents are not read before the third message comes in, a CAN Data Overrun situation is signaled. This condition is signaled via the Status register and the Data Overrun Interrupt (if enabled).  In a Data Overrun condition, the CAN controller is locked from further message reception. '
p342
sg10
g11
sg12
g3
sg13
g338
sg15
g3
sg16
g3
sg17
S'3.2 CAN.1: Data Overrun condition can lock the CAN controller '
p343
sg19
g20
sa(dp344
g2
g3
sg4
S' In software-controlled mode (BURST bit is 0), the START conversion options (bits 26:24 set to 0x1 or 0x4 or 0x5 or 0x6 or 0x7) can be used. The user can also start a conversion by connecting an external trigger signal to a capture input pin (CAPx) from a Timer peripheral to generate an interrupt. The timer interrupt routine can then start the ADC conversion by setting the START bits (26:24) to 0x1. The trigger can also be generated from a timer match register.'
p345
sg6
g3
sg7
g3
sg8
S' In software-controlled mode (BURST bit is 0), the 10-bit ADC can start conversion by using the following options in the A/D Control Register: Fig 1. A/D control register options  The external start conversion feature, ADCR:START = 0x2 or 0x3, may not work reliably and ADC external trigger edges on P0.16 or P0.22 may be missed. The occurrence of this problem is peripheral clock (pclk) dependent. The probability of error (missing a ADC trigger from GPIO) is estimated as follows: \xe2\x80\xa2 For PCLK_ADC = 60 MHz, probability error = 12 % \xe2\x80\xa2 For PCLK_ADC = 50 MHz, probability error = 6 % \xe2\x80\xa2 For PCLK_ADC = 12 MHz, probability error = 1.5 % The probability of error is not affected by the frequency of ADC start conversion edges. '
p346
sg10
g60
sg12
g3
sg13
g338
sg15
g3
sg16
g3
sg17
S'3.3 ADC.1: External sync inputs not operational '
p347
sg19
g20
sa(dp348
g2
g3
sg4
S' In a system that does not use Thumb state, there will be no problem. In a system that uses Thumb state but does not use data aborts, or does not try to use data aborts in a recoverable manner, there will be no problem. Otherwise the workaround is to ensure that a STR, STMIA or PUSH cannot precede a PC-relative load. One method for this is to add a NOP before any PC-relative load instruction. However this would have to be done manually. ES_LPC2131_01 . \xc2\xa9 NXP B.V. 2012. All rights reserved.  Rev. 2.1 \xe2\x80\x94 1 May 2012 5 of 13  ES_LPC2131/01  LPC2131/01 '
p349
sg6
g3
sg7
g3
sg8
S' If the processor is in Thumb state and executing the code sequence STR, STMIA or PUSH followed by a PC relative load, and the STR, STMIA or PUSH is aborted, the PC is saved to the abort link register.  In this situation the PC is saved to the abort link register in word resolution, instead of half-word resolution. Conditions: The processor must be in Thumb state, and the following sequence must occur: <any instruction> <STR, STMIA, PUSH> <---- data abort on this instruction LDR rn, [pc,#offset] In this case the PC is saved to the link register R14_abt in only word resolution, not half-word resolution. The effect is that the link register holds an address that could be #2 less than it should be, so any abort handler could return to one instruction earlier than intended. '
p350
sg10
g11
sg12
g3
sg13
S'LPC2131'
p351
sg15
g3
sg16
g3
sg17
S'3.1 Core.1: Incorrect update of the Abort Link register in Thumb state '
p352
sg19
g20
sa(dp353
g2
g3
sg4
g3
sg6
g3
sg7
g3
sg8
S' Timer0 and Timer1 can be used in a counter mode. In this mode, the Timer Counter register can be incremented on rising, falling or both edges which occur on a selected CAP input pin. This counter mode can be combined with the match functionality to provide additional features. One of the features would be to reset the Timer Counter register on a match. The same would also apply for Timer1.  The Timer Counter reset does not trigger on the same incoming edge when the match takes place between the corresponding Match register and the Timer Counter register. The Timer Counter register will be reset only on the next incoming edge. Workaround: There are two possible workarounds: 1. Combine the Timer Counter reset feature with the \xe2\x80\x9cinterrupt on match\xe2\x80\x9d feature. The interrupt on match occurs on the correct incoming edge. In the ISR, the Timer Counter register can also be reset. This solution can only work if no edges are expected during the duration of the ISR. 2. In this solution, the \xe2\x80\x9cinterrupt on match\xe2\x80\x9d feature is not used. Instead, the following specific initialization can achieve the counting operation: a. Initialize the Timer Counter register to 0xFFFFFFFF. b. If \xe2\x80\x9cn\xe2\x80\x9d edges have to be counted then initialize the corresponding Match register with value n-1. For instance, if 2 edges need to be counted then load the Match register with value 1. More details on the above example: 1. Edge 1 - Timer overflows and Timer Counter (TC) is set to 0. 2. Edge 2 - TC = 1. Match takes place. 3. Edge 3 - TC = 0. 4. Edge 4 - TC = 1. Match takes place. 5. Edge 5 - TC = 0. ES_LPC2131_01 . \xc2\xa9 NXP B.V. 2012. All rights reserved.  Rev. 2.1 \xe2\x80\x94 1 May 2012 6 of 13  ES_LPC2131/01  LPC2131/01'
p354
sg10
g11
sg12
g3
sg13
g351
sg15
g3
sg16
g3
sg17
S'3.2 Timer.1: In counter mode, the Timer Counter reset does not occur on the correct incoming edge '
p355
sg19
g20
sa(dp356
g2
g3
sg4
S' None. ES_LPC2131_01 . \xc2\xa9 NXP B.V. 2012. All rights reserved.  Rev. 2.1 \xe2\x80\x94 1 May 2012 7 of 13  ES_LPC2131/01  LPC2131/01 '
p357
sg6
g3
sg7
g3
sg8
S' The SSP is a Synchronous Serial Port (SSP) controller capable of operation on a SPI, 4-wire SSI or a Microwire bus. The SSP can operate at a maximum speed of 30 MHz and is referred to as SPI1 in the device documentation.  At high SSP frequencies, it is found that the first four pulses are shorter than the subsequent pulses. At 30 MHz, the first pulse can be expected to be approximately 10 ns shorter and the second pulse around 5 ns shorter. The remaining two pulses are around 2 ns shorter than subsequent pulses. At 25 MHz, the length of the first pulse would be around 7 ns shorter. The subsequent three pulses are around 2 ns shorter. At 20 MHz only the first pulse is affected and it is around 2 ns shorter. All subsequent pulses are fine. The deviation of the initial data bits/clocks will decrease as the SSP frequency decreases. '
p358
sg10
g11
sg12
g3
sg13
g351
sg15
g3
sg16
g3
sg17
S'3.3 SSP.1: Initial data bits/clocks of the SSP transmission are shorter than subsequent pulses at higher frequencies '
p359
sg19
g20
sa(dp360
g2
g3
sg4
S' Apply another power-on Reset during which Vdd rises from below 0.8 V to above 2.0 V in less than 200 ms. '
p361
sg6
g3
sg7
g3
sg8
S' The device operating voltage range is 3.0 V to 3.6 V and it is an internal DC/DC converter that provides 1.8 V to the ARM7 Core.  If during a power-on reset the voltage on Vdd takes longer than 200 ms to ramp from below 0.8 V to above 2.0 V, the chip-internal DC/DC converter might not start up correctly. If this happens, the crystal oscillator will not be running, resulting in no code execution. As an example, having a Vdd rise time of less than 10 V/s might trigger this problem. The same problem might occur during a supply voltage drop during which Vdd remains between 300 mV and 80 mV for more than 200 ms before going back to the specified Vdd level. As an example, having a residual battery voltage of less than 0.3 V but more than 0.08 V in a rechargeable battery application might trigger this problem when the charger providing the 3 V supply is being connected. '
p362
sg10
g11
sg12
g3
sg13
g351
sg15
g3
sg16
g3
sg17
S'3.4 DC/DC.1: DC/DC converter start-up issue '
p363
sg19
g20
sa(dp364
g2
g3
sg4
S' If the above problem is encountered then Mode 2 should not be used. Instead, partially enable the MAM using Mode 1. ES_LPC2131_01 . \xc2\xa9 NXP B.V. 2012. All rights reserved.  Rev. 2.1 \xe2\x80\x94 1 May 2012 8 of 13  ES_LPC2131/01  LPC2131/01 '
p365
sg6
g3
sg7
g3
sg8
S' The MAM block maximizes the performance of the ARM processor when it is running code in Flash memory. It includes three 128-bit buffers called the Prefetch Buffer, the Branch Trail Buffer and the data buffer. It can operate in 3 modes; Mode 0 (MAM off), Mode 1 (MAM partially enabled) and Mode 2 (MAM fully enabled).  Under certain conditions when the MAM is fully enabled (Mode 2) code execution from internal Flash can fail. The conditions under which the problem can occur is dependent on the code itself along with its positioning within the Flash memory. '
p366
sg10
g11
sg12
g3
sg13
g351
sg15
g3
sg16
g3
sg17
S'3.5 MAM.1: Under certain conditions in MAM Mode 2 code execution out of internal Flash can fail '
p367
sg19
g20
sa(dp368
g2
g3
sg4
S' Avoid APB accesses in the middle of the feed sequence. This implies that interrupts and the GPDMA should be disabled while feeding the Watchdog. ES_LPC2131_01 . \xc2\xa9 NXP B.V. 2012. All rights reserved.  Rev. 2.1 \xe2\x80\x94 1 May 2012 9 of 13  ES_LPC2131/01  LPC2131/01 '
p369
sg6
g3
sg7
g3
sg8
S' The Watchdog timer can reset the microcontroller within a reasonable amount of time if it enters an erroneous state.  After writing 0xAA to WDFEED, any APB register access other than writing 0x55 to WDFEED may cause an immediate reset. '
p370
sg10
g11
sg12
g3
sg13
g351
sg15
g3
sg16
g3
sg17
S'3.6 WDT.1: Accessing non-Watchdog APB registers during the feed sequence causes a reset '
p371
sg19
g20
sa(dp372
g2
g3
sg4
S' In software-controlled mode (BURST bit is 0), the START conversion options (bits 26:24 set to 0x1 or 0x4 or 0x5 or 0x6 or 0x7) can be used. The user can also start a conversion by connecting an external trigger signal to a capture input pin (CAPx) from a Timer peripheral to generate an interrupt. The timer interrupt routine can then start the ADC conversion by setting the START bits (26:24) to 0x1. The trigger can also be generated from a timer match register. ES_LPC2131_01 . \xc2\xa9 NXP B.V. 2012. All rights reserved.  Rev. 2.1 \xe2\x80\x94 1 May 2012 10 of 13  ES_LPC2131/01  LPC2131/01 4. AC/DC deviations detail '
p373
sg6
g3
sg7
g3
sg8
S' In software-controlled mode (BURST bit is 0), the 10-bit ADCs can start conversion by using the following options in the A/D Control Register: Fig 1. A/D control register options  The external start conversion feature, ADxCR:START = 0x2 or 0x3, may not work reliably and ADC external trigger edges on P0.16 or P0.22 may be missed. The occurrence of this problem is peripheral clock (pclk) dependent. The probability of error (missing an ADC trigger from GPIO) is estimated as follows: \xe2\x80\xa2 For PCLK_ADC = 60 MHz, probability error = 12 % \xe2\x80\xa2 For PCLK_ADC = 50 MHz, probability error = 6 % \xe2\x80\xa2 For PCLK_ADC = 12 MHz, probability error = 1.5 % The probability of error is not affected by the frequency of ADC start conversion edges. '
p374
sg10
g11
sg12
g3
sg13
g351
sg15
g3
sg16
g3
sg17
S'3.7 ADC.1: External sync inputs not operational '
p375
sg19
g20
sa(dp376
g2
g3
sg4
S' Observe proper ESD handling precautions for the RTCX1 pin.'
p377
sg6
g3
sg7
g3
sg8
S' The LPC2131/01 is rated for 2 kV ESD. The RTCX1 pin is the input pin for the RTC oscillator circuit.  The LPC2131/01 does not meet the required 2 kV ESD specified. '
p378
sg10
g60
sg12
g3
sg13
g351
sg15
g3
sg16
g3
sg17
S'4.1 ESD.1: The device does not meet the 2 kV ESD requirements on the RTCX1 pin '
p379
sg19
g20
sa(dp380
g2
g3
sg4
S' For software controlled mode or burst mode with only one channel selected, the DONE bit in the A/D Global Data Register (located at 0xE003 4004) can be used instead of the individual ADDRx result register with no impact on performance. For burst mode with multiple channels selected, the DONE bit together with the CHN field in the A/D Global Data Register can be used with some impact on throughput. ES_LPC2364_66_68 . \xc2\xa9 NXP B.V. 2012. All rights reserved.  Rev. 9.1 \xe2\x80\x94 1 July 2012 5 of 20  ES_LPC2364_66_68  LPC2364/66/68 '
p381
sg6
g3
sg7
g3
sg8
S' The LPC2364/66/68 has a 10-bit ADC, which can be used to measure analog signals and convert the signals into a 10-bit digital result. There are eight A/D channels and each channel has its own individual A/D Data Register (ADDR0 to ADDR7). The A/D Data Register holds the result when an A/D conversion is complete, and also includes the flags that indicate when a conversion has been completed (DONE bit) and when a conversion overrun has occurred. The DONE bit is cleared when the respective A/D Data Register is read.  If a software read of ADDRx conflicts with the hardware setting of the DONE bit in the same register (once a conversion is completed) then the DONE bit gets cleared automatically, thereby clearing the indication that a conversion was completed. '
p382
sg10
g11
sg12
g3
sg13
S'LPC2364'
p383
sg15
g3
sg16
g3
sg17
S'3.1 ADC.1: ADDRx read conflicts with hardware setting of the DONE bit '
p384
sg19
g20
sa(dp385
g2
g3
sg4
S' In software-controlled mode (BURST bit is 0), the START conversion options (bits 26:24 set to 0x1 or 0x4 or 0x5 or 0x6 or 0x7) can be used. The user can also start a conversion by connecting an external trigger signal to a capture input pin (CAPx) from a Timer peripheral to generate an interrupt. The timer interrupt routine can then start the ADC conversion by setting the START bits (26:24) to 0x1. The trigger can also be generated from a timer match register. ES_LPC2364_66_68 . \xc2\xa9 NXP B.V. 2012. All rights reserved.  Rev. 9.1 \xe2\x80\x94 1 July 2012 6 of 20  ES_LPC2364_66_68  LPC2364/66/68 '
p386
sg6
g3
sg7
g3
sg8
S' In software-controlled mode (BURST bit is 0), the 10-bit ADC can start conversion by using the following options in the A/D Control Register: Fig 1. A/D control register options  The external start conversion feature, AD0CR:START = 0x2 or 0x3, may not work reliably and ADC external trigger edges on P2.10 or P1.27 may be missed. The occurrence of this problem is peripheral clock (pclk) dependent. The probability of error (missing a ADC trigger from GPIO) is estimated as follows: \xe2\x80\xa2 For PCLK_ADC = 72 MHz, probability error = 12 % \xe2\x80\xa2 For PCLK_ADC = 50 MHz, probability error = 6 % \xe2\x80\xa2 For PCLK_ADC = 12 MHz, probability error = 1.5 % The probability of error is not affected by the frequency of ADC start conversion edges. '
p387
sg10
g11
sg12
g3
sg13
g383
sg15
g3
sg16
g3
sg17
S'3.2 ADC.2: External sync inputs not operational '
p388
sg19
g20
sa(dp389
g2
g3
sg4
S' 1. Recovering from this situation is only possible with a soft reset to the CAN controller. 2. If software cannot read all messages in time before a third message comes in, it is recommend to change the acceptance filtering by adding further acceptance filter group(s) for messages which are normally rejected. With this approach, the third incoming message is accepted, and while it does cause a Data Overrun condition, the lockup condition is avoided. These additional messages are received with the corresponding group index number can be easily identified and rejected by software. ES_LPC2364_66_68 . \xc2\xa9 NXP B.V. 2012. All rights reserved.  Rev. 9.1 \xe2\x80\x94 1 July 2012 7 of 20  ES_LPC2364_66_68  LPC2364/66/68 '
p390
sg6
g3
sg7
g3
sg8
S' Each CAN controller provides a double Receive Buffer (RBX) per CAN channel to store incoming messages until they are processed by the CPU. Software task should read and save received data as soon as a message reception is signaled. In cases where both receive buffers are filled and the contents are not read before the third message comes in, a CAN Data Overrun situation is signaled. This condition is signaled via the Status register and the Data Overrun Interrupt (if enabled).  If both receive buffers are full and a third message arrives which is rejected by the CAN Acceptance Filter, the CAN controller is locked from further message reception. '
p391
sg10
g11
sg12
g3
sg13
g383
sg15
g3
sg16
g3
sg17
S'3.3 CAN.1: Data Overrun condition can lock the CAN controller '
p392
sg19
g20
sa(dp393
g2
g3
sg4
S' In a system that does not use Thumb state, there will be no problem. In a system that uses Thumb state but does not use data aborts, or does not try to use data aborts in a recoverable manner, there will be no problem. Otherwise the workaround is to ensure that a STR, STMIA or PUSH cannot precede a PC-relative load. One method for this is to add a NOP before any PC-relative load instruction. However this is would have to be done manually. ES_LPC2364_66_68 . \xc2\xa9 NXP B.V. 2012. All rights reserved.  Rev. 9.1 \xe2\x80\x94 1 July 2012 8 of 20  ES_LPC2364_66_68  LPC2364/66/68 '
p394
sg6
g3
sg7
g3
sg8
S' If the processor is in Thumb state and executing the code sequence STR, STMIA or PUSH followed by a PC relative load, and the STR, STMIA or PUSH is aborted, the PC is saved to the abort link register.  In this situation the PC is saved to the abort link register in word resolution, instead of half-word resolution. Conditions: The processor must be in Thumb state, and the following sequence must occur: <any instruction> <STR, STMIA, PUSH> <---- data abort on this instruction LDR rn, [pc,#offset] In this case the PC is saved to the link register R14_abt in only word resolution, not half-word resolution. The effect is that the link register holds an address that could be #2 less than it should be, so any abort handler could return to one instruction earlier than intended. '
p395
sg10
g11
sg12
g3
sg13
g383
sg15
g3
sg16
g3
sg17
S'3.4 Core.1: Incorrect update of the Abort Link register in Thumb state '
p396
sg19
g20
sa(dp397
g2
g3
sg4
S' None. '
p398
sg6
g3
sg7
g3
sg8
S' Deep power-down mode is like Power-down mode, but the on-chip regulator that supplies power to internal logic is also shut off. This produces the lowest possible power consumption without actually removing power from the entire chip.  The power consumption in Deep power-down mode does not meet the specifications. '
p399
sg10
g11
sg12
g3
sg13
g383
sg15
g3
sg16
g3
sg17
S'3.5 Deep power-down.1: Deep power-down mode is not functional '
p400
sg19
g20
sa(dp401
g2
g3
sg4
S" To use the Ethernet interface in RMII mode write a 1 to bit 12 (P1.16) in PINSEL2 register (located at 0xE002 C008). This workaround only applies for Rev \xe2\x80\x98-\xe2\x80\x99 devices and does not apply for Rev \xe2\x80\x98A\xe2\x80\x99 and newer devices. In order to have both Rev \xe2\x80\x98-\xe2\x80\x99 and other revisions coexist in the same piece of software, the MAC module ID can be used to identify the part and determine if port pin P1.6 needs to be set or not. Here are the steps (along with some sample code) to initialize the MAC based on the module ID: 1. In master header file lLPC24xx.h, make sure Module ID is defined (Please note, this ID register is not documented in the User's Manual). #define MAC_BASE_ADDR 0xFFE00000 #define MAC_MODULEID (*(volatile unsigned long *)(MAC_BASE_ADDR + 0xFFC)) /* Module ID reg (RO) */ 2. In the beginning of the MAC initialization file, add below definition: #define OLD_EMAC_MODULE_ID 0x3902 << 16) | 0x2000) 3. In MAC initialization routine, right after setting the EMAC clock in the PCONP register, add a few lines as below: /* Turn on the ethernet MAC clock in PCONP, bit 30 */ regVal = PCONP; regVal |= PCONP_EMAC_CLOCK; PCONP = regVal; /*------------------------------------------------------ * Write to PINSEL2/3 to select the PHY functions on P1[17:0] ES_LPC2364_66_68 . \xc2\xa9 NXP B.V. 2012. All rights reserved.  Rev. 9.1 \xe2\x80\x94 1 July 2012 9 of 20  ES_LPC2364_66_68  LPC2364/66/68 * P1.6, ENET-TX_CLK, has to be set for Rev '-' devices and it * must not be set for Rev 'A\xe2\x80\x99 and newer devices *------------------------------------------------------*/ regVal = MAC_MODULEID; if ( regVal == OLD_EMAC_MODULE_ID ) { /* On Rev. '-', MAC_MODULEID should be equal to OLD_EMAC_MODULE_ID, P1.6 should be set. */ PINSEL2 = 0x50151105; /* selects P1[0,1,4,6,8,9,10,14,15] */ } else { /* on rev. 'A', MAC_MODULEID should not equal to OLD_EMAC_MODULE_ID, P1.6 should not be set. */ PINSEL2 = 0x50150105; /* selects P1[0,1,4,8,9,10,14,15] */ } PINSEL3 = 0x00000005; /* selects P1[17:16] */ "
p402
sg6
g3
sg7
g3
sg8
S' The LPC2364/66/68 has an Ethernet interface, which can be interfaced with an off-chip PHY using the RMII interface.  The default configuration of the device does not enable the RMII interface. '
p403
sg10
g11
sg12
g3
sg13
g383
sg15
g3
sg16
g3
sg17
S'3.6 Ethernet.1: Setting up the Ethernet interface in RMII mode '
p404
sg19
g20
sa(dp405
g2
g3
sg4
S' Enable the Ethernet block by setting the PCENET bit (bit no. 30) in the PCONP register. The Ethernet SRAM is now enabled. '
p406
sg6
g3
sg7
g3
sg8
S' The LPC2364/66/68 has an Ethernet interface, which has a dedicated 16 kB SRAM.  When the Ethernet block is disabled (in the PCONP register located at 0xE01F C0C4), the Ethernet SRAM is also disabled. '
p407
sg10
g11
sg12
g3
sg13
g383
sg15
g3
sg16
g3
sg17
S'3.7 Ethernet.2: Ethernet SRAM disabled '
p408
sg19
g20
sa(dp409
g2
g3
sg4
S' Define 4 or less in the Receive number of Descriptors register. ES_LPC2364_66_68 . \xc2\xa9 NXP B.V. 2012. All rights reserved.  Rev. 9.1 \xe2\x80\x94 1 July 2012 10 of 20  ES_LPC2364_66_68  LPC2364/66/68 '
p410
sg6
g3
sg7
g3
sg8
S' The Receive number of Descriptors register (RxDescriptor-0xFFE0 0110) defines the number of descriptors in the Descriptor array. Each receive descriptor element in the Descriptor array has an associated status field which consists of the HashCRC word and Status Information word.  The status words are updated incorrectly if the number of Descriptors set in the Receive number of Descriptors register is greater than or equal to 5. '
p411
sg10
g11
sg12
g3
sg13
g383
sg15
g3
sg16
g3
sg17
S'3.8 Ethernet.3: Receive Status registers will not function correctly if RxDescriptor number is greater than 4 '
p412
sg19
g20
sa(dp413
g2
g3
sg4
S' Software can correct this situation in many ways; for example, sending a dummy frame after initialization. ES_LPC2364_66_68 . \xc2\xa9 NXP B.V. 2012. All rights reserved.  Rev. 9.1 \xe2\x80\x94 1 July 2012 11 of 20  ES_LPC2364_66_68  LPC2364/66/68 '
p414
sg6
g3
sg7
g3
sg8
S' The transmit consume index register defines the descriptor that is going to be transmitted next by the hardware transmit process. After a frame has been transmitted hardware increments the index, wrapping the value to 0 once the value of TxDescriptorNumber has been reached. If the TxConsumeIndex equals TxProduceIndex the descriptor array is empty and the transmit channel will stop transmitting until software produces new descriptors.  The TxConsumeIndex register is not updated correctly (from 0 to 1) after the first frame is sent. After the next frame sent, the TxConsumeIndex register is updated by two (from 0 to 2). This only happens the very first time, so subsequent updates are correct (even those from 0 to 1, after wrapping the value to 0 once the value of TxDescriptorNumber has been reached) '
p415
sg10
g11
sg12
g3
sg13
g383
sg15
g3
sg16
g3
sg17
S'3.9 Ethernet.4: Ethernet TxConsumeIndex register does not update correctly after the first frame is sent '
p416
sg19
g20
sa(dp417
g2
g3
sg4
S' None. '
p418
sg6
g3
sg7
g3
sg8
S' The operating speed of this device out of internal flash/SRAM is specified at 72 MHz.  Code execution from internal flash is restricted depending upon the device revision: 1. Rev \xe2\x80\x98A\xe2\x80\x99 devices: Code execution from internal flash is restricted to a maximum of 60 MHz. For example, use a PLL output frequency of FCCO = 360 MHz and divide it by 6 (CCLKSEL = 5) to generate 60 MHz CPU clock (do not use even values for CCLKSEL). 2. Rev \xe2\x80\x98-\xe2\x80\x99 devices: Code execution from internal flash is restricted to a maximum of 60 MHz also. However, this device revision has one more restriction in terms of the PLL output frequency (FCCO - Please refer to PLL.1 above). FCCO is limited to 290 MHz. Considering the same example in PLL.1 (Input crystal-12 MHz, N = 1, M = 12): FCCO = 288 MHz The CPU Clock Configuration register (located at 0xE01F C104) can then be used to divide this frequency by 6 (CCLKSEL = 5) to achieve 48 MHz. Since this register only accepts odd values for CCLKSEL, a division by 5 (CCLKSEL = 4) is not a valid option. In both the above revisions, code can still execute out of SRAM at up to 72 MHz. '
p419
sg10
g11
sg12
g3
sg13
g383
sg15
g3
sg16
g3
sg17
S'3.10 Flash.1: Operating speed out of on-chip flash is restricted '
p420
sg19
g20
sa(dp421
g2
g3
sg4
S' No known workaround. ES_LPC2364_66_68 . \xc2\xa9 NXP B.V. 2012. All rights reserved.  Rev. 9.1 \xe2\x80\x94 1 July 2012 12 of 20  ES_LPC2364_66_68  LPC2364/66/68 '
p422
sg6
g3
sg7
g3
sg8
S' The LPC2364/66/68 has an I2S interface, which can be used for audio devices. The I2S interface was initially designed to operate with the general purpose DMA controller.  The DMA controller cannot access the I2S interface. '
p423
sg10
g11
sg12
g3
sg13
g383
sg15
g3
sg16
g3
sg17
S'3.11 I2S.1: I2S DMA interface is non-operational '
p424
sg19
g20
sa(dp425
g2
g3
sg4
S' If the above problem is encountered then Mode 2 should not be used. Instead, partially enable the MAM using Mode 1. '
p426
sg6
g3
sg7
g3
sg8
S' The MAM block maximizes the performance of the ARM processor when it is running code in flash memory. It includes three 128-bit buffers called the Prefetch Buffer, the Branch Trail Buffer and the data buffer. It can operate in 3 modes; Mode 0 (MAM off), Mode 1 (MAM partially enabled) and Mode 2 (MAM fully enabled).  Under certain conditions when the MAM is fully enabled (Mode 2) code execution from internal flash can fail. The conditions under which the problem can occur is dependent on the code itself along with its positioning within the flash memory. '
p427
sg10
g11
sg12
g3
sg13
g383
sg15
g3
sg16
g3
sg17
S'3.12 MAM.1: Under certain conditions in MAM Mode 2 code execution out of internal flash can fail '
p428
sg19
g20
sa(dp429
g2
g3
sg4
S' Care should be taken while programming the PLL so that FCCO resides in the desired range. The suggested setting is to use a 12 MHz external crystal. Use a PLLdivider (N) of 1 and PLL multiplier (M) of 12. Putting the values in the equation: FCCO = (2 \xef\x82\xb4 M \xef\x82\xb4 FIN) / N FCCO = 288 MHz The CPU Clock Configuration register (located at 0xE01F C104) can then be used to divide this frequency by 4 to produce the maximum CPU speed of 72 MHz (except on Rev \xe2\x80\x98-\xe2\x80\x99 and Rev \xe2\x80\x98A\xe2\x80\x99, see Flash.1). ES_LPC2364_66_68 . \xc2\xa9 NXP B.V. 2012. All rights reserved.  Rev. 9.1 \xe2\x80\x94 1 July 2012 13 of 20  ES_LPC2364_66_68  LPC2364/66/68 '
p430
sg6
g3
sg7
g3
sg8
S' The PLL input, in the range of 32 KHz to 50 MHz, may initially be divided down by a value \xe2\x80\x9cN\xe2\x80\x9d, which may be in the range of 1 to 256. Following the PLL input divider is the PLL multiplier. This can multiply the input divider output through the use of a Current Controlled Oscillator (CCO) by a value \xe2\x80\x9cM\xe2\x80\x9d, in the range of 1 through 32768. The resulting frequency, FCCO must be in the range of 275 MHz to 550 MHz.This frequency can be divided down (using the Clock Divider registers) to get the desired clock frequencies for the core and peripherals.  The maximum output of the CCO within the PLL block is limited to 290 MHz. '
p431
sg10
g11
sg12
g3
sg13
g383
sg15
g3
sg16
g3
sg17
S'3.13 PLL.1: PLL output (FCCO) is limited to 290 MHz '
p432
sg19
g20
sa(dp433
g2
g3
sg4
S' No known workaround. '
p434
sg6
g3
sg7
g3
sg8
S' The LPC2364/66/68 has 16 kB of SRAM on the AHB2 bus, which would generally be used by the Ethernet block.  The 16 kB of SRAM can only be used as data RAM. Code can not be executed from this memory. '
p435
sg10
g11
sg12
g3
sg13
g383
sg15
g3
sg16
g3
sg17
S'3.14 SRAM.1: 16 kB SRAM cannot be used for code execution '
p436
sg19
g20
sa(dp437
g2
g3
sg4
S' After setting the PCUSB bit in PCONP (located at 0xE01F C0C4), write 0x1 to address 0xFFE0C008. The USB_NEED_CLK signal will now function correctly. Writing to address 0xFFE0C008 only needs to be done once after each chip reset. '
p438
sg6
g3
sg7
g3
sg8
S' The USB_NEED_CLK signal is used to facilitate going into and waking up from chip Power Down mode. USB_NEED_CLK is asserted if any of the bits of the USBClkSt register are asserted.  The USB_NEED_CLK bit of the USBIntSt register (located at 0xE01F C1C0) is always asserted, preventing the chip from entering Power Down mode when the USBWAKE bit is set in the INTWAKE register (located at 0xE01F C144). '
p439
sg10
g11
sg12
g3
sg13
g383
sg15
g3
sg16
g3
sg17
S'3.15 USB.1: USB_NEED_CLK is always asserted '
p440
sg19
g20
sa(dp441
g2
g3
sg4
S' Configure P2.9 as a GPIO pin, and use it to enable the pull-up resistor on the U1D+ pin. ES_LPC2364_66_68 . \xc2\xa9 NXP B.V. 2012. All rights reserved.  Rev. 9.1 \xe2\x80\x94 1 July 2012 14 of 20  ES_LPC2364_66_68  LPC2364/66/68 '
p442
sg6
g3
sg7
g3
sg8
S' U1CONNECT Signal (alternate function of P2.9) is part of the SoftConnect USB feature, which is used to switch an external 1.5 KW resistor under the software control.  The USB U1CONNECT alternate function does not work as expected. '
p443
sg10
g11
sg12
g3
sg13
g383
sg15
g3
sg16
g3
sg17
S'3.16 USB.2: U1CONNECT signal is not functional '
p444
sg19
g20
sa(dp445
g2
g3
sg4
S' Configure P1.30 as a GPIO pin, and poll it to determine when VBUS goes to 0, signalling a disconnect event. '
p446
sg6
g3
sg7
g3
sg8
S' The VBUS signal indicates the presence of USB bus power.  The VBUS status input is not functional. '
p447
sg10
g11
sg12
g3
sg13
g383
sg15
g3
sg16
g3
sg17
S'3.17 USB.3: VBUS status input is not functional '
p448
sg19
g20
sa(dp449
g2
g3
sg4
S' Provide 3.3 V supply used by rest of the device first and then provide VBAT voltage. '
p450
sg6
g3
sg7
g3
sg8
S' The device has a VBAT pin which provides power only to the RTC and Battery RAM. VBAT can be connected to a battery or the same 3.3 V supply used by rest of the device (VDD(3V3) pin, VDD(DCDC)(3V3) pin).  If VBAT is powered before the 3.3 V supply, VBAT is unable to source the start-up current required for the Battery RAM. Therefore, power consumption on the VBAT pin will be high and will remain high until 3.3 V supply is powered up. Once 3.3 V supply is powered up, power consumption on the VBAT pin will reduce to normal and subsequent power cycle on the 3.3 V supply will not cause an increased power consumption on the VBAT pin. '
p451
sg10
g11
sg12
g3
sg13
g383
sg15
g3
sg16
g3
sg17
S'3.18 VBAT.1: Increased power consumption on VBAT when VBAT is powered before the 3.3 V supply used by rest of the device '
p452
sg19
g20
sa(dp453
g2
g3
sg4
S' The VBAT should be connected to a battery or the same supply used by rest of the device (VDD(3V3) pin, VDD(DCDC)(3V3) pin). ES_LPC2364_66_68 . \xc2\xa9 NXP B.V. 2012. All rights reserved.  Rev. 9.1 \xe2\x80\x94 1 July 2012 15 of 20  ES_LPC2364_66_68  LPC2364/66/68 '
p454
sg6
g3
sg7
g3
sg8
S' The device has a VBAT pin which provides power only to the Real Time Clock (RTC) and Battery RAM. VBAT can be connected to a battery or the same supply used by rest of the device (VDD(3V3) pin, VDD(DCDC)(3V3) pin). The input voltage range on the VBAT pin is 2.0 V minimum to 3.6 V maximum for temperature \xef\x80\xad40 \xef\x82\xb0C to +85 \xef\x82\xb0C. Normally, if the RTC and the Battery RAM are not used, the VBAT pin can be left floating.  If the VBAT pin is left floating, the internal reset signal within the RTC domain may get corrupted and as a result, prevents the device from starting-up. '
p455
sg10
g11
sg12
g3
sg13
g383
sg15
g3
sg16
g3
sg17
S'3.19 VBAT.2: The VBAT pin cannot be left floating '
p456
sg19
g20
sa(dp457
g2
g3
sg4
S' Avoid APB accesses in the middle of the feed sequence. This implies that interrupts and the GPDMA should be disabled while feeding the Watchdog. ES_LPC2364_66_68 . \xc2\xa9 NXP B.V. 2012. All rights reserved.  Rev. 9.1 \xe2\x80\x94 1 July 2012 16 of 20  ES_LPC2364_66_68  LPC2364/66/68 4. AC/DC deviations detail '
p458
sg6
g3
sg7
g3
sg8
S' The Watchdog timer can reset the microcontroller within a reasonable amount of time if it enters an erroneous state.  After writing 0xAA to WDFEED, any APB register access other than writing 0x55 to WDFEED may cause an immediate reset. '
p459
sg10
g11
sg12
g3
sg13
g383
sg15
g3
sg16
g3
sg17
S'3.20 WDT.1: Accessing non-Watchdog APB registers in the middle of the feed sequence causes a reset '
p460
sg19
g20
sa(dp461
g2
g3
sg4
S' Observe proper ESD handling precautions for the RTCX1 pin.'
p462
sg6
g3
sg7
g3
sg8
S' The LPC2364/66/68 is rated for 2 kV ESD. The RTCX1 pin is the input pin for the RTC oscillator circuit.  The LPC2364/66/68 does not meet the required 2 kV ESD specified. '
p463
sg10
g60
sg12
g3
sg13
g383
sg15
g3
sg16
g3
sg17
S'4.1 ESD.1: The LPC2364/66/68 does not meet the 2 kV ESD requirements on the RTCX1 pin '
p464
sg19
g20
sa.