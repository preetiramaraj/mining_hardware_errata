Chip	Details	Core	Errata ID	Module	Criticality	Workaround	Revisions Impacted	Failure	Fix Status	Masks Affected	Manufacturer
STR91xFA	Description of limitation Status register bit 7 (ready bit) does not reflect the correct status when it is read immediately after the CPU issues a Flash memory program or erase command. 	ARM9				 This requires bit 18 (instruction TCM order bit) in the configuration control register of the ARM966E-S core to be set. This can be done by the following assembler code: MOV R0, #0x40000 MCR P15,0x1,R0,C15,C1,0 When set, the write and read to the Flash bank are performed in the order generated by the ARM966-ES core.This ensures that writes are committed to the Flash memory before any subsequent read. This will not be fixed in future silicon revisions. 		2.1 Flash memory status register bit 7 			ST
STR91xFA	Description of limitation At power up, the Flash protection level 1 register is reset to 0FFFh (all Flash sectors are protected). A warm reset does not reset the register. 	ARM9				 Firmware must change the values if desired. This will not be fixed in future silicon revisions. 		2.2 Flash memory sector protection 			ST
STR91xFA	Description of limitation in revision G There are two independent Flash memory banks (primary and secondary) that allow read-while-write capability from one bank to the other, enabling in-application programming (IAP) of the primary bank while executing code from the secondary bank. After IAP has upgraded firmware in the primary bank, the bootloader code in the secondary bank should remap the banks by writing to FMI registers FMI_BBADR and FMI_NBBADR in order to have the primary bank start at address 0x0, which allows interrupt handlers to reside in the application code primary bank instead of interrupts being handled by bootloader code in the secondary bank. There are two forms of reset in the STR91xFA: A global reset (from power-up or voltage drop-out) that clears all functions in the device, and a system reset (from the reset input pin, watchdog, or JTAG reset command) that clears all but a few configuration registers. 4/16  STR91xFA Silicon limitations and fixes Silicon limitation The remapping operation is possible. However, when a system reset occurs after the remapping, the application hangs because the FMI_BBADR and FMI_NBBADR registers which define bank locations are not cleared by the system reset, while the FMI_CR register which controls the chip select enable of the non boot bank are cleared by the system reset. 	ARM9				 using revision G Do not remap the banks after IAP (keep secondary bank at address 0x0), and in the secondary bank redirect ARM interrupts to be handled in the primary bank. This limitation is fixed in revision H devices by clearing all FMI registers (including bank base address and bank size) after a system reset. 		2.3 Flash memory remapping 			ST
STR91xFA	Description of limitation In either of the following two conditions, the CPU may freeze or generate an exception: 1. When the two banks (Bank0 and Bank1) are configured at contiguous addresses in the STR91xFA address map and if a code sequence is stored and then fetched by the CPU across this boundary, 2. When data is read from a bank other than the bank fetched by the CPU for execution. This will not be fixed in future silicon revisions. 	ARM9				s For the first case, three workarounds are proposed: 1. Do not use the last 8 x 32-bit words of a Flash bank for storing code and use it instead to store data constants (this can be configured by the linker to specify the last zone). 2. If the application firmware is larger than one bank in size, ensure that before reaching the last 8 x 32-bit words of one bank, application code must jump (using LDR, or a branch) to an address forced by the linker to a location in the other bank. 3. Disable the PFQ block before executing code stored across a bank boundary. For the second case, the workaround is as follows: Disable the PFQ block before reading (data/constants) from a bank other than the bank from which code is fetched and enable it again after completing the read operations.  5/16 Silicon limitations and fixes STR91xFA 		2.4 Flash fetch/read across banks 			ST
STR91xFA	Description of limitation When programming the internal Flash or the Flash registers with an FMICLK frequency of 96 MHz, either using read-while-write operations or executing from the internal SRAM, for some STR91xFA slow parts that may be seen in the field, some data are not properly written. This issue is due to a limitation in the Flash command interface that affects Flash write operations (such as program or erase). 	ARM9				 To ensure that internal Flash programming and CUI registers (command user interface) programmings are performed correctly, configure the frequency of FMICLK to RCLK/2 during these operations. 		2.5 Flash frequency limitation when programming 			ST
STR91xFA	Description of limitation By default, the ETM9 interface in the STR91xFA core is an 8-bit medium size model as defined by ARM Ltd. When an emulator tool boots up and performs an automatic configuration on the ETM (ETM sniffers), the configuration register always sends back the 8-bit model status. However, in order to reduce the number of I/O pins required for debugging, the ETM trace data port is implemented as a 4-bit port. When polled, the 8-bit status provided by the configuration register is incorrect. 	ARM9				 When booting up an emulator, do not select the automatic configuration option. Instead, configure the ETM to be a 4-bit port manually. This limitation will not be fixed in future silicon revisions. 		2.6 ETM (embedded trace module) configuration 			ST
STR91xFA	Description of limitation When the EMI clock is configured with a ratio of 2, modifying SCU_CLKCNTR register may cause incorrect EMI write cycles to occur when the EMI is used. This is due to the de-synchronization of the two clock state machines feeding the EMI when the EMI clock ratio is configured with a ratio of 2. 	ARM9				 Whenever the SCU_CLKCNTR register is modified, the EMI must be subsequently reset by writing bit 6 (RST_EMI) of the SCU_PRR0 register to 0 and setting it again just before configuring and using the EMI. 6/16  STR91xFA Silicon limitations and fixes 2.7.2 Address boundary limitation in 16-bit asynchronous or synchronous modes Description of limitation When accessing the external memory in 16-bit mode, the address must always be aligned to half word (16 bit) or word (32 bit) boundary. The memory address must consequently be an even address, and reading or writing from/to an odd address location may result in incorrect data. This limitation applies to data memory space only, as code fetch is always aligned to word boundary. Workaround All data must be stored at even address location. 2.7.3 Write signal configuration in 16-bit synchronous mode Description of limitation (applies only to BGA144 devices) There are two sets of write control signals for 16-bit write bus cycle: 1. EMI_WRLn, EMI_WRHn 2. EMI_WEn, EMI_UBn, EMI_LBn The 2nd set of signals is activated by setting bit 2 in the SCU_GPIOEMI register. When configured in 16-bit synchronous mode, the EMI bus works only with the 2nd set of write signals. The 1st set of signal results in incorrect write signal timings. Workaround When using EMI in 16-bit synchronous mode, choose a memory device which accepts write enable (EMI_WEn), EMI_UBn and EMI_LBn signals. If these signals are not available on the memory, it is recommended to operate in asynchronous mode. 		2.7 EMI bus limitations 2.7.1 Impact of SCU_CLKCNTR register modification on EMI operation with clock ratio of 2 			ST
STR91xFA	Description of limitation When the STR91xFA enters Sleep mode, the current drawn from the CPU core voltage (VDD) and from the I/O supply voltage (VDDQ) should drop to a very low value. ISLEEP current on VDD pins correctly drops to as low as 50 ÂµA at 25 Â°C. However ISLEEP current on the VDDQ pins drops to around 500 ÂµA at 25 Â°C while it should be less than 10 ÂµA. 	ARM9				 using revision G A limited workaround may be implemented to save around 120 ÂµA by using firmware to put the USB transceiver into Suspend mode (bit2, LP_MODE in the USB_CNTR register). This allows reducing Sleep mode current on VDDQ pins to around 380 ÂµA.  7/16 Silicon limitations and fixes STR91xFA Sleep mode current consumption on VDDQ pins is reduced to less than 10 ÂµA on revision H silicon devices. 		2.8 Sleep mode current (ISLEEP) on VDDQ pins 			ST
STR91xFA	Description of limitation After the CPU enters sleep mode, it can be woken up by: 1. External interrupt 2. RTC/USB interrupt 3. External reset When an oscillator chip is used as the clock source for the STR91xFA, the CPU wakes up from sleep mode following any of the above three input events. If a crystal is used as the clock source, the crystal is disabled in sleep mode to save power consumption. When a wakeup event occurs, the crystal does not recover fast enough and the CPU hangs. 	ARM9				s Workaround solutions include: 1. Use the 32 kHz RTC clock as the clock source for sleep mode: a) Select the RTC clock as the CPU clock source prior entering sleep mode. b) The CPU wakes up following any of the three wakeup events and waits for the crystal to start oscillation. A crystal startup time is about 1.5 ms typical. c) After the crystal wakes up, the CPU waits for a tWAIT time before the first code is fetched from Flash memory. The software can then change the CPU clock source back to the OSC or PLL clock. The duration of tWAIT depends on the crystal frequency. tWAIT equals 50 Âµs at 25 MHz and 312 Âµs at 4 MHz. 2. Instead of a crystal, use an oscillator as STR91xFA clock source. This limitation will not be fixed in future silicon revisions 		2.9 Waking up from sleep mode 			ST
STR91xFA	Description of limitation Once the idle or sleep mode are entered by writing the PWR_MODE[2:0] bits in the SCU_PWRMNG register, it takes about 12 fOSC cycles for the device to stop the execution. In addition, if a wakeup event or an interrupt (external or internal coming from peripherals) occurs during this period while entering idle, the internal low power state machine is frozen and the STR91xFA hangs. In this case, only a reset event can wake up the device. 8/16  STR91xFA Silicon limitations and fixes 	ARM9				s In order to avoid executing any valid instructions after setting the idle or sleep bit and before entering the mode, it is mandatory to execute a certain number of dummy instructions after setting the SCU_PWRMNG register. The number of dummy instructions to be executed is given by the following formula: No_dummy_instr = (f â f ) Ã 12 CPUCLK OSC Where fCPUCLK is the CPU core clock frequency and fOSC is the oscillator frequency. The worst scenario is obtained when the core works from the PLL maximum frequency (96 MHz) with an 4 MHz crystal or oscillator connected to the X1_CPU input. In this case 288 dummy instructions are needed. Note: If (fCPUCLK/ fOSC) is less than 1, the number of dummy instruction is always 3. Random external/internal wakeup events or interrupts may freeze the STR91xFA when occurring during the execution of these dummy instructions. In this case, only a reset event can wake up the CPU. This limitation will not be fixed in future silicon revisions 2.10.2 Time required to enter sleep mode Description of limitation After the mode bit is set in the SCU_PWRMNG register, the power management unit requires a period of time (tSLEEP) to switch off all CPU and peripheral clocks safely before entering sleep mode. A very slow peripheral clock results in a long switch off time. The tSLEEP time required to enter sleep mode depends on the oscillator frequency, on the slowest peripheral clock frequency, and on the CPU clock frequency. If a wakeup event occurs during tSLEEP, it is ignored and the STR91xFA does not exit from sleep mode. tSLEEP is given by the following formula: t = 17 Ã t_OSC + 14 Ã t_Slowest_IP_CLK + 6 Ã t_CPUCLK SLEEP Where t_OSC is the oscillator frequency, t_Slowest_IP_CLK the slowest peripheral clock frequency, and t_CPUCLK the CPU clock frequency. Example â CPU running on RTC clock before entering sleep mode (fCPUCLK = 32 kHz) (see Section 2.9). â t_OSC = 40 ns (fOSC = 25 MHz) â t_CPUCLK = t_RTC = 31,250 ns (fCPUCLK = 32 kHz) â t_Slowest_IP_CLK = 2*31,250 ns assuming all clock dividers are set to 1 (default state) except for APB clock divided which is set to 2, the slowest peripheral clock frequency is then fCPUCLK/2. Then, the value of tSLEEP is: t = 17 Ã 40 + 14 Ã 2 Ã 31, 250 + 6 Ã 31, 250 1.06 â¼ ms SLEEP  9/16 Silicon limitations and fixes STR91xFA Workaround To prevent random external wakeup events from occurring while the device is entering sleep mode (during tSLEEP), the maximum time required by the application to enter sleep mode must be taken into account. This limitation will not be fixed in future silicon revisions. 		2.10 Sleep and Idle mode requirements 2.10.1 Code execution after setting the sleep or idle mode bit 			ST
STR91xFA	Description of limitation None of the STR9 general inputs have hysteresis which means they have no Schmitt trigger. Simulation in typical conditions (3.3 V, ambient temperature, typical processing) shows that approximately 25 mV noise is enough to provide unexpected glitches in the core when the 1 kHz pad signaling crosses the input buffer threshold. The slower the input signaling frequency is, the greater this limitation. 	ARM9				s Some possible software workarounds can be implemented depending on the application and the impact of the limitation. A hardware workaround, feasible in all cases, is to implement an external Schmitt trigger to act as a noise filter. 		2.11 Noise sensitivity of GPIO ports 			ST
STR91xFA	Description of limitation A high leakage current is observed when applying 5.5 V on 5 V-tolerant I/O pins. This leakage does not dependent on VDDQ, and increases with the temperature. This high leakage is distributed between the different pins when using a 5.5 V supply voltage. If the application hardware has 10 pins connected to 5.5 V, the leakage current is not multiplied by 10, but distributed between the 10 pins. This limitation will not be fixed in future silicon revisions. 	ARM9				 Limit the voltage applied to the 5 V-tolerant I/O pins to 5 V to limit the leakage current. 10/16  STR91xFA Silicon limitations and fixes 		2.12 High leakage on GPIO ports at 5.5 V 			ST
STR91xFA	Description of limitation The ADC generates an end of conversion (EVC) or an analog watchdog (AWD) interrupt when enabled. Before returning from serving the interrupt, the ISR typically clears the interrupt by setting the corresponding EVC or AWD flag bit in the ADC_CR register to â0â. The ADC clock is used to clear the interrupt flags. The time taken to clear the flags is longer when the ADC runs on a slow clock. The CPU may return from ISR before the interrupt flag has been cleared. Since the interrupt controller input is level sensitive, the CPU sees immediately if another interrupt is pending. 	ARM9				 Instead of clearing the ADC interrupt flag at the end of the ISR, clear the flag when ISR is entered. This limitation will not be fixed in future silicon revisions. 		2.13 ADC interrupt generation 			ST
STR91xFA	"Description of limitation When the ADC unit is in single conversion mode, the time to complete the conversion varies between 36 and 48 ADC clock periods after the conversion is initiated by an external ADC trigger, a timer trigger, or a firmware command. This limits the maximum ADC conversion rate to 500,000 samples per second for a single channel using an external trigger. This situation also introduces a ""jitter"" of as many as 12 ADC clocks from one completed conversion to the next. When the ADC unit is in continuous and scan conversion modes, the time to complete the first conversion varies between 36 and 48 ADC clocks like single conversion mode, but subsequent conversions complete every 16 ADC clocks producing a maximum ADC conversion rate of 1,500,000 samples per second for a single channel. "	ARM9				 on revision G In single conversion mode, there is no workaround to exceed 500 Ksps conversion rate with external trigger or timer trigger, and no workaround to reduce jitter from one sample to the next. In continuous and scan conversion modes there is no workaround to reduce delay of the first conversion. To eliminate jitter, a new conversion mode started by fast trigger has been added in silicon revision H (refer to STR91xFA datasheet and reference manual). It allows each conversion to be completed in 16 ADC clocks after it has been triggered by external ADC trigger or internal timer event. A minimum conversion rate of 1.2 Msps can be achieved on a single channel. In single and scan mode, the time to complete the first conversion is reduced to the range of 20 to 32 clocks (down from 36 to 48 clocks) after a trigger event allowing continuous conversion. In this case, the maximum rate on subsequent continuous conversions remains 1.5 Msps on a single channel.  11/16 Silicon limitations and fixes STR91xFA 		2.14 ADC conversion time and external trigger mode 			ST
STR91xFA	Description of limitation only in revision H ADC scan and continuous mode cannot be used together on revision H silicon. The first conversion is performed, but the next channel is not selected, so the end of conversion never occurs. 	ARM9				 Instead of using scan mode with continuous mode, the application has to select scan mode in single mode. Each conversion can be started by an internal trigger (PWM) for the required number of channels. The conversion time is deterministic in fast trigger mode. This is a new feature available in revision H silicon (see STR91xFA datasheet and reference manual). It can be computed using the following formula: f < 1 â (nb_channels Ã 16 â f ) TRIGGER ADC 		2.15 ADC scan and continuous modes 			ST
STR91xFA	Description of limitation only in rev H If both channel selection and start conversion bits (SC and STR bits) are written at the same time, it may occur that the ADC sampling/conversion is performed on the previous selected channel. 	ARM9				 A delay max. of 16 ADC clocks between the channel selection and the conversion start should be enough to prevent this effect. A generic dummy loop (equivalent to 16 ADC clocks) is recommended. This workaround is only needed in single mode with a channel selection change. 		2.16 ADC single mode and channel selection 			ST
STR91xFA	Description of limitation For daisy-chained interrupts, if only the VAR from one VIC is read, it does not update the hardware priority in the other VIC. This means the daisy chained interrupt controller doesn't realize the interrupt is being serviced and keeps the interrupt request active. For daisy-chained interrupts the processor must read the VAR register from both interrupt controllers and branch to the addresses provided. However, the address provided by reading the daisy-chained VAR register must be manipulated to skip the interrupt preamble. If two daisy chained interrupts occur soon after each other and the daisy chained VAR register address isn't branched to, the interrupt controller priority logic may be updated incorrectly. This may cause a low priority interrupt to be missed. 12/16  STR91xFA Silicon limitations and fixes 	ARM9				 Note: This workaround is taken from the ARM prime cell vectored interrupt controller (PL190) errata notice. For already existing software that services daisy-chained nested interrupts, a possible software workaround is to branch to the address provided by the VIC1 VAR register. This ensures that the correct ISR is serviced. 0x18 LDR pc, [VIC0_VAR] ; VIC0 VAR read ; daisy_chained_vector_handler: STMFD r13!, {r12-r14} LDR r12, [VIC1_VAR] ; Read VIC1 VAR and update PC, ; VIC1 priority hardware is updated LDR PC, [r12, #12] ; Processor branches to the highest priority ; daisy chained ISR and skips ; the preamble(+12) Note: The value, 12, used in instruction LDR PC, [r12, #12] is only specific to the example code given here. The offset #12 is dependent on the system's interrupt stacking preamble code size. 		2.17 Daisy chained interrupt controller VIC1 hardware priority management limitation 			ST
STR91xFA	Description of limitation Using wait state insertion bits and/or the Flash bus clock bit under some specific configurations and/or combinations with respect to the Flash programming manual, may cause the device to be used outside its operating conditions. 	ARM9				 To ensure that the application use of the above bits is well supported, a new Flash configuration specification has been put in place: Bits 12:11 WSTATES[1:0]: Wait states These bits define the number of wait states inserted in asynchronous read access. 00: 1 wait state (default) 01: 2 wait states 10: 3 wait states Note: Wait states are inserted only for non-bursting Flash read bus cycles. One wait state is required for a Flash memory interface (FMI) bus clock frequency < 66 MHz. Two wait states are required for an FMI bus clock frequency â¥ 66 MHz. Bit 4 BUSCFG: Flash bus clock configuration This bit selects the FMI Flash bus clock configuration. 0: BUSCFG disabled (default) 1: BUSCFG enabled Note: The BUSCFG bit must be set for a frequency of: â¥ 48 MHz (with 1 wait state) â¥ 66 MHz (with 2 wait state).		2.18 Flash configuration register bits correction 			ST
LPC3220	 The DMA controller is an AHB master that can transfer blocks of data between peripheral-to-memory, memory-to-peripheral, peripheral-to-peripheral, and memory-to-memory. In addition to transferring data between memories, a DMA memory-to-memory flow can be used to transfer blocks of data to / from an FPGA or external peripheral chip connected to an EMC static memory chip select. When a memory, FPGA or external peripheral chip does not support burst transfers (i.e. multiple reads for each active chip select or read strobe) the burst size for that memory-to-memory flow must be set for one transfer per burst.  When using memory-to-memory DMA with the EMC static chip select (EMC_CS[x]_N) as the DMA source and the DMA channel source burst size is set for a single transfer (DMACCxControl:SBSIZE = 0), each DMA source read should be a single bus-wide access. The access should be similar to reading the EMC_CS[x]_N static memory with an ARM LDR instruction, as shown in Figure 1. Note the EMC signal timing for the read is controlled by the EMCSTATICx registers. In all example scope shots the EMCSTATICWAITx registers are set to the maximum value. Fig 1. Scope shot 1 - expected read timing However, the actual EMC timing for the source DMA read is a double wide chip select with a burst of two reads (notice how the address increments near the halfway point of nCS0 active), see Figure 2. The second data read during the burst is discarded, as the DMA destination write (also to nCS0 in Figure 2) following each read, always writes the first value read during the read burst. When the DMA source address is set to auto-increment, the last DMA read transfer will address the last address of the source buffer and the last source buffer address +1. This behavior only happens during the read part of the DMA transfer. Memory-to-memory DMA destination writes to the EMC static chip select work as expected. ES_LPC3220 . Â©   Rev. 9 â 1 June 2011 4 of 16  ES_LPC3220  LPC3220 DMA register values used in Figure 2: DMACConfig = 0x01 DMACCxSrcAddr = 0xe0000000; EMC_CS0 DMACCxDestAddr = 0xe0000040; EMC_CS0 DMACCxLLI = 0x0 DMACCxControl = 0x0c480004; Dest & Src addrs increment, Dest & Src 32-bit; Dburst & Sburst size 1; transfer size 4 DMACCxConfig = 0x01 EMCStaticConfig0 = 0x00000082; 32-bit width, Byte lane state 1 Fig 2. Scope shot 2 - actual read timing Results of this behavior: 1. DMA reads from an external memory will have lower performance than a software read loop. The source read burst of two, to get one transfer, will significantly increase the time to complete all transfers in the memory-to-memory DMA, therefore decreasing the overall throughput possible on the EMC_CSx_N static memory interface. 2. Potential unintended consequence when the last DMA read accesses the address beyond the DMA source buffer address in the FPGA or external peripheral chip. This extra address is the second access during the last DMA source read. ES_LPC3220 . Â©   Rev. 9 â 1 June 2011 5 of 16  ES_LPC3220  LPC3220 	ARM9				 When interfacing an external peripheral device that does not support burst mode access through the EMC Static Memory interface the following work-arounds are recommended: 1. Avoid using DMA to transfer read blocks of data from the external device. Instead use a software loop with LDR instruction to read blocks of data from the external device. 2. If DMA can't be avoided, ensure there is at least one unused address between the highest address used for the external device DMA data buffer and any status or control register in the device that will initiate any unwanted action just by reading from the register (i.e. clear an interrupt or status). 		3.1 DMA.1: Single burst DMA memory-to-memory transfers have additional memory cycles when the DMA source memory is on the EMC bus 			NXP
LPC3220	 In systems that use SDRAM and boot from NOR FLASH, an issue can occur on system reset that will prevent the SDRAM devices from releasing the data bus. This will prevent normal operation of NOR FLASH due to data bus contention and prevent the LPC3220 from booting correctly. This applies to systems using either Single Data Rate (SDR) or Double Data Rate (DDR) SDRAM devices.  If the LPC3220 is reset during an SDRAM access, the SDRAM clock and clock enable will be immediately de-asserted. If the de-assertion occurs during the period of time the SDRAM is driving the data bus, the SDRAM will hold that state until the next clock occurs at the SDRAM clock input when the clock enable is active. However, the LPC3220 won't deliver the clock and clock enables until software actually sets up the EMC state to do this, so the SDRAM will remain in the data assertion state on the data bus while the LPC3220 tries to boot. When the chip attempts to load boot code from NOR FLASH after reset, the correct signals are asserted to the NOR FLASH device and the NOR FLASH device places its data on the data bus. But if the SDRAM is still driving the bus, the NOR FLASH device and SDRAM device are in contention and the data will not be read correctly into the LPC3220. In this situation, the LPC3220 will fail to boot. 	ARM9				 Since this issue only occurs with NOR FLASH, using one of the other boot methods such as NAND or SPI FLASH boot is a good workaround for the issue. If booting from NOR FLASH is a requirement, the simple circuit shown in Figure 3 can be used to clear the SDRAM state at system reset. This will not change the normal functioning of the LPC3220 EMC or SDRAM operations. If SDRAM devices are also present on the 2nd SDRAM chip select, a similar circuit will be needed for those devices using EMC_CKE1. ES_LPC3220 . Â©   Rev. 9 â 1 June 2011 6 of 16  ES_LPC3220  LPC3220 Fig 3. 128 MB DDR SDRAM example ES_LPC3220 . Â©   Rev. 9 â 1 June 2011 7 of 16  ES_LPC3220  LPC3220 		3.2 NOR.1: When booting from NOR flash, SDRAM devices will not release the data bus, preventing the LPC3220 from booting correctly 			NXP
LPC3220	 DDR memory interface signal EMC_DQS[1:0] is source synchronous, defined to be driven by the MCU center aligned to the data EMC_D[15:0] for writes, while driven by the DDR memory edge aligned to the EMC_D[15:0] for reads. The basic DDR write timing is shown in the data sheet Fig 1. EMC_CLK t t DSS DSH command WRITE tDQSS tDQSL tDQSH EMC_DQS[1:0] t t su(Q) h(Q) EMC_D[15:0], EMC_DQM[1:0] 002aae437 Fig 4. Basic DDR write timing  For DDR writes the LPC3220 drives the EMC_DQS[1:0] earlier in the data valid window than center aligned. With the EMC_CLK at 133 MHz this produces a minimum set-up time between the EMC_D[15:0] and EMC_DQS[1:0] of 600 ps across silicon process, voltage and temperature. Test conditions are with the EMC buffers set to fast slew rate driving 2 inches of 50 ï transmission line and 10 pF load capacitance. DDR memories specify EMC_D[15:0] to EMC_DQS[1:0] set-up time minimum as 400 ps. This leaves 200 ps set-up time margin due to customer specific load and PCB layout implementation. See the LPC3220_30_40_50 data sheet for the complete range of DDR data output set-up time, tsu(Q), and data output hold time th(Q) times. 	ARM9				" To get the most DDR set-up time margin, the following is recommended: 1. The DDR initialization software should set the SDRAMCLK_CTRL register (0x4000 4068) SDRAM_PIN_SPEED[3:1] bits = 0 (fast slew rate). This is for both 1.8 V mobile and 2.5 V DDR memories. 2. Systems requiring 128 MB or less of DDR should be implemented using a single EMC_DYCSx_N for DDR. The single chip select system may be constructed with a single 16-bit wide DDR or two 8-bit wide DDR SDRAMs using up to the maximum supported 512 Mbit DDR density. Using two 8-bit wide DDRs will have less capacitive loading and facilitate simple point-to-point routing of EMC_D[15:0] and EMC_DQS[1:0] signals over using two 16-bit DDRs and two EMC_DYCSx banks. ES_LPC3220 . Â©   Rev. 9 â 1 June 2011 8 of 16  ES_LPC3220  LPC3220 3. Series termination resistors are not needed for the LPC3220 EMC outputs. If series termination resistors are used they should be placed as close to the DDR EMC_D[15:0] and EMC_DQS[1:0] pins as possible. 4. If the data bus EMC_D[15:0] is shared with additional devices (i.e., NOR flash, buffers, etc.) the board should be routed with a daisy chain topology, where the LPC3220 is placed at one extreme of the data bus and the DDR(s) at the other extreme. Other device(s) should be placed between the LPC3220 and DDR memory (closer to the DDR). 5. The PCB trace length of EMC_DQS[1:0] should be at least 2 inches (but not more than 4 inches) longer than EMC_DQ[15:0] and EMC_DQM[1:0]. On a typical FR4 PCB this adds at least 334 ps to set-up time margin for DDR writes. For reads from DDR the increased trace length of EMC_DQS[1:0] will be automatically compensated for by the software initialization function find_ddr_dqsin_delay() which sets the optimal value DDR_DQSIN_DELAY(SDRAMCLK_CTRL[6:2]). The function find_ddr_dqsin_delay() can be found in the ""DDR SDRAM setup code for the LPC32x0 series"" on the NXP web site. Example 128 MB system DDR SDRAM using a single EMC_DYCSx_N: LPC32x0 EMC DDR high byte (64M x 8) EMC_D[15:08] DQ7:0 22ohms EMC_DQS1 DQS 22ohms EMC_DQM1 DM BA1:0 / A12:0 nCS CKE, nRAS, nCAS, nWE CLK nCLK VREF low byte (64M x 8) V+_EMC EMC_D[07:00] DQ7:0 22ohms EMC_DQS0 DQS 22ohms EMC_DQM0 DM 20Kohms EMC_A[14:00] BA1:0 / A12:0 0.1uF 1% EMC_DYCS0_N nCS EMC_Control CKE, nRAS, nCAS, nWE EMC_CLK CLK 20Kohms 0.1uF 1% EMC_CLK_N NC nCLK VREF EMC_CLKIN Fig 5. 128 MB DDR SDRAM example ES_LPC3220 . Â©   Rev. 9 â 1 June 2011 9 of 16  ES_LPC3220  LPC3220 "		3.3 DDR.2: DDR EMC_D[15:0] to EMC_DQS[1:0] data output set-up time, tsu(Q), for MCU write to DDR provides limited timing margin Remark: This affects both 1.8 V mobile and 2.5 V DDR SDRAM system implementations. 			NXP
LPC3220	 DDR memory uses a differential clock which is generated by the LPC3220. The differential clock consists of two clock signals: EMC_CLK is the positive clock and DDR_nCLK is the negative clock.  There is approximately 1.27 ns of skew between the low transition of the DDR_nCLK and the high transition of the EMC_CLK. This can cause two problems: 1) Some DDR devices use this clock transition to drive a digital lock loop (DLL) in the DDR device. The DDR clock skew can cause the DDR device's internal DLL to loose lock, resulting in the wrong data being latched. 2) The DDR clock skew can also cause a reduced Data Valid Window (also called Data-Out Window) from a DDR device. However, the LPC3220 has a programmable DQS delay to achieve center alignment for accurate data reads. 	ARM9				 Connecting the DDR device negative clock input (DDR_nCLK from the LPC3220) to the DDR Reference Voltage (Vref - the midpoint of the DDR signal voltage swing, which is generally VDDQ/2) avoids the clock skew problem, though it also eliminates the advantages of differential signaling. The LPC3220 DDR_nCLK output should be left unconnected. DDR Reference Voltage can be generated with a divide-by-two voltage divider. Standard DDR memories usually require a Vref input, so this DDR reference voltage should already be available. Mobile DDR devices typically do not have a Vref input, so the external voltage divider may need to be added to the design for this work-around. It is also possible to compensate for the 1.27 ns clock skew by adding an additional 7 inches of pcb trace length to the EMC_CLK signal. However, this could have unintentional consequences; such as increased Electro-Magnetic Interference. ES_LPC3220 . Â©   Rev. 9 â 1 June 2011 10 of 16  ES_LPC3220  LPC3220 		3.4 DDR.1: DDR interface has >1.2 ns clock skew 			NXP
LPC3220	 An ONSW output pin (M15) is included in the LPC3220 to assist in waking up the chip after power is removed from all functions except the RTC and Battery RAM. When there is an active match condition the RTC will drive the ONSW pin HIGH. The RTC only drives the ONSW pin while the match is active, and after 1 second of active match, if the software has not accessed the RTC block, the ONSW pin will go low when the match is no longer active.  When power is removed from all functions except the RTC and Battery RAM, the RTC does NOT drive the ONSW pin HIGH when there is an active match condition. 	ARM9				 There is no work-around for this problem. 		3.5 RTC.1: An RTC match doesnât drive the ONSW pin active (HIGH) 			NXP
LPC3220	 The LPC3220 contains 12 pins (GPI_00 - GPI_09, GPI_19, GPI_28) that function as dedicated General Purpose Inputs. Each of these pins can generate an individual interrupt for the input pin. Sub Interrupt Controller Register 1 (SIC1_ER) and Sub Interrupt Controller Register 2 (SIC2_ER) contains bits that allow enabling or disabling the interrupt for the associated pin.  When bit nine is set to one in the Sub Interrupt Controller 2 Enable register (SIC2_ER[9]) it does not enable the interrupt for the GPI_08 pin. All other General Purpose Input pins (GPI_00 - GPI_07, GPI_09, GPI_19, GPI_28) interrupts work correctly. 	ARM9				 There is no work-around for this problem. ES_LPC3220 . Â©   Rev. 9 â 1 June 2011 11 of 16  ES_LPC3220  LPC3220 		3.6 INT.1: GPI_08 does not generate an interrupt signal 			NXP
LPC3220	 On the LPC3220, the Motor Control PWM (MCPWM) peripheral is optimized for three-phase AC and DC motor control applications and can also be used in applications which require timing, counting, capture, and comparison. The MCPWM contains three input pins (MCI0-2) for PWM channels 0, 1, and 2. The inputs can be used as feedbacks for controlling brushless DC motors with Hall sensors, and also can be used to trigger a Timer/Counterâs (TC) capture or increment a channelâs TC when MCPWM is configured as a timer/counter. Note: MCI0-2 pins are also called MCFB0-2 (refer to LPC32x0 User manual for more details).  The input pins (MCI0-2) are not functional. 	ARM9				 The GPIO interrupts1 need to be used instead of the MCPWM MCI0-2 pins. On the LPC3220, the GPIO interrupts can only be set to either trigger on the rising edge or on the falling edge. Therefore, in order to detect all six states of the connected hall sensor through an interrupt, the state of the pin needs to be determined and switch to rising or falling edge interrupt accordingly. 1. Available GPIO interrupt pins: GPIO_00 to GPIO_05, GPI_00 to GPI_09, GPI_19, GPI_28, and all port 0 and port 1 pins. ES_LPC3220 . Â©   Rev. 9 â 1 June 2011 12 of 16  ES_LPC3220  LPC3220 		3.7 MCPWM.1: Input pins (MCI0-2) on the Motor Control PWM peripheral are not functional 			NXP
LPC3220	 The three high speed UART's (HSUART) receive (RX) FIFOs can sometimes enter a state where they no longer accept received data. When this state occurs, the HSUART's RX FIFO will no longer accept data regardless of RX FIFO fill status. The receive state of the HSUART may indicate a number of possible, but invalid, receive statuses. These invalid statuses may include RX FIFO or timeout interrupts pending with no receive data in the RX FIFO, invalid RX FIFO status, stuck RX interrupts, or other possible RX statuses. Once the HSUART enters this state, the state can only be cleared by a chip reset. This applies to the U1_RX, U2_RX, and U7_RX pins. The HSUART's transmit side is not affected by this issue and will work as normal when the HSUART receive side stops. The four standard UARTs do not exhibit this behavior.  It has been determined that this failed receive state can be entered by receiving a burst of high frequency noise into the HSUART RX pin. High frequency noise consists of pulsed or random toggling of the HSUART RX line at about 2.5 MHz or greater. The chance of the HSUART entering the state increases with the number of pulses and frequency of the pulses received. Generally, a single pulse won't cause the state to occur. During normal data transfer with transfer rates 2400 bps (416 uS) to 921.6 Kbps (1.085 uS), this state won't occur. However, conditions outside the transfer itself may cause the state to occur. It has been observed in some systems that insertion of the serial cable into the board's serial connector can cause connection noise or oscillations on the transceiver. This noise is driven onto the HSUART RX pin from the transceiver as a series of random pulses. 	ARM9				 If all 7 UARTs aren't needed or 921.6 Kbps transfer rate isn't needed, use the standard UARTs instead of the high speed UARTs to avoid the issue altogether. For systems that require the HSUARTs, care must be taken to limit the exposure of the HSUART RX signal for the type of signal conditions that can cause the state to occur. There are several possible solutions that can help reduce the state from occurring. Whenever the HSUART is not in use, place the HSUART into loopback mode. When in loopback, the RX pin is connected internally to the HSUARTs TX pin and is isolated from the external RX input. While in this loopback state, the condition won't occur on the HSUART regardless of the signal on the RX input. The HSUART TX pin will remain in the idle state in loopback mode when no data is being sent from the HSUART. Optionally, if the HSUART is connected to a transceiver that supports enabling and disabling of the input signal from the transceiver RX input to the transceiver RX output to the HSUART RX input, disable it when not expecting a transmission. Regardless of how the transceiver is connected to the RX pin, the RX pin should be prevented from floating at power-up, reset, or when the transceiver is disabled. This can be done by adding a pull-up resistor to the HSUART RX pin. If using a system where the HSUART always need to be enabled, consider adding the capability to sense when the cable has been plugged into the connector and switch the HSUART out of loopback mode only once the cable has been installed to prevent cable insertion noise. ES_LPC3220 . Â©   Rev. 9 â 1 June 2011 13 of 16  ES_LPC3220  LPC3220 		3.8 HSUART.1: High speed UART receive FIFO and status can freeze 			NXP
LPC3220	 Full-/low-speed signaling uses bit stuffing throughout the packet without exception. If the receiver sees seven consecutive ones anywhere in the packet, then a bit stuffing error has occurred and the packet should be ignored. The time interval just before an EOP is a special case. The last data bit before the EOP can become stretched by hub switching skews. This is known as dribble and can lead to a situation where dribble introduces a sixth bit that does not require a bit stuff. Therefore, the receiver must accept a packet for which there are up to six full bit times at the port with no transitions prior to the EOP.  The USB host controller will hang indefinitely if it sees a dribble bit on the USB bus. It will hang the first time a dribble bit is seen. Once it is in this state there is no recovery other than a hard chip reset. This problem has no effect on the USB device controller. 	ARM9				 None. 4. AC/DC deviations detail 		3.9 USB.1: USB host controller hangs on a dribble bit 			NXP
LPC3220	 The LPC3220 was designed to withstand electrostatic discharges up to 2000 V using the Human Body Model.  The RESET_N pad (pin M14) does not pass ESD tests above 1000 V. 	ARM9				 Observe proper ESD handling precautions for the RESET_N pin ES_LPC3220 . Â©   Rev. 9 â 1 June 2011 14 of 16		4.1 ESD.1: Weak ESD protection on Reset_N pad 			NXP
LPC3240	 The DMA controller is an AHB master that can transfer blocks of data between peripheral-to-memory, memory-to-peripheral, peripheral-to-peripheral, and memory-to-memory. In addition to transferring data between memories, a DMA memory-to-memory flow can be used to transfer blocks of data to / from an FPGA or external peripheral chip connected to an EMC static memory chip select. When a memory, FPGA or external peripheral chip does not support burst transfers (i.e. multiple reads for each active chip select or read strobe) the burst size for that memory-to-memory flow must be set for one transfer per burst.  When using memory-to-memory DMA with the EMC static chip select (EMC_CS[x]_N) as the DMA source and the DMA channel source burst size is set for a single transfer (DMACCxControl:SBSIZE = 0), each DMA source read should be a single bus-wide access. The access should be similar to reading the EMC_CS[x]_N static memory with an ARM LDR instruction, as shown in Figure 1. Note the EMC signal timing for the read is controlled by the EMCSTATICx registers. In all example scope shots the EMCSTATICWAITx registers are set to the maximum value. Fig 1. Scope shot 1 - expected read timing However, the actual EMC timing for the source DMA read is a double wide chip select with a burst of two reads (notice how the address increments near the halfway point of nCS0 active), see Figure 2. The second data read during the burst is discarded, as the DMA destination write (also to nCS0 in Figure 2) following each read, always writes the first value read during the read burst. When the DMA source address is set to auto-increment, the last DMA read transfer will address the last address of the source buffer and the last source buffer address +1. This behavior only happens during the read part of the DMA transfer. Memory-to-memory DMA destination writes to the EMC static chip select work as expected. ES_LPC3240 . Â©   Rev. 9 â 1 June 2011 5 of 17  ES_LPC3240  LPC3240 DMA register values used in Figure 2: DMACConfig = 0x01 DMACCxSrcAddr = 0xe0000000; EMC_CS0 DMACCxDestAddr = 0xe0000040; EMC_CS0 DMACCxLLI = 0x0 DMACCxControl = 0x0c480004; Dest & Src addrs increment, Dest & Src 32-bit; Dburst & Sburst size 1; transfer size 4 DMACCxConfig = 0x01 EMCStaticConfig0 = 0x00000082; 32-bit width, Byte lane state 1 Fig 2. Scope shot 2 - actual read timing Results of this behavior: 1. DMA reads from an external memory will have lower performance than a software read loop. The source read burst of two, to get one transfer, will significantly increase the time to complete all transfers in the memory-to-memory DMA, therefore decreasing the overall throughput possible on the EMC_CSx_N static memory interface. 2. Potential unintended consequence when the last DMA read accesses the address beyond the DMA source buffer address in the FPGA or external peripheral chip. This extra address is the second access during the last DMA source read. ES_LPC3240 . Â©   Rev. 9 â 1 June 2011 6 of 17  ES_LPC3240  LPC3240 	ARM9				 When interfacing an external peripheral device that does not support burst mode access through the EMC Static Memory interface the following work-arounds are recommended: 1. Avoid using DMA to transfer read blocks of data from the external device. Instead use a software loop with LDR instruction to read blocks of data from the external device. 2. If DMA can't be avoided, ensure there is at least one unused address between the highest address used for the external device DMA data buffer and any status or control register in the device that will initiate any unwanted action just by reading from the register (i.e. clear an interrupt or status). 		3.1 DMA.1: Single burst DMA memory-to-memory transfers have additional memory cycles when the DMA source memory is on the EMC bus 			NXP
LPC3240	 In systems that use SDRAM and boot from NOR FLASH, an issue can occur on system reset that will prevent the SDRAM devices from releasing the data bus. This will prevent normal operation of NOR FLASH due to data bus contention and prevent the LPC3240 from booting correctly. This applies to systems using either Single Data Rate (SDR) or Double Data Rate (DDR) SDRAM devices.  If the LPC3240 is reset during an SDRAM access, the SDRAM clock and clock enable will be immediately de-asserted. If the de-assertion occurs during the period of time the SDRAM is driving the data bus, the SDRAM will hold that state until the next clock occurs at the SDRAM clock input when the clock enable is active. However, the LPC3240 won't deliver the clock and clock enables until software actually sets up the EMC state to do this, so the SDRAM will remain in the data assertion state on the data bus while the LPC3240 tries to boot. When the chip attempts to load boot code from NOR FLASH after reset, the correct signals are asserted to the NOR FLASH device and the NOR FLASH device places its data on the data bus. But if the SDRAM is still driving the bus, the NOR FLASH device and SDRAM device are in contention and the data will not be read correctly into the LPC3240. In this situation, the LPC3240 will fail to boot. 	ARM9				 Since this issue only occurs with NOR FLASH, using one of the other boot methods such as NAND or SPI FLASH boot is a good workaround for the issue. If booting from NOR FLASH is a requirement, the simple circuit shown in Figure 3 can be used to clear the SDRAM state at system reset. This will not change the normal functioning of the LPC3240 EMC or SDRAM operations. If SDRAM devices are also present on the 2nd SDRAM chip select, a similar circuit will be needed for those devices using EMC_CKE1. ES_LPC3240 . Â©   Rev. 9 â 1 June 2011 7 of 17  ES_LPC3240  LPC3240 Fig 3. 128 MB DDR SDRAM example 		3.2 NOR.1: When booting from NOR flash, SDRAM devices will not release the data bus, preventing the LPC3240 from booting correctly 			NXP
LPC3240	 The transmit consume index register defines the descriptor that is going to be transmitted next by the hardware transmit process. After a frame has been transmitted hardware increments the index, wrapping the value to 0 once the value of TxDescriptorNumber has been reached. If the TxConsumeIndex equals TxProduceIndex the descriptor array is empty and the transmit channel will stop transmitting until software produces new descriptors.  The TxConsumeIndex register is not updated correctly (from 0 to 1) after the first frame is sent. After the next frame sent, the TxConsumeIndex register is updated by two (from 0 to 2). This only happens the very first time, so subsequent updates are correct (even those from 0 to 1, after wrapping the value to 0 once the value of TxDescriptorNumber has been reached) 	ARM9				 Software can correct this situation in many ways; for example, sending a dummy frame after initialization. 		3.3 Ethernet.1: Ethernet TxConsumeIndex register does not update correctly after the first frame is sent 			NXP
LPC3240	 DDR memory interface signal EMC_DQS[1:0] is source synchronous, defined to be driven by the MCU center aligned to the data EMC_D[15:0] for writes, while driven by the DDR memory edge aligned to the EMC_D[15:0] for reads. The basic DDR write timing is shown in the data sheet Fig 1. ES_LPC3240 . Â©   Rev. 9 â 1 June 2011 8 of 17  ES_LPC3240  LPC3240 EMC_CLK t t DSS DSH command WRITE tDQSS tDQSL tDQSH EMC_DQS[1:0] t t su(Q) h(Q) EMC_D[15:0], EMC_DQM[1:0] 002aae437 Fig 4. Basic DDR write timing  For DDR writes the LPC3240 drives the EMC_DQS[1:0] earlier in the data valid window than center aligned. With the EMC_CLK at 133 MHz this produces a minimum set-up time between the EMC_D[15:0] and EMC_DQS[1:0] of 600 ps across silicon process, voltage and temperature. Test conditions are with the EMC buffers set to fast slew rate driving 2 inches of 50 ï transmission line and 10 pF load capacitance. DDR memories specify EMC_D[15:0] to EMC_DQS[1:0] set-up time minimum as 400 ps. This leaves 200 ps set-up time margin due to customer specific load and PCB layout implementation. See the LPC3220_30_40_50 data sheet for the complete range of DDR data output set-up time, tsu(Q), and data output hold time th(Q) times. 	ARM9				" To get the most DDR set-up time margin, the following is recommended: 1. The DDR initialization software should set the SDRAMCLK_CTRL register (0x4000 4068) SDRAM_PIN_SPEED[3:1] bits = 0 (fast slew rate). This is for both 1.8 V mobile and 2.5 V DDR memories. 2. Systems requiring 128 MB or less of DDR should be implemented using a single EMC_DYCSx_N for DDR. The single chip select system may be constructed with a single 16-bit wide DDR or two 8-bit wide DDR SDRAMs using up to the maximum supported 512 Mbit DDR density. Using two 8-bit wide DDRs will have less capacitive loading and facilitate simple point-to-point routing of EMC_D[15:0] and EMC_DQS[1:0] signals over using two 16-bit DDRs and two EMC_DYCSx banks. 3. Series termination resistors are not needed for the LPC3240 EMC outputs. If series termination resistors are used they should be placed as close to the DDR EMC_D[15:0] and EMC_DQS[1:0] pins as possible. 4. If the data bus EMC_D[15:0] is shared with additional devices (i.e., NOR flash, buffers, etc.) the board should be routed with a daisy chain topology, where the LPC3240 is placed at one extreme of the data bus and the DDR(s) at the other extreme. Other device(s) should be placed between the LPC3240 and DDR memory (closer to the DDR). ES_LPC3240 . Â©   Rev. 9 â 1 June 2011 9 of 17  ES_LPC3240  LPC3240 5. The PCB trace length of EMC_DQS[1:0] should be at least 2 inches (but not more than 4 inches) longer than EMC_DQ[15:0] and EMC_DQM[1:0]. On a typical FR4 PCB this adds at least 334 ps to set-up time margin for DDR writes. For reads from DDR the increased trace length of EMC_DQS[1:0] will be automatically compensated for by the software initialization function find_ddr_dqsin_delay() which sets the optimal value DDR_DQSIN_DELAY(SDRAMCLK_CTRL[6:2]). The function find_ddr_dqsin_delay() can be found in the ""DDR SDRAM setup code for the LPC32x0 series"" on the NXP web site. Example 128 MB system DDR SDRAM using a single EMC_DYCSx_N: LPC32x0 EMC DDR high byte (64M x 8) EMC_D[15:08] DQ7:0 22ohms EMC_DQS1 DQS 22ohms EMC_DQM1 DM BA1:0 / A12:0 nCS CKE, nRAS, nCAS, nWE CLK nCLK VREF low byte (64M x 8) V+_EMC EMC_D[07:00] DQ7:0 22ohms EMC_DQS0 DQS 22ohms EMC_DQM0 DM 20Kohms EMC_A[14:00] BA1:0 / A12:0 0.1uF 1% EMC_DYCS0_N nCS EMC_Control CKE, nRAS, nCAS, nWE EMC_CLK CLK 20Kohms 0.1uF 1% EMC_CLK_N NC nCLK VREF EMC_CLKIN Fig 5. 128 MB DDR SDRAM example ES_LPC3240 . Â©   Rev. 9 â 1 June 2011 10 of 17  ES_LPC3240  LPC3240 "		3.4 DDR.2: DDR EMC_D[15:0] to EMC_DQS[1:0] data output set-up time, tsu(Q), for MCU write to DDR provides limited timing margin Remark: This affects both 1.8 V mobile and 2.5 V DDR SDRAM system implementations. 			NXP
LPC3240	 DDR memory uses a differential clock which is generated by the LPC3240. The differential clock consists of two clock signals: EMC_CLK is the positive clock and DDR_nCLK is the negative clock.  There is approximately 1.27 ns of skew between the low transition of the DDR_nCLK and the high transition of the EMC_CLK. This can cause two problems: 1) Some DDR devices use this clock transition to drive a digital lock loop (DLL) in the DDR device. The DDR clock skew can cause the DDR device's internal DLL to loose lock, resulting in the wrong data being latched. 2) The DDR clock skew can also cause a reduced Data Valid Window (also called Data-Out Window) from a DDR device. However, the LPC3240 has a programmable DQS delay to achieve center alignment for accurate data reads. 	ARM9				 Connecting the DDR device negative clock input (DDR_nCLK from the LPC3240) to the DDR Reference Voltage (Vref - the midpoint of the DDR signal voltage swing, which is generally VDDQ/2) avoids the clock skew problem, though it also eliminates the advantages of differential signaling. The LPC3240 DDR_nCLK output should be left unconnected. DDR Reference Voltage can be generated with a divide-by-two voltage divider. Standard DDR memories usually require a Vref input, so this DDR reference voltage should already be available. Mobile DDR devices typically do not have a Vref input, so the external voltage divider may need to be added to the design for this work-around. It is also possible to compensate for the 1.27 ns clock skew by adding an additional 7 inches of pcb trace length to the EMC_CLK signal. However, this could have unintentional consequences; such as increased Electro-Magnetic Interference. ES_LPC3240 . Â©   Rev. 9 â 1 June 2011 11 of 17  ES_LPC3240  LPC3240 		3.5 DDR.1: DDR interface has >1.2 ns clock skew 			NXP
LPC3240	 An ONSW output pin (M15) is included in the LPC3240 to assist in waking up the chip after power is removed from all functions except the RTC and Battery RAM. When there is an active match condition the RTC will drive the ONSW pin HIGH. The RTC only drives the ONSW pin while the match is active, and after 1 second of active match, if the software has not accessed the RTC block, the ONSW pin will go low when the match is no longer active.  When power is removed from all functions except the RTC and Battery RAM, the RTC does NOT drive the ONSW pin HIGH when there is an active match condition. 	ARM9				 There is no work-around for this problem. 		3.6 RTC.1: An RTC match doesnât drive the ONSW pin active (HIGH) 			NXP
LPC3240	 The LPC3240 contains 12 pins (GPI_00 - GPI_09, GPI_19, GPI_28 ) that function as dedicated General Purpose Inputs. Each of these pins can generate an individual interrupt for the input pin. Sub Interrupt Controller Register 1 (SIC1_ER) and Sub Interrupt Controller Register 2 (SIC2_ER) contains bits that allow enabling or disabling the interrupt for the associated pin.  When bit nine is set to one in the Sub Interrupt Controller 2 Enable register (SIC2_ER[9]) it does not enable the interrupt for the GPI_08 pin. All other General Purpose Input pins (GPI_00 - GPI_07, GPI_09, GPI_19, GPI_28) interrupts work correctly. 	ARM9				 There is no work-around for this problem. ES_LPC3240 . Â©   Rev. 9 â 1 June 2011 12 of 17  ES_LPC3240  LPC3240 		3.7 INT.1: GPI_08 does not generate an interrupt signal 			NXP
LPC3240	 On the LPC3240, the Motor Control PWM (MCPWM) peripheral is optimized for three-phase AC and DC motor control applications and can also be used in applications which require timing, counting, capture, and comparison. The MCPWM contains three input pins (MCI0-2) for PWM channels 0, 1, and 2. The inputs can be used as feedbacks for controlling brushless DC motors with Hall sensors, and also can be used to trigger a Timer/Counterâs (TC) capture or increment a channelâs TC when MCPWM is configured as a timer/counter. Note: MCI0-2 pins are also called MCFB0-2 (refer to LPC32x0 User manual for more details).  The input pins (MCI0-2) are not functional. 	ARM9				 The GPIO interrupts1 need to be used instead of the MCPWM MCI0-2 pins. On the LPC3240, the GPIO interrupts can only be set to either trigger on the rising edge or on the falling edge. Therefore, in order to detect all six states of the connected hall sensor through an interrupt, the state of the pin needs to be determined and switch to rising or falling edge interrupt accordingly. 1. Available GPIO interrupt pins: GPIO_00 to GPIO_05, GPI_00 to GPI_09, GPI_19, GPI_28, and all port 0 and port 1 pins. ES_LPC3240 . Â©   Rev. 9 â 1 June 2011 13 of 17  ES_LPC3240  LPC3240 		3.8 MCPWM.1: Input pins (MCI0-2) on the Motor Control PWM peripheral are not functional 			NXP
LPC3240	 The three high speed UART's (HSUART) receive (RX) FIFOs can sometimes enter a state where they no longer accept received data. When this state occurs, the HSUART's RX FIFO will no longer accept data regardless of RX FIFO fill status. The receive state of the HSUART may indicate a number of possible, but invalid, receive statuses. These invalid statuses may include RX FIFO or timeout interrupts pending with no receive data in the RX FIFO, invalid RX FIFO status, stuck RX interrupts, or other possible RX statuses. Once the HSUART enters this state, the state can only be cleared by a chip reset. This applies to the U1_RX, U2_RX, and U7_RX pins. The HSUART's transmit side is not affected by this issue and will work as normal when the HSUART receive side stops. The four standard UARTs do not exhibit this behavior.  It has been determined that this failed receive state can be entered by receiving a burst of high frequency noise into the HSUART RX pin. High frequency noise consists of pulsed or random toggling of the HSUART RX line at about 2.5 MHz or greater. The chance of the HSUART entering the state increases with the number of pulses and frequency of the pulses received. Generally, a single pulse won't cause the state to occur. During normal data transfer with transfer rates 2400 bps (416 uS) to 921.6 Kbps (1.085 uS), this state won't occur. However, conditions outside the transfer itself may cause the state to occur. It has been observed in some systems that insertion of the serial cable into the board's serial connector can cause connection noise or oscillations on the transceiver. This noise is driven onto the HSUART RX pin from the transceiver as a series of random pulses. 	ARM9				 If all 7 UARTs aren't needed or 921.6 Kbps transfer rate isn't needed, use the standard UARTs instead of the high speed UARTs to avoid the issue altogether. For systems that require the HSUARTs, care must be taken to limit the exposure of the HSUART RX signal for the type of signal conditions that can cause the state to occur. There are several possible solutions that can help reduce the state from occurring. Whenever the HSUART is not in use, place the HSUART into loopback mode. When in loopback, the RX pin is connected internally to the HSUARTs TX pin and is isolated from the external RX input. While in this loopback state, the condition won't occur on the HSUART regardless of the signal on the RX input. The HSUART TX pin will remain in the idle state in loopback mode when no data is being sent from the HSUART. Optionally, if the HSUART is connected to a transceiver that supports enabling and disabling of the input signal from the transceiver RX input to the transceiver RX output to the HSUART RX input, disable it when not expecting a transmission. Regardless of how the transceiver is connected to the RX pin, the RX pin should be prevented from floating at power-up, reset, or when the transceiver is disabled. This can be done by adding a pull-up resistor to the HSUART RX pin. If using a system where the HSUART always need to be enabled, consider adding the capability to sense when the cable has been plugged into the connector and switch the HSUART out of loopback mode only once the cable has been installed to prevent cable insertion noise. ES_LPC3240 . Â©   Rev. 9 â 1 June 2011 14 of 17  ES_LPC3240  LPC3240 		3.9 HSUART.1: High speed UART receive FIFO and status can freeze 			NXP
LPC3240	 Full-/low-speed signaling uses bit stuffing throughout the packet without exception. If the receiver sees seven consecutive ones anywhere in the packet, then a bit stuffing error has occurred and the packet should be ignored. The time interval just before an EOP is a special case. The last data bit before the EOP can become stretched by hub switching skews. This is known as dribble and can lead to a situation where dribble introduces a sixth bit that does not require a bit stuff. Therefore, the receiver must accept a packet for which there are up to six full bit times at the port with no transitions prior to the EOP.  The USB host controller will hang indefinitely if it sees a dribble bit on the USB bus. It will hang the first time a dribble bit is seen. Once it is in this state there is no recovery other than a hard chip reset. This problem has no effect on the USB device controller. 	ARM9				 None. 4. AC/DC deviations detail 		3.10 USB.1: USB host controller hangs on a dribble bit 			NXP
LPC3240	 The LPC3240 was designed to withstand electrostatic discharges up to 2000 V using the Human Body Model.  The RESET_N pad (pin M14) does not pass ESD tests above 1000 V. 	ARM9				 Observe proper ESD handling precautions for the RESET_N pin		4.1 ESD.1: Weak ESD protection on Reset_N pad 			NXP
LPC3250	 The DMA controller is an AHB master that can transfer blocks of data between peripheral-to-memory, memory-to-peripheral, peripheral-to-peripheral, and memory-to-memory. In addition to transferring data between memories, a DMA memory-to-memory flow can be used to transfer blocks of data to / from an FPGA or external peripheral chip connected to an EMC static memory chip select. When a memory, FPGA or external peripheral chip does not support burst transfers (i.e. multiple reads for each active chip select or read strobe) the burst size for that memory-to-memory flow must be set for one transfer per burst.  When using memory-to-memory DMA with the EMC static chip select (EMC_CS[x]_N) as the DMA source and the DMA channel source burst size is set for a single transfer (DMACCxControl:SBSIZE = 0), each DMA source read should be a single bus-wide access. The access should be similar to reading the EMC_CS[x]_N static memory with an ARM LDR instruction, as shown in Figure 1. Note the EMC signal timing for the read is controlled by the EMCSTATICx registers. In all example scope shots the EMCSTATICWAITx registers are set to the maximum value. Fig 1. Scope shot 1 - expected read timing However, the actual EMC timing for the source DMA read is a double wide chip select with a burst of two reads (notice how the address increments near the halfway point of nCS0 active), see Figure 2. The second data read during the burst is discarded, as the DMA destination write (also to nCS0 in Figure 2) following each read, always writes the first value read during the read burst. When the DMA source address is set to auto-increment, the last DMA read transfer will address the last address of the source buffer and the last source buffer address +1. This behavior only happens during the read part of the DMA transfer. Memory-to-memory DMA destination writes to the EMC static chip select work as expected. ES_LPC3250 . Â©   Rev. 9 â 1 June 2011 5 of 17  ES_LPC3250  LPC3250 DMA register values used in Figure 2: DMACConfig = 0x01 DMACCxSrcAddr = 0xe0000000; EMC_CS0 DMACCxDestAddr = 0xe0000040; EMC_CS0 DMACCxLLI = 0x0 DMACCxControl = 0x0c480004; Dest & Src addrs increment, Dest & Src 32-bit; Dburst & Sburst size 1; transfer size 4 DMACCxConfig = 0x01 EMCStaticConfig0 = 0x00000082; 32-bit width, Byte lane state 1 Fig 2. Scope shot 2 - actual read timing Results of this behavior: 1. DMA reads from an external memory will have lower performance than a software read loop. The source read burst of two, to get one transfer, will significantly increase the time to complete all transfers in the memory-to-memory DMA, therefore decreasing the overall throughput possible on the EMC_CSx_N static memory interface. 2. Potential unintended consequence when the last DMA read accesses the address beyond the DMA source buffer address in the FPGA or external peripheral chip. This extra address is the second access during the last DMA source read. ES_LPC3250 . Â©   Rev. 9 â 1 June 2011 6 of 17  ES_LPC3250  LPC3250 	ARM9				 When interfacing an external peripheral device that does not support burst mode access through the EMC Static Memory interface the following work-arounds are recommended: 1. Avoid using DMA to transfer read blocks of data from the external device. Instead use a software loop with LDR instruction to read blocks of data from the external device. 2. If DMA can't be avoided, ensure there is at least one unused address between the highest address used for the external device DMA data buffer and any status or control register in the device that will initiate any unwanted action just by reading from the register (i.e. clear an interrupt or status). 		3.1 DMA.1: Single burst DMA memory-to-memory transfers have additional memory cycles when the DMA source memory is on the EMC bus 			NXP
LPC3250	 In systems that use SDRAM and boot from NOR FLASH, an issue can occur on system reset that will prevent the SDRAM devices from releasing the data bus. This will prevent normal operation of NOR FLASH due to data bus contention and prevent the LPC3250 from booting correctly. This applies to systems using either Single Data Rate (SDR) or Double Data Rate (DDR) SDRAM devices.  If the LPC3250 is reset during an SDRAM access, the SDRAM clock and clock enable will be immediately de-asserted. If the de-assertion occurs during the period of time the SDRAM is driving the data bus, the SDRAM will hold that state until the next clock occurs at the SDRAM clock input when the clock enable is active. However, the LPC3250 won't deliver the clock and clock enables until software actually sets up the EMC state to do this, so the SDRAM will remain in the data assertion state on the data bus while the LPC3250 tries to boot. When the chip attempts to load boot code from NOR FLASH after reset, the correct signals are asserted to the NOR FLASH device and the NOR FLASH device places its data on the data bus. But if the SDRAM is still driving the bus, the NOR FLASH device and SDRAM device are in contention and the data will not be read correctly into the LPC3250. In this situation, the LPC3250 will fail to boot. 	ARM9				 Since this issue only occurs with NOR FLASH, using one of the other boot methods such as NAND or SPI FLASH boot is a good workaround for the issue. If booting from NOR FLASH is a requirement, the simple circuit shown in Figure 3 can be used to clear the SDRAM state at system reset. This will not change the normal functioning of the LPC3250 EMC or SDRAM operations. If SDRAM devices are also present on the 2nd SDRAM chip select, a similar circuit will be needed for those devices using EMC_CKE1. ES_LPC3250 . Â©   Rev. 9 â 1 June 2011 7 of 17  ES_LPC3250  LPC3250 Fig 3. 128 MB DDR SDRAM example 		3.2 NOR.1: When booting from NOR flash, SDRAM devices will not release the data bus, preventing the LPC3250 from booting correctly 			NXP
LPC3250	 The transmit consume index register defines the descriptor that is going to be transmitted next by the hardware transmit process. After a frame has been transmitted hardware increments the index, wrapping the value to 0 once the value of TxDescriptorNumber has been reached. If the TxConsumeIndex equals TxProduceIndex the descriptor array is empty and the transmit channel will stop transmitting until software produces new descriptors.  The TxConsumeIndex register is not updated correctly (from 0 to 1) after the first frame is sent. After the next frame sent, the TxConsumeIndex register is updated by two (from 0 to 2). This only happens the very first time, so subsequent updates are correct (even those from 0 to 1, after wrapping the value to 0 once the value of TxDescriptorNumber has been reached) 	ARM9				 Software can correct this situation in many ways; for example, sending a dummy frame after initialization. 		3.3 Ethernet.1: Ethernet TxConsumeIndex register does not update correctly after the first frame is sent 			NXP
LPC3250	 DDR memory interface signal EMC_DQS[1:0] is source synchronous, defined to be driven by the MCU center aligned to the data EMC_D[15:0] for writes, while driven by the DDR memory edge aligned to the EMC_D[15:0] for reads. The basic DDR write timing is shown in the data sheet Fig 1. ES_LPC3250 . Â©   Rev. 9 â 1 June 2011 8 of 17  ES_LPC3250  LPC3250 EMC_CLK t t DSS DSH command WRITE tDQSS tDQSL tDQSH EMC_DQS[1:0] t t su(Q) h(Q) EMC_D[15:0], EMC_DQM[1:0] 002aae437 Fig 4. Basic DDR write timing  For DDR writes the LPC3250 drives the EMC_DQS[1:0] earlier in the data valid window than center aligned. With the EMC_CLK at 133 MHz this produces a minimum set-up time between the EMC_D[15:0] and EMC_DQS[1:0] of 600 ps across silicon process, voltage and temperature. Test conditions are with the EMC buffers set to fast slew rate driving 2 inches of 50 ï transmission line and 10 pF load capacitance. DDR memories specify EMC_D[15:0] to EMC_DQS[1:0] set-up time minimum as 400 ps. This leaves 200 ps set-up time margin due to customer specific load and PCB layout implementation. See the LPC3220_30_40_50 data sheet for the complete range of DDR data output set-up time, tsu(Q), and data output hold time th(Q) times. 	ARM9				" To get the most DDR set-up time margin, the following is recommended: 1. The DDR initialization software should set the SDRAMCLK_CTRL register (0x4000 4068) SDRAM_PIN_SPEED[3:1] bits = 0 (fast slew rate). This is for both 1.8 V mobile and 2.5 V DDR memories. 2. Systems requiring 128 MB or less of DDR should be implemented using a single EMC_DYCSx_N for DDR. The single chip select system may be constructed with a single 16-bit wide DDR or two 8-bit wide DDR SDRAMs using up to the maximum supported 512 Mbit DDR density. Using two 8-bit wide DDRs will have less capacitive loading and facilitate simple point-to-point routing of EMC_D[15:0] and EMC_DQS[1:0] signals over using two 16-bit DDRs and two EMC_DYCSx banks. 3. Series termination resistors are not needed for the LPC3250 EMC outputs. If series termination resistors are used they should be placed as close to the DDR EMC_D[15:0] and EMC_DQS[1:0] pins as possible. 4. If the data bus EMC_D[15:0] is shared with additional devices (i.e., NOR flash, buffers, etc.) the board should be routed with a daisy chain topology, where the LPC3250 is placed at one extreme of the data bus and the DDR(s) at the other extreme. Other device(s) should be placed between the LPC3250 and DDR memory (closer to the DDR). ES_LPC3250 . Â©   Rev. 9 â 1 June 2011 9 of 17  ES_LPC3250  LPC3250 5. The PCB trace length of EMC_DQS[1:0] should be at least 2 inches (but not more than 4 inches) longer than EMC_DQ[15:0] and EMC_DQM[1:0]. On a typical FR4 PCB this adds at least 334 ps to set-up time margin for DDR writes. For reads from DDR the increased trace length of EMC_DQS[1:0] will be automatically compensated for by the software initialization function find_ddr_dqsin_delay() which sets the optimal value DDR_DQSIN_DELAY(SDRAMCLK_CTRL[6:2]). The function find_ddr_dqsin_delay() can be found in the ""DDR SDRAM setup code for the LPC32x0 series"" on the NXP web site. Example 128 MB system DDR SDRAM using a single EMC_DYCSx_N: LPC32x0 EMC DDR high byte (64M x 8) EMC_D[15:08] DQ7:0 22ohms EMC_DQS1 DQS 22ohms EMC_DQM1 DM BA1:0 / A12:0 nCS CKE, nRAS, nCAS, nWE CLK nCLK VREF low byte (64M x 8) V+_EMC EMC_D[07:00] DQ7:0 22ohms EMC_DQS0 DQS 22ohms EMC_DQM0 DM 20Kohms EMC_A[14:00] BA1:0 / A12:0 0.1uF 1% EMC_DYCS0_N nCS EMC_Control CKE, nRAS, nCAS, nWE EMC_CLK CLK 20Kohms 0.1uF 1% EMC_CLK_N NC nCLK VREF EMC_CLKIN Fig 5. 128 MB DDR SDRAM example ES_LPC3250 . Â©   Rev. 9 â 1 June 2011 10 of 17  ES_LPC3250  LPC3250 "		3.4 DDR.2: DDR EMC_D[15:0] to EMC_DQS[1:0] data output set-up time, tsu(Q), for MCU write to DDR provides limited timing margin Remark: This affects both 1.8 V mobile and 2.5 V DDR SDRAM system implementations. 			NXP
LPC3250	 DDR memory uses a differential clock which is generated by the LPC3250. The differential clock consists of two clock signals: EMC_CLK is the positive clock and DDR_nCLK is the negative clock.  There is approximately 1.27 ns of skew between the low transition of the DDR_nCLK and the high transition of the EMC_CLK. This can cause two problems: 1) Some DDR devices use this clock transition to drive a digital lock loop (DLL) in the DDR device. The DDR clock skew can cause the DDR device's internal DLL to loose lock, resulting in the wrong data being latched. 2) The DDR clock skew can also cause a reduced Data Valid Window (also called Data-Out Window) from a DDR device. However, the LPC3250 has a programmable DQS delay to achieve center alignment for accurate data reads. 	ARM9				 Connecting the DDR device negative clock input (DDR_nCLK from the LPC3250) to the DDR Reference Voltage (Vref - the midpoint of the DDR signal voltage swing, which is generally VDDQ/2) avoids the clock skew problem, though it also eliminates the advantages of differential signaling. The LPC3250 DDR_nCLK output should be left unconnected. DDR Reference Voltage can be generated with a divide-by-two voltage divider. Standard DDR memories usually require a Vref input, so this DDR reference voltage should already be available. Mobile DDR devices typically do not have a Vref input, so the external voltage divider may need to be added to the design for this work-around. It is also possible to compensate for the 1.27 ns clock skew by adding an additional 7 inches of pcb trace length to the EMC_CLK signal. However, this could have unintentional consequences; such as increased Electro-Magnetic Interference. 		3.5 DDR.1: DDR interface has >1.2 ns clock skew 			NXP
LPC3250	 The LCD controller is an AHB Master that uses an internal DMA controller to transfer frame data from memory to the LCD panel.  The time required to read data from either SDR or DDR SDRAM using the LCD DMA controller takes longer than expected. This issue has little effect when the LCD DMA controller reads frame data from IRAM or external SRAM. 	ARM9				 When using external SDRAM for the LCD framebuffer, use a display size and color depth that reserves sufficient system bandwidth for the remaining peripherals in the application. For systems using LCD displays sizes greater than QVGA and high color we suggest the use of external SRAM. ES_LPC3250 . Â©   Rev. 9 â 1 June 2011 11 of 17  ES_LPC3250  LPC3250 		3.6 LCD.1: Low throughput when LCD controller accesses DDR/SDRAM 			NXP
LPC3250	 An ONSW output pin (M15) is included in the LPC3250 to assist in waking up the chip after power is removed from all functions except the RTC and Battery RAM. When there is an active match condition the RTC will drive the ONSW pin HIGH. The RTC only drives the ONSW pin while the match is active, and after 1 second of active match, if the software has not accessed the RTC block, the ONSW pin will go low when the match is no longer active.  When power is removed from all functions except the RTC and Battery RAM, the RTC does NOT drive the ONSW pin HIGH when there is an active match condition. 	ARM9				 There is no work-around for this problem. 		3.7 RTC.1: An RTC match doesnât drive the ONSW pin active (HIGH) 			NXP
LPC3250	 The LPC3250 contains 12 pins (GPI_00 - GPI_09, GPI_19, GPI_28 ) that function as dedicated General Purpose Inputs. Each of these pins can generate an individual interrupt for the input pin. Sub Interrupt Controller Register 1 (SIC1_ER) and Sub Interrupt Controller Register 2 (SIC2_ER) contains bits that allow enabling or disabling the interrupt for the associated pin.  When bit nine is set to one in the Sub Interrupt Controller 2 Enable register (SIC2_ER[9]) it does not enable the interrupt for the GPI_08 pin. All other General Purpose Input pins (GPI_00 - GPI_07, GPI_09, GPI_19, GPI_28) interrupts work correctly. 	ARM9				 There is no work-around for this problem. ES_LPC3250 . Â©   Rev. 9 â 1 June 2011 12 of 17  ES_LPC3250  LPC3250 		3.8 INT.1: GPI_08 does not generate an interrupt signal 			NXP
LPC3250	 On the LPC3250, the Motor Control PWM (MCPWM) peripheral is optimized for three-phase AC and DC motor control applications and can also be used in applications which require timing, counting, capture, and comparison. The MCPWM contains three input pins (MCI0-2) for PWM channels 0, 1, and 2. The inputs can be used as feedbacks for controlling brushless DC motors with Hall sensors, and also can be used to trigger a Timer/Counterâs (TC) capture or increment a channelâs TC when MCPWM is configured as a timer/counter. Note: MCI0-2 pins are also called MCFB0-2 (refer to LPC32x0 User manual for more details).  The input pins (MCI0-2) are not functional. 	ARM9				 The GPIO interrupts1 need to be used instead of the MCPWM MCI0-2 pins. On the LPC3250, the GPIO interrupts can only be set to either trigger on the rising edge or on the falling edge. Therefore, in order to detect all six states of the connected hall sensor through an interrupt, the state of the pin needs to be determined and switch to rising or falling edge interrupt accordingly. 1. Available GPIO interrupt pins: GPIO_00 to GPIO_05, GPI_00 to GPI_09, GPI_19, GPI_28, and all port 0 and port 1 pins. ES_LPC3250 . Â©   Rev. 9 â 1 June 2011 13 of 17  ES_LPC3250  LPC3250 		3.9 MCPWM.1: Input pins (MCI0-2) on the Motor Control PWM peripheral are not functional 			NXP
LPC3250	 The three high speed UART's (HSUART) receive (RX) FIFOs can sometimes enter a state where they no longer accept received data. When this state occurs, the HSUART's RX FIFO will no longer accept data regardless of RX FIFO fill status. The receive state of the HSUART may indicate a number of possible, but invalid, receive statuses. These invalid statuses may include RX FIFO or timeout interrupts pending with no receive data in the RX FIFO, invalid RX FIFO status, stuck RX interrupts, or other possible RX statuses. Once the HSUART enters this state, the state can only be cleared by a chip reset. This applies to the U1_RX, U2_RX, and U7_RX pins. The HSUART's transmit side is not affected by this issue and will work as normal when the HSUART receive side stops. The four standard UARTs do not exhibit this behavior.  It has been determined that this failed receive state can be entered by receiving a burst of high frequency noise into the HSUART RX pin. High frequency noise consists of pulsed or random toggling of the HSUART RX line at about 2.5 MHz or greater. The chance of the HSUART entering the state increases with the number of pulses and frequency of the pulses received. Generally, a single pulse won't cause the state to occur. During normal data transfer with transfer rates 2400 bps (416 uS) to 921.6 Kbps (1.085 uS), this state won't occur. However, conditions outside the transfer itself may cause the state to occur. It has been observed in some systems that insertion of the serial cable into the board's serial connector can cause connection noise or oscillations on the transceiver. This noise is driven onto the HSUART RX pin from the transceiver as a series of random pulses. 	ARM9				 If all 7 UARTs aren't needed or 921.6 Kbps transfer rate isn't needed, use the standard UARTs instead of the high speed UARTs to avoid the issue altogether. For systems that require the HSUARTs, care must be taken to limit the exposure of the HSUART RX signal for the type of signal conditions that can cause the state to occur. There are several possible solutions that can help reduce the state from occurring. Whenever the HSUART is not in use, place the HSUART into loopback mode. When in loopback, the RX pin is connected internally to the HSUARTs TX pin and is isolated from the external RX input. While in this loopback state, the condition won't occur on the HSUART regardless of the signal on the RX input. The HSUART TX pin will remain in the idle state in loopback mode when no data is being sent from the HSUART. Optionally, if the HSUART is connected to a transceiver that supports enabling and disabling of the input signal from the transceiver RX input to the transceiver RX output to the HSUART RX input, disable it when not expecting a transmission. Regardless of how the transceiver is connected to the RX pin, the RX pin should be prevented from floating at power-up, reset, or when the transceiver is disabled. This can be done by adding a pull-up resistor to the HSUART RX pin. If using a system where the HSUART always need to be enabled, consider adding the capability to sense when the cable has been plugged into the connector and switch the HSUART out of loopback mode only once the cable has been installed to prevent cable insertion noise. ES_LPC3250 . Â©   Rev. 9 â 1 June 2011 14 of 17  ES_LPC3250  LPC3250 		3.10 HSUART.1: High speed UART receive FIFO and status can freeze 			NXP
LPC3250	 Full-/low-speed signaling uses bit stuffing throughout the packet without exception. If the receiver sees seven consecutive ones anywhere in the packet, then a bit stuffing error has occurred and the packet should be ignored. The time interval just before an EOP is a special case. The last data bit before the EOP can become stretched by hub switching skews. This is known as dribble and can lead to a situation where dribble introduces a sixth bit that does not require a bit stuff. Therefore, the receiver must accept a packet for which there are up to six full bit times at the port with no transitions prior to the EOP.  The USB host controller will hang indefinitely if it sees a dribble bit on the USB bus. It will hang the first time a dribble bit is seen. Once it is in this state there is no recovery other than a hard chip reset. This problem has no effect on the USB device controller. 	ARM9				 None. 4. AC/DC deviations detail 		3.11 USB.1: USB host controller hangs on a dribble bit 			NXP
LPC3250	 The LPC3250 was designed to withstand electrostatic discharges up to 2000 V using the Human Body Model.  The RESET_N pad (pin M14) does not pass ESD tests above 1000 V. 	ARM9				 Observe proper ESD handling precautions for the RESET_N pin		4.1 ESD.1: Weak ESD protection on Reset_N pad 			NXP
"MC9328MX21MC94MX21"	Details:  For Infineon Cellular RAM HYE18P32160AC(-/L) 12.5, burst writes  can work with the following constraints:  1. EW bit does not work correctlyâWhen the EW bit is set, failures  are found when WSC= 7 and Cellular RAM is set up for LAT2. It does  work when WSC=9 and Cellular RAM is set for LAT3. This greatly  effects burst writes and reads. EW=0 always works (as NOR flash end  current burst).  2. After performing a sync access (like burst read), the Infineon  Cellular RAM expects another rising clock edge when CS goes high  to terminate burstâIf the Cellular RAM is left idle after a burst read  and NO rising clock edge is detected, it is stuck in sync mode not  allowing internal refresh cycles to occurâthis will cause Cellular RAM  to lose data. This appears to be more of an Infineon issue as Micron  asserts the extra rising edge clock is not needed. Also, Infineon stated  that in their next generation Cellular RAM this extra rising edge clock  is not required.  3. BCS bits do not shift the burst clock correctlyâOnly BCS bit 0  (LSB) effects the shifting of burst clock, other bits do not effect burst  clock phase (though they still effect LBA assertion time).  4. Only async writes are possible to Cellular RAM BCR and RCRâIn  addition, when switching modes or re-programming the RCR/BCR,  the system must first be placed back into async mode.  5. When D cache is enabled and EIM is doing async writes to the Cellular RAM, the EIM will hold CS asserted (low) for >10usâThis causes a problem for Cellular RAM because it cannot perform an internal refresh operation. The work around is to set CSA to 1 to force CS assertion between writes to allow time for Cellular RAM to refresh or to place EIM and Cellular RAM in sync mode of operation (burst writes) whenever D cache is enabled.	ARM9	 	EIM	 	1. Cellular RAM is basically Mobile SDRAM with the exception of a NOR flash interface. MX21 has an SDRAM controller. System designers are advised to use Mobile SDRAM for its higher performance(133 MHz) and lower cost. 2. Recommend not to enable burst write and treat Cellular RAM as NOR flash burst interface.	 	EIM Cellular RAM support fails	No fix solution is planned.	"1L45X2L45X0M55B1M55BM55B"	NXP
"MC9328MX21MC94MX21"	Details/Impact:  The PC_POE pin may cause system boot up failure when PCMCIA  interface buffer is connected directly. This is due to PC_POE pin  (muxed with NFCLE) driven low during initial boot (with/without NAND  Flash) which enables the external buffer and results in data bus  contention. This multiplexed signal can be re-programmed to perform  the PC_OE function after the system starts up, therefore, only boot  time is affected. 	ARM9	 	 PCMCIA 	 	 Add a logic gate on board between the PC_POE signal and the  PCMCIA buffer such that the buffer is disabled at boot time. An  additional GPIO is required to control the gate ON/OFF. 	 	 Inverted PC_POE causes possible  system boot up failure when  PCMCIA buffer is used	 No fix solution is planned	"1L45X 2L45X 0M55B 1M55B M55B"	NXP
"MC9328MX21MC94MX21"	Details: The PCMCIA controller only supports up to 2 Kbytes of total space to map the attribute memory, common memory, or I/O space. However, the CF/CF+ specification and operating systems such as WinCE/PPC, require them to locate at a separate space and beyond the 2 Kbyte range. Impact: CF/CF+ cannot be supported on WinCE/PPC. Possible difficulty in building drivers in other OS.	ARM9	 	PCMCIA	 	CF/CF+ card support: No workaround available to support WinCE OS. For other OS, basic functionality can be fulfilled by allocating 1 Kbyte to attribute memory and 1 Kbyte to I/O memory or common memory.	 	Cannot fully support CF/CF+ specification.	CF/CF+ support problem is fixed in masks 0M55B, 1M55B, and M55B. PCMCIA Base registers 0â4 are enhanced to hold base addresses PBA[14:4] in the same programmable bits position. Memory windows such as common memory space, I/O space, True IDE or attribute memory space can be defined in an extended 32K space. Please refer to MC9328MX21 Mask Differences Between 2L45X and M55B Reference Manual Addendum for MC9328MX21RM, for further information on PCMCIA changes.	"1L45X2L45X"	NXP
"MC9328MX21MC94MX21"	Details: A total of 26 address lines are needed to fully support the PCMCIA standard. The i.MX21 processor does not support this many address lines. Impact: PCMCIA cards cannot be supported.	ARM9	 	PCMCIA	 	No workaround is available.	 	Not fully compliant with PCMCIA Ver. 2.1.	No fix solution is planned.	"1L45X2L45X0M55B1M55BM55B"	NXP
"MC9328MX21MC94MX21"	Details/Impact: In AC97 variable mode, the AC97 controller is required to process the SLOTREQ automatically and source data from the transmit FIFO. However, the SLOTREQ bits are not handled and no variable mode operation is possible.	ARM9	 	SSI	 	No workaround is available.	 	AC97 Mode cannot be supported.	No fix solution is planned.	"1L45X2L45X0M55B1M55BM55B"	NXP
"MC9328MX21MC94MX21"	Details/Impact: When TE has been enabled and RE is enabled in the middle of a valid frame, the SSI starts to receive data immediately without synchronizing with the next frame sync event. This causes the receiver section to remain out-of-sync with the frame timing and results in incorrect data received.	ARM9	 	SSI	 	System designer is advised to: 1. Wait for the TLS (Transmit Last Slot) interrupt before enabling the receiver, Or 2. Disable the transmitter, then enable both transmitter and receiver simultaneously.	 	SSI does not wait for frame sync to receive data when RE is enabled in sync mode.	This erratum is corrected in masks 0M55B, 1M55B, and M55B.	"1L45X2L45X"	NXP
"MC9328MX21MC94MX21"	Details/Impact: The counter is enhanced to reset automatically in restart mode. However, the change also influences freerun mode. The counter is now reset whenever the compare register is written. Applications are affected that allow compare values to change from time to time.	ARM9	 	GP Timer	 	If more than one compare event is needed in freerun mode, use software comparisons instead.	 	The GP timer counter is reset even in freerun mode whenever the compare register is written.	This erratum is corrected in masks 0M55B and 1M55B.	"1L45X2L45X"	NXP
"MC9328MX21MC94MX21"	Details: In EIM Chip select control register, there are two bits controlling the RW assertion and deassertion (negation) time: RWA and RWN. It is found that RWN incorrectly influences the assertion of the RW signal when RWA = 0 and RWN â¥ 1. The RW signal assertion is delayed 1/2 HCLK later. The RW signals acts as though RWA is set to 1, even though RWA bit is cleared in software. Other settings work correctly. Impact: Minimal. A slight timing delay is introduced to RW signal assertion.	ARM9	 	EIM	 	No workaround is available.	 	RW assertion incorrectly influenced by RWN bit in EIM module when RWA = 0 and RWN â¥ 1.	No fix solution is planned.	"1L45X2L45X0M55B1M55BM55B"	NXP
"MC9328MX21MC94MX21"	Details/Impact: Standby current at QVDD and NVDD is higher than the typical value specified in data sheet.	ARM9	 	Power	 	No workaround is available.	 	Standby current at QVDD and NVDD is higher than the typical value specified in data sheet.	Standby current has been improved on subsequent masks. Please refer to the MC9328MX21 data sheet for power figures.	1L45X	NXP
"MC9328MX21MC94MX21"	Details/Impact: When setting BMI Tx_Water_Mark bit to 0000, TxF_EMPTY status bit will always be set. This makes detecting 16 empty slots in FIFO impossible and user will not be able to check if the last data has been transmitted. Therefore, variable burst transfer cannot be supported.	ARM9	 	BMI	 	System designer is advised to define data transfer with a fixed burst length for reliable communication.	 	BMI Tx_Water_Mark bit = 0000 fails.	No fix solution is planned.	"1L45X2L45X0M55B1M55BM55B"	NXP
"MC9328MX21MC94MX21"	Details: Memory access may fail at the following condition: 1. Both CSD0 and CSD1 are used, and 2. Both Power-down time-out bits of SDCTL0 and SDCTL1 are programmed to non-zero. Impact: As SDRAM cannot be put to power down mode, a slightly higher operating power may result. This issue does not affect self refresh mode operation and no difference in sleep mode power will be seen.	ARM9	 	SDRAMC	 	It is advised to program Powerdown Timout bits of SDCTL0 and SDCTL1 to ZERO when using both CSD0 and CSD1. This issue does not happen when single CSD0 or CSD1 is used.	 	SDRAM Power Down mode failing to support both CSD0 and CSD1 simultaneously.	No fix solution is planned.	"1L45X2L45X0M55B1M55BM55B"	NXP
"MC9328MX21MC94MX21"	Details/Impact: NAND Flash controller drives the NF_CE signal high in tR period. For NAND Flash memory that requires CE_B to be held low during the tR period, memory access failure may result.	ARM9	 	NAND Flash Memory Controller	 	This can be accomplished through the use of an external AND gate, where the NFCE and NFRB signals of the i.MX21 are inputs to the AND gate and the output is connected to the CE_B input of the NAND Flash device.	 	Cannot support NAND Flash memory requiring CE_B pin held low during tR (data transfer from cell to register) period.	No fix solution is planned.	"1L45X2L45X0M55B1M55BM55B"	NXP
"MC9328MX21MC94MX21"	Details/Impact: After sending the first block of data, the SDIO controller operation will stop if there is no BUSY signal detected. Therefore, multiple block transfers without any BUSY signal responding from card cannot be supported.	ARM9	 	SDIO Controller	 	No workaround is available for multiple block transfers. It requires card manufacturers to modify their firmwire to use single block transfers if not currently supported.	 	Multiple block transfer support fails if no BUSY signal is detected.	Multiple block transfers are supported in the following cases: â¢multi-block reads â¢operation in 1-bit mode â¢busy signal is supported â¢4-bit mode, when fast DMACLK (HCLK) is not used, see below Multiple block transfer are not supported when all of the following conditions apply: â¢multi-block writes, and â¢there is no busy signal between blocks, and â¢4-bit bus width, and â¢when DMACLK (HCLK) is faster than MMCCLK/0.216. For example, 20 MHz SDIO, cannot use DMACLK (HCLK) faster than 92.6 MHz, thus HCLK cannot be 133 MHz during SDIO 4-bit multi-block reads.	"1L45X2L45X0M55B1M55BM55B"	NXP
"MC9328MX21MC94MX21"	Details: When the boot mode is set to NAND Flash boot-up, after the reset_in signal is asserted, the processor needs to wait about 10 seconds before continuing the boot-up process. Impact: During the NAND Flash boot-up process, there is a waiting loop that checks the transfer of boot code completion (bit 15 of NAND FLASH Operation and Configuration register 2, NAND_Flash_Config2). However, the bit will not set immediately because the NAND Flash controller will not transfer the whole code during reset_in assertion time. It is required to wait 10 seconds for the NAND Flash controller to reset when a soft reset (Reset_In or Watchdog reset) occurs.	ARM9	 	NAND Flash Controller (NFC)	 	No Workaround is available	 	NAND Flash warm reset delay	Fixed in 1M55B and M55B	0M55B	NXP
"MC9328MX21MC94MX21"	Impact: Not able to support single chip 4M x 16-bit (8Mbyte total size) SDRAM devices or devices with a page size of less than 1 kilobyte. A page size is defined as the number of bits in a row in the SDRAM device.	ARM9	 	SDRAMC	 	Must use SDRAM devices with 1 kilobyte or greater page sizes.	 	Cannot support SDRAMs with less than 1kilobyte page size.	No fix solution is planned.	"1L45X2L45X0M55B1M55BM55B"	NXP
"MC9328MX21MC94MX21"	Impact: Not able to support single chip 32M x 16-bit (64Mbyte total size) SDRAM devices or devices with a column address size of 10.	ARM9	 	SDRAMC	 	For 64 Mbyte SDRAM devices the configuration of 16M x 32 or two 16M x 16-bit must be used to form a 32-bit data bus, where either configuration contains only 9 column addresses.	 	Cannot support SDRAMs with column address sizes of 10.	No fix solution is planned.	"1L45X2L45X0M55B1M55BM55B"	NXP
"MC9328MX21MC94MX21"	Details: In cases when there are single-bit errors in two consecutive page reads, then the error in the second page is not corrected by the NFC. Impact: NFC error correction logic is faulty on read accesses and errors in consecutive pages are not fixed. Thus, software must correct the errors in place of the hardware. Special care must be given when booting from a Nand Flash for both 512 bytes, and 2 Kbytes page boot optionsâsee details under Workaround.	ARM9	 	NFC / System Boot	 	"In general, when reading from Nand Flash, SW must turn off the code correction in HW (ECC) and perform the correction in SW (done by performing error check and correction at the end of each page). When booting from Nand Flash, the Nand Flash Controller (NFC) copies the first 2Kbytes to internal RAM and jumps to the beginning of the code. This is done with no option for SW intervention/modification, so the aforementioned general guideline could not be applied. Note: If the NAND flash requires Error Correction on the initial block, then the following procedure is required. Otherwise, apply the S/W ECC after boot up: Due to the nature of this bug, any single-bit error (if found) in the first 512 bytes (first page) is corrected properly, therefore, ""specialâ boot loader code must be placed in those first 512 bytes. The loader code, once executed, must then perform the following: 1. Turn off error correction in HW. 2. Re-load pages 2, 3, and 4 (which comprise the remaining 1.5 Kbytes of code). 3. For every page read, perform error correction in SW. 4. Continue normal execution."	 	NFC (Nand Flash Controller) fails to correct two single-bit errors if they occur on consecutive pages, on data read accesses.	No fix solution is planned.	"1L45X2L45X0M55B1M55BM55B"	NXP
"MC9328MX21MC94MX21"	Details: When doing single or multiple DMA transfers the action of clearing a single DMA bit from the DISR register can result in clearing the whole DISR register. Impact: If the DISR register cleared accidentally, then an interrupt for DMA transfers does not take place. This can be an issue when there are multiple DMA channels transferring data at the same time. The Interrupt Service routine can miss interrupt notifications that DMA transfers have happened.	ARM9	 	DMA	 	"Do not access the DISR register to clear DMA transfer interrupts. Instead clear the interrupt of each DMA being used by setting the SMOD bits of the DMA CCR register for the DMA channel being used. Software Example: // pointer to 32bit program register DMA_CCR0 volatile unsigned int * P_32_DMA_CCR0 ; int  tmp ; // save the old value of CCR tmp = *(P_32_DMA_CCR0+(0x40*channelID)) ; //Force DMA channel's source mode as reserved ""11"" to clear the DISR bit for the selected channel * (P_32_DMA_CCR0+(0x40*channelID)) = tmp | (0x3<<10); // restore the old value back into CCR"	 	The DMA DISR register may be cleared accidentally when trying to clear any interrupt in the DISR register		"1L45X2L45X0M55B1M55BM55B"	NXP
"MC9328MX21MC94MX21"	Details: In 4 bpp, 8 bpp, 18 bpp, and TFT modes, LSCLK is missed in these conditions: â¢One clock cycle before every OE_ACD assert timing â¢Every VSYNC rising timing â¢Every VSYNC falling timing Impact: If the user connects LSCLK directly with LCD panel and the LCD panel allows missing clock, there is no issue. However, if the user adds a serializer between LSCLK and LCD panel, the serializer may not work correctly because of the missing clock and the LCD panel may have noise.	ARM9	 	LCDC	 	Connect LSCLK directly with the LCD panel, if the LCD panel allows it.	 	LSCLK is missing.	No fix solution is planned.		NXP
MC9328MXS	Impact:  If SyncFlash channel is disabled, the SDRAMC puts the  syncflash into a mode called deep low-power mode. When  the SyncFlash is re-enabled, it requires a 100 Î¼s period to  initialize before allowing any access to it.  The current design does not have a built-in timer to prevent  access before 100 Î¼s has passed. Therefore, an access  occurring during this time period could return invalid data  from the SyncFlash. 	ARM9	 	SDRAMC 	 	 Use the TIMER register to count 100 Î¼s to determine the time  period during which the user is not allowed to access the  SyncFlash. 	 	It is necessary to use a  separate timer to prevent access  to the SyncFlash immediately after  the SyncFlash is re-enabled from  deep low-power mode	 No metal-fix solution	2L45N	NXP
MC9328MXS	Impact:  Typically, the back-to-back burst access that does not use  the IDLE cycle as a separator occurs for operations such as  cache fill, miss, and burst operations by the ARM processor.  In cases such as this, the MEMC arbiter incorrectly treats the  back-to-back sequence as a single instruction process that  causes the other bus masters to wait longer to access the  bus. On the AHB bus, only the LCDC and MMA modules are  affected. Because the MMA is not a periodic and time critical  module with regards to requesting the grant of the bus, the  impact of this issue is minimal, although the LCDC frame  buffer refresh can be greatly impacted. 	ARM9	 	LCDC 	 	 Use a dummy DMA transfer to and from a dummy memory  space to force the MEMC to release the bus for other bus  masters. For more detailed information and code example,  please visit our website www.freescale.com/imx. 	 	The Memory Controller  arbiter (MEMC) does not break  and release the ARMâ¢ coreâs  back-to-back burst access to the  other (for example, LCDC, DMA,  and MMA) bus masters. In this  situation, the ARM coreâs back-toback access does not use an IDLE  cycle as a separator.	 No metal-fix solution	2L45N	NXP
MC9328MXS	Impact:  The DMA request does not clear after the reception of a short  packet, causing a long packet to start filling in the FIFO  before the data in the short packet is moved out of the FIFO.  This causes the USBD FIFO to overflow and generate an  error that prevents a DMA interrupt DMA_ISR from being  generated.  This occurs because the ALARM bit (DMA request) being  cleared is based on the setting of the 4*GR[2:0] granularity  bits in USB_EPn_FCTRL register. The ALARM bit for IN  transfer is set when the amount of data bytes that remain in  the FIFO is below the alarm value (ALARM[5:0] in the  USB_Epn_FALARM register and cleared when there is less  than 4*GR[2:0] of free bytes that remain in the FIFO.  The Granularity bits GR[2:0] are fixed at 3 bits regardless of  the FIFO depth. For IN transfer, DMA requests are cleared  when FREE data bytes are 4*GR[3:0]. Because GR[2:0]=3 *  111 as a maximum value, there can only be 28 free bytes.  Therefore, a 6 byte short packet in the 64-byte FIFO will not  dessert the DMA request. 	ARM9	 	USB Device Port 	 	 Two methods are used to prevent this limitation depending on  the data packet size:  1. For data packet sizes of less than 5 bytes:  After the short packet data transfer, software must poll the  USBD BYTE_COUNT==0 before initiating the next DMA  transfer. This ensures that FIFO can accept the next long  data packet of 64-bytes.  2. For data packet sizes of 5 bytes and greater:  Use a 32-byte FIFO instead of a 64-byte FIFO to ensure that  the DMA request is cleared. The granularity bits GR[2:0] must  be set to 111. 	 	Limitation on using DMA  for USBD IN data transfer.  There is a limitation on using DMA  to transfer continuous data from  memory to a 64-byte USBD FIFO  (FIFO1 and FIFO2) when using a  short packet (<37 bytes) followed  by a long packet (> 32 bytes).  For example: A 6 byte packet  followed by a 64 byte packet, or a  32 byte packet followed by a 40  byte packet such that the short  packet length + the long packet  length is greater than 64 bytes  (FIFO depth).	 No metal-fix solution	2L45N	NXP
MC9328MXS	Impact: This double interrupt is the result of a glitch produced by the seconds counter bits 1 and 0. Bit 0 of the seconds counter has greater loading than bit position 1. Upon receiving a clock signal to update the seconds counter, the seconds counter bit 0 changes state to be slower than counter bit 1. This glitch causes the alarm to see a momentary match, triggering the interrupt one second early. When the seconds counter actually does match the alarm value, another interrupt is triggered (if it has not been disabled following the previous interrupt) at the correct time. For example: If you set the alarm to âxx : xx : xx : 15 secâ, when the second counter changes from 13(1101) to14(1110), the bit position 1 changes faster than bit position 0. The result is 13(1101) to 15(1111) to 14(1110). This 15(1111), the glitch, matches the alarm setting and triggers the interrupt.	ARM9	 	RTC	 	Either set the seconds alarm register to an even value or, if set to an odd value, when the interrupt occurs, check the current time against the alarm time. If it does not match, then clear the interrupt and return. The actual interrupt will occur one second later.	 	An alarm set to an odd number of seconds results in a false interrupt one second before the actual alarm time, followed by the actual interrupt.	No metal-fix solution.	2L45N	NXP
MC9328MXS	Impact:  Using the workaround, the power-up current can be  minimized to less than maximum specified operating current. 	ARM9	 	IOPAD 	 	 Attach a 1 KÎ© series resistor to each tied-low input pin. 	 	Power-up leakage during  the recommended power-up  sequence, NVDD>AVDD>QVDD.  In the normal configuration, the  maximum current leakage  occurring during the power-up  period can be up to 600mA	 No metal-fix solution	2L45N	NXP
MC9328MXS	Impact: The low mark must never be set higher than 10 and the high mark must be set at 3.	ARM9	 	MEMC/AHBC	 	For a bus that is heavily loaded and that requires SDRAM access, a dynamic burst length is recommended: â¢fixed burst length = 0 â¢high mark = 3 â¢low mark = 8 For a very heavily loaded system, increasing the low mark value increases the chance of a bus grant of the system bus, at the expense of more frequent bus requests.	 	The LCD flicker issue is not completely resolved by the use of dummy DMA transfer (See Erratum number 7). The LCDC DMA high/low setting does not ensure that the next bus request is triggered in the event the current DMA burst is not completed. The problem occurs when the next bus request is initiated while the LCDC is waiting for the last data in the current DMA burst. This is because when the LCDC is waiting for the last data, it only expects an HREADY signal to be asserted. So, if the next bus request is triggered while the LCDC is waiting, the bus request will be missed. A data fetch can not be initiated while data in FIFO is being continuously drained so an under-run will eventually occur. In Summary: If the next bus request is issued when the LCDC is waiting for the last data in the current DMA burst it will not be recognized.	No metal-fix solution.	2L45N	NXP
MC9328MXS	Impact: When CS5 is configured to an external input DTACK signal to terminate the bus cycle (for example WSC = 0x3F), using either DTACK mode (DTACK_SEL = 0) or WAIT mode (DTACK_SEL= 1), the CPU or DMA read cycles in CS5 memory space may terminate incorrectly. CS5 can function normally by using wait state control bus terminationâthat is, WSC is not set to 0x3F. All write cycles will function correctly.	ARM9	 	EIM	 	DTACK mode (DTACK_SEL = 0): No workaround. WAIT mode (DTACK_SEL=1): In Wait mode the OE signal for read cycle is negated up to 1 system clock before a data latch occurs at the end of bus cycle, possibly causing incorrect data to be latched by the i.MXS because the external device releases the data bus after OE negates. The workaround is to use external logic (one D-flip flop and one OR-gate) to extend OE negation time until the CS cycle is completed (after or at CS5 rising edge). D-FF connection must be D=1, RST= /OE OR /CS5, CLK= CS5, Q=NewOE for DTACK device only. To avoid disrupting other devices using /OE, the NewOE signal only replaces the /OE signal going to a DTACK device. See Figure 1. /OE /CS5 rst1 /NewOE for device DQ using DTACK only /CS5 set 1. If using LCX logic from ON Semiconductor, expect propagation delays from /OE and /CS assertion to /newOE of 3.0 to 12.5 ns. Freescale Semiconductor cannot recommend one supplier over another and in no way suggests that ON Semiconductor is the only supplier of logic devices. Figure 1. D-FF Connection Workaround	 	CS5 fails read operation when using the DTACK function.	No metal-fix solution.	2L45N	NXP
MC9328MXS	Impact:  When the DTACK signal is not used, toggling the GPIO pin  PA17 will adversely affect the other EIM chip-select functions. 	ARM9	 	EIM 	 	 PA17 is restricted for the DTACK functionality only. Thus, in  any other situation when DTACK is not used, this pin must be  pulled up or tied high (may be done by simply setting the  corresponding PUEN bit, configuring it as an input, and  leaving the pin unconnected). If the DTACK functionality is  used, the pin will only toggle during CS5 accesses and  should not toggle during any non-CS5 access. 	 	Port A pin 17 (multiplexed  with DTACK) inadvertently affects  other chip-select functions when  DTACK is not used.	 No metal-fix solution	2L45N	NXP
MC9328MXS	Impact: Not able to support single chip 4M x 16-bit (8 Mbyte total size) SDRAM devices or devices with a page size of less than 1 kilobyte. A page size is defined as the number of bits in a row in the SDRAM device.	ARM9	 	SDRAMC	 	Must use SDRAM devices with 1 kilobyte or greater page sizes.	 	Cannot support SDRAMs with less than 1kilobyte page size.	No metal fix is planned.	2L45N	NXP
MC9328MXS	Impact: Not able to support single chip 32M x 16-bit (64 Mbyte total size) SDRAM devices or devices with a column address size of 10.	ARM9	 	SDRAMC	 	For 64 Mbyte SDRAM devices the configuration of 16 M x 32 or two 16M x 16-bit must be used to form a 32-bit data bus, where either configuration contains only 9 column addresses.	 	Cannot support SDRAMs with column address sizes of 10.	No metal fix is planned.	2L45N	NXP
MC9328MXS	Impact:  In 16-bit mode, burst access is not guaranteed for SDRAM  with number of columns not equal to 9. Known impact is  failure to support following devices in 16-bit mode:  a. SDRAM with 12 Rows and 8 Cols  (4Mx16-bit, 8MB total size)  b. SDRAM with 13 Rows and 10 Cols  (32Mx16-bit, 64 Mbyte total size) 	ARM9	 	SDRAMC 	 	 No workaround is available. Recommend system designer to  use 32-bit SDRAM if 8 Mbyte or 64 Mbyte memory  configuration is desired. 	 	In 16-bit mode, only  SDRAM device with 9 Cols are  supported	 No metal fix is planned	2L45N	NXP
MC9328MXS	Impact:  When a load multiple (LDM) instruction is used to load two  specific registers from an un-cached region of memory, and  the load instruction begins immediately after a delayed  buffered write, then the LDM will not load the second register  correctly. 	ARM9	 	ARM920T AHB  Wrapper 	 	 The ARM Realview 3.0 SP1 Build 617 compiler and linker  have a patch that addresses this issue. With this patch  applied, the compiler will not generate this LDM instruction.  The Build 617 patch is available to download from the ARM  website.  To use the patch, users must insert  â--branchpatch 920t-ldm2â  to the compiler and linker command lines.  For code compiled by a compiler other than the above stated  tool, a manual search and replace for the LDM instruction of  two values in assembly code can be done with multiple  options for equivalent code replacements.  Example 1:  LDMIA r0, {r1, r2}  is functionally IDENTICAL to:  LDR r1, [r0]  LDR r2, [r0, #4]  Example 2:  If updating the base register to a new value, such as:  LDMIA r0!, {r1, r2}  then this is functionally IDENTICAL to:  LDR r1, [r0], #4  LDR r2, [r0], #4 	 	LDM instruction fails to  load non-cached data from  memory	 No hardware fix planned	2L45N	NXP
MC9328MXS	Impact:  A parity error in UART character transmissions may occur.  TxFIFO data being shifted out is not alterable after the start  bit is issued. However, the parity bit can change after the  start bit is issued and is not fixed until data Bit0 is issued. If  the TxFIFO is overwritten by the CPU during the interval from  the end of the start bit to the end of the data Bit0, there will be  a mismatch between the data shifted out and the parity bit. In  this case, a parity error may occur. 	ARM9	 	 UART 	 	 The following software solutions are recommended to be  used in Interrupt Service Routines (ISRs) to avoid the parity  bug. Polling can also be used instead of interrupts.  1. A maximum of 32 bytes can be written into the TxFIFO  when transmission is complete (USR2.TXDC = 1).  2. A maximum of 31 bytes can be written into the TxFIFO  when the TxFIFO is empty (USR2.TXFE = 1).  3. A maximum of 32 - n bytes, where n = UFCR.TXTL, can  be written into the TxFIFO when the data level in the TxFIFO  falls below the selected threshold (when USR1.TRDY = 1). 	 	 Parity bug in UART transmitter	 No hardware fix planned.	2L45N	NXP
MC9328MXS	Impact: Receive malfunction: Rx data is usually taken with the period of FS=H. However, in some special use cases, it is changed to period of FS=L. Once this occurs, this period never returns to the period of FS=H. The issue occurs in the following conditions: Normal mode Sync mode Slave mode Some additional conditions of this scenario are: TX and RX are used at the same time (full duplex) SYN=1,RXDIR=0,TXDIR=0,TFDIR=0 External clock is 2.048MHz Frame frequency is 8kHz Frame pulse width is 1 word (8 clock) SSI_EN and RE is set to 1 within latter 4 clocks of FS=H period (8 clocks) Transmit malfunction: TxData is changed to different value at only the first time of transmitting when TE bit is set just before FS signal or within FS timing.	ARM9	 	SSI	 	To ensure a gap of at least 2 bit-clock cycles between SSI_EN and TX/RX bit setting (only for External word-wide frame-sync patterns), here is an example code for this workaround. void ssi_transmit_receive_test() { //parameters defined here Statement1 (); //clock configuration here Statement2(); //AUDMUX configuration here Statement3(); //SSI configuration here Statement4(); //Enable SSI by programming SSI_SCR MEMWD(SSI2_SCR,scr_mask1); //delay some time for the SSI state machine to function //properly for(i=0;i<=5;i++); //Enable transmit and receive of SSI by programming //SSI_SCR MEMWD(SSI2_SCR,scr_mask2); ...... }	 	In word-wide frame-sync mode, if SSI_EN and TX/RX_EN are set near new frame start, SSI Receive and Transmit does not function properly and there is a chance of words getting missed/shifted or transmit data line being driven low for 1/2 clock cycles during the first frame.	No metal-fix solution planned.	2L45N	NXP
MCIMX27	Description: Video Codec module supporting MV and MVD ranges does not conform with the H.264 standard. â¢The standard specifies the range of MVD to be â4096 to 4095.75. However, the Video Codec module only supports up to â2048â2047.75. â¢The standard specifies that the range of horizontal MV to be â2048 to 2047.75. However, the Video Codec module only supports up to â1024 to 1023.75. Because the maximum image resolution in the i.MX27 device is 720 Ã 576, it is not likely to receive a bitstream with MV/MVD in such a large range in real codec applications; therefore, there is no real impact to applications.	ARM9	bo57692	â¢Video â¢Codec	3	No workaround	 	Video Codec module supporting MV and MVD ranges does not conform with standard.	No fix planned	0M72J	NXP
MCIMX27	Description: In Host mode in the ULPI core, a remote wake-up can be interpreted as a disconnect. This issue involves the latency when asserting in synchronous mode. In some instances, the host will not properly latch the K state. When this occurs, the core wakes up to a J state. Eventually the host will not resume, and will show an SE0 and assume a disconnect occurred.	ARM9	bo58229	USB	3	No workaround	 	A remote wake-up can be interpreted as a disconnect.	No fix planned	0M72J	NXP
MCIMX27	Description:  When a burst access to WEIM external memory is immediately  followed by another burst access, the first word may be missed at  write-burst access because the eb_b signal comes too late.  Reason:  The ecb_hburst_ecb_fw signal in the WEIM Bus Controller  module has an extra-high pulse, and only one high pulse is  required. 	ARM9	bo57815	 WEIM 	3	 Set EDC field to two breaks, which continues the burst access to  external memory. 	 	A burst write  access will miss the  first word when the  burst write follows  another burst  operation	 No fix planned	0M72J	NXP
MCIMX27	Description: During encoding or decoding MPEG-4, the Video Codec module can lock up. In the combined AXI to AHB and 32â64 gasket, there is a FIFO for read data, which buffers data that is coming from the 64-bit bus faster than the 32-bit bus can accept it. There is no logic to send a request to memory only when the FIFO has room for return data. In a case with ideal data throughput, this FIFO overruns and read data is corrupted. This ideal data throughput only happens during MPEG-4 encoding and decoding.	ARM9	bo93263	â¢Video â¢Codec	2	â¢Set the Latency Hiding Disable (LHD) bit in the ESDCTL DDR Controller ESDMISC register. This adds latency between DDR transactions, removing the ideal data throughput. This should only be done during MPEG-4 encoding and decoding. Note that this reduces performance. During MPEG-4 encoding/decoding, this degradation is acceptable. LHD should not be set during H.264 or H.263 operation. â¢Assign all buffers accessed by the video code into the same DRAM bank and ensure every buffer type has a size of integer number of pages. This ensures that there is a page miss between accesses of different sub-masters inside the VPU, increasing the delay. The DRAM is split into four equal sizes called banks, so the bank size is 1/4 of the DRAM size.	 	Lockup of Video Codec in MPEG-4 encode or decode Note: Applies only to silicon revision 2.0	Fixed in silicon revision 2.1	0M72J	NXP
MCIMX27	Description:  Timing is not properly extracted for the boundary scan circuitry so  post-layout gate-level simulations did not correctly simulate the  circuit. A race condition prevents proper shifting of data through  the Boundary Scan circuitry. 	ARM9	bo93708	 JTAG Controller 	3	 None 	 	Boundary scan  fails because of an  internal timing issue.  Note: Applies only to  silicon revision  2.0	 Fixed in silicon revision 2.1	0M72J	NXP
MCIMX27	Description: Internal fuses on the processor could be unintentionally programmed, regardless of the voltage level set for FuseVDD. Even if FuseVDD is set to 1.8 V (read-only voltage), some processors may be programmed at that voltage. This only happens when the incorrect power-up or power-down sequence is used on the processor.	ARM9	bo95933	IIM	2	It is recommended to power up and power-down the processor following the power-up and power-down sequence documented in the MCIMX27 Multimedia Applications Processor Data Sheet.	 	When the incorrect power-up or power-down sequence is used on the processor, unintentional programming of IIM fuses is possible, regardless of the set FuseVDD voltage, reconfiguring the part permanently.	No fix planned	0M72J	NXP
MCIMX27	Description: The gasket that is between the Post Processor and the EMI cannot support burst accesses when the burst length is equal to or over 16 words. However, the Post Processor will do the burst access over 16 words when it resizes with the horizontal scale over 2. In this case, the Post Processor's access misses the data or will be pending due to no response from the gasket.	ARM9	â	eMMA PP (Post Processor)	2	Use software for horizontal resizing when the scale is bigger than two. For example, when the scale is 2.5 for both horizontal and vertical, software should be used to produce the horizontal resize with scale 2, and the Post Processor should do the vertical 2.5 and horizontal 1.25 resize.	 	Resize fails when the horizontal scale is bigger than two.	No fix planned	0M72J	NXP
MCIMX27	Description:  The AUS bits in the WEIM Configuration Register (WCR) do not  work for the address bus bit A[23]. The WEIM address busâ most  significant bits (ADDR[25:16], Address Bus MSB) are used for  address bits [25:16]. If the corresponding AUSx bit (each WEIM  chip select has a corresponding AUS bit) is set to 1 in the WCR  register, then these MSB signals reflect the AHB address bits  [25:16]. If the AUSx bit is set to 0, then these signals should  represent AHB address bits [27:18] for word width memory,  [26:17] for half word width memory, and [25:16] for byte-width  memory. The error occurs when the AUSx bit is set to 1, which  causes the A[23] bit to not match the correct value of the  corresponding AHB address bit.  Reason:  This errata affects all Chip-Select regions (that is, CS0âCS5). You  cannot use the WEIM AUS feature to use un-shifted address  mode if address bit A[23] is needed to address the external  memory device. 	ARM9	ENGcm11270	 WEIM 	3	 Set AUSx to 0, if address bit A[23] is needed to address the  external device. 	 	AUSx bits do not  work for address bit  A[23].  Note: The AUS feature  is not only for  ADDR[25:16]  (Address Bus  MSB), but also  for ADDR[15:0]  (Multiplexed  Address Bus  LSB)	 No fix planned	0M72J	NXP
MCIMX27	Description:  End current burst (WAIT). This active-low input signal ECB is  asserted by external burst capable devices. It is serviced only in  synchronous mode (SYNC = 1).This signal can be used in the  following modes depending on the EW bit in the Chip Select  Control Register.  â¢ In the ECB mode (EW = 0), ECB indicates the end of the  current (continuous) burst sequence. Following assertion, the  WEIM terminates the current burst sequence and initiates a  new one.  â¢ In the WAIT mode (EW = 1), the memory device asserts this  signal to insert WAIT states during refresh collisions or during  a row boundary crossing. Following assertion, the WEIM does  not terminate the current burst sequence and continues it once  WAIT is negated.  FCE is a parameter in the register CSCRxA that is used to enable  or disable feedback clock:  â¢ If FCE = 0, WEIM samples the data by internal AHB bus clock.  â¢ If FCE = 1, WEIM samples the data by BCLK_FB signal that is  from PAD.  â¢ If FCE is configured to 1 and there is ECB assertion during  access, WEIM does not sample the correct data.  Reason:  You cannot use FCE = 1 mode when there is ECB assertion  during access. 	ARM9	ENGcm11409	 WEIM 	2	 If external device asserts ECB_B signal during burst access in  FCE = 1 mode, use FCE = 0 mode instead. 	 	In FCE = 1  mode, WEIM cannot  correctly sample the  data if there is ECB  asserted during burst  access	 No fix planned	0M72J	NXP
MCIMX27	Description:  There is a design errata in the i.MX27 PLL/DIV design, which  causes the ARM_CLK to have an incorrect duty cycle. The root  cause of this issue is due to an uninitialized node in the PLL, clock  gating, and divider circuitry, so the probability of this issue is  random. This error causes the ARMâ¢ and DDR clocks duty cycle  to be 66% when they are running at 266 MHz and 75% when at  399 MHz, instead of 50%.  Projected Impact:  The result of the incorrect duty cycle of the clock is that the ARM  core might halt. This issue affects systems that enable 399 MHz  for the ARM core. 	ARM9	ENGcm11563	PLL 	2	 There are both a hardware and a software workaround. To  guarantee correct operation, the software workaround should  only be applied to devices that have had the new PLL test applied.  The test will be applied from a date code 1105:  â¢ Workaround 1âHardware:  Keep MPLLVDD < 200 mV during the initial part of the power-up  sequence and delay the MPLLVDD supply with respect to QVDD,  NVDD5, and AVDD. See Figure 1 for a recommended power-up  sequence. This workaround sets the uninitialized node to the  correct state enabling the appropriate 399 MHz clock output duty  cycle. For the clock switching errata workaround, the following  conditions must be satisfied:  â QVDD must be powered up before MPLLVDD.  â NVCC5 must be powered up before MPLLVDD. (This is  required for the POR_B signal to propagate to the clock  gating logic.)  â AVDD must be powered up before MPLLVDD. (This is  required for the POR_B signal to propagate to the clock  gating logic.)  â MPLLVDD must be driven to 0, not floating, before  powering up  A suggested delay circuit is described in Figure 2.  â¢ Workaround 2âSoftware:  Originally for the ARM clock to work at 400 MHz, the MPLL is  configured for 800-MHz operating frequency at the 2x Clock Port  (see Figure 3 and code that follows the figure), and the DIV2  divider is selected by software to achieve the 400-MHz operating  frequency at the ARM core. The default 266-MHz frequency is  achieved by using the DIV3 divider with an 800-MHz frequency at  the 2x Clock Port (so 400-MHz MPLL frequency).  The intent of this workaround is to reconfigure the 2x Clock Port  to 1.2 GHz (600-MHz MPLL frequency), and continue to use the  DIV3 divider in order to achieve the 400-MHz operating  frequency. This avoids switching to the DIV2 divider, which  introduced the problem. 	 	Boot problem  due to improper clock  duty cycle  Note: Systems that  use 266 MHz are  not affected by  this bug.	 No fix planned.	0M72J	NXP
MCIMX27	Description: Any read access from the Clock Controller Module SPCTL0 register will clear the contents of the register. Projected Impact: For silicon revision 2.0 and prior, any read access performed from the Clock Controller Module SPCTL0 register will clear the contents of the register.	ARM9	TLSbo94561	CCM	2	The SPCTL0 register needs to be re-programmed after each read access: either with a new value, or with the same value that was just read.	 	Read access to Clock Controller SPCTL0 register clears it	Fixed in silicon revision 2.1.	0M72J	NXP
MCIMX27	Description: In 4 bpp, 8 bpp, 18 bpp, and TFT modes, LSCLK is missed in these conditions: â¢One clock cycle before every OE_ACD assert timing â¢Every VSYNC rising timing â¢Every VSYNC falling timing Projected Impact: If the user connects LSCLK directly with LCD panel and the LCD panel allows missing clock, then, there is no issue. However, if the user adds a serializer between LSCLK and LCD panel, then, the serializer may not work correctly because of missing clock and the LCD panel may have noise.	ARM9	TLSbo95476	LCDC	2	Connect LSCLK directly with LCD panel, if the LCD panel allows it.	 	LSCLK is missing	No fix scheduled.	0M72J	NXP
MCIMX27	Description:  There is a limitation in the i.MX27 CCM module of the latest i.  MX27 silicon (rev 2.2). This limitation requires that the MPLL can  only be restarted under the following conditions:  â¢ CSCR register bit fields: ARMSRC == 1 and ARMDIV[1:0] ==  00 (meaningARM_CLK is divided by 2 from MPLL_CLK)  or  â¢ CSCR register bit fields ARMSRC == 0 and ARMDIV[1:0] ==  00 (meaning ARM_CLK is divided by 3) and MPLL 2x output is  greater than 537 MHz.  The ARMSRC and ARMDIV bits can be configured to any value  required by the application immediately after the MPLL restart. 	ARM9	ENGcm12387	PLL 	2	 Make sure either of the following two conditions are satisfied  when MPLL is restarted:  â¢ ARMSRC == 1 and ARMDIV[1:0] == 00  or  â¢ ARMSRC == 0 and ARMDIV=[1:0] == 00 AND MPLL 2x 	 	MPLL restart  limitation. Applies only  to silicon rev. 2.2.		0M72J	NXP
MCIMX27	Description:  A âwarmâ reset is a reset initiated by a watchdog timeout,  RESET_IN, or by software forcing a reset via the watchdog  module. Such a reset will reconfigure all the CCM registers to  their default values but it will not restart the MPLL, so the full CCM  configuration defined by the registers does not take effect. In  particular, MCU_SEL is cleared, selecting the internal FPM  output. Changes to ARMSRC and ARMDIV also take immediate  effect. As a consequence, if the external high frequency reference  clock is slower than the internal FPM output, and the MPLL has  been configured to operate at 1.2 GHz, the MPLL will exceed the  specified limite of 1.2 GHz. For example: Given an external high  frequency clock of 24 MHz, a low frequency clock of 32 kHz, and  the MPLL configured for 1.2 GHz (MF=50) using the external  24-MHz clock as the reference, the following will occur: After a  warm reset, the MPLL will continue using MF=50, because the  CCM registers are reset to default values but the PLLs are not  restarted. As a result, the MPLL will lock to the FPM output  (32.768 MHz, selected by the default value of MCU_SEL in  CSCR), driving MPLL output frequency to 1.64 GHz, which is  beyond the specified maximum. 	ARM9	ENGcm12388	PLL 	2	 1) Reconfigure the MPLL prior to a warm reset to avoid  exceeding the 1.2-GHz maximum MPLL output frequency. This  workaround only works when warm resets can be anticipated.  2) In applications that cannot anticipate a warm reset, as in the  case of RESET_IN from somewhere else in the system or a  watchdog timeout, the MPLL should be operated at a sufficiently  lower frequency so as to prevent a warm reset causing the MPLL  to exceed 1.2 GHz.  3) The CLKMODE[1:0] pads may be used to bypass the FPM and 	 	MPLL reference  clock source change  following a warm reset.		0M72J	NXP
IMX28	"The HW_PXP_CSCCOEFF2_C3 register does not receive the correct reset value after using the PXP software reset function or after power up.The PXP operates incorrectly with wrong coefficient setting."	ARM9	ENGR116904	PXP	 	"Always write the HW_PXP_CSCCOEFF2_C3 register with the expected value before using it. The PXP_CSCCOEFF2 register address is 0x8002A0F0."	 	"PXP: The HW_PXP_CSCCOEFF2_C3 register can not be reset correctly under some PVT corner"	No fix scheduled	 	NXP
IMX28	"The USB controller may not operate properly when receiving a packet in INCR8 and INCR16 modes. The packet is completed correctly (ACK is sent) on the USB bus, but cannot be seen by software. This issue exists when all of following conditions are met: 1. Controller is receiving data (Host Bulk IN or Device Bulk OUT) 2. Primary INCR8/INCR16 mode is selected (SBUSCFG. AHBBRST of the USB register is set to 0b010 or 0b011) 3. Length of data received is less than the total_byte field in TD 4. Data length is not a multiple of the burst size and the remainder is a sub-burst. For example, if the data length is 32n + 16 bytes in INCR8 mode, or 64n + 16/32/48 in INCR16 mode, this errata is triggered. Projected Impact: This is a low severity bug because INCR8 and INCR16 are not mandatory modes. Other modes should be used."	ARM9	ENGR119650	USB	 	Set SBUSCFG.AHBBRST of the USB register to a modes other than 0b010 or 0b011.	 	 USB: USB core INCR8 and INCR16 modes are inoperable	No fix scheduled	 	NXP
IMX28	"The ARM writes a data error to the USB core register unless SRM SWP instruction is used. The issue occurs when all of the following conditions are met: 1. Last AHB access is to the non-USB AHB slave 2. Current AHB access is to the USB 3. These two accesses are back-to-back 4. The last data phase of the last AHB access has a wait state 5. Only happens when D-cache is enabled Projected Impact: The USB register does not get correct data when writing to the USB slave through the AHB bus when D-cache is enabled"	ARM9	ENGR119653	USB	 	All USB register write operations must use the ARM SWP instruction.	 	USB: ARM to USB register error issue	No fix scheduled	 	NXP
IMX28	"The PWM channel might not generate the required output signal when in HSADC driving mode. When in HSADC mode, if the HSADC input clock is much lower than the APBX bus clock (for example APBX Bus clock is 24 MHz and HSADC input clock is 4 MHz) the write signal to the PWM registers is missed. Write access to the following registers has no effect after HSADC mode is enabled: â¢ PWM Control and Status Register â¢ PWM Channel Active Register â¢ PWM Channel Period Register As a result, dedicated PWM channel is not triggered. Projected Impact: HSADC or off chip linear sensor does not receive the required control signals."	ARM9	ENGR119657	PWM	 	"If the HSADC input clock is lower than the 24 MHz APBX bus clock the APBX bus clock should be set to a lower frequency before every write to the PWM register. When the write access finishes, the APBX clock can be set back to normal."	 	"PWM: Register write sync issue when HSADC clock frequency is lower than APBX clock frequency"	No fix scheduled.	 	NXP
IMX28	"The endian mode of the Ethernet controller is designed to be big-endian mode which is not compatible with the ARM core and reset sections of the device. Projected Impact: The ARM core cannot establish data communication correctly to/from the Ethernet controller without software endian conversion."	ARM9	ENGR121613	ENET	 	"When communicating with the Ethernet controller, an additional byte-swap routine has to be called by the ARM core."	 	ENET: ENET big endian mode not compatible with ARM little endian	No fix scheduled.	 	NXP
IMX28	"When the channel freeze bit is set, the APBH/APBX DMA channel can stall while waiting to access a peripheral on the APBH/APBX bus. This occurs if the channel freeze bit is set exactly at the same time as when the channel internal state machine changes from the PIO_REQ state to the REQ_WAIT state. Projected Impact: The data communication with the APBH/APBX DMA channel associated peripheral is stalled."	ARM9	ENGR121616	DMA	 	"Do not use DMA PIO operation to configure the associated peripheral when using channel freeze function. Use ARM PIO operation instead."	 	"DMA: APBH/APBX DMA channel can stall while waiting to access a APBH/APBX bus peripheral when the channel freeze bit is set"	No fix scheduled	 	NXP
IMX28	"An Abort request to a transmit message buffer (TxMB) can block any write operation into its CODE field. Therefore, the TxMB cannot be aborted or deactivated until it completes a valid transmission (by winning the CAN bus arbitration and transmitting the contents of the TxMB). Projected Impact: The TxMB cannot be aborted or deactivated until it completes a valid transmission."	ARM9	ERR002656	FlexCAN	 	"Instead of aborting the transmission, use deactivation instead. Note that there is a chance the deactivated TxMB can be transmitted without setting IFLAG and updating the CODE field if it is deactivated."	 	FlexCAN: Abort request blocks the CODE field	No fix scheduled	 	NXP
IMX28	"During CAN message reception by FlexCAN, the RXGMASK (Rx Global Mask) is used as an acceptance mask for most of the Rx message buffers (MB). When the FIFO Enable bit in the FlexCAN Module Configuration Register (CANx_MCR[FEN], bit 29) is set, the RXGMASK also applies to most of the elements of the ID filter table. However, there is a misalignment between the position of the ID field in the RxMB and that in the RXIDA, RXIDB and RXIDC fields of the ID tables. In fact, the RXIDA filter in the ID tables is shifted one bit to the left from the RxMBs ID position, as shown below: RxMB ID = bits 28-0 of ID word corresponding to message ID bits 28-0 RXIDA = bits 29-1 of ID Table corresponding to message ID bits 28-0 Note that the mask bits align to the ID filter bits, not to the incoming ID bits. For example, the bit 4 in RXGMASK masks bit 4 in RxMB ID, but it does not mask bit 4 in incoming message ID. This misalignment leads the RXGMASK to affect RxMB and Rx FIFO filtering in different ways. For example, if the user intends to mask out bit 4 of the ID filter of message buffer then the RXGMASK will be configured as 0xffff_ffef. As a result, bit 4 of the ID field of the incoming message is ignored during the filtering process for message buffers. This very same configuration of RXGMASK, which would lead bit 4 of RXIDA to be âdo not careâ and thus bit 3 of the ID field of the incoming message would be ignored during the filtering process for the Rx FIFO. Similarly, both RXIDB and RXIDC filters have multiple misalignments with regards to position of the ID field in the RxMBs, which can lead to erroneous masking during the filtering process for either Rx FIFO or MBs. RX14MASK (Rx 14 Mask) and RX15MASK (Rx 15 Mask) have the same structure as the RXGMASK. This includes the misalignment problem between the position of the ID field in the RxMBs and in the RXIDA, RXIDB and RXIDC fields of the ID Tables. Leading to mask misalignment between RxMB and Rx FIFO filtering."	ARM9	ERR002360	FlexCAN	 	"It is recommended that one of the following actions be taken to avoid problems: â¢ Do not enable the RxFIFO. If CANx_MCR[FEN]=0 then the Rx FIFO is disabled and thus the masks RXGMASK, RX14MASK and RX15MASK do not affect it. â¢ Enable Rx Individual Mask Registers. If the Backwards Compatibility Configuration bit in the FlexCAN Module Configuration Register (CANx_MCR[BCC], bit 16) is set then the Rx Individual Mask Registers (RXIMR0-63) are enabled and thus the masks RXGMASK, RX14MASK and RX15MASK are not used. â¢ Do not use the masks RXGMASK, RX14MASK and RX15MASK (leave them in reset value which is 0xffff_ffff) when CANx_MCR[FEN]=1 and CANx_MCR[BCC]=0. In this case, filtering processes for both RxMBs and Rx FIFO are not affected by those masks. â¢ Do not configure any MB as Rx (leave all MBs as either Tx or inactive) when CANx_MCR[FEN]=1 and CANx_MCR[BCC]=0. In this case, the masks RXGMASK, RX14MASK and RX15MASK can be used to affect ID tables without affecting filtering process for RxMBs."	 	FlexCAN: Global Masks misalignment	No fix scheduled	 	NXP
IMX28	"In order to switch the EMI clock from asynchronous to synchronous mode, both the xtal_ref and the cpu_ref must be active, even if both BYPASS_CPU and BYPASS_EMI are set in the HW_CLKCTRL_CLKSEQ register. Projected Impact: The i.MX28 locks up."	ARM9	2765	EMI Clock	 	If cpu_ref is inactive, then activate the cpu_ref before attempting to switch to synchronous mode.	 	EMI Clock: Switching to synchronous mode error	No fix scheduled	 	NXP
IMX28	"Currently, software checks the active bit in dTD to see whether it is finished. If the Active bit is 0, then software frees the allocated memory for the dTD. The hardware sequence after all data of a dTD is transferred is as follows: 1. Update the dTD. This includes an AHB write access of three DWords. The active bit is cleared in the first DW write. 2. Update the qHead (this includes an AHB write access of three DWords). 3. Read the dTD again to check if software added a new dTD (this is a SINGLE AHB read). At the same time, send out an interrupt if needed. After step 1, if software finds the Active bit is cleared, then the dTD memory space is freed and may be allocated for another threadâs use. In step 3, hardware may get a wrong dTD. This issue does not occur if some delay is added before freeing the dTD memory space. This issue only occurs in USB INCR8 mode, because steps 1 and 2 have 6 SINGLE AHB transfers in INC8 mode, but only two burst AHB transfers in INCR mode. This issue only occurs when the dTD list is used; because if only one dTD is used, the software only checks the Active bit after an interrupt is received (step 3). However, when the dTD list is used, the software may check the entire list after the interrupt for the first dTD is received, when the hardware has just finished the transfer of the second dTD. Projected Impact: USB Controller may hang if dTD is freed too quickly."	ARM9	2858	USB	 	"Postpone freeing the current dTD; free it when its next dTD can be freed, so the last completed dTD (followed by an ACTIVE dTD) is always freed when the next IOC irq comes."	 	"USB controller may access a wrong address for the dTD (endpoint transfer descriptor) and then hangs"	No fix scheduled	 	NXP
IMX28	"If the DCDC_XFER bit is clear, the DCDC converter should not automatically turn on when 5 V is removed. Instead, a power-down should occur if 5 V is removed, when DCDC_XFER and ENABLE_DCDC are zero. Projected Impact: DCDC converter input source may switch to DCDC_BATT pin but no power source is present there. This may latch-up the DCDC converter circuit."	ARM9	2814	DCDC	 	"In order to power down the system properly when 5 V is removed, set PWDN_5VBRNOUT bit in Register HW_POWER_5VCTRL."	 	"The DCDC converters unexpectedly turn on when 5 V is removed while the DCDC_XFER bit is clear"	No fix scheduled	 	NXP
IMX28	"Due to unreliability of the VDD5V_GT_VDDIO functionality, the power supply should never be configured to be used as the 5-V plug/unplug detection method. Projected Impact: VDD5V_GT_VDDIO output may not change to â0â (and VDD5V_GT_VDDIO_IRQ may not be triggered) when 5 V is unplugged."	ARM9	2811	VDD5V_GT_VDDIO	 	"Use the VBUSVALID comparator for 5V plug/unplug detection. Actually, the VBUSVALID comparator is recommended in the reference manual, not VDD5V_GT_VDDIO. The VBUSVALID_5VDETECT bit in HW_POWER_5VCTRL should be set to â1â (itâs default value) and never cleared. The detection threshold can be changed in the VBUSVALID_TRSH bit field in HW_POWER_5VCTRL."	 	Unreliability of VDD5V_GT_VDDIO functionality	No silicon fix scheduled.	 	NXP
IMX28	"When boot mode is set as boot from SD/MMC/eMMC on SSP0/1, the SSP_SCK polarity is not correctly set up in ROM. The POLARITY bit in HW_SSP_CTRL1 register should be set to â1â (command and data output on falling edge of clock) according to SD/MMC/eMMC specification. However, the POLARITY bit is set to â0â in ROM in the existing silicon (TO1.2). As a result, input setup time (tISU) at SD/MMC/eMMC input may not be met. Projected Impact: Write command error may occur when booting from the SD/MMC/eMMC on SSP0/1 and result in boot failure."	ARM9	TKT131240	SSP0/1-SD/MMC/eMMC Boot	 	"If tISU at SD/MMC/eMMC input is violated and write command error occurs during boot from SD/MMC/eMMC, a ROM patch of 1kByte size loaded from the EEPROM is required to fix this issue. Boot mode should be set to [0001] for the EEPROM on I2C0 or [1000] for the EEPROM on SPI3. The patch executes from the EEPROM, patches the ROM SSP driver code, and switches boot to either SSP0 or SSP1. There are separate patch binaries to boot from SSP0 and SSP1."	 	SSP0/1-SD/MMC/eMMC Boot: SSP_SCK polarity setup issue in ROM	No silicon fix scheduled.	 	NXP
IMX28	"When the ENABLE_DCDC bit in HW_POWER_DCDC4P2 or HW_POWER_5V_CTRL is set, a glitch is propagated through the brownout comparators. If the glitch is sufficiently large, it can cause a false brownout detection. The VDDD, VDDA, VDDIO, and VBUSVALID comparators are all susceptible to the glitch. Projected Impact: Can result in a false brownout detection."	ARM9	5837	ENABLE_DCDC	 	"The sequence below is needed to work around this issue prior to setting the ENABLE_DCDC bit in HW_POWER_DCDC4P2: 1. Disable the power rail brownout interrupts (clear HW_POWER_CTRL VDDA, VDDD, VDDIO ENIRQ bits). 2. Set the HW_POWER_5VCTRL PWRUP_VBUS_CMPS bit. 3. Set the HW_POWER_5VCTRL VBUSVALID_TRSH to 0x0 (2.9 V). 4. Set the HW_POWER_5VCTRL VBUSVALID_5VDETECT bit to 1. 5. Disable VBUSDROOP status and interrupts (clear VDD5V_DROOP_IRQ). 6. Set the ENABLE_DCDC bit in HW_POWER_DCDC4P2. 7. Wait 100 Âµs 8. Check VBUSVALID_IRQ bit. If it is set, then set and clear the PWD_CHARGE_4P2 bit to repower on the 4P2 regulator because it is automatically shut off on a VBUSVALID false condition. It may be helpful to ramp up the CHARGE_4P2_ILIMIT value at this point to gradually draw power from 5 V rail. If HW_POWER_5VCTRL ENABLE_DCDC is already set, the DCDC will draw current from VDD4P2 as soon as PWD_CHARGE_4P2 is cleared. 9. Clear VBUSDROOP, VBUSVALID, and the output rails IRQ bits as needed. 10. Restore the output rail ENIRQ bits, the VBUSVALID_TRSH level, VBUSVALID_5VDETECT value, ENIRQ_VBUS_VALID, and ENIRQ_VDD5V_DROOP to their original values. The sequence below is needed to work-around this issue prior to setting the ENABLE_DCDC bit in HW_POWER_5VCTRL and HW_POWER_DCDC4P2. Note that the below workaround assumes the usual requirements for setting the HW_POWER_5VCTRL ENABLE_DCDC bit are met (that is, the hardware and/or software battery brownout protection mechanism is enabled to properly protect the system against the DCDC sourcing from the battery if the battery voltage is too low). 1. Disable the power rail brownout interrupts (clear HW_POWER_CTRL VDDA, VDDD, VDDIO ENIRQ bits). 2. Set the HW_POWER_5VCTRL PWRUP_VBUS_CMPS bit. 3. Set the HW_POWER_5VCTRL VBUSVALID_TRSH to 0x0 (2.9 V). 4. Set the HW_POWER_5VCTRL VBUSVALID_5VDETECT bit to 1. 5. Disable VBUSDROOP status and interrupts (clear VDD5V_DROOP_IRQ). 6. Set the ENABLE_DCDC bit in HW_POWER_5VCTRL. 7. Wait 100 Âµs. 8. Check VBUSVALID_IRQ bit. If it is set, and 5 V is present and the VDD4P2 rail was enabled, then repeat the sequence for enabling the 4P2 regulator and DCDC from VDD4P2. This bit indicates that the DCDC has tried to source from the battery, even if 4P2 sourcing is enabled. This is because a VBUSVALID false condition automatically disables the 4P2 regulator, so the DCDC then falls back to battery sourcing. 9. Clear VBUSDROOP, VBUSVALID, and the output rails IRQ bits as needed. 10. Restore the output rail ENIRQ bits, the VBUSVALID_TRSH level, VBUSVALID_5VDETECT value, ENIRQ_VBUS_VALID, and ENIRQ_VDD5V_DROOP to their original values."	 	Setting the ENABLE_DCDC bit in the HW_POWER_DCDC4P2 or HW_POWER_5VCTRL registers can result in false brownout Detection	No silicon fix scheduled	 	NXP
IMX28	"ROM in existing silicon (TO1.2) supports ONFI BA-NAND boot-up. During boot-up it reads Bit 7 of Byte 6-7 (1=supports Block Abstracted access mode) in ONFI NAND deviceâs parameter page to determine if the NAND device is ONFI BA-NAND. BA-NAND memory devices are no longer part of the ONFI spec and memory vendors do not support these devices anymore. However in ONFI 3.0 Spec, that bit has been re-used to specify whether the NAND device supports extended parameter page. When a system is mounted with ONFI 3.0 NAND device with âsupports extended parameter pageâ bit set to â1â, the i.MX28 boot ROM will see it as BA-NAND and will use BA-NAND commands to access the NAND device. As a result, the system will fail to boot-up. Projected Impact: System mounted with ONFI 3.0 NAND device will fail to boot-up."	ARM9	TKT140334	ONFI	 	"Contact ONFI NAND vendor to supply NAND device with the âsupports extended parameter pageâ bit set to â0â, so that the i.MX28 boot ROM will not treat it as BA-NAND."	 	ONFI 3.0 NAND boot-up issue	No silicon fix scheduled.	 	NXP
IMX28	The Ethernet 1588 clock (CLK_ENET_TIME) continues to toggle when the Ethernet module is disabled by setting ENET disable control bit in the HW_CLKCTRL_ENET register. The ethernet controller consumes 30 ?A on the 4.2 V power supply. Projected Impact: The Ethernet 1588 clock consumes 30 ?A on the 4.2 V power supply when the Ethernet module is disabled.	ARM9	ENGR119956	CLKCTRL	 	"The Ethernet 1588 clock can be gated off by clearing the HW_CLKCTRL_ENET_DIV_TIME register. The HW_CLKCTRL_ENET_DIV_TIME register address is 0x80040140."	 	"CLKCTRL: ENET 1588 clock (CLK_ENET_TIME) is not under control of ENET disable control bit"	No fix scheduled	 	NXP
SAM9260	The DRDY Flag should be clear only after a read of ADC_LCDR (Last Converted Data Register). A read of any ADC_CDRx (Channel Data Register) automatically clears the DRDY ï¬ag.	ARM9	 	Analog-to-digital Converter (ADC)	 	None	 	43.1.1.1 ADC: DRDY Bit Cleared	Not fixed	 	Atmel
SAM9260	When reading LCDR at the same instant as an end of conversion, with DRDY already active. DRDY is kept active regardless of the enable status of the current channel. This sets DRDY, whereas new data is not stored.	ARM9	 	Analog-to-digital Converter (ADC)	 	None	 	43.1.1.2 ADC: DRDY not Cleared on Disable	Not fixed	 	Atmel
SAM9260	"Reading CDR for channel ""yâ at the same instant as an end of conversion on channel ""xâ with EOC[x] already active, leads to skipping to set the DRDY ï¬ag if channel ""x"" is enabled."	ARM9	 	Analog-to-digital Converter (ADC)	 	Use of DRDY functionality with access to CDR registers should be avoided.	 	43.1.1.3 ADC: DRDY Possibly Skipped due to CDR Read	Not fixed	 	Atmel
SAM9260	I: u DRDY does not rise when disabling channel y at the same time as an end of âxâ channel conversion, although data is stored into CDRx and LCDR.	ARM9	 	Analog-to-digital Converter (ADC)	 	None.	 	43.1.1.4 ADC: Possible Skip on DRDY when Disabling a Channel	Not fixed	 	Atmel
SAM9260	Read of the Status Register at the same instant as an end of conversion leads to skipping the update of the GOVRE (general overrun) ï¬ag. GOVRE is neither reset nor set. For example, if reading the status while an end of conversion is occurring and: 1. GOVRE is active but DRDY is inactive, does not correspond to a new general overrun condition but the GOVRE ï¬ag is not reset. 2. GOVRE is inactive but DRDY is active, does correspond to a new general overrun condition but the GOVRE ï¬ag is not set.	ARM9	 	Analog-to-digital Converter (ADC)	 	None 790 SAM926O [DATASHEET] AtmeL Almel-6221 M-ATARM-SAMQZSO-DatasheetJ 3-Jan-16	 	43.1.1.5 ADC: GOVRE Bit is Not Updated	Not fixed	 	Atmel
SAM9260	"When reading CDRy (Channel Data Register y) at the same instant as an end of conversion on channel ""xâ with the following conditions: 0 EOC[x] already active, 0 DRDY already active, 0 GOVRE inactive, 0 previous data stored in LCDR being neither data from channel â"",y nor data from channel âx"". GOVRE should be set but is not."	ARM9	 	Analog-to-digital Converter (ADC)	 	None	 	43.1.1.6 ADC: GOVRE Bit is Not Set when Reading CDR	Not fixed	 	Atmel
SAM9260	"When disabling channel ây"" at the same instant as an end of conversion on channel âxâ, EOC[x] and DRDY being already active, GOVRE does not rise. Note: OVRE[x] rises as expected."	ARM9	 	Analog-to-digital Converter (ADC)	 	None	 	43.1.1.7 ADC: GOVRE Bit is Not Set when Disabling a Channel	Not fixed	 	Atmel
SAM9260	When the OVRE ï¬ag (on channel i) has been set but the related EOC status (of channel i) has been cleared (by a read of CDRi or LCDR), reading the Status register at the same instant as an end of conversion (causing the set of ECG status on channel i), does not lead to a reset of the OVRE ï¬ag (on channel i) as expected.	ARM9	 	Analog-to-digital Converter (ADC)	 	None	 	43.1.1.8 ADC: OVRE Flag Behavior	Not fixed	 	Atmel
SAM9260	If a channel is disabled while a conversion is running and if a read of CDR is performed at the same time as an end of conversion of any channel occurs, the ECG of the channel with the conversion running may rise (whereas it has been disabled).	ARM9	 	Analog-to-digital Converter (ADC)	 	Do not take into account the E00 of a disabled channel	 	43.1.1.9 ADC: EOC Set Although Channel Disabled	Not fixed	 	Atmel
SAM9260	"If âx"" and ""yâ are two successively converted channels and ""zâ is yet another enabled channel (""2â being neither âx"" n I: nor âyâ), reading CDR on channel â2"" at the same instant as an end of conversion on channel y automatically clears EOC[x] instead of EOC[z]."	ARM9	 	Analog-to-digital Converter (ADC)	 	None.	 	43.1.1.10 ADC: Spurious Clear of EOC Flag	Not fixed	 	Atmel
SAM9260	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	ARM9	 	Analog-to-digital Converter (ADC)	 	To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit ï¬eld); to start an analog-toâdigital conversion, in order put ADC into sleep mode at the end of this conversion. AtmeL SAM926O [DATASHEET] 791 AtmeIâ6221M-ATARM-SAMQZSO-Datasheet_13-Jan-16 43.1.2 Boot ROM	 	43.1.1.11 ADC: Sleep Mode	Not fixed	 	Atmel
SAM9260	"The SMC_SETUP register for the NAND Flash Chip Select (NCS3) is not initialized correctly in the ROM code. NRD_SETUP is initialized to ""0"" which leads to a violation of parameters tAR and tCLR. The following commands are concerned; READ ID (0x90), READ STATUS (0x70), PAGE READ (0x00, 0x30) and RANDOM DATA READ (0x05, OxEO)."	ARM9	 	Boot ROM	 	Use DataFlash Boot or external memory on EBI_NCSO.	 	43.1.2.1 NAND Flash Boot Does Not Work Correctly	Not fixed	 	Atmel
SAM9260	The Real-time Timer is reset by the BootROM after each power up. This prevents using the RTT as a backed up real-time clock.	ARM9	 	Boot ROM	 	Boot on an external memory connected on CSO (BMS = 0).	 	43.1.2.2 Problem with RTI'	Not fixed	 	Atmel
SAM9260	The boot ROM program configures the NRST pin as an input, and programs the User Reset length. As RSTC registers are powered by VDDBU, the settings are saved and ovenNrite the user conï¬guration.	ARM9	 	Boot ROM	 	Writing the URSTEN bit to 0 in RSTC_MR disables the User Reset trigger. 43.1.3 Bus Matrix	 	43.1.2.3 User Reset trigger is enabled by default	Not fixed	 	Atmel
SAM9260	MATRIX_MCFG5 is write-only. The value written is effective but not readable.	ARM9	 	Bus Matrix	 	None. 43.1 .4 EMAC	 	43.1.3.1 Bus Matrix Master Conï¬guration Register 5	Not fixed	 	Atmel
SAM9260	"EMACB FIFO internal arbitration scheme is: 1. Receive buffer manager write Receive buffer manager read Transmit data DMA read Receive data DMA write Transmit buffer manager read 6. Transmit buffer manager write 91:59!"" EMACB master interface releases the AHB bus between two transfers. EMACB has the highest priority. If EMACB RX and TX FlFOs both have pending requests, the following sequence occurs: 1. EMACB RX FIFO write (burst 4) 2 EMACB releases the AHB bus 3. The AHB matrix can grant an another master (ARM | or D for example) 4 AHB matrix re-arbitration (finishes at least the current word/halfword/byte) 792 SAM926O [DATASHEET] AtmeL Almel-6221 M-ATARM-SAMQZSO-DatasheetJ 3-Jan-16 5. The AHB matrix grants the EMACB 6. The EMACB TX FIFO read (burst 4) In case of a slow memory and/or a special operation like SDRAM refresh or SDRAM bank opening, a TX underrun may occur. (latency min 960 ns)."	ARM9	 	Bus Matrix	 	Reduce re-arbitration time between RX & TX EMACB transfers by using internal SRAM (or another memory slave with a short access time) to transmit buffers and descriptors. 43.1.5 IIO Considerations	 	43.1.4.1 EMAC: TX Underrun May Occur in Some Cases	Not fixed	 	Atmel
SAM9260	The I/O output buffer drive is too high to guarantee the timings. This is applicable to the External Bus Interface signals and to the peripheral I/Os. This leads to fast rise and fall time when the signals change, causing high currents to be drawn on the power supply pins and leads to emission of high frequencies. This may affect the operation of the device and may result in the emission of radio-frequency signals, making EMC certiï¬cation difï¬cult.	ARM9	 	IIO Considerations	 	It is strongly recommended: 0 to place the memories connected to the EBI as close as possible to the SAM9260 on the PCB o to route all the EBI signals with a series resistor, typical value 33 ohms o to adjust the series resistor value with tools taking into account the IBIS model of the pads and the characteristics of the wires of the PCB, in order to guarantee rise and fall times as long as timings permit. 43.1.6 MCI	 	43.1.5.1 IIO High Drive Strength	Not fixed	 	Atmel
SAM9260	The busy status of the card during the response (R1b) is ignored for the commands CMD7, CMD28, CMD29, CMD38, CMD42, CMD56. Additionally, for commands CMD42 and CMD56 a conï¬ict can occur on data lineO if the MCI sends data to the card while the card is still busy. The behavior is correct for CMD12 command (STOP_TRANSFER).	ARM9	 	MCI	 	None	 	43.1.6.1 MCI: Busy Signal of R1b Responses is Not Taken in Account	Not fixed	 	Atmel
SAM9260	If there is 1-bit data bus width on slots other than slot A, the SDIO interrupt cannot be captured. The sample is made on the wrong data line.	ARM9	 	MCI	 	None	 	43.1.6.2 MCI: SDIO Interrupt Does Not Work With Slots Other Than A	Not fixed	 	Atmel
SAM9260	As the data Timeout error ï¬ag checking the Naac timing cannot rise, the MCI can be stalled waiting indeï¬nitely the Data start bit.	ARM9	 	MCI	 	A STOP command must be sent with a software timeout.	 	43.1.6.3 MCI: Data Timeout Error Flag	Not fixed	 	Atmel
SAM9260	The Data Write operation with a number of bytes less than 12 is impossible. AtmeL SAM9260 [DATASHEET] 793 AtmeIâ6221M-ATARM-SAMQZSO-Datasheet_13-Jan-16	ARM9	 	MCI	 	The PDC counters must always be equal to 12 bytes for data transfers lower than 12 bytes. The BLKLEN or BCNT field are used to specify the real count number.	 	43.1.6.4 MCI: Data Write Operation and Number of Bytes	Not fixed	 	Atmel
SAM9260	In half duplex mode, the reset of the ï¬ags ENDRX, RXBUFF, ENDTX and TXBUFE can be incorrect. These ï¬ags are reset correctly after a PDC channel enable.	ARM9	 	MCI	 	Enable the interrupts related to ENDRX, ENDTX, RXBUFF and TXBUFE only after enabling the PDC channel by writing PDC_TXTEN or PDC_RXTEN. 43.1.7 Reset Controller (RSTC)	 	43.1.6.5 MCI: Flag Reset is Not Correct in Half Duplex Mode	Not fixed	 	Atmel
SAM9260	When a user reset, watchdog reset, or software reset occurs during SDRAM read access, the SDRAM clock is turned off while data is ready to be read on the data bus. The SDRAM maintains the data until the clock restarts. If the user reset, watchdog reset, or software reset is programmed to assert a general reset, the data maintained by the SDRAM leads to a data bus conï¬ict and adversely affects the boot memories connected on the EBI: o NAND Flash boot functionality, if the system boots out of internal ROM. 0 NOR Flash boot, if the system boots on an external memory connected on the EBI CSO.	ARM9	 	Reset Controller (RSTC)	 	1. Avoid user reset, watchdog reset, software reset to generate a system reset. 2. Trap the user reset, watchdog reset, software reset with an interrupt. In the interrupt routine, power down the SDRAM properly and perform Peripheral and Processor Reset with software in assembler. Example with IibV3. o The main code: //user reset interrupt setting // Configure AIC controller to handle System peripheral interrupts AT9lF_AIC_ConfigureIt ( AT91C_BASE_AIC, // AIC base address AT91C_ID_SYS, // System peripheral ID AT91C_AIC_PRIOR_HIGHEST, // Max priority AT9lC_AIC_SRCTYPE_INT_EDGE_TRIGGERED, // Level sensitive sysc_handler ); // Enable SYSC interrupt in AIC AT9lF_AIC_EnableIt(AT91C_BASE_AIC, AT91C_ID_SYS); *AT91C_RSTC_RMR = (0xA5<<24) | (Ox4<<8) | AT91C_RSTC_URSTIEN; o The C SYS handler: extern void soft_user_reset(void); void sysc_handler(void){ //check if interrupt comes from RSTC if( (*AT91C_RSTC_RSR & AT9lC_RSTC_URSTS ) == AT91C_RSTC_URSTS){ soft_user_reset(); //never reached 794 SAM9260 [DATASH EET] AtmeL Almel-6221 M-ATARM-SAMQZSO-DatasheetJ 3-Jan-16 while(l); } } 0 Assembly code is mandatory for the following sequence as ARM instructions need to be pipelined. The assembler routine: AREA TEST, CODE INCLUDE AT91$AM9xxx.inc EXPORTsoft_user_reset soft_user_reset ;disable IRQs MRS r0, CPSR ORR r0, r0, #0x80 MSR CPSR_c, r0 ;change refresh rate to block all data accesses LDR r0, =AT91C_SDRAMC_TR LDR r1, =1 STR r1, [r0] ;prepare power down command LDR r0, =AT9lC_SDRAMC_LPR LDR rl, =2 ;prepare proc_reset and periph_reset LDR r2, =AT91C_RSTC_RCR LDR r3, =0xA5000005 ;perform power down command STR r1, [r0] ;perform proc_reset and periph_reset (in the ARM pipeline) STR r3, [r2] END 43.1.8 Oscillators	 	43.1.7.1 RSTC: Reset during SDRAM Accesses	Not fixed	 	Atmel
SAM9260	When booting from the on-chip RC, the startup time is ï¬xed at 1200 ms and not 240 us as speciï¬ed in Table 5-1 on page 18.	ARM9	 	Oscillators	 	None	 	43.1.8.1 On-chip RC Startup Time	Not fixed	 	Atmel
SAM9260	When VDDBU only is powered, either internal RC oscillator or external 32K osc may start regardless of the setting of the OSCSEL pin. The OSCSEL pin sampling is correct after applying VDDCORE power supply and remains correct if VDDCORE is removed.	ARM9	 	Oscillators	 	The ï¬rst power-up sequence requires both VDDBU and VDDCORE to correctly sample the OSCSEL signal. AtmeL SAM9260 [DATASHEET] 795 AtmeIâ6221M-ATARM-SAMQZSO-Datasheet_13âJan-16 43.1.9 SDRAM Controller	 	43.1.8.2 Bad Sampling of OSCSEL	Not fixed	 	Atmel
SAM9260	After a reset, the SDRAM clock is always active leading to over consumption in the pad.	ARM9	 	SDRAM Controller	 	The following sequence stops the SDRAM clock. 1. Set the bit LPCB in the SDRAMC Low Power Register. 2. Write 0 in the SDRAMC Mode Register and perform a dummy write in SDRAM to complete.	 	43.1.9.1 SDCLK Clock Active After Reset	Not fixed	 	Atmel
SAM9260	"Using Mobile SDRAM devices that need to have their DQMx level HIGH during Mobile SDRAM device initialization may lead to data bus contention and thus external memories on the same EBI must not be accessed. This does not apply to Mobile SDRAM devices whose DQMx level is âDon't care"" during this phase."	ARM9	 	SDRAM Controller	 	Mobile SDRAM initialization must be performed in internal SRAM.	 	43.1.9.2 Mobile SDRAM Device Initialization Constraint	Not fixed	 	Atmel
SAM9260	In the current revision, SDCKE rises at the same time as SDCK while exiting self-refresh mode. To be fully compliant with the JEDEC standard, SDCK must be STABLE before the rising edge of SDCKE.	ARM9	 	SDRAM Controller	 	None. 43.1.10 Serial Peripheral Interface (SPI)	 	43.1.9.3 JEDEC Standard Compatibility	Not fixed	 	Atmel
SAM9260	If the SPI is used in the following conï¬guration: 0 Master mode 0 CPOL = 1 and NCPHA = 0 0 multiple chip selects used with one transfer with Baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR not equal to 1 o transmit with the slowest chip select and then with the fastest one then an additional pulse will be generated on output PSCK during the second transfer.	ARM9	 	Serial Peripheral Interface (SPI)	 	Do not use a multiple Chip Select conï¬guration where at least one SPI_CSRx register is conï¬gured with SCBR = 1 and the others differ from 1 if CPHA = 0 and CPOL = 1. If all chip selects are conï¬gured with SCBR = 1, the issue does not appear.	 	43.1.10.1 SPI: Bad Serial Clock Generation on Second chip_select when SCBR = 1, CPOL = 1 and NCPHA = 0	Not fixed	 	Atmel
SAM9260	When baud rate is set to 1 (i.e., when serial clock frequency equals the system clock frequency), and when the fields BITS (number of bits to be transmitted) equals an ODD value (in this case 9, 11, 13 or 15), an additional pulse is generated on output SPCK. No error occurs if BITS ï¬eld equals 8, 10, 12, 14 or 16 and SCBR = 1.	ARM9	 	Serial Peripheral Interface (SPI)	 	None. 796 SAM9260 [DATASHEET] AtmeL Almel-6221 M-ATARM-SAMQZSO-DatasheetJ 3-Jan-16	 	43.1.10.2 SPI: Baud Rate Set to 1	Not fixed	 	Atmel
SAM9260	One byte data can be lost when PDC transmits. This occurs when write accesses are performed on the base address of any peripheral, during the PDC transfer.	ARM9	 	Serial Peripheral Interface (SPI)	 	0 Add a timeout for the PDC transfer and check the value of the PDC transmit counter when the timeout has elapsed. Check the data integrity by a checksum. Avoid write access on the base address of peripherals during a PDC transfer.	 	43.1.10.3 SPI: PDC Data Loss	Not fixed	 	Atmel
SAM9260	If a software reset (SWRST in the SPI Control Register) is performed, the SPI may not work properly (the clock is enabled before the chip select).	ARM9	 	Serial Peripheral Interface (SPI)	 	The SPI Control Register ï¬eld SWRST needs to be written twice to be correctly set. 43.1.11 Serial Synchronous Controller (SSC)	 	43.1.10.4 SPI: Software Reset Needs to be Written Twice	Not fixed	 	Atmel
SAM9260	When the SSC receiver is used in the following conï¬guration: 0 the internal clock divider is used (CKS = 0 and DIV different from 0), o RK pin set as output and provides the clock during data transfer (CKO = 2) 0 data sampled on RK falling edge (CKI = 0) then, at the end of the data, the RK pin is set in high impedance which may be interpreted as an unexpected clock cycle.	ARM9	 	Serial Synchronous Controller (SSC)	 	Enable the pull-up on RK pin.	 	43.1.11.1 SSC: Unexpected RK Clock Cycle when RK Outputs a Clock During Data Transfer	Not fixed	 	Atmel
SAM9260	When the SSC receiver is used in the following conï¬guration: 0 RX clock is divided clock (CKS = 0 and DIV different from 0) o RK pin set as output and provides the clock during data transfer (CKO = 2) 0 data sampled on RK falling edge (CKI = 0) then the ï¬rst clock cycle time generated by the RK pin is equal to MCK/(2 x (DIV + 1)) instead of MCK/(2 x DIV).	ARM9	 	Serial Synchronous Controller (SSC)	 	None.	 	43.1.11.2 SSC: Incorrect ï¬rst RK Clock Cycle when RK Outputs a Clock During Data Transfer	Not fixed	 	Atmel
SAM9260	If TK is programmed as output and TF is programmed as input, it is impossible to emit data when start of edge (rising or falling) of synchro has a Start Delay equal to zero.	ARM9	 	Serial Synchronous Controller (SSC)	 	None.	 	43.1.11.3 SSC: Transmitter Limitations in Slave Mode	Not fixed	 	Atmel
SAM9260	If Least Significant Bit is sent ï¬rst (MSBF = 0) the ï¬rst TAG during the frame synchro is not sent.	ARM9	 	Serial Synchronous Controller (SSC)	 	None. AtmeL SAM9260 [DATASHEET] 797 AtmeIâ6221M-ATARM-SAMQZSO-Datasheet_13âJan-16 43.1.12 Static Memory Controller (SMC)	 	43.1.11.4 SSC: Periodic Transmission Limitations in Master Mode	Not fixed	 	Atmel
SAM9260	The user must not change the conï¬guration parameters of an SMC Chip Select (Setup, Pulse, Cycle, Mode) if accesses are performed on this CS during the modiï¬cation. For example, the modiï¬cation of the Chip Select 0 (080) parameters, while fetching the code from a memory connected on this CSO, may lead to unpredictable behavior.	ARM9	 	Static Memory Controller (SMC)	 	The code used to modify the parameters of an SMC Chip Select can be executed from the internal RAM or from a memory connected to another Chip Select. 43.1.13 Shutdown Controller (SHDWC)	 	43.1.12.1 SMC: Chip Select Parameters Modification	Not fixed	 	Atmel
SAM9260	If only VDDBU is powered during boot sequence (No VDDCORE), the SHDN signal may be driven to low level voltage after a delay. This delay is linked to the startup time of the slow clock selected by OSCSEL signal. If SHDN pin is connected to the Enable pin (EN) of the VDDCORE regulator, VDDCORE establishment does not occur and the system does not start.	ARM9	 	Shutdown Controller (SHDWC)	 	1. VDDCORE must be established within the delay corresponding to the startup time of the slow clock selected by OSCSEL. 2. Add a glue logic to latch the rising edge of the SHDN signal. The reset of the latch output (EN_REG) can be connected to a PIO and used to enter the shutdown mode. 43.1.14 System Controller	 	43.1.13.1 SHDWC: SHDN Signal may be Driven to Low Level Voltage During Device Power-on	Not fixed	 	Atmel
SAM9260	If an event (RTTINC or ALMS) occurs within the same slow clock cycle as when the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	ARM9	 	System Controller	 	The software must handle an RTT event as an interrupt and should not poll RTT_SR. 43.1.15 Two-wire Interface (TWI)	 	43.1.14.1 Possible Event Loss when Reading R1T_SR	Not fixed	 	Atmel
SAM9260	At the end of transfer in slave mode, the slave mode is disabled, the master mode is enabled and thus a transfer in master mode can be performed. In the current device, the start event is correctly generated but the SCL line is stuck at 1, so no transfer is possible.	ARM9	 	Two-wire Interface (TWI)	 	Two workarounds are possible: 1. Perform a software reset before going to master mode (TWI must be reconï¬gured). or 2. Perform a slave read access before switching to master mode. 798 SAM9260 [DATASHEET] AtmeL Almel-6221 M-ATARM-SAMQZSO-DatasheetJ 3-Jan-16 43.1.16 UHP	 	43.1.15.1 TWI: Switch from Slave to Master Mode	Not fixed	 	Atmel
SAM9260	Conditions: Consider the following sequence: 1. The Host controller issues an IN token. 2 The Device provides the IN data in a short packet. 3. The Host controller writes the received data to the system memory. 4 The Host controller is now supposed to carry out two Write transactions (TD status write and TD retirement write) to the system memory in order to complete the status update. 5. The Host controller raises the request for the ï¬rst write transaction. By the time the transaction is completed, a frame boundary is crossed. 6. After completing the first write transaction, the Host controller skips the second write transaction. Consequence: When this error occurs, the Host controller tries the same IN token again.	ARM9	 	UHP	 	This problem can be avoided if the system guarantees that the status update can be completed within the same frame.	 	43.1.16.1 UHP: Non-ISO IN Transfers	Not fixed	 	Atmel
SAM9260	Conditions: Consider the following sequence: 1. The Host controller sends an ISO OUT token after fetching 16 bytes of data from the system memory. 2. When the Host controller is sending the ISO OUT data, because of system latencies, remaining bytes of the packet are not available. This results in a buffer underrun condition. 3. While there is an underrun condition, if the Host controller is in the process of bit-stufï¬ng, it causes the Host controller to hang. Consequence: After the failure condition, the Host controller stops sending the SOF. This causes the connected device to go into suspend state.	ARM9	 	UHP	 	This problem can be avoided if the system can guarantee that no buffer underrun occurs during the transfer.	 	43.1.16.2 UHP: ISO OUT Transfers	Not fixed	 	Atmel
SAM9260	Conditions: When a Remote Wakeup event occurs on a downstream port, the OHCI Host controller begins sending resume signaling to the device. The Host controller is supposed to send this resume signaling for 20 ms. However, if the driver sets the HcControl.HCFS into USBOPERATIONAL state during the resume event, then the Host controller terminates sending the resume signal with an EOP to the device. Consequence: If the Device does not recognize the resume (< 20 ms) event, then the Device remains in suspend state.	ARM9	 	UHP	 	Host stack can do a port resume after it sets the HcControl.HCFS to USBOPERATIONAL. AtmeL SAM9260 [DATASHEET] 799 AtmeIâ6221M-ATARM-SAMQZSO-Datasheet_13âJan-16 43.1 .17 USART	 	43.1.16.3 UHP: Remote Wakeup Event	Not fixed	 	Atmel
SAM9260	TXD signal should be pulled up in Modem and Hardware Handshaking mode.	ARM9	 	UHP	 	TXD is multiplexed with PIO which integrates a pull up resistor. This internal pull-up must be enabled.	 	43.1.17.1 USART: TXD Signal is Floating in Modern and Hardware Handshaking Mode.	Not fixed	 	Atmel
SAM9260	The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	ARM9	 	UHP	 	Add an inverter.	 	43.1.17.2 USART: DCD is Active High Instead of Low	Not fixed	 	Atmel
SAM9260	In receiver mode, when two characters are consecutive (without timeguard in between) the RXBRK is not taken into account. As a result the RXBRK ï¬ag is not enabled correctly and the frame error flag is set.	ARM9	 	UHP	 	Constraints on the transmitter device connected to the SAM9260 USART receiver side. The transmitter may use the timeguard feature or send 2 STOP conditions. Only one STOP condition is taken into account by the receiver state machine. After this STOP condition, as there is no valid data the receiver state machine will go into idle mode and enable the RXBRK condition.	 	43.1.17.3 USART: RXBRK Flag Error in Asynchronous Mode	Not fixed	 	Atmel
SAM9260	When Hardware Handshaking is used and if CTS goes low near the end of the starting bit of the transmitter, a character is lost.	ARM9	 	UHP	 	CTS must not go low during a time slot comprised between 2 Master Clock periods before the rising edge of the starting bit and 16 Master Clock periods after the rising edge of the starting bit.	 	43.1.17.4 USART: CTS Signal in Hardware Handshake	Not fixed	 	Atmel
SAM9260	1. Setting the receiver to hardware handshaking mode drops RTS line to low level even if the receiver is still turned off. USART needs to be completely configured and started before setting the receiver to hardware handshaking mode. 2. Disabling the receiver during a PDC transfer while RXBUFF ï¬ag is '0' has no effect on RTS. The only way to get the RTS line to rise to high level is to reset both PDMA buffers by writing the value '0' in both counter registers.	ARM9	 	UHP	 	None.	 	43.1.17.5 USART: RTS Not Expected Behavior	Not fixed	 	Atmel
SAM9260	If CTS rises to 1 during a character transmit, the Transmit Holding Register is also transmitted if not empty.	ARM9	 	UHP	 	None. 800 SAM9260 [DATASHEET] AtmeL Almel-6221 M-ATARM-SAMQZSO-DatasheetJ 3-Jan-16 43.1.18 Power Management Controller (PMC)	 	43.1.17.6 USART: Two Characters Sent if CTS Rises During Emission	Not fixed	 	Atmel
SAM9260	If MDIV and another ï¬eld (088 or PRES) are changed at the same, clock frequency may not be correct.	ARM9	 	Power Management Controller (PMC)	 	For each clock switching user must take care to: 0 change ï¬elds CSS, MDIV, PRES one by one o wait MCKRDY bit setting in PMC_SR before changing PMC_MCKR 0 ensure each transitory frequency value is in operational range for PCK and MCK AtmeL SAM9260 [DATASHEET] 801 AtmeIâ6221M-ATARM-SAMQZSO-Datasheet_13âJan-16 43.2 SAM9260 Errata - Revision âBâ Parts Refer to Section 43.1 âSAM9260 Errata - Revision âAâ Partsâ on page 790. 43.2.1 Analog-to-digital Converter (ADC)	 	43.1.18.1 PMC: PMC bad frequency after MDIV switching	Not fixed	 	Atmel
SAM9260	The DRDY Flag should be clear only after a read of ADC_LCDR (Last Converted Data Register). A read of any ADC_CDRx (Channel Data Register) automatically clears the DRDY ï¬ag.	ARM9	 	Analog-to-digital Converter (ADC)	 	None	 	43.2.1.1 ADC: DRDY Bit Cleared	Not fixed	 	Atmel
SAM9260	When reading LCDR at the same instant as an end of conversion, with DRDY already active, DRDY is kept active regardless of the enable status of the current channel. This sets DRDY, whereas new data is not stored.	ARM9	 	Analog-to-digital Converter (ADC)	 	None	 	43.2.1.2 ADC: DRDY not Cleared on Disable	Not fixed	 	Atmel
SAM9260	"Reading CDR for channel y at the same instant as an end of conversion on channel âx"" with EOC[x] already active, leads to skipping to set the DRDY ï¬ag if channel x is enabled."	ARM9	 	Analog-to-digital Converter (ADC)	 	Use of DRDY functionality with access to CDR registers should be avoided.	 	43.2.1.3 ADC: DRDY Possibly Skipped due to CDR Read	Not fixed	 	Atmel
SAM9260	"DRDY does not rise when disabling channel y at the same time as an end of âx"" channel conversion, although data is stored into CDRx and LCDR."	ARM9	 	Analog-to-digital Converter (ADC)	 	None.	 	43.2.1.4 ADC: Possible Skip on DRDY when Disabling a Channel	Not fixed	 	Atmel
SAM9260	Read of the Status Register at the same instant as an end of conversion leads to skipping the update of the GOVRE (general overrun) ï¬ag. GOVRE is neither reset nor set. For example, if reading the status while an end of conversion is occurring and: 1. GOVRE is active but DRDY is inactive, does not correspond to a new general overrun condition but the GOVRE ï¬ag is not reset. 2. GOVRE is inactive but DRDY is active, does correspond to a new general overrun condition but the GOVRE ï¬ag is not set.	ARM9	 	Analog-to-digital Converter (ADC)	 	None	 	43.2.1.5 ADC: GOVRE Bit is Not Updated	Not fixed	 	Atmel
SAM9260	"When reading CDRy (Channel Data Register y) at the same instant as an end of conversion on channel x with the following conditions: EOC[x] already active, 0 DRDY already active, 0 GOVRE inactive, 0 previous data stored in LCDR being neither data from channel â"",y nor data from channel ""xâ. 802 SAM9260 [DATASHEET] At m eL Almel-6221 M-ATARM-SAMQZSO-Datasheet_13-Jan-16 GOVRE should be set but is not."	ARM9	 	Analog-to-digital Converter (ADC)	 	None	 	43.2.1.6 ADC: GOVRE Bit is Not Set when Reading CDR	Not fixed	 	Atmel
SAM9260	"When disabling channel ây"" at the same instant as an end of conversion on channel âx"", EOC[x] and DRDY being already active, GOVRE does not rise. Note: OVRE[x] rises as expected."	ARM9	 	Analog-to-digital Converter (ADC)	 	None	 	43.2.1.7 ADC: GOVRE Bit is Not Set when Disabling a Channel	Not fixed	 	Atmel
SAM9260	When the OVRE ï¬ag (on channel i) has been set but the related EOC status (of channel i) has been cleared (by a read of CDRi or LCDR), reading the Status register at the same instant as an end of conversion (causing the set of EOC status on channel i), does not lead to a reset of the OVRE ï¬ag (on channel i) as expected.	ARM9	 	Analog-to-digital Converter (ADC)	 	None	 	43.2.1.8 ADC: OVRE Flag Behavior	Not fixed	 	Atmel
SAM9260	If a channel is disabled while a conversion is running and if a read of CDR is performed at the same time as an end of conversion of any channel occurs, the EOC of the channel with the conversion running may rise (whereas it has been disabled).	ARM9	 	Analog-to-digital Converter (ADC)	 	Do not take into account the EOC of a disabled channel	 	43.2.1.9 ADC: EOC Set Although Channel Disabled	Not fixed	 	Atmel
SAM9260	"If âx"" and ""y"" are two successively converted channels and âz"" is yet another enabled channel (â2"" being neither âx"" nor ây""), reading CDR on channel â2â at the same instant as an end of conversion on channel âyâ automatically clears EOC[x] instead of EOC[z]."	ARM9	 	Analog-to-digital Converter (ADC)	 	None.	 	43.2.1.10 ADC: Spurious Clear of EOC Flag	Not fixed	 	Atmel
SAM9260	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	ARM9	 	Analog-to-digital Converter (ADC)	 	To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit ï¬eld); to start an analog-toâdigital conversion, in order put ADC into sleep mode at the end of this conversion. 43.2.2 Bus Matrix	 	43.2.1.11 ADc: Sleep Mode	Not fixed	 	Atmel
SAM9260	MATRIX_MCFG5 is write-only. The value written is effective but not readable.	ARM9	 	Bus Matrix	 	None. AtmeL SAM9260 [DATASHEET] 803 AtmeIâ6221M-ATARM-SAMQZSO-Datasheet_13âJan-16 43.2.3 EMAC	 	43.2.2.1 Bus Matrix Master Conï¬guration Register 5	Not fixed	 	Atmel
SAM9260	"EMACB FIFO internal arbitration scheme is: 1. PIPE-9!â 6. Receive buffer manager write Receive buffer manager read Transmit data DMA read Receive data DMA write Transmit buffer manager read Transmit buffer manager write EMACB master interface releases the AHB bus between two transfers. EMACB has the highest priority. If EMACB RX and TX FIFOs both have pending requests, the following sequence occurs: 1. 9391??!"" EMACB RX FIFO write (burst 4) EMACB releases the AHB bus The AHB matrix can grant an another master (ARM I or D for example) AHB matrix re-arbitration (finishes at least the current word/halfword/byte) The AHB matrix grants the EMACB The EMACB TX FIFO read (burst 4) In case of a slow memory and/or a special operation like SDRAM refresh or SDRAM bank opening, a TX underrun may occur. (latency min 960 ns)."	ARM9	 	EMAC	 	Reduce re-arbitration time between RX & TX EMACB transfers by using internal SRAM (or another memory slave with a short access time) to transmit buffers and descriptors. 43.2.4 IIO Considerations	 	43.2.3.1 EMAC: TX Underrun May Occur in Some Cases	Not fixed	 	Atmel
SAM9260	The I/O output buffer drive is too high to guarantee the timings. This is applicable to the External Bus Interface signals and to the peripheral I/Os. This leads to fast rise and fall time when the signals change, causing high currents to be drawn on the power supply pins and leads to emission of high frequencies. This may affect the operation of the device and may result in the emission of radio-frequency signals, making EMC certiï¬cation difï¬cult.	ARM9	 	IIO Considerations	 	It is strongly recommended: to place the memories connected to the EBI as close as possible to the SAM9260 on the PCB to route all the EBI signals with a series resistor, typical value 33 ohms to adjust the series resistor value with tools taking into account the IBIS model of the pads and the characteristics of the wires of the PCB, in order to guarantee rise and fall times as long as timings permit. 804 SAM9260 [DATASHEET] AtmeL Almel-6221 M-ATARM-SAMQZSO-Datasheet_13-Jan-16 43.2.5 MCI	 	43.2.4.1 IIO High Drive Strength	Not fixed	 	Atmel
SAM9260	The busy status of the card during the response (R1 b) is ignored for the commands CMD7, CMD28, CMD29, CMD38, CMD42, CMD56. Additionally, for commands CMD42 and CMD56 a conï¬ict can occur on data Iine0 if the MCI sends data to the card while the card is still busy. The behavior is correct for CMD12 command (STOP_TRANSFER).	ARM9	 	MCI	 	None	 	43.2.5.1 MCI: Busy Signal of R15 Responses is Not Taken in Account	Not fixed	 	Atmel
SAM9260	If the data bus width is 1 bit and slots other than slot A chosen, the SDIO interrupt can not be captured. The sample is made on the bad data line.	ARM9	 	MCI	 	None	 	43.2.5.2 MCI: SDIO Interrupt Does Not Work for Slot Different from A	Not fixed	 	Atmel
SAM9260	As the data Timeout error ï¬ag checking the Naac timing cannot rise, the MCI can be stalled waiting indeï¬nitely the Data start bit.	ARM9	 	MCI	 	A STOP command must be sent with a software timeout.	 	43.2.5.3 MCI: Data Timeout Error Flag	Not fixed	 	Atmel
SAM9260	The Data Write operation with a number of bytes less than 12 is impossible.	ARM9	 	MCI	 	The PDC counters must always be equal to 12 bytes for data transfers lower than 12 bytes. The BLKLEN or BCNT field are used to specify the real count number.	 	43.2.5.4 MCI: Data Write Operation and Number of Bytes	Not fixed	 	Atmel
SAM9260	In half duplex mode, the reset of the ï¬ags ENDRX, RXBUFF, ENDTX and TXBUFE can be incorrect. These ï¬ags are reset correctly after a PDC channel enable.	ARM9	 	MCI	 	Enable the interrupts related to ENDRX, ENDTX, RXBUFF and TXBUFE only after enabling the PDC channel by writing PDC_TXTEN or PDC_RXTEN. 43.2.6 SDRAM Controller	 	43.2.5.5 MCI: Flag Reset is Not Correct in Half Duplex Mode	Not fixed	 	Atmel
SAM9260	After a reset, the SDRAM clock is always active leading to over consumption in the pad.	ARM9	 	SDRAM Controller	 	The following sequence stops the SDRAM clock. 1. Set the bit LPCB in the SDRAMC Low Power Register. 2. Write 0 in the SDRAMC Mode Register and perform a dummy write in SDRAM to complete.	 	43.2.6.1 SDCLK Clock Active After Reset	Not fixed	 	Atmel
SAM9260	Using Mobile SDRAM devices that need to have their DQMx level HIGH during Mobile SDRAM device initialization may lead to data bus contention and thus external memories on the same EBI must not be accessed. AtmeL SAM9260 [DATASHEET] 805 AtmeIâ6221M-ATARM-SAMQZSO-Datasheet_13âJan-16 This does not apply to Mobile SDRAM devices whose DQMx level is âDonât careâ during this phase.	ARM9	 	SDRAM Controller	 	Mobile SDRAM initialization must be performed in internal SRAM. 43.2.7 Reset Controller (RSTC)	 	43.2.6.2 Mobile SDRAM Device Initialization Constraint	Not fixed	 	Atmel
SAM9260	When a user reset, watchdog reset, or software reset occurs during SDRAM read access, the SDRAM clock is turned off while data is ready to be read on the data bus. The SDRAM maintains the data until the clock restarts. If the user reset, watchdog reset, or software reset is programmed to assert a general reset, the data maintained by the SDRAM leads to a data bus conï¬ict and adversely affects the boot memories connected on the EBI: o NAND Flash boot functionality, if the system boots out of internal ROM. 0 NOR Flash boot, if the system boots on an external memory connected on the EBI CSO.	ARM9	 	Reset Controller (RSTC)	 	1. Avoid user reset, watchdog reset, software reset to generate a system reset. 2. Trap the user reset, watchdog reset, software reset with an interrupt. In the interrupt routine, power down the SDRAM properly and perform Peripheral and Processor Reset with software in assembler. Example with IibV3. o The main code: //user reset interrupt setting // Configure AIC controller to handle System peripheral interrupts AT9lF_AIC_ConfigureIt ( AT91C_BASE_AIC, // AIC base address AT91C_ID_SYS, // System peripheral ID AT91C_AIC_PRIOR_HIGHEST, // Max priority AT91C_AIC_SRCTYPE_INT_EDGE_TRIGGERED, // Level sensitive sysc_handler ); // Enable SYSC interrupt in AIC AT91F_AIC_EnableIt (AT91C_BASE_AIC, AT91C_ID_SYS) ; *AT91C_RSTC_RMR = (0xA5<<24) | (Ox4<<8) | AT91C_RSTC_URSTIEN; o The C SYS handler: extern void soft_user_reset(void); void sysc_handler(void){ //check if interrupt comes from RSTC if( (*AT91C_RSTC_RSR & AT91C_RSTC_URSTS ) == AT91C_RSTC_URSTS){ soft_user_reset(); //never reached while(l); } l 0 Assembly code is mandatory for the following sequence as ARM instructions need to be pipelined. The assembler routine: AREA TEST, CODE 806 SAM9260 [DATASHEET] AImeI-6221M-ATARM-SAMQZSO-DatasheetJ3-Jan-16 A t meL INCLUDE ATQlSAM9xxx.inc EXPORTsoft_user_reset soft_user_reset ;disable IRQs MRS r0, CPSR ORR r0, r0, #0x80 MSR CPSR_c, r0 ;change refresh rate to block all data accesses LDR r0, =AT91C_SDRAMC_TR LDR rl, =1 STR rl, [r0] ;prepare power down command LDR r0, =AT91C_SDRAMC_LPR LDR rl, =2 ;prepare proc_reset and periph_reset LDR r2 , =AT91C_RSTC_RCR LDR r3, =0xA5000005 ;perform power down command STR rl, [r0] ;perform proc_reset and periph_reset (in the ARM pipeline) STR r3, [r2] END 43.2.8 Serial Peripheral Interface (SPI)	 	43.2.7.1 RSTC: Reset during SDRAM Accesses	Not fixed	 	Atmel
SAM9260	If the SPI is used in the following conï¬guration: 0 Master mode 0 CPOL = 1 and NCPHA = 0 0 multiple chip selects used with one transfer with baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR not equal to 1 o transmit with the slowest chip select and then with the fastest one then an additional pulse will be generated on output PSCK during the second transfer.	ARM9	 	Serial Peripheral Interface (SPI)	 	Do not use a multiple Chip Select conï¬guration where at least one SPI_CSRx register is conï¬gured with SCBR = 1 and the others differ from 1 if CPHA = 0 and CPOL = 1. If all chip selects are conï¬gured with SCBR = 1, the issue does not appear.	 	43.2.8.1 SPI: Bad Serial Clock Generation on Second chip_select when SCBR = 1, CPOL =1 and NCPHA = 0	Not fixed	 	Atmel
SAM9260	When baud rate is set to 1 (i.e., when serial clock frequency equals the system clock frequency), and when the fields BITS (number of bits to be transmitted) equals an ODD value (in this case 9, 11, 13 or 15), an additional pulse is generated on output SPCK. No error occurs if BITS ï¬eld equals 8, 10, 12, 14 or 16 and SCBR = 1.	ARM9	 	Serial Peripheral Interface (SPI)	 	None. AtmeL SAM9260 [DATASHEET] 807 AtmeIâ6221M-ATARM-SAMQZSO-Datasheet_13âJan-16 43.2.9 Serial Synchronous Controller (SSC)	 	43.2.8.2 SPI: Baud Rate Set to 1	Not fixed	 	Atmel
SAM9260	When the SSC receiver is used in the following conï¬guration: 0 the internal clock divider is used (CKS = 0 and DIV different from 0), o RK pin set as output and provides the clock during data transfer (CKO = 2) 0 data sampled on RK falling edge (CKI = 0) then, at the end of the data, the RK pin is set in high impedance which may be interpreted as an unexpected clock cycle.	ARM9	 	Serial Synchronous Controller (SSC)	 	Enable the pull-up on RK pin.	 	43.2.9.1 SSC: Unexpected RK Clock Cycle when RK Outputs a Clock During Data Transfer	Not fixed	 	Atmel
SAM9260	When the SSC receiver is used in the following conï¬guration: 0 RX clock is divided clock (CKS = 0 and DIV different from 0) o RK pin set as output and provides the clock during data transfer (CKO = 2) 0 data sampled on RK falling edge (CKI = 0) then the ï¬rst clock cycle time generated by the RK pin is equal to MCK/(2 >< (DIV + 1)) instead of MCK/(2 >< DIV).	ARM9	 	Serial Synchronous Controller (SSC)	 	None.	 	43.2.9.2 SSC: Incorrect First RK Clock Cycle when RK Outputs a Clock During Data Transfer	Not fixed	 	Atmel
SAM9260	If TK is programmed as output and TF is programmed as input, it is impossible to emit data when start of edge (rising or falling) of synchro has a Start Delay equal to zero.	ARM9	 	Serial Synchronous Controller (SSC)	 	None.	 	43.2.9.3 SSC: Transmitter Limitations in Slave Mode	Not fixed	 	Atmel
SAM9260	If Least Significant Bit is sent ï¬rst (MSBF = 0) the ï¬rst TAG during the frame synchro is not sent.	ARM9	 	Serial Synchronous Controller (SSC)	 	None. 43.2.10 Shutdown Controller (SHDWC)	 	43.2.9.4 SSC: Periodic Transmission Limitations in Master Mode	Not fixed	 	Atmel
SAM9260	If only VDDBU is powered during boot sequence (No VDDCORE), the SHDN signal may be driven to low level voltage after a delay. This delay is linked to the startup time of the slow clock selected by OSCSEL signal. If SHDN pin is connected to the Enable pin (EN) of the VDDCORE regulator, VDDCORE establishment does not occur and the system does not start.	ARM9	 	Shutdown Controller (SHDWC)	 	1. VDDCORE must be established within the delay corresponding to the startup time of the slow clock selected by OSCSEL. 2. Add a glue logic to latch the rising edge of the SHDN signal. The reset of the latch output (EN_REG) can be connected to a PIO and used to enter the shutdown mode. 808 SAM9260 [DATASHEET] AtmeL AImeI-6221 M-ATARM-SAMQZSO-Datasheet_13-Jan-16 43.2.11 System Controller	 	43.2.10.1 SHDWC: SHDN Signal may be Driven to Low Level Voltage During Device Power-on	Not fixed	 	Atmel
SAM9260	If an event (RTTINC or ALMS) occurs within the same slow clock cycle as when the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	ARM9	 	System Controller	 	The software must handle an RTT event as an interrupt and should not poll RTT_SR. 43.2.12 Two-wire Interface (TWI)	 	43.2.11.1 Possible Event Loss when Reading R1T_SR	Not fixed	 	Atmel
SAM9260	At the end of transfer in slave mode, the slave mode is disabled, the master mode is enabled and thus a transfer in master mode can be performed. In the current device, the start event is correctly generated but the SCL line is stuck at 1, so no transfer is possible.	ARM9	 	Two-wire Interface (TWI)	 	Two workarounds are possible: 1. Perform a software reset before going to master mode (TWI must be reconï¬gured). or 2. Perform a slave read access before switching to master mode. 43.2.13 UHP	 	43.2.12.1 TWI: Switch from Slave to Master Mode	Not fixed	 	Atmel
SAM9260	Conditions: Consider the following sequence: 1. The Host controller issues an IN token. 2 The Device provides the IN data in a short packet. 3. The Host controller writes the received data to the system memory. 4 The Host controller is now supposed to carry out two Write transactions (TD status write and TD retirement write) to the system memory in order to complete the status update. 5. The Host controller raises the request for the ï¬rst write transaction. By the time the transaction is completed, a frame boundary is crossed. 6. After completing the first write transaction, the Host controller skips the second write transaction. Consequence: When this error occurs, the Host controller tries the same IN token again.	ARM9	 	UHP	 	This problem can be avoided if the system guarantees that the status update can be completed within the same frame.	 	43.2.13.1 UHP: Non-ISO IN Transfers	Not fixed	 	Atmel
SAM9260	Conditions: Consider the following sequence: 1. The Host controller sends an ISO OUT token after fetching 16 bytes of data from the system memory. 2. When the Host controller is sending the ISO OUT data, because of system latencies, remaining bytes of the packet are not available. This results in a buffer underrun condition. 3. While there is an underrun condition, if the Host controller is in the process of bit-stufï¬ng, it causes the Host controller to hang. AtmeL SAM9260 [DATASHEET] 809 AtmeIâ6221M-ATARM-SAMQZSO-Datasheet_13âJan-16 Consequence: After the failure condition, the Host controller stops sending the SOF. This causes the connected device to go into suspend state.	ARM9	 	UHP	 	This problem can be avoided if the system can guarantee that no buffer underrun occurs during the transfer.	 	43.2.13.2 UHP: ISO OUT Transfers	Not fixed	 	Atmel
SAM9260	Conditions: When a Remote Wakeup event occurs on a downstream port, the OHCI Host controller begins sending resume signaling to the device. The Host controller is supposed to send this resume signaling for 20 ms. However, if the driver sets the HcControl.HCFS into USBOPERATIONAL state during the resume event, then the Host controller terminates sending the resume signal with an EOP to the device. Consequence: If the Device does not recognize the resume (< 20 ms) event, then the Device remains in suspend state.	ARM9	 	UHP	 	Host stack can do a port resume after it sets the HcControl.HCFS to USBOPERATIONAL. 43.2.14 USART	 	43.2.13.3 UHP: Remote Wakeup Event	Not fixed	 	Atmel
SAM9260	TXD signal should be pulled up in Modern and Hardware Handshaking mode.	ARM9	 	USART	 	TXD is multiplexed with PIO which integrates a pull up resistor. This internal pull-up must be enabled.	 	43.2.14.1 USART: TXD Signal is ï¬oating in Modern and Hardware Handshaking Mode.	Not fixed	 	Atmel
SAM9260	The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	ARM9	 	USART	 	Add an inverter.	 	43.2.14.2 USART: DCD is Active High instead of Low	Not fixed	 	Atmel
SAM9260	In receiver mode, when two characters are consecutive (without timeguard in between) the RXBRK is not taken into account. As a result the RXBRK ï¬ag is not enabled correctly and the frame error flag is set.	ARM9	 	USART	 	Constraints on the transmitter device connected to the SAM9260 USART receiver side. The transmitter may use the timeguard feature or send 2 STOP conditions. Only one STOP condition is taken into account by the receiver state machine. After this STOP condition, as there is no valid data the receiver state machine will go into idle mode and enable the RXBRK condition.	 	43.2.14.3 USART: RXBRK Flag Error in Asynchronous Mode	Not fixed	 	Atmel
SAM9260	1. Setting the receiver to hardware handshaking mode drops RTS line to low level even if the receiver is still turned off. USART needs to be completely conï¬gured and started before setting the receiver to hardware handshaking mode. 2. Disabling the receiver during a PDC transfer while RXBUFF ï¬ag is '0' has no effect on RTS. The only way to get the RTS line to rise to high level is to reset both PDMA buffers by writing the value '0' in both counter registers.	ARM9	 	USART	 	None. 810 SAM9260 [DATASHEET] AtmeL AImeI-6221 M-ATARM-SAMQZSO-Datasheet_13-Jan-16 43.2.15 Power Management Controller (PMC)	 	43.2.14.4 USART: RTS not Expected Behavior	Not fixed	 	Atmel
SAM9G20	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	ARM9	 	Analog-to-digital Converter (ADC)	 	To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit field); to start an analog-to-digi- tal conversion, in order put ADC into sleep mode at the end of this conversion. 44.2.2 MCI	 	44.2.1.1 ADC: Sleep Mode	Not fixed	 	Atmel
SAM9G20	The busy status of the card during the response (R1 b) is ignored for the commands CMD7, CMD28, CMD29, CMD38, CMD42, CMD56. Additionally, for commands CMD42 and CMD56 a conflict can occur on data lineO if the MCI sends data to the card while the card is still busy.The behavior is correct for CMD12 command (STOP_TRANSFER).	ARM9	 	MCI	 	None.	 	44.2.2.1 MCI: Busy Signal of R1b responses is not taken in account	Not fixed	 	Atmel
SAM9G20	If 1-bit data bus width and on other slots than slot A, the SDIO interrupt can not be captured. The sample is made on the bad data line.	ARM9	 	MCI	 	None	 	44.2.2.2 MCI: SDIO Interrupt does not work for slot different from A	Not fixed	 	Atmel
SAM9G20	As the data Timeout error flag checking the Naac timing cannot rise, the MCI can be stalled wait- ing indefinitely the Data start bit.	ARM9	 	MCI	 	A STOP command must be sent with a software timeout.	 	44.2.2.3 MCI: Data Timeout Error Flag	Not fixed	 	Atmel
SAM9G20	The Data Write operation with a number of bytes less than 12 is impossible.	ARM9	 	MCI	 	The PDC counters must always be equal to 12 bytes for data transfers lower than 12 bytes. The BLKLEN or BCNT field are used to specify the real count number.	 	44.2.2.4 MCI: Data Write Operation and number of bytes	Not fixed	 	Atmel
SAM9G20	In half duplex mode, the reset of the flags ENDRX, RXBUFF, ENDTX and TXBUFE can be incorrect. These flags are reset correctly after a PDC channel enable.	ARM9	 	MCI	 	792 AT91SAM9G20 Preliminary â 6384AâATARMâ28-May-08 â AT91SAM9G20 Preliminary Enable the interrupts related to ENDRX, ENDTX, RXBUFF and TXBUFE only after enabling the PDC channel by writing PDC_TXTEN or PDC_RXT EN. 44.2.3 Reset Controller (RSTC)	 	44.2.2.5 MCI: Flag Reset is not correct in half duplex mode	Not fixed	 	Atmel
SAM9G20	When a User Reset occurs during SDRAM read access, the SDRAM clock is turned off while data are ready to be read on the data bus. The SDRAM maintains the data until the clock restarts. If the user Reset is programmed to assert a general reset, the data maintained by the SDRAM leads to a data bus conflict and adversely affects the boot memories connected on the EBI: . NAND Flash boot functionality, if the system boots out of internal ROM. . NOR Flash boot, if the system boots on an external memory connected on the EBI CSO.	ARM9	 	Reset Controller (RSTC)	 	1. Avoid User Reset to generate a system reset. 2. Trap the User Reset with an interrupt. In the interrupt routine, Power Down SDRAM properly and perform Peripheral and Processor Reset with software in assembler. Example with libV3. - The main code: //user reset interrupt setting // Configure AIC controller to handle SSC interrupts AT91F_AIC_ConfigureIt ( AT91C_BASE_AIC, // AIC base address AT91C_ID_SYS, // System peripheral ID AT91C_AIC_PRIOR_HIGHEST, // Max priority AT91C_AIC_SRCTYPE_INT_EDGE_TRIGGERED, // Level sensitive sysc_handler ); // Enable SYSC interrupt in AIC AT91F_AIC_EnableIt (AT91C_BASE_AIC, AT91C_ID_SYS) ,' *AT91C_RSTC_R.MR = (0xA5<<24) | (0x4<<8) | AT91C_RSTC_URSTIEN; 0 The C SYS handler: extern void soft_user_reset (void); void sysc_handler (void) { A IIIEI. 793   6384AâATARMâ28-May-08   E Â® //check if interrupt comes from RSTC if( (*AT91C_RSTC_RSR s: AT91C_RSTC_URSTS ) == AT91C_RSTC_U'RSTS){ soft_user_reset(); //never reached while(1); } - The assembler routine: AREA TEST, CODE INCLUDEATSlSAMSxxx. inc EXPORTsoft_user_reset soft_user_reset ;disable IRQs MRS r0, CPSR ORR r0, r0, #0x80 MSR CPSR_C, r0 ;change refresh rate to block all data accesses LDR r0, =AT9lC_SDRAMC_TR LDR r1, 1 STR r1, [r0] ;prepare power down command LDR r0, =AT91C_SDRAMC_LPR LDR r1, =2 ;prepare proc_reset and periph_reset LDR r2, =AT91C_RSTC_RCR LDR r3, =0xA5000005 ;perform power down command STR r1, [r0] ;perform proc_reset and periph_reset (in the ARM pipeline) STR r3 , [r2] END 44.2.4 Serial Peripheral Interface (SPI)	 	44.2.3.1 RSTC: Reset During SDRAM Accesses	Not fixed	 	Atmel
SAM9G20	If the SPI is used in the following configuration: - master mode 794 AT91SAM9G20 Preliminary â 6384AâATARMâ28-May-08 â AT91SAM9G20 Preliminary 0 CPOL =1 and NCPHA = O - multiple chip selects used with one transfer with Baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR not equal to 1 - transmit with the slowest chip select and then with the fastest one then an additional pulse will be generated on output PSCK during the second transfer.	ARM9	 	Serial Peripheral Interface (SPI)	 	Do not use a multiple Chip Select configuration where at least one SCRx register is configured with SCBR = 1 and the others differ from 1 it CPHA = 0 and CPOL = 1. If all chip selects are configured with Baudrate = 1, the issue does not appear.	 	44.2.4.1 SPI: Bad Serial Clock Generation on second chip_select when SCBR = 1, CPOL = 1 and NCPHA = 0	Not fixed	 	Atmel
SAM9G20	When Baudrate is set to 1 (i.e., when serial clock frequency equals the system clock frequency), and when the fields BITS (number of bits to be transmitted) equals an ODD value (in this case 9,11,13 or 15), an additional pulse is generated on output SPCK. No error occurs if BITS field equals 8,10,12,14 or 16 and Baudrate = 1.	ARM9	 	Serial Peripheral Interface (SPI)	 	None. 44.2.5 Serial Synchronous Controller (SSC)	 	44.2.4.2 SPI: Baudrate set to 1	Not fixed	 	Atmel
SAM9G20	When the SSC receiver is used in the following configuration: - the internal clock divider is used (CKS =0 and DIV different from 0), - RK pin set as output and provides the clock during data transfer (CKO=2) - data sampled on RK falling edge (CKI =0) then, at the end of the data, the RK pin is set in high impedance which may be interpreted as an unexpected clock cycle.	ARM9	 	Serial Synchronous Controller (SSC)	 	Enable the pull-up on RK pin.	 	44.2.5.1 SSC: Unexpected RK clock cycle when RK outputs a clock during data transfer	Not fixed	 	Atmel
SAM9G20	When the SSC receiver is used in the following configuration: 0 RX clock is divided clock (CKS = 0 and DIV different from 0) o RK pin set as output and provides the clock during data transfer (CKO = 2) - data sampled on RK falling edge (CKI = 0) then the first clock cycle time generated by the RK pin is equal to MCK/(2 x (DIV +1)) instead of MCK/(2 x DIV).	ARM9	 	Serial Synchronous Controller (SSC)	 	None.	 	44.2.5.2 SSC: Incorrect first Fl'K clock cycle when RK outputs a clock during data transfer	Not fixed	 	Atmel
SAM9G20	If TK is programmed as output and TF is programmed as input, it is impossible to emit data when start of edge (rising or falling) of synchro with a Start Delay equal to zero.   A IIIEI. 795 6384AâATARMâ28-May-08	ARM9	 	Serial Synchronous Controller (SSC)	 	None.	 	44.2.5.3 SSC: Transmitter Limitations in Slave Mode	Not fixed	 	Atmel
SAM9G20	If Last Significant Bit is sent first (MSBF = 0) the first TAG during the frame synchro is not sent.	ARM9	 	Serial Synchronous Controller (SSC)	 	None. 44.2.6 System Controller (SYSC)	 	44.2.5.4 SSC: Periodic Transmission Limitations in Master Mode	Not fixed	 	Atmel
SAM9G20	If an event (R'I'I'INC or ALMS) occurs within the same slow clock cycle as when the R'I'I'_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	ARM9	 	System Controller (SYSC)	 	The software must handle an R'I'I' event as an interrupt and should not poll RTI'_SR. 44.2.7 UHP	 	44.2.6.1 SYSC: Possible Event Loss when reading R'IT_SR	Not fixed	 	Atmel
SAM9G20	Conditions: Consider the following sequence: 1. The Host controller issues an IN token. 2 The Device provides the IN data in a short packet. 3. The Host controller writes the received data to the system memory. 4 The Host controller is now supposed to carry out two Write transactions (TD status write and TD retirement write) to the system memory in order to complete the status update. 5. The Host controller raises the request for the first write transaction. By the time the transaction is completed, a frame boundary is crossed. 6. After completing the first write transaction, the Host controller skips the second write transaction. Consequence: When this error occurs, the Host controller tries the same IN token again.	ARM9	 	UHP	 	This problem can be avoided if the system guarantees that the status update can be completed within the same frame.	 	44.2.7.1 UHP:Non-ISO IN Transfers	Not fixed	 	Atmel
SAM9G20	Conditions: Consider the following sequence: 1. The Host controller sends an ISO OUT token after fetching 16 bytes of data from the system memory. 2. When the Host controller is sending the ISO OUT data, because of system latencies, remaining bytes of the packet are not available. This results in a buffer underrun condition. 3. While there is an underrun condition, if the Host controller is in the process of bit-stuff- ing, it causes the Host controller to hang. 796 AT91SAM9G20 Preliminary â 6384AâATARMâ28-May-08 â AT91SAM9G20 Preliminary Consequence: After the failure condition, the Host controller stops sending the SOF. This causes the connected device to go into suspend state.	ARM9	 	UHP	 	This problem can be avoided if the system can guarantee that no buffer underrun occurs during the transfer.	 	44.2.7.2 UHP: ISO OUT transfers	Not fixed	 	Atmel
SAM9G20	Conditions: When a Remote Wakeup event occurs on a downstream port, the OHCI Host controller begins sending resume signaling to the device. The Host controller is supposed to send this resume signaling for 20 ms. However, if the driver sets the HcControl.HCFS into USBOPERATIONAL state during the resume event, then the Host controller terminates sending the resume signal with an EOP to the device. Consequence: If the Device does not recognize the resume (<20 ms) event then the Device remains in suspend state.	ARM9	 	UHP	 	Host stack can do a port resume after it sets the HcControl.HCFS to USBOPERATIONAL. 44.2.8 Two-wire Interface (TWI)	 	44.2.7.3 UHP: Remote Wakeup Event	Not fixed	 	Atmel
SAM9G20		ARM9	 	Two-wire Interface (TWI)	 	44.2.9 USART The RXRDY Flag is not reset when a Software reset is performed. Problem Fix/Workaround After a Software Reset, the Register TWI_RHR must be read.	 	44.2.8.1 TWI: RXRDY Flag is not reset by a SOFTWARE Reset	Not fixed	 	Atmel
AT91RM9200	A24 is not wired internally between the EBI and the PIO. Use only PIO mode on it.	ARM9	 	EBI	 	Due to this error, static memories over 16 Mbytes per chip select cannot be used. To interface 32-Mbyte memories and over, the user must use two memory chips connected on two different chip selects. 41.2 EMAC	 	41.1.1 A24 not wired internally between the EBI and the PIO	Not fixed	 	Atmel
AT91RM9200	A dead lock may appear when the Ethernet MAC attempts to store a new received valid frame while there are no more rx buffer descriptors. This appears only when the received frame length is not a multiple of 4 bytes. In this conï¬guration, even if the application enables new receive buffer descriptors, all packets will be rejected.	ARM9	 	EMAC	 	The software workaround is to disable and re-enable the receive function in the network function register ETH_CTL each time a buffer is not available (RBNA in the status register). ETH CTL &= ~0x00000004 ; ETH CTL |= 0x00000004 ; Note that an interrupt can be activated for the RBNA detection. Another workaround is to align the address of the receive buffer descriptor on a boundary of 16 Words (address Oxaaaa aaOO, Oxaaaa aa40, Oxaaaa aa80, ..... ) 41.3 MCI	 	41.2.1 Using Receive frames and buffers not word-aligned	Not fixed	 	Atmel
AT91RM9200	The data endianess is inverted when writing or reading to or from an MMC or SD card. If the MCI interface is exclusively used to read/write from/to a dedicated card the inversion is not visible (two inversions). Furthermore, if the card is shared with other systems then endianess will not match. This endianess inversion concerns only data sectors and not command and response.	ARM9	 	MCI	 	A software workaround consists of swapping the order of word bytes before writing and after reading.	 	41.3.1 Data Endianess inversion from the MCI to MMC or SD Card	Not fixed	 	Atmel
AT91RM9200	As the data timeout error ï¬ag cannot rise, the MCI is stalled indeï¬nitely waiting for the data start bit.	ARM9	 	MCI	 	A STOP command must be sent with a software timeout.	 	41.3.2 Data Timeout Error Flag	Not fixed	 	Atmel
AT91RM9200	The STREAM READ/WRITE commands are not supported by the MCI.	ARM9	 	MCI	 	None. 682 AT91RM9200 [DATASHEET] AtmeL Almel-1768J-ATARM-AT91 RM9200-Datasheet_03-Marâ1 G	 	41.3.3 STREAM command not supported	Not fixed	 	Atmel
AT91RM9200	The WRITE_MULTIPLE_BLOCK with a transfer size (PDC) not a multiple of the block length is not stopped by the STOP command.	ARM9	 	MCI	 	Choose an appropriate size for the block length.	 	41.3.4 STOP during a WRITE_MULTIPLE_BLOCK command	Not fixed	 	Atmel
AT91RM9200	The DTIP ï¬ag is not reset if STOP_COMMAND is received in the middle of a block data transfer.	ARM9	 	MCI	 	None.	 	41.3.5 DTIP flag	Not fixed	 	Atmel
AT91RM9200	A STOP command with SYNCHRONISED special command is sent after the block data transfer ends. During this time the MMCI receives data but the RXRDY ï¬ag is no longer asserted.	ARM9	 	MCI	 	Do not send a STOP command with SYNCHRONISED special command.	 	41.3.6 STOP command with SYNCHRONISED special command	Not fixed	 	Atmel
AT91RM9200	Do not read/write the Data FIFO if RXRDY/TXRDY status bits are not set.	ARM9	 	MCI	 	None.	 	41.3.7 Data FIFO and status bits	Not fixed	 	Atmel
AT91RM9200	The shared FIFO is reset at the beginning of a transfer command.	ARM9	 	MCI	 	So as to avoid losing data, it is mandatory to enable the PDC channel after writing to the command register. In order to achieve this sequence correctly, it is mandatory to disable all IT sources.	 	41.3.8 DATA FIFO problem with PDC	Not fixed	 	Atmel
AT91RM9200	The DATA_CRC_ERR (error ï¬ag) never rises during the checking of bad data CRC status sent by MMC/SD card after block writing.	ARM9	 	MCI	 	CRC must be done by software.	 	41.3.9 DATA_CRC_ERR ï¬ag never rises	Not fixed	 	Atmel
AT91RM9200	If the user sends a READ_MULT|PLE_BLOCK command and stops it by using a STOP_COMMAND in the middle of a data block transfer then the internal state of the MMCI controller stops in a bad state.After that the following read block (with READ_SINGLE_BLOCK or READ_MULT|PLE_BLOCK) will be entirely corrupted.	ARM9	 	MCI	 	It consists in doing a software reset if RXRDY = 1 after the STOP_COMMAND. This ï¬ag indicates that the MMCI receives more data than the PDC has been settle to transfer. After this soft reset the MCI_CR, MCI_MR, MCI_DTOR, MCI_SDCR need to be reassigned. At m eL AT91RM9200 [DATASHEET] 683 Atmel-1768J-ATARM-ATQ1 RM9200-Damsheet_03-Mar-16	 	41.3.10 STOP during a READ_MULT|PLE_BLOCK command	Not fixed	 	Atmel
AT91RM9200	The Data Write operation with a number of bytes less than 12 is impossible.	ARM9	 	MCI	 	The PDC counters must always be equal to 12 bytes for data transfers lower than 12 bytes. The BLKLEN or BCNT ï¬eld are used to specify the real count number. 41.4 PIO	 	41.3.11 Data write operation and number of bytes	Not fixed	 	Atmel
AT91RM9200	NWAIT activity depends on use of P06. The P06 line multiplexes with the NWAIT function. As the PIO Controller is transparent in input, the level on the P06 line has direct impact on the behavior of the EBI. In particular, driving the P06 line to 0 might lead to a deadlock of the system.	ARM9	 	PIO	 	Use P06 carefully. In general, it is recommended to not use P06 and to make sure the pull-up is enabled.	 	41.4.1 NWAIT activity depends on use of P06	Not fixed	 	Atmel
AT91RM9200	The programming of the register P|O_OWSR has no effect on the read/write features of PIO_ODSR, which is always read/write accessible.	ARM9	 	PIO	 	None. 41.5 PMC	 	41.4.2 Output Data Status Register is always Readerite	Not fixed	 	Atmel
AT91RM9200	The PMC_MCKR register must not be programmed in a single write operation.	ARM9	 	PMC	 	The preferred programming sequence for the PMC_MCKR register is as follows: 1. Program the 088 ï¬eld in the PMC_MCKR. 2. Wait for the MCKRDY bit to be set in the PMC_SR register. 3. Program the PRES ï¬eld (in the PMC_MCKR). An exception to this sequence occurs when the processor clock frequency is greater than the master clock frequency. In this case, the PRES ï¬eld should be written first.	 	41.5.1 Constraints on the Master Clock selection sequence	Not fixed	 	Atmel
AT91RM9200	When re-programming the Master Clock Register, if both ï¬elds PRES and 083 are written with the same values as the ones already stored, or if both ï¬elds are written with different values than the ones already stored, the status bit MCKRDY does not rise. When one and only one of the ï¬elds PRES and CSS is changed, the MCKRDY bit operates normally.	ARM9	 	PMC	 	If both ï¬elds must be re-programmed, carry out the change in two steps.	 	41.5.2 MCKRDY does not rise in some cases	Not fixed	 	Atmel
AT91RM9200	When the fields MUL and DIV in the CKGR_PLLBR register are written with the same values as already programmed, the Master Clock signal switches to Main Clock (output of the Main Oscillator) until a different value is programmed in the register. AT91RM9200 [DATASHEET] AtmeL Almel-1768J-ATARM-AT91 RM9200-Datasheet_03-Marâ1 G When the fields MUL and DIV in the CKGR_PLLAR register are written with the same values as already programmed, the Master Clock signal switches to Slow Clock (output of the 32.768 kHz Oscillator) until a different value is programmed in the register.	ARM9	 	PMC	 	The user must be sure that either the DIV or MUL ï¬eld changes when setting the CKGR_PLLBR or CKGR_PLLAR register. 684	 	41.5.3 PMC, Clock Generator: Bad switching when writing PLL registers with same MUL and DIV values	Not fixed	 	Atmel
AT91RM9200	With PLLA, it is not possible to have an MCKRDY ï¬ag raised.	ARM9	 	PMC	 	Even if MCKRDY ï¬ag does not raise with PLLA, it will not prevent you from switching on it. You just need to wait for the PLLA lock time; for that program, PLLA then PLLB. When PLLB is ready, PLLA is ready too. Main Oscillator in Bypass Mode: CKGR_MOR = 0x00000002 PLLA programming: CKGR_PLLAR = 0x20063E01 PLLB programming: CKGR_PLLBR = 0x10173F05 Wait PLLB LOCKB bit: PMC_SR will be 0x00000000 Switch on PLLACK clock: PMC_MCKR -> 0x00000102 PMC_SR will be 0x00000000 41.6 ROM Bootloader ROM Bootloader: Limitation with 8-bit parallel memories. Limitation with 8-bit parallel memories. In the internal Boot ROM program, version 1.0, the wait state number on 080 is set to 0 during Boot ROM initialization. This gives an access time of 20 ns at 48 MHz Master Clock Frequency. This limitation of the ROM Bootloader applies to AT91RM9200 with the product number 58A07F. Problem Fix/Workaround None. 41.7 SDRAMC	 	41.5.4 OSCBYPASS is not functional with PLLA	Not fixed	 	Atmel
AT91RM9200	The Interrupt Mask Register in the SDRAM Controller is not read-only. Thus, writing to it modifies the contents instead of having no effect.	ARM9	 	SDRAMC	 	None.	 	41.7.1 SDRC_IMR can be written	Not fixed	 	Atmel
AT91RM9200	In the case of SDRAM devices featuring two internal banks, when the physical address is higher than the memory size, the SDRAM controller does not wrap around. It activates virtual bank numbers three or four.	ARM9	 	SDRAMC	 	None. At m eL AT91RM9200 [DATASHEET] 685 Atmel-1768J-ATARM-ATQ1 RM9200-Damsheet_03-Mar-16	 	41.7.2 No wrap-around for SDRAM devices with two internal banks	Not fixed	 	Atmel
AT91RM9200	When low-power mode is enabled and after a refresh command is sent to the SDRAM, the SDRAM Controller enters low-power mode by asserting SDCKE low. The tRc timing between Auto-refresh and Low-power mode is not respected. As SDCKE is low, the INHIBIT and NOP commands are not sent to the SDRAM. For the moment this warning has no effect on the correct functionality of the SDRAM.	ARM9	 	SDRAMC	 	None.	 	41.7.3 No tRc after refresh when low-power mode is enabled	Not fixed	 	Atmel
AT91RM9200	The SDRAM controller does not support the following devices in 32-bit mode: 0 128 Mbit device: 32M*4bits: 4 banks/12 rows/11 columns 0 256 Mbit device: 64M*4bits: 4 banks/13 rows/11 columns	ARM9	 	SDRAMC	 	None.	 	41.7.4 Some devices are not supported	Not fixed	 	Atmel
AT91RM9200	Writing 0 to the Interrupt Enable Register or to the Interrupt Disable Register modifies the value of Interrupt Mask Register.	ARM9	 	SDRAMC	 	None. 41.8 SMC	 	41.7.5 Interrupt Disable Register	Not fixed	 	Atmel
AT91RM9200	The address bus is continuously driven with the address of the current access, even if it is an internal one.	ARM9	 	SMC	 	None.	 	41.8.1 Address Bus continuously active	Not fixed	 	Atmel
AT91RM9200	When at least two SMC_CSR registers are programmed as follows: â SMC_SCRx: With wait states (1 < NWS < 127), 16-bit data bus width, and byte write access (BAT ï¬eld set to 0) _ SMC_CSRy: With wait states (1 < NWS < 127), 16-bit data bus width, and byte select access (BAT field set to 1), the associated NCSx signal is not asserted for the write access.	ARM9	 	SMC	 	For registers programmed with wait states and 16-bit data bus width conï¬guration, the BAT ï¬elds in these registers must be programmed with the same value. 41.9 SPI	 	41.8.2 16-bit write access constraints	Not fixed	 	Atmel
AT91RM9200	If the SPI receives a frame followed by 8 bits of data, the user needs to mask the highest byte of the Receive Holding Register, as this data may be incorrect and not 0.	ARM9	 	SPI	 	AT91RM9200 [DATASHEET] AtmeL Almel-1768J-ATARM-AT91 RM9200-Datasheet_03-Marâ1 G The user should implement the PDC. If the PDC is not implemented, the user should mask the highest byte of the Receive Holding register. 686	 	41.9.1 Slave Mode Receiver does not mask the highest data bits	Not fixed	 	Atmel
AT91RM9200	If the SPI is programmed in Master Mode and in Fixed Peripheral Mode, and data is being sent to a slave, the user has to wait for completion of the transfer before changing the slave number. Programming a new slave number (PCS) and/or a new DLYBCS ï¬eld locks the SPI on the current slave.	ARM9	 	SPI	 	The user should use the Variable Peripheral Mode.	 	41.9.2 No chip select configuration change before end of current transfer	Not fixed	 	Atmel
AT91RM9200	If the SPI has sent all the data written in the SPI_TDR, the current NPCS rises immediately. This might be inconvenient in the case of several SPI peripherals requiring their chip select line to remain active until a complete data buffer has been transmitted. The PDC channel may be late in providing data to be transmitted when bus latencies are too high.	ARM9	 	SPI	 	For high-speed applications, the relevant PIO pins can be used to manage the data transmission.	 	41.9.3 NPCSx rises if no data is to be transmitted	Not fixed	 	Atmel
AT91RM9200	If Mode fault is disabled, Chip Select 0 cannot be driven by a component other than the SPI otherwise the transfer does not occur.	ARM9	 	SPI	 	None. 41.10 SSC	 	41.9.4 Mode Fault does not allow more than one Master on Chip Select 0	Not fixed	 	Atmel
AT91RM9200	The SSC receiver does not support reception of the last data sequence of a frame that overlaps a new start of frame, regardless of the mode of detection of the start condition. For example, this prevents reception of the last data of a TDM bus.	ARM9	 	SSC	 	None.	 	41.10.1 Receiver does not take into account a start condition while receiving data	Not fixed	 	Atmel
AT91RM9200	The status bits RXSYN and TXSYN are active during a complete serial clock period and are not immediately cleared when SSC_SR is read.	ARM9	 	SSC	 	The user must enable the interrupt relevant to RXSYN and TXSYN.	 	41.10.2 RXSYN and TXSYN not cleared when read	Not fixed	 	Atmel
AT91RM9200	â If RF is programmed as input, the maximum clock frequency is MCK divided by 2. â If RF is programmed as output and RK is programmed as input, the maximum clock frequency is MCK divided by 6. â If RF and RK are both programmed as output, the maximum clock frequency is MCK divided by 4.	ARM9	 	SSC	 	None. At m eL AT91RM9200 [DATASHEET] 687 Atmel-1768J-ATARM-ATQ1 RM9200-Damsheet_03-Mar-16 41 .10.4 Transmitter Speed Limitations _ If both TF and TK are programmed as output, the maximum clock frequency is MCK divided by 4. _ If TF is programmed in output and TK is programmed as input, the maximum clock frequency is MCK divided by 8. â If both TF and TK are programmed as input, the maximum clock frequency is MCK divided by 8. _ If TF is programmed in input and TK is programmed as output, the maximum clock frequency is MCK divided by 4. Problem Fix/Workaround None.	 	41.10.3 Receiver Speed Limitations	Not fixed	 	Atmel
AT91RM9200	Generating RF can be stopped only by programming the FSOS ï¬eld in SSC_RFMR to 0x0. Generating TF can be stopped only by programming the FSOS ï¬eld in SSC_TFMR to 0x0.	ARM9	 	SSC	 	None.	 	41.10.5 Disabling the SSC does not stop the Frame Synchronization signal generation	Not fixed	 	Atmel
AT91RM9200	When transmission of data is programmed at the end of a frame and the start condition of the following frame is detected at the end of the current frame, the delay programmed by the STTDLY bit (in the SSC_RCMR and in the SSC_TCMR registers) is not performed on the next frame. Transmission starts immediately regardless of the programming of the ï¬eld STTDLY.	ARM9	 	SSC	 	None.	 	41.10.6 No delay when start condition overlays data transmit	Not fixed	 	Atmel
AT91RM9200	When SSC is conï¬gured with the following conditions: 0 TOMR.STI'DLY more than 0 o ROMR.START = Start on falling edge / Start on Rising edge I Start on any edge 0 RFMR.FSOS = None (input) 0 TOMR.START = Receive Start An unexpected delay of 2 or 3 system clock cycles is added to TD output.	ARM9	 	SSC	 	None. 41.11 TC	 	41.10.7 Unexpected delay on TD output	Not fixed	 	Atmel
AT91RM9200	If the counter was stopped or disabled, unwanted Compare RA, RB or R0 may occur at restart if the clock selected by the counter is masked by a low selected burst input when the trigger event is recognized at the selected clock active edge. All compare effects are affected, as the ï¬ags are set incorrectly and 0P0 trigger, 0P0 stop or 0P0 disable may occur.	ARM9	 	TC	 	None. 688 AT91RM9200 [DATASHEET] AtmeL Almel-1768J-ATARM-AT91 RM9200-Datasheet_03-Marâ1 G	 	41.11.1 Wrong Compare at restart if burst low	Not fixed	 	Atmel
AT91RM9200	A wrong 0 is captured in RA or RB during the last selected counter clock period if CPCTRG is active and the capture event occurred at least one Master Clock cycle after the last counter value update.	ARM9	 	TC	 	None.	 	41.11.2 Wrong 0 captured before Compare RC trigger	Not fixed	 	Atmel
AT91RM9200	The value captured is not equal to the Counter Value if the selected burst input is low at capture time, i.e., at the selected clock active edge where the capture event is recognized. The captured value may be 0; othenrvise, it is the Counter Value plus one instead of the Counter Value.	ARM9	 	TC	 	None.	 	41.11.3 Erroneous capture with burst low	Not fixed	 	Atmel
AT91RM9200	The captured value is not zero if burst is low when the preceding trigger event is recognized. Instead, the captured value is the Counter Value before the trigger.	ARM9	 	TC	 	None.	 	41.11.4 Bad capture at restart if burst low	Not fixed	 	Atmel
AT91RM9200	In the register TC_CMR, if at least one of the fields ASWTRG or AEEVT or ACPC is set to 0x0 (none), the event programmed by ACPA is not carried out. In the register TC_CMR, if at least one of the fields ASWTRG or AEEVT is set to 0x0 (none), the event programmed by ACPC is not carried out. In the register TC_CMR, if the ï¬eld ASWTRG is set to 0x0 (none), the event programmed by AEEVT is not carried out. The same problem exists on the TIOB output with the ï¬elds BSWTRG, BEEVT, BCPC and BCPB.	ARM9	 	TC	 	An order of priority for TIOA and/or TIOB events must be deï¬ned depending on the user application.	 	41.11.5 TIOA and TIOB outputs stuck in case of simultaneous events	Not fixed	 	Atmel
AT91RM9200	TIMER_CLOCK2/TIMER_CLOCK5 is sampled on the system clock falling edge of Master Clock, whereas TIMER_0LOCKO/TIMER_CLOCK3 and TIMER_CLOCK1/TIMER_CLOCK4 are sampled on the rising edge of Master Clock. This should not have any effect on the functional operations of the Timer Counter unless the Timer Counter is used at its speed limit.	ARM9	 	TC	 	None.	 	41.11.6 TIMER_CLOCK2 not sampled on same edge as TIMER_CLOCKO and TIMER_CLOCK1	Not fixed	 	Atmel
AT91RM9200	When the field WAVESEL in TC_CMR is at value 0x1 or 0x3, the triggers do not reset the counter value. The counter value can be reset only by modifying the ï¬eld WAVESEL.	ARM9	 	TC	 	None. At m eL AT91RM9200 [DATASHEET] 689 Atmel-1768J-ATARM-ATQ1 RM9200-Damsheet_03-Mar-16	 	41.11.7 Triggers do not clear the counter in UplDown Mode	Not fixed	 	Atmel
AT91RM9200	When the ï¬eld WAVESEL in TC_CMR is at value 0x1 or 0x3, the triggers occurring while the selected burst signal is active (clock disabled) are not taken into account.	ARM9	 	TC	 	None.	 	41.11.8 Triggers in UplDown Mode are lost when burst signal is active	Not fixed	 	Atmel
AT91RM9200	Selecting the Master Clock or the Master Clock divided by 2 as the Timer Counter Clock may lead to unpredictable result when the ï¬eld WAVESEL in TC_CMR is at value 0x1 or 0x3.	ARM9	 	TC	 	None.	 	41.11.9 Clock Selection Limitation in UplDown Mode	Not fixed	 	Atmel
AT91RM9200	When the ï¬eld WAVESEL in TC_CMR is at value 0x1 or 0x3 and when the counter reaches the value OxFFFF, it inverts its sense and decrements to OxFFFE. At the same time, the OVF bit in TC_SR is set.	ARM9	 	TC	 	None. 41.12 TWI	 	41.11.10 Spurious counter overï¬ow in UplDown Mode	Not fixed	 	Atmel
AT91RM9200	Any transfer in progress is immediately frozen if the Control Register (TWI_CR) is written with the bit MSDIS at 1. Furthermore, the status bits TXCOMP and TXRDY in the Status Register (TWI_SR) are not reset.	ARM9	 	TWI	 	The user must wait for the end of transfer before disabling the TWI. In addition, the interrupts must be disabled before disabling the TWI.	 	41.12.1 Disabling Does not Operate Correctly	Not fixed	 	Atmel
AT91RM9200	During a master frame, if TWI_SR is read between the Non Acknowledge condition detection and the TXCOMP bit rising in the TWI_SR, the NACK bit is not set.	ARM9	 	TWI	 	The user must wait for the TXCOMP status bit by interrupt and must not read the TWI_SR as long as transmission is not completed. Note: TXCOMP and NACK ï¬elds are set simultaneously and the NACK ï¬eld is reset after the read of the TWI_SR.	 	41.12.2 NACK Status Bit Lost	Not fixed	 	Atmel
AT91RM9200	When loading the TWI_RHR, the transfer direction is ignored. The last data byte received in the TWI_RHR is corrupted at the end of the ï¬rst subsequent transmit data byte. Neither RXRDY nor OVERRUN status bits are set if this occurs.	ARM9	 	TWI	 	The user must be sure that received data is read before transmitting any new data.	 	41.12.3 Possible Receive Holding Register Corruption	Not fixed	 	Atmel
AT91RM9200	"The value of CLDIV x 2â3""âV must be less than or equal to 8191; the value of CHDIV x 2â3""âV must be less than or equal to 8191."	ARM9	 	TWI	 	None. 690 AT91RM9200 [DATASHEET] AtmeL Almel-1768J-ATARM-AT91 RM9200-Datasheet_03-Marâ1 G	 	41.12.4 Clock Divider	Not fixed	 	Atmel
AT91RM9200	When a software reset is performed during a frame and when TWCK is low, it is impossible to initiate a new transfer in READ or WRITE mode.	ARM9	 	TWI	 	None.	 	41.12.5 Software reset	Not fixed	 	Atmel
AT91RM9200	TXCOMP and TXRDY are not reset by MSDIS.	ARM9	 	TWI	 	None.	 	41.12.6 TXCOMP and TXRDY reset	Not fixed	 	Atmel
AT91RM9200	In case of high latency to process the RXRDY interrupt, with RXRDY set, if the receive data register is read at the same time as new data is captured into the register, the RXRDY ï¬ag is cleared and the new data is lost because the associated RXRDY is not set.	ARM9	 	TWI	 	None. 41.13 USART	 	41.12.7 Data lost on high latency	Not fixed	 	Atmel
AT91RM9200	Internally, the RTSO signal of the USARTO is not connected to PA21.	ARM9	 	USART	 	The RTSO signal of the USARTO is connected to the PIO Controller D. The PIOD can be used to control the RTSO signal. The PIOD is only available in the AT91RM9200 LFBGA package.	 	41.13.1 RTSO not connected	Not fixed	 	Atmel
AT91RM9200	US_IF must be initialized even in transmission mode.	ARM9	 	USART	 	None.	 	41.13.2 US_IF must be initialized	Not fixed	 	Atmel
AT91RM9200	The TXD signal should be pulled up in Modern and Hardware Handshaking modes.	ARM9	 	USART	 	TXD is multiplexed with PIO which integrates a pull-up resistor. This internal pull-up needs to be enabled.	 	41.13.3 TXD signal is ï¬oating in Modem and Hardware Handshaking modes	Not fixed	 	Atmel
AT91RM9200	The DCD signal is active at 'High' level into the USART block (Modem mode). DCD should be active at 'Low' level.	ARM9	 	USART	 	Add an inverter. At m eL AT91RM9200 [DATASHEET] 691 Atmel-1768J-ATARM-ATQ1 RM9200-Betasheet_03-Mar-16	 	41.13.4 DCD is active High instead of Low	Not fixed	 	Atmel
AT91RM9200	The Number of Errors Register always returns 0 instead of the ISO7816 error number.	ARM9	 	USART	 	None. 41.14 USB Host Port	 	41.13.5 Bad value in Number of Errors Register	Not fixed	 	Atmel
SAM7S512	ADC: DRDY Bit Cleared The DRDY Flag should be clear only after a read of ADC_LCDR (Last Converted Data Register). A read of any ADC_CDRx register (Channel Data Register) automatically clears the DRDY flag.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: DRDY Bit Cleared	Not fixed	 	Atmel
SAM7S512	ADC: DRDY not Cleared on Disable When reading LCDR at the same instant as an end of conversion, with DRDY already active, DRDY is kept active regardless of the enable status of the current channel. This sets DRDY, whereas new data is not stored.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: DRDY not Cleared on Disable	Not fixed	 	Atmel
SAM7S512	ADC: DRDY Possibly Skipped due to CDR Read Reading CDR for channel âyâ at the same instant as an end of conversion on channel âxâ with EOC[x] already active, leads to skipping to set the DRDY flag if channel âxâ is enabled.	ARM7	 	Analog-to-Digital Converter (ADC)	 	Use of DRDY functionality with access to CDR registers should be avoided.	 	ADC: DRDY Possibly Skipped due to CDR Read	Not fixed	 	Atmel
SAM7S512	ADC: Possible Skip on DRDY when Disabling a Channel DRDY does not rise when disabling channel âyâ at the same time as an end of âxâ channel conversion, although data is stored into CDRx and LCDR.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None.	 	ADC: Possible Skip on DRDY when Disabling a Channel	Not fixed	 	Atmel
SAM7S512	ADC: GOVRE Bit is not Updated Read of the Status Register at the same instant as an end of conversion leads to skipping the update of the GOVRE (general overrun) flag. GOVRE is neither reset nor set. For example, if reading the status while an end of conversion is occurring and: 1. GOVRE is active but DRDY is inactive, does not correspond to a new general overrun condition but the GOVRE flag is not reset. 2. GOVRE is inactive but DRDY is active, does correspond to a new general overrun condition but the GOVRE flag is not set.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Updated	Not fixed	 	Atmel
SAM7S512	ADC: GOVRE Bit is not Set when Reading CDR When reading CDRy (Channel Data Register y) at the same instant as an end of conversion on channel âxâ with the following conditions: â¢ EOC[x] already active, â¢ DRDY already active, SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 599 â¢ GOVRE inactive, â¢ previous data stored in LCDR being neither data from channel âyâ, nor data from channel âxâ. GOVRE should be set but is not.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Set when Reading CDR	Not fixed	 	Atmel
SAM7S512	ADC: GOVRE Bit is not Set when Disabling a Channel When disabling channel âyâ at the same instant as an end of conversion on channel âxâ, EOC[x] and DRDY being already active, GOVRE does not rise. Note: OVRE[x] rises as expected.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Set when Disabling a Channel	Not fixed	 	Atmel
SAM7S512	ADC: OVRE Flag Behavior When the OVRE flag (on channel i) has been set but the related EOC status (of channel i) has been cleared (by a read of CDRi or LCDR), reading the Status register at the same instant as an end of conversion (causing the set of EOC status on channel i), does not lead to a reset of the OVRE flag (on channel i) as expected.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: OVRE Flag Behavior	Not fixed	 	Atmel
SAM7S512	ADC: EOC Set although Channel Disabled If a channel is disabled while a conversi on is running and if a read of CDR is performed at the same time as an end of conversion of any channel occurs, the EOC of the channel with the conversion running may rise (whereas it has been disabled).	ARM7	 	Analog-to-Digital Converter (ADC)	 	Do not take into account the EOC of a disabled channel	 	ADC: EOC Set although Channel Disabled	Not fixed	 	Atmel
SAM7S512	ADC: Spurious Clear of EOC Flag If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ nor âyâ), reading CDR on channel âzâ at the same instant as an end of conversion on channel âyâ automatically clears EOC[x] instead of EOC[z].	ARM7	 	Analog-to-Digital Converter (ADC)	 	None.	 	ADC: Spurious Clear of EOC Flag	Not fixed	 	Atmel
SAM7S512	ADC: Sleep Mode If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	ARM7	 	Analog-to-Digital Converter (ADC)	 	To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit field); to start an analog-to-digital conversion, in order put ADC into sleep mode at the end of this conversion. 40.4.2 Embedded Flash Controller (EFC)	 	ADC: Sleep Mode	Not fixed	 	Atmel
SAM7S512	EFC: Embedded Flash Access Time 1 The embedded Flash maximum access time is 20 MHz (instead of 30 MHz) at zero Wait State (FWS = 0). SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 600 The maximum operating frequency with one Wait State (FWS = 1) is 48.1 MHz (instead of 55 MHz). Above 48.1 MHz and until 55 MHz, two Wait States (FWS = 2) are required.	ARM7	 	Embedded Flash Controller (EFC)	 	Set the number of Wait States (FWS) according to the frequency requirements described in this errata. 40.4.3 Parallel Input/Output Controller (PIO)	 	EFC: Embedded Flash Access Time 1	Not fixed	 	Atmel
SAM7S512	PIO: Leakage on PA17 - PA20 When PA17, PA18, PA19 or PA20 (the I/O lines multiplexed with the analog inputs) are set as digital inputs with pull-up disabled, the leakage can be 9 ÂµA in worst case and 90 nA in typical case per I/O when the I/O is set externally at low level.	ARM7	 	Parallel Input/Output Controller (PIO)	 	Set the I/O to VDDIO by internal or external pull-up.	 	PIO: Leakage on PA17 - PA20	Not fixed	 	Atmel
SAM7S512	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31 When NRST or PA0-PA16 or PA21-PA31 are set as digital inputs with pull-up enabled, the voltage of the I/O stabilizes at VPull-up. Vpull-up VPull-up Min VPull-up Max VDDIO - 0.65 V VDDIO - 0.45 V This condition causes a leakage through VDDIO. This leakage is 45 ÂµA per pad in worst case at 3.3 V and 25 ÂµA at 1.8V. I Leakage Parameter Typ Max I Leakage at 3,3V 2.5 ÂµA 45 ÂµA I Leakage at 1.8V 1 ÂµA 25 ÂµA	ARM7	 	Parallel Input/Output Controller (PIO)	 	It is recommended to use an external pull-up if needed.	 	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31	Not fixed	 	Atmel
SAM7S512	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31 When NRST or PA0-PA16 and or PA21-PA31 are set as digital inputs with pull-up enabled, driving the I/O with an output impedance higher than 500 ohms may not drive the I/O to a logical zero.	ARM7	 	Parallel Input/Output Controller (PIO)	 	Output impedance must be lower than 500 ohms. 40.4.4 Pulse Width Modulation Controller (PWM)	 	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31	Not fixed	 	Atmel
SAM7S512	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Check the Channel Counter Register before writing the update register. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 601	 	PWM: Update when PWM_CCNTx = 0 or 1	Not fixed	 	Atmel
SAM7S512	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not write 0 in the period register.	 	PWM: Update when PWM_CPRDx = 0	Not fixed	 	Atmel
SAM7S512	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	None.	 	PWM: Counter Start Value	Not fixed	 	Atmel
SAM7S512	PWM: Constraints on Duty Cycle Value Setting Channel Duty Cycle Register (PWM_CDTYx) at 0 in center aligned mode or at 0 or 1 in left aligned mode may change the polarity of the signal.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not set PWM_CDTYx at 0 in center aligned mode. Do not set PWM_CDTYx at 0 or 1 in left aligned mode.	 	PWM: Constraints on Duty Cycle Value	Not fixed	 	Atmel
SAM7S512	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register Erratic behavior of the CHIDx status bit in the PWM_SR Register. When a channel is disabled by writing in the PWM_DIS Register just after enabling it (before completion of a Clock Period of the clock selected for the channel), the PWM line is internally disabled but the CHIDx status bit in the PWM_SR stays at 1.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not disable a channel before completion of one period of the selected clock. 40.4.5 Real Time Timer (RTT)	 	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register	Not fixed	 	Atmel
SAM7S512	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	ARM7	 	Real Time Timer (RTT)	 	The software must handle the RTT event as an interrupt and should not poll RTT_SR. 40.4.6 Serial Peripheral Interface (SPI)	 	RTT: Possible Event Loss when Reading RTT_SR	Not fixed	 	Atmel
SAM7S512	SPI: Software Reset Must be Written Twice If a software reset (SWRST in the SPI Control Register) is performed, the SPI may not work properly (the clock is enabled before the chip select).	ARM7	 	Serial Peripheral Interface (SPI)	 	The SPI Control Register field, SWRST needs to be written twice to be set correctly.	 	SPI: Software Reset Must be Written Twice	Not fixed	 	Atmel
SAM7S512	SPI: Bad tx_ready Behavior when CSAAT = 1 and SCBR = 1 If the SPI is programmed with CSAAT = 1, SCBR(baudrate) = 1 and two transfers are performed consecutively on the same slave with an IDLE state between them, the tx_ready signal does not rise after the second data has been transferred in the shifter. This can imply for example, that the second data is sent twice.	ARM7	 	Serial Peripheral Interface (SPI)	 	Do not use the combination CSAAT = 1 and SCBR = 1. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 602	 	SPI: Bad tx_ready Behavior when CSAAT = 1 and SCBR = 1	Not fixed	 	Atmel
SAM7S512	SPI: LASTXFER (Last Transfer) Behavior In FIXED Mode, with CSAAT bit set, and in âPDC modeâ the Chip Select can rise depending on the data written in the SPI_TDR when the TX_EMPTY flag is set. If for example, the PDC writes a â1â in the bit 24 (LASTXFER bit) of the SPI_TDR, the chip select will rise as soon as the TXEMPTY flag is set.	ARM7	 	Serial Peripheral Interface (SPI)	 	Use the CS in PIO mode when PDC mode is required and CS has to be maintained between transfers.	 	SPI: LASTXFER (Last Transfer) Behavior	Not fixed	 	Atmel
SAM7S512	SPI: SPCK Behavior in Master Mode SPCK pin can toggle out before the first transfer in Master Mode.	ARM7	 	Serial Peripheral Interface (SPI)	 	In Master Mode, MSTR bit must be set (in SPI_MR register) before configuring SPI_CSRx registers.	 	SPI: SPCK Behavior in Master Mode	Not fixed	 	Atmel
SAM7S512	SPI: Chip Select and Fixed Mode In fixed Mode, if a transfer is performed through a PDC on a Chip select different from the Chip select 0, the output spi_size sampled by the PDC will depend on the field, BITS (Bits per Transfer) of SPI_CSR0 register, whatever the selected Chip select is. For example, if SPI_CSR0 is configured for a 10-bit transfer whereas SPI_CSR1 is configured for an 8-bit transfer, when a transfer is performed in Fixed mode through the PDC, on Chip select 1, the transfer will be considered as a HalfWord transfer.	ARM7	 	Serial Peripheral Interface (SPI)	 	If a PDC transfer has to be performed in 8 bits, on a Chip select y (y as different from 0), the BITS field of the SPI_CSR0 must be configured in 8 bits, in the same way as the BITS field of the CSRy Register.	 	SPI: Chip Select and Fixed Mode	Not fixed	 	Atmel
SAM7S512	SPI: Baudrate Set to 1 When Baudrate is set at 1 (i.e. when serial clock frequency equals the system clock frequency) and when the BITS field of the SPI_CSR register (number of bits to be transmitted) equals an ODD value (in this case 9,11,13 or 15), an additional pulse will be generated on output SPCK. Everything is OK if the BITS field equals 8,10,12,14 or 16 and Baudrate = 1.	ARM7	 	Serial Peripheral Interface (SPI)	 	None.	 	SPI: Baudrate Set to 1	Not fixed	 	Atmel
SAM7S512	SPI: Disable In Slave Mode The SPI disable is not possible in slave mode.	ARM7	 	Serial Peripheral Interface (SPI)	 	Read first the received data, then perform the software reset.	 	SPI: Disable In Slave Mode	Not fixed	 	Atmel
SAM7S512	SPI: Bad Serial Clock Generation on 2nd Chip Select Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0. This occurs using SPI with the following conditions: â¢ Master Mode â¢ CPOL = 1 and NCPHA = 0 â¢ Multiple chip selects are used with one transfer with Baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR are not equal to 1 â¢ Transmitting with the slowest chip select and then with the fastest one, then an additional on output SPCK during the second transfer. pulse is generated	ARM7	 	Serial Peripheral Interface (SPI)	 	SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 603 Do not use a multiple Chip Select configuration where at least one SCRx register is configured with SCBR = 1 and the others differ from 1 if NCPHA = 0 and CPOL = 1. If all chip selects are configured with Baudrate = 1, the issue does not appear. 40.4.7 Synchronous Serial Controller (SSC)	 	SPI: Bad Serial Clock Generation on 2nd Chip Select	Not fixed	 	Atmel
SAM7S512	SSC: Periodic Transmission Limitations in Master Mode If the Least Significant Bit is sent first (MSBF = 0), the first TAG during the frame synchro is not sent.	ARM7	 	Synchronous Serial Controller (SSC)	 	None.	 	SSC: Periodic Transmission Limitations in Master Mode	Not fixed	 	Atmel
SAM7S512	SSC: Transmitter Limitations in Slave Mode If TK is programmed as output and TF is programmed as input, it is impossible to emit data when the start of edge (rising or falling) of synchro has a Start Delay equal to zero.	ARM7	 	Synchronous Serial Controller (SSC)	 	None.	 	SSC: Transmitter Limitations in Slave Mode	Not fixed	 	Atmel
SAM7S512	SSC: Transmitter Limitations in Slave Mode If TK is programmed as an input and TF is programmed as an output and requested to be set to low/high during data emission, the Frame Synchro signal is generated one bit clock period after the data start and one data bit is lost. This problem does not exist when generating a periodic synchro.	ARM7	 	Synchronous Serial Controller (SSC)	 	The data need to be delayed for one bit clock period with an external assembly. In the following schematic, TD, TK and NRST are SAM7S signals, TXD is the delayed data to connect to the device. 40.4.8 Two-wire Interface (TWI)	 	SSC: Transmitter Limitations in Slave Mode	Not fixed	 	Atmel
SAM7S512	TWI: Clock Divider The value of CLDIV x 2 CKDIV must be less than or equal to 8191 the value of CHDIV x 2 CKDIV must be less than or equal to 8191	ARM7	 	Two-wire Interface (TWI)	 	SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 604 None.	 	TWI: Clock Divider	Not fixed	 	Atmel
SAM7S512	TWI: Software Reset when a software reset is performed during a frame and when TWCK is low, it is impossible to initiate a new transfer in READ or WRITE mode.	ARM7	 	Two-wire Interface (TWI)	 	None.	 	TWI: Software Reset	Not fixed	 	Atmel
SAM7S512	TWI: Disabling Does not Operate Correctly Any transfer in progress is immediately frozen if the Control Register (TWI_CR) is written with the bit MSDIS at 1. Furthermore, the status bits TXCOMP and TXRDY in the Status Register (TWI_SR) are not reset.	ARM7	 	Two-wire Interface (TWI)	 	The user must wait for the end of transfer before disabling the TWI. In addition, the interrupts must be disabled before disabling the TWI.	 	TWI: Disabling Does not Operate Correctly	Not fixed	 	Atmel
SAM7S512	TWI: NACK Status Bit Lost During a master frame, if TWI_SR is read between the Non Acknowledge condition detection and the TXCOMP bit rising in the TWI_SR, the NACK bit is not set.	ARM7	 	Two-wire Interface (TWI)	 	The user must wait for the TXCOMP status bit by interrupt and must not read the TWI_SR as long as transmission is not completed. TXCOMP and NACK fields are set simultaneously and the NACK field is reset after the read of the TWI_SR.	 	TWI: NACK Status Bit Lost	Not fixed	 	Atmel
SAM7S512	TWI: Possible Receive Holding Register Corruption When loading the TWI_RHR, the transfer direction is ignored. The last data byte received in the TWI_RHR is corrupted at the end of the first subsequent transmit data byte . Neither RXRDY nor OVERRUN status bits are set if this occurs.	ARM7	 	Two-wire Interface (TWI)	 	The user must be sure that received data is read before transmitting any new data. 40.4.9 Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	TWI: Possible Receive Holding Register Corruption	Not fixed	 	Atmel
SAM7S512	USART: CTS in Hardware Handshaking When Hardware Handshaking is used and if CTS goes high near the end of the start bit, a character can be lost. CTS must not go high during a time slot occurring between 2 Master Clock periods before and 16 Master Clock periods after the rising edge of the start bit.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	None.	 	USART: CTS in Hardware Handshaking	Not fixed	 	Atmel
SAM7S512	USART: Hardware Handshaking â Two Characters Sent If CTS switches from 0 to 1 during the TX of a character and if the holding register (US_THR) is not empty, the content of US_THR will also be transmitted.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	Don't use the PDC in transmit mode and do not fill US_THR before TXEMPTY is set at 1. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 605	 	USART: Hardware Handshaking â Two Characters Sent	Not fixed	 	Atmel
SAM7S512	USART: XOFF Character Bad Behavior The XOFF character is sent only when the receive buffer is detected full. While the XOFF is being sent, the remote transmitter is still transmitting. As only one Holding register is available in the receiver, characters will be lost in reception. This makes the software handshaking functionality ineffective.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	None.	 	USART: XOFF Character Bad Behavior	Not fixed	 	Atmel
SAM7S512	USART: RXBRK Flag Error in Asynchronous Mode In receiver mode, when there are two consecutive characters (without timeguard in between), RXBRK is not taken into account. As a result, the RXBRK flag is not enabled correctly and the frame error flag is set.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	Constraints on the transmitter device connected to the SAM7S USART receiver side: The transmitter may use the timeguard feature or send two STOP conditions. Only one STOP condition is taken into account by the receiver state machine. After this STOP condition, as there is no valid data, the receiver state machine will go in idle mode and enable the RXBRK flag.	 	USART: RXBRK Flag Error in Asynchronous Mode	Not fixed	 	Atmel
SAM7S512	USART: DCD is active High instead of Low The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	Add an inverter. 40.5 SAM7S512 Errata - Revision B Parts Refer to Section 40.1 âMarkingâ on page 595. Note: AT91SAM7S512 Revision B chip ID is: 0x270B 0A4F. 40.5.1 Analog-to-Digital Converter (ADC)	 	USART: DCD is active High instead of Low	Not fixed	 	Atmel
SAM7S512	ADC: DRDY Bit Cleared The DRDY Flag should be clear only after a read of ADC_LCDR (Last Converted Data Register). A read of any ADC_CDRx register (Channel Data Register) automatically clears the DRDY flag.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: DRDY Bit Cleared	Not fixed	 	Atmel
SAM7S512	ADC: DRDY not Cleared on Disable When reading LCDR at the same instant as an end of conversion, with DRDY already active, DRDY is kept active regardless of the enable status of the current channel. This sets DRDY, whereas new data is not stored.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: DRDY not Cleared on Disable	Not fixed	 	Atmel
SAM7S512	ADC: DRDY Possibly Skipped due to CDR Read Reading CDR for channel âyâ at the same instant as an end of conversion on channel âxâ with EOC[x] already active, leads to skipping to set the DRDY flag if channel âxâ is enabled.	ARM7	 	Analog-to-Digital Converter (ADC)	 	Use of DRDY functionality with access to CDR registers should be avoided. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 606	 	ADC: DRDY Possibly Skipped due to CDR Read	Not fixed	 	Atmel
SAM7S512	ADC: Possible Skip on DRDY when Disabling a Channel DRDY does not rise when disabling channel âyâ at the same time as an end of âxâ channel conversion, although data is stored into CDRx and LCDR.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None.	 	ADC: Possible Skip on DRDY when Disabling a Channel	Not fixed	 	Atmel
SAM7S512	ADC: GOVRE Bit is not Updated Read of the Status Register at the same instant as an end of conversion leads to skipping the update of the GOVRE (general overrun) flag. GOVRE is neither reset nor set. For example, if reading the status while an end of conversion is occurring and: 1. GOVRE is active but DRDY is inactive, does not correspond to a new general overrun condition but the GOVRE flag is not reset. 2. GOVRE is inactive but DRDY is active, does correspond to a new general overrun condition but the GOVRE flag is not set.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Updated	Not fixed	 	Atmel
SAM7S512	ADC: GOVRE Bit is not Set when Reading CDR When reading CDRy (Channel Data Register y) at the same instant as an end of conversion on channel âxâ with the following conditions: â¢ EOC[x] already active, â¢ DRDY already active, â¢ GOVRE inactive, â¢ previous data stored in LCDR being neither data from channel âyâ, nor data from channel âxâ. GOVRE should be set but is not.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Set when Reading CDR	Not fixed	 	Atmel
SAM7S512	ADC: GOVRE Bit is not Set when Disabling a Channel When disabling channel âyâ at the same instant as an end of conversion on channel âxâ, EOC[x] and DRDY being already active, GOVRE does not rise. Note: OVRE[x] rises as expected.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Set when Disabling a Channel	Not fixed	 	Atmel
SAM7S512	ADC: OVRE Flag Behavior When the OVRE flag (on channel i) has been set but the related EOC status (of channel i) has been cleared (by a read of CDRi or LCDR), reading the Status register at the same instant as an end of conversion (causing the set of EOC status on channel i), does not lead to a reset of the OVRE flag (on channel i) as expected.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: OVRE Flag Behavior	Not fixed	 	Atmel
SAM7S512	ADC: EOC Set although Channel Disabled If a channel is disabled while a conversi on is running and if a read of CDR is performed at the same time as an end of conversion of any channel occurs, the EOC of the channel with the conversion running may rise (whereas it has been disabled). SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 607	ARM7	 	Analog-to-Digital Converter (ADC)	 	Do not take into account the EOC of a disabled channel	 	ADC: EOC Set although Channel Disabled	Not fixed	 	Atmel
SAM7S512	ADC: Spurious Clear of EOC Flag If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ nor âyâ), reading CDR on channel âzâ at the same instant as an end of conversion on channel âyâ automatically clears EOC[x] instead of EOC[z].	ARM7	 	Analog-to-Digital Converter (ADC)	 	None.	 	ADC: Spurious Clear of EOC Flag	Not fixed	 	Atmel
SAM7S512	ADC: Sleep Mode If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	ARM7	 	Analog-to-Digital Converter (ADC)	 	To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit field); to start an analog-to-digital conversion, in order put ADC into sleep mode at the end of this conversion. 40.5.2 Embedded Flash Controller (EFC)	 	ADC: Sleep Mode	Not fixed	 	Atmel
SAM7S512	EFC: Embedded Flash Access Time 2 The Flash memory access time has been reduced as per the table below: Flash Wait State (FWS) Read Operations Maximum Operating Frequency (MHz) 0 1 cycle 16 1 2 cycles 32 2 3 cycles 48 3 4 cycles 55	ARM7	 	Embedded Flash Controller (EFC)	 	Set the number of Wait States (FWS) according to the frequency requirements described in this errata. 40.5.3 Parallel Input/Output Controller (PIO)	 	EFC: Embedded Flash Access Time 2	Not fixed	 	Atmel
SAM7S512	PIO: Leakage on PA17 - PA20 When PA17, PA18, PA19 or PA20 (the I/O lines multiplexed with the analog inputs) are set as digital inputs with pull-up disabled, the leakage can be 9 ÂµA in worst case and 90 nA in typical case per I/O when the I/O is set externally at low level.	ARM7	 	Parallel Input/Output Controller (PIO)	 	Set the I/O to VDDIO by internal or external pull-up. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 608	 	PIO: Leakage on PA17 - PA20	Not fixed	 	Atmel
SAM7S512	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31 When NRST or PA0-PA16 or PA21-PA31 are set as digital inputs with pull-up enabled, the voltage of the I/O stabilizes at VPull-up. Vpull-up VPull-up Min VPull-up Max VDDIO - 0.65 V VDDIO - 0.45 V This condition causes a leakage through VDDIO. This leakage is 45 ÂµA per pad in worst case at 3.3 V and 25 ÂµA at 1.8V. I Leakage Parameter Typ Max I Leakage at 3,3V 2.5 ÂµA 45 ÂµA I Leakage at 1.8V 1 ÂµA 25 ÂµA	ARM7	 	Parallel Input/Output Controller (PIO)	 	It is recommended to use an external pull-up if needed.	 	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31	Not fixed	 	Atmel
SAM7S512	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31 When NRST or PA0-PA16 and or PA21-PA31 are set as digital inputs with pull-up enabled, driving the I/O with an output impedance higher than 500 ohms may not drive the I/O to a logical zero.	ARM7	 	Parallel Input/Output Controller (PIO)	 	Output impedance must be lower than 500 ohms. 40.5.4 Pulse Width Modulation Controller (PWM)	 	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31	Not fixed	 	Atmel
SAM7S512	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Check the Channel Counter Register before writing the update register.	 	PWM: Update when PWM_CCNTx = 0 or 1	Not fixed	 	Atmel
SAM7S512	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not write 0 in the period register.	 	PWM: Update when PWM_CPRDx = 0	Not fixed	 	Atmel
SAM7S512	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	None.	 	PWM: Counter Start Value	Not fixed	 	Atmel
SAM7S512	PWM: Constraints on Duty Cycle Value Setting Channel Duty Cycle Register (PWM_CDTYx) at 0 in center aligned mode or at 0 or 1 in left aligned mode may change the polarity of the signal.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 609 Do not set PWM_CDTYx at 0 in center aligned mode. Do not set PWM_CDTYx at 0 or 1 in left aligned mode.	 	PWM: Constraints on Duty Cycle Value	Not fixed	 	Atmel
SAM7S512	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register Erratic behavior of the CHIDx status bit in the PWM_SR Register. When a channel is disabled by writing in the PWM_DIS Register just after enabling it (before completion of a Clock Period of the clock selected for the channel), the PWM line is internally disabled but the CHIDx status bit in the PWM_SR stays at 1.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not disable a channel before completion of one period of the selected clock. 40.5.5 Real Time Timer (RTT)	 	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register	Not fixed	 	Atmel
SAM7S512	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	ARM7	 	Real Time Timer (RTT)	 	The software must handle the RTT event as an interrupt and should not poll RTT_SR. 40.5.6 Serial Peripheral Interface (SPI)	 	RTT: Possible Event Loss when Reading RTT_SR	Not fixed	 	Atmel
SAM7S512	SPI: Software Reset Must be Written Twice If a software reset (SWRST in the SPI Control Register) is performed, the SPI may not work properly (the clock is enabled before the chip select).	ARM7	 	Serial Peripheral Interface (SPI)	 	The SPI Control Register field, SWRST needs to be written twice to be set correctly.	 	SPI: Software Reset Must be Written Twice	Not fixed	 	Atmel
SAM7S512	SPI: Bad tx_ready Behavior when CSAAT = 1 and SCBR = 1 If the SPI is programmed with CSAAT = 1, SCBR(baudrate) = 1 and two transfers are performed consecutively on the same slave with an IDLE state between them, the tx_ready signal does not rise after the second data has been transferred in the shifter. This can imply for example, that the second data is sent twice.	ARM7	 	Serial Peripheral Interface (SPI)	 	Do not use the combination CSAAT = 1 and SCBR = 1.	 	SPI: Bad tx_ready Behavior when CSAAT = 1 and SCBR = 1	Not fixed	 	Atmel
SAM7S512	SPI: LASTXFER (Last Transfer) Behavior In FIXED Mode, with CSAAT bit set, and in âPDC modeâ the Chip Select can rise depending on the data written in the SPI_TDR when the TX_EMPTY flag is set. If for example, the PDC writes a â1â in the bit 24 (LASTXFER bit) of the SPI_TDR, the chip select will rise as soon as the TXEMPTY flag is set.	ARM7	 	Serial Peripheral Interface (SPI)	 	Use the CS in PIO mode when PDC mode is required and CS has to be maintained between transfers.	 	SPI: LASTXFER (Last Transfer) Behavior	Not fixed	 	Atmel
SAM7S512	SPI: SPCK Behavior in Master Mode SPCK pin can toggle out before the first transfer in Master Mode.	ARM7	 	Serial Peripheral Interface (SPI)	 	In Master Mode, MSTR bit must be set (in SPI_MR register) before configuring SPI_CSRx registers. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 610	 	SPI: SPCK Behavior in Master Mode	Not fixed	 	Atmel
SAM7S512	SPI: Chip Select and Fixed Mode In fixed Mode, if a transfer is performed through a PDC on a Chip select different from the Chip select 0, the output spi_size sampled by the PDC will depend on the field, BITS (Bits per Transfer) of SPI_CSR0 register, whatever the selected Chip select is. For example, if SPI_CSR0 is configured for a 10-bit transfer whereas SPI_CSR1 is configured for an 8-bit transfer, when a transfer is performed in Fixed mode through the PDC, on Chip select 1, the transfer will be considered as a HalfWord transfer.	ARM7	 	Serial Peripheral Interface (SPI)	 	If a PDC transfer has to be performed in 8 bits, on a Chip select y (y as different from 0), the BITS field of the SPI_CSR0 must be configured in 8 bits, in the same way as the BITS field of the CSRy Register.	 	SPI: Chip Select and Fixed Mode	Not fixed	 	Atmel
SAM7S512	SPI: Baudrate Set to 1 When Baudrate is set at 1 (i.e. when serial clock frequency equals the system clock frequency) and when the BITS field of the SPI_CSR register (number of bits to be transmitted) equals an ODD value (in this case 9,11,13 or 15), an additional pulse will be generated on output SPCK. Everything is OK if the BITS field equals 8,10,12,14 or 16 and Baudrate = 1.	ARM7	 	Serial Peripheral Interface (SPI)	 	None.	 	SPI: Baudrate Set to 1	Not fixed	 	Atmel
SAM7S512	SPI: Disable In Slave Mode The SPI disable is not possible in slave mode.	ARM7	 	Serial Peripheral Interface (SPI)	 	Read first the received data, then perform the software reset.	 	SPI: Disable In Slave Mode	Not fixed	 	Atmel
SAM7S512	SPI: Bad Serial Clock Generation on 2nd Chip Select Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0. This occurs using SPI with the following conditions: â¢ Master Mode â¢ CPOL = 1 and NCPHA = 0 â¢ Multiple chip selects are used with one transfer with Baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR are not equal to 1 â¢ Transmitting with the slowest chip select and then with the fastest one, then an additional on output SPCK during the second transfer. pulse is generated	ARM7	 	Serial Peripheral Interface (SPI)	 	Do not use a multiple Chip Select configuration where at least one SCRx register is configured with SCBR = 1 and the others differ from 1 if NCPHA = 0 and CPOL = 1. If all chip selects are configured with Baudrate = 1, the issue does not appear. 40.5.7 Synchronous Serial Controller (SSC)	 	SPI: Bad Serial Clock Generation on 2nd Chip Select	Not fixed	 	Atmel
SAM7S512	SSC: Periodic Transmission Limitations in Master Mode If the Least Significant Bit is sent first (MSBF = 0), the first TAG during the frame synchro is not sent.	ARM7	 	Synchronous Serial Controller (SSC)	 	None. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 611	 	SSC: Periodic Transmission Limitations in Master Mode	Not fixed	 	Atmel
SAM7S512	SSC: Transmitter Limitations in Slave Mode If TK is programmed as output and TF is programmed as input, it is impossible to emit data when the start of edge (rising or falling) of synchro has a Start Delay equal to zero.	ARM7	 	Synchronous Serial Controller (SSC)	 	None.	 	SSC: Transmitter Limitations in Slave Mode	Not fixed	 	Atmel
SAM7S512	SSC: Transmitter Limitations in Slave Mode If TK is programmed as an input and TF is programmed as an output and requested to be set to low/high during data emission, the Frame Synchro signal is generated one bit clock period after the data start and one data bit is lost. This problem does not exist when generating a periodic synchro.	ARM7	 	Synchronous Serial Controller (SSC)	 	The data need to be delayed for one bit clock period with an external assembly. In the following schematic, TD, TK and NRST are SAM7S signals, TXD is the delayed data to connect to the device. 40.5.8 Two-wire Interface (TWI)	 	SSC: Transmitter Limitations in Slave Mode	Not fixed	 	Atmel
SAM7S512	TWI: Clock Divider The value of CLDIV x 2 CKDIV must be less than or equal to 8191 the value of CHDIV x 2 CKDIV must be less than or equal to 8191	ARM7	 	Two-wire Interface (TWI)	 	None.	 	TWI: Clock Divider	Not fixed	 	Atmel
SAM7S512	TWI: Software Reset when a software reset is performed during a frame and when TWCK is low, it is impossible to initiate a new transfer in READ or WRITE mode.	ARM7	 	Two-wire Interface (TWI)	 	None.	 	TWI: Software Reset	Not fixed	 	Atmel
SAM7S512	TWI: Disabling Does not Operate Correctly Any transfer in progress is immediately frozen if the Control Register (TWI_CR) is written with the bit MSDIS at 1. Furthermore, the status bits TXCOMP and TXRDY in the Status Register (TWI_SR) are not reset. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 612	ARM7	 	Two-wire Interface (TWI)	 	The user must wait for the end of transfer before disabling the TWI. In addition, the interrupts must be disabled before disabling the TWI.	 	TWI: Disabling Does not Operate Correctly	Not fixed	 	Atmel
SAM7S512	TWI: NACK Status Bit Lost During a master frame, if TWI_SR is read between the Non Acknowledge condition detection and the TXCOMP bit rising in the TWI_SR, the NACK bit is not set.	ARM7	 	Two-wire Interface (TWI)	 	The user must wait for the TXCOMP status bit by interrupt and must not read the TWI_SR as long as transmission is not completed. TXCOMP and NACK fields are set simultaneously and the NACK field is reset after the read of the TWI_SR.	 	TWI: NACK Status Bit Lost	Not fixed	 	Atmel
SAM7S512	TWI: Possible Receive Holding Register Corruption When loading the TWI_RHR, the transfer direction is ignored. The last data byte received in the TWI_RHR is corrupted at the end of the first subsequent transmit data byte . Neither RXRDY nor OVERRUN status bits are set if this occurs.	ARM7	 	Two-wire Interface (TWI)	 	The user must be sure that received data is read before transmitting any new data. 40.5.9 Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	TWI: Possible Receive Holding Register Corruption	Not fixed	 	Atmel
SAM7S512	USART: CTS in Hardware Handshaking When Hardware Handshaking is used and if CTS goes high near the end of the start bit, a character can be lost. CTS must not go high during a time slot occurring between 2 Master Clock periods before and 16 Master Clock periods after the rising edge of the start bit.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	None.	 	USART: CTS in Hardware Handshaking	Not fixed	 	Atmel
SAM7S512	USART: Hardware Handshaking â Two Characters Sent If CTS switches from 0 to 1 during the TX of a character and if the holding register (US_THR) is not empty, the content of US_THR will also be transmitted.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	Don't use the PDC in transmit mode and do not fill US_THR before TXEMPTY is set at 1.	 	USART: Hardware Handshaking â Two Characters Sent	Not fixed	 	Atmel
SAM7S512	USART: XOFF Character Bad Behavior The XOFF character is sent only when the receive buffer is detected full. While the XOFF is being sent, the remote transmitter is still transmitting. As only one Holding register is available in the receiver, characters will be lost in reception. This makes the software handshaking functionality ineffective.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	None.	 	USART: XOFF Character Bad Behavior	Not fixed	 	Atmel
SAM7S512	USART: RXBRK Flag Error in Asynchronous Mode In receiver mode, when there are two consecutive characters (without timeguard in between), RXBRK is not taken into account. As a result, the RXBRK flag is not enabled correctly and the frame error flag is set.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	Constraints on the transmitter device connected to the SAM7S USART receiver side: SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 613 The transmitter may use the timeguard feature or send two STOP conditions. Only one STOP condition is taken into account by the receiver state machine. After this STOP condition, as there is no valid data, the receiver state machine will go in idle mode and enable the RXBRK flag.	 	USART: RXBRK Flag Error in Asynchronous Mode	Not fixed	 	Atmel
SAM7S512	USART: DCD is active High instead of Low The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	Add an inverter. 40.6 SAM7S256 Errata - Manufacturing Number 58818C Refer to Section 40.1 âMarkingâ on page 595. Important: Section 40.6.14.1 âWDT: The Watchdog Timer May Lock the Device in a Reset Stateâ 40.6.1 Chip ID	 	USART: DCD is active High instead of Low	Not fixed	 	Atmel
SAM7S256	Wrong Chip ID Value The Chip ID is 0x270D0940 instead of 0x270B0940.	ARM7	 	Chip ID	 	None. 40.6.2 Analog-to-Digital Converter (ADC)	 	Wrong Chip ID Value	Not fixed	 	Atmel
SAM7S256	ADC: DRDY Bit Cleared The DRDY Flag should be clear only after a read of ADC_LCDR (Last Converted Data Register). A read of any ADC_CDRx register (Channel Data Register) automatically clears the DRDY flag.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: DRDY Bit Cleared	Not fixed	 	Atmel
SAM7S256	ADC: DRDY not Cleared on Disable When reading LCDR at the same instant as an end of conversion, with DRDY already active, DRDY is kept active regardless of the enable status of the current channel. This sets DRDY, whereas new data is not stored.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: DRDY not Cleared on Disable	Not fixed	 	Atmel
SAM7S256	ADC: DRDY Possibly Skipped due to CDR Read Reading CDR for channel âyâ at the same instant as an end of conversion on channel âxâ with EOC[x] already active, leads to skipping to set the DRDY flag if channel âxâ is enabled.	ARM7	 	Analog-to-Digital Converter (ADC)	 	Use of DRDY functionality with access to CDR registers should be avoided.	 	ADC: DRDY Possibly Skipped due to CDR Read	Not fixed	 	Atmel
SAM7S256	ADC: Possible Skip on DRDY when Disabling a Channel DRDY does not rise when disabling channel âyâ at the same time as an end of âxâ channel conversion, although data is stored into CDRx and LCDR.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 614	 	ADC: Possible Skip on DRDY when Disabling a Channel	Not fixed	 	Atmel
SAM7S256	ADC: GOVRE Bit is not Updated Read of the Status Register at the same instant as an end of conversion leads to skipping the update of the GOVRE (general overrun) flag. GOVRE is neither reset nor set. For example, if reading the status while an end of conversion is occurring and: 1. GOVRE is active but DRDY is inactive, does not correspond to a new general overrun condition but the GOVRE flag is not reset. 2. GOVRE is inactive but DRDY is active, does correspond to a new general overrun condition but the GOVRE flag is not set.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Updated	Not fixed	 	Atmel
SAM7S256	ADC: GOVRE Bit is not Set when Reading CDR When reading CDRy (Channel Data Register y) at the same instant as an end of conversion on channel âxâ with the following conditions: â¢ EOC[x] already active, â¢ DRDY already active, â¢ GOVRE inactive, â¢ previous data stored in LCDR being neither data from channel âyâ, nor data from channel âxâ. GOVRE should be set but is not.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Set when Reading CDR	Not fixed	 	Atmel
SAM7S256	ADC: GOVRE Bit is not Set when Disabling a Channel When disabling channel âyâ at the same instant as an end of conversion on channel âxâ, EOC[x] and DRDY being already active, GOVRE does not rise. Note: OVRE[x] rises as expected.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Set when Disabling a Channel	Not fixed	 	Atmel
SAM7S256	ADC: OVRE Flag Behavior When the OVRE flag (on channel i) has been set but the related EOC status (of channel i) has been cleared (by a read of CDRi or LCDR), reading the Status register at the same instant as an end of conversion (causing the set of EOC status on channel i), does not lead to a reset of the OVRE flag (on channel i) as expected.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: OVRE Flag Behavior	Not fixed	 	Atmel
SAM7S256	ADC: EOC Set although Channel Disabled If a channel is disabled while a conversi on is running and if a read of CDR is performed at the same time as an end of conversion of any channel occurs, the EOC of the channel with the conversion running may rise (whereas it has been disabled).	ARM7	 	Analog-to-Digital Converter (ADC)	 	Do not take into account the EOC of a disabled channel SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 615	 	ADC: EOC Set although Channel Disabled	Not fixed	 	Atmel
SAM7S256	ADC: Spurious Clear of EOC Flag If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ nor âyâ), reading CDR on channel âzâ at the same instant as an end of conversion on channel âyâ automatically clears EOC[x] instead of EOC[z].	ARM7	 	Analog-to-Digital Converter (ADC)	 	None.	 	ADC: Spurious Clear of EOC Flag	Not fixed	 	Atmel
SAM7S256	ADC: Sleep Mode If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	ARM7	 	Analog-to-Digital Converter (ADC)	 	To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit field); to start an analog-to-digital conversion, in order put ADC into sleep mode at the end of this conversion. 40.6.3 Master Clock (MCK)	 	ADC: Sleep Mode	Not fixed	 	Atmel
SAM7S256	MCK: Limited Master Clock Frequency Ranges If the Flash is operating without wait states, the frequency of the Master Clock MCK must be lower than 3 MHz or higher than 19 MHz. If the Flash is operating with one wait state, the frequency of the Master Clock MCK must be lower than 3 MHz or higher than 19 MHz. If the Flash is operating with two wait states, the frequency of the Master Clock MCK must be lower than 3 MHz or higher than 25 MHz. If the Flash is operating with three wait states, the frequency of the Master Clock MCK must be lower than 3 MHz or higher than 38 MHz. If these constraints are not respected, the correct operation of the system cannot be guaranteed and either data or prefetch abort might occur. The maximum operating frequencies (at 30 MHz @ 0 Wait States and 55 MHz @ 1 Wait State) as stated in Table 37-24, âEmbedded Flash Wait States,â on page 582, are still applicable. Note: It is not necessary to use 2 o 3 wait states because t he Flash can operate at maximum frequency with only 1 wait state.	ARM7	 	Master Clock (MCK)	 	The user must ensure that the device is running at the authorized frequency by programming the PLL properly to not run within the forbidden frequency range. 40.6.4 Non Volatile Memory Bits (NVM Bits)	 	MCK: Limited Master Clock Frequency Ranges	Not fixed	 	Atmel
SAM7S256	NVM Bits: Write/Erase Cycles Number The maximum number of write/erase cycles for Non Volatile Memory bits is 100. This includes Lock Bits (LOCKx), General Purpose NVM bits (GPNVMx) and the Security Bit. This maximum number of write/erase cycles is not applic able to 256 KB Flash memory, it remains at 10K for the Flash memory.	ARM7	 	Non Volatile Memory Bits (NVM Bits)	 	None. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 616 40.6.5 Parallel Input/Output Controller (PIO)	 	NVM Bits: Write/Erase Cycles Number	Not fixed	 	Atmel
SAM7S256	PIO: Leakage on PA17 - PA20 When PA17, PA18, PA19 or PA20 (the I/O lines multiplexed with the analog inputs) are set as digital inputs with pull-up disabled, the leakage can be 9 ÂµA in worst case and 90 nA in typical case per I/O when the I/O is set externally at low level.	ARM7	 	Parallel Input/Output Controller (PIO)	 	Set the I/O to VDDIO by internal or external pull-up.	 	PIO: Leakage on PA17 - PA20	Not fixed	 	Atmel
SAM7S256	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31 When NRST or PA0-PA16 or PA21-PA31 are set as digital inputs with pull-up enabled, the voltage of the I/O stabilizes at VPull-up. Vpull-up VPull-up Min VPull-up Max VDDIO - 0.65 V VDDIO - 0.45 V This condition causes a leakage through VDDIO. This leakage is 45 ÂµA per pad in worst case at 3.3 V and 25 ÂµA at 1.8V. I Leakage Parameter Typ Max I Leakage at 3,3V 2.5 ÂµA 45 ÂµA I Leakage at 1.8V 1 ÂµA 25 ÂµA	ARM7	 	Parallel Input/Output Controller (PIO)	 	It is recommended to use an external pull-up if needed.	 	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31	Not fixed	 	Atmel
SAM7S256	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31 When NRST or PA0-PA16 and or PA21-PA31 are set as digital inputs with pull-up enabled, driving the I/O with an output impedance higher than 500 ohms may not drive the I/O to a logical zero.	ARM7	 	Parallel Input/Output Controller (PIO)	 	Output impedance must be lower than 500 ohms. 40.6.6 Power Management Controller (PMC)	 	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31	Not fixed	 	Atmel
SAM7S256	PMC: Slow Clock Selected in PMC and a Transition Occurs on PA1 Under certain rare circumstances, when CSS = 00 in PMC_MCKR, and PA1 is set as an input and a transition occurs on PA1, device malfunction might occur.	ARM7	 	Power Management Controller (PMC)	 	Do not transition PA1 as an input when CSS = 00 in PMC_MCKR.	 	PMC: Slow Clock Selected in PMC and a Transition Occurs on PA1	Not fixed	 	Atmel
SAM7S256	PMC: Programming CSS in PMC_MCKR Register Under certain rare circumstances, reprogramming the CSS value in the PMC_MCKR register (i.e switching the main clock source) might generate malfunction of the device if the following two actions occur simultaneously. 1. Switching from: â PLL Clock to Slow Clock or SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 617 â PLL Clock to Main Clock or â Main Clock to PLL Clock or â Main Clock to Slow Clock And 2. Program code is being executed out of flash, or a transition is occurring on PA1, either as an input or output. Note: This issue does not occur when transitioning from slow clock to main clock or from slow clock to PLL clock.	ARM7	 	Power Management Controller (PMC)	 	When changing CSS in the PMC_MCKR to switch from â PLL Clock to Slow Clock or â PLL Clock to Main Clock or â Main Clock to PLL Clock or â Main Clock to Slow Clock Ensure that the processor is executing out of SRAM and ensure no transition occurs on PA1, either as an input or output, starting from writing to the PMC_MCKR register until MCKRDY = 1. 40.6.7 Pulse Width Modulation Controller (PWM)	 	PMC: Programming CSS in PMC_MCKR Register	Not fixed	 	Atmel
SAM7S256	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Check the Channel Counter Register before writing the update register.	 	PWM: Update when PWM_CCNTx = 0 or 1	Not fixed	 	Atmel
SAM7S256	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not write 0 in the period register.	 	PWM: Update when PWM_CPRDx = 0	Not fixed	 	Atmel
SAM7S256	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	None.	 	PWM: Counter Start Value	Not fixed	 	Atmel
SAM7S256	PWM: Constraints on Duty Cycle Value Setting Channel Duty Cycle Register (PWM_CDTYx) at 0 in center aligned mode or at 0 or 1 in left aligned mode may change the polarity of the signal.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not set PWM_CDTYx at 0 in center aligned mode. Do not set PWM_CDTYx at 0 or 1 in left aligned mode.	 	PWM: Constraints on Duty Cycle Value	Not fixed	 	Atmel
SAM7S256	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register Erratic behavior of the CHIDx status bit in the PWM_SR Register. When a channel is disabled by writing in the PWM_DIS Register just after enabling it (before completion of a Clock Period of the clock selected for the channel), the PWM line is internally disabled but the CHIDx status bit in the PWM_SR stays at 1. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 618	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not disable a channel before completion of one period of the selected clock. 40.6.8 Real Time Timer (RTT)	 	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register	Not fixed	 	Atmel
SAM7S256	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	ARM7	 	Real Time Timer (RTT)	 	The software must handle the RTT event as an interrupt and should not poll RTT_SR.	 	RTT: Possible Event Loss when Reading RTT_SR	Not fixed	 	Atmel
SAM7S256	RTT: RTT_VR May be Corrupted Under certain rare circumstances, the Real-time Timer Value (RTT_VR) may be corrupted.	ARM7	 	Real Time Timer (RTT)	 	Use RTTINC as an increment for a software counter. 40.6.9 Serial Peripheral Interface (SPI)	 	RTT: RTT_VR May be Corrupted	Not fixed	 	Atmel
SAM7S256	SPI: Bad tx_ready Behavior when CSAAT = 1 and SCBR = 1 If the SPI is programmed with CSAAT = 1, SCBR(baudrate) = 1 and two transfers are performed consecutively on the same slave with an IDLE state between them, the tx_ready signal does not rise after the second data has been transferred in the shifter. This can imply for example, that the second data is sent twice.	ARM7	 	Serial Peripheral Interface (SPI)	 	Do not use the combination CSAAT = 1 and SCBR = 1.	 	SPI: Bad tx_ready Behavior when CSAAT = 1 and SCBR = 1	Not fixed	 	Atmel
SAM7S256	SPI: LASTXFER (Last Transfer) Behavior In FIXED Mode, with CSAAT bit set, and in âPDC modeâ the Chip Select can rise depending on the data written in the SPI_TDR when the TX_EMPTY flag is set. If for example, the PDC writes a â1â in the bit 24 (LASTXFER bit) of the SPI_TDR, the chip select will rise as soon as the TXEMPTY flag is set.	ARM7	 	Serial Peripheral Interface (SPI)	 	Use the CS in PIO mode when PDC mode is required and CS has to be maintained between transfers.	 	SPI: LASTXFER (Last Transfer) Behavior	Not fixed	 	Atmel
SAM7S256	SPI: SPCK Behavior in Master Mode SPCK pin can toggle out before the first transfer in Master Mode.	ARM7	 	Serial Peripheral Interface (SPI)	 	In Master Mode, MSTR bit must be set (in SPI_MR register) before configuring SPI_CSRx registers.	 	SPI: SPCK Behavior in Master Mode	Not fixed	 	Atmel
SAM7S256	SPI: Chip Select and Fixed Mode In fixed Mode, if a transfer is performed through a PDC on a Chip select different from the Chip select 0, the output spi_size sampled by the PDC will depend on the field, BITS (Bits per Transfer) of SPI_CSR0 register, whatever the selected Chip select is. For example, if SPI_CSR0 is configured for a 10-bit transfer whereas SPI_CSR1 is configured for an 8-bit transfer, when a transfer is performed in Fixed mode through the PDC, on Chip select 1, the transfer will be considered as a HalfWord transfer.	ARM7	 	Serial Peripheral Interface (SPI)	 	If a PDC transfer has to be performed in 8 bits, on a Chip select y (y as different from 0), the BITS field of the SPI_CSR0 must be configured in 8 bits, in the same way as the BITS field of the CSRy Register. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 619	 	SPI: Chip Select and Fixed Mode	Not fixed	 	Atmel
SAM7S256	SPI: Baudrate Set to 1 When Baudrate is set at 1 (i.e. when serial clock frequency equals the system clock frequency) and when the BITS field of the SPI_CSR register (number of bits to be transmitted) equals an ODD value (in this case 9,11,13 or 15), an additional pulse will be generated on output SPCK. Everything is OK if the BITS field equals 8,10,12,14 or 16 and Baudrate = 1.	ARM7	 	Serial Peripheral Interface (SPI)	 	None.	 	SPI: Baudrate Set to 1	Not fixed	 	Atmel
SAM7S256	SPI: Disable In Slave Mode The SPI disable is not possible in slave mode.	ARM7	 	Serial Peripheral Interface (SPI)	 	Read first the received data, then perform the software reset.	 	SPI: Disable In Slave Mode	Not fixed	 	Atmel
SAM7S256	SPI: Bad Serial Clock Generation on 2nd Chip Select Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0. This occurs using SPI with the following conditions: â¢ Master Mode â¢ CPOL = 1 and NCPHA = 0 â¢ Multiple chip selects are used with one transfer with Baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR are not equal to 1 â¢ Transmitting with the slowest chip select and then with the fastest one, then an additional on output SPCK during the second transfer. pulse is generated	ARM7	 	Serial Peripheral Interface (SPI)	 	Do not use a multiple Chip Select configuration where at least one SCRx register is configured with SCBR = 1 and the others differ from 1 if NCPHA = 0 and CPOL = 1. If all chip selects are configured with Baudrate = 1, the issue does not appear. 40.6.10 Synchronous Serial Controller (SSC)	 	SPI: Bad Serial Clock Generation on 2nd Chip Select	Not fixed	 	Atmel
SAM7S256	SSC: Periodic Transmission Limitations in Master Mode If the Least Significant Bit is sent first (MSBF = 0), the first TAG during the frame synchro is not sent.	ARM7	 	Synchronous Serial Controller (SSC)	 	None.	 	SSC: Periodic Transmission Limitations in Master Mode	Not fixed	 	Atmel
SAM7S256	SSC: Transmitter Limitations in Slave Mode If TK is programmed as output and TF is programmed as input, it is impossible to emit data when the start of edge (rising or falling) of synchro has a Start Delay equal to zero.	ARM7	 	Synchronous Serial Controller (SSC)	 	None.	 	SSC: Transmitter Limitations in Slave Mode	Not fixed	 	Atmel
SAM7S256	SSC: Transmitter Limitations in Slave Mode If TK is programmed as an input and TF is programmed as an output and requested to be set to low/high during data emission, the Frame Synchro signal is generated one bit clock period after the data start and one data bit is lost. This problem does not exist when generating a periodic synchro. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 620	ARM7	 	Synchronous Serial Controller (SSC)	 	The data need to be delayed for one bit clock period with an external assembly. In the following schematic, TD, TK and NRST are SAM7S signals, TXD is the delayed data to connect to the device. 40.6.11 Two-wire Interface (TWI)	 	SSC: Transmitter Limitations in Slave Mode	Not fixed	 	Atmel
SAM7S256	TWI: Clock Divider The value of CLDIV x 2 CKDIV must be less than or equal to 8191 the value of CHDIV x 2 CKDIV must be less than or equal to 8191	ARM7	 	Two-wire Interface (TWI)	 	None.	 	TWI: Clock Divider	Not fixed	 	Atmel
SAM7S256	TWI: Software Reset When a software reset is performed during a frame and when TWCK is low, it is impossible to initiate a new transfer in READ or WRITE mode.	ARM7	 	Two-wire Interface (TWI)	 	None.	 	TWI: Software Reset	Not fixed	 	Atmel
SAM7S256	TWI: Disabling Does not Operate Correctly Any transfer in progress is immediately frozen if the Control Register (TWI_CR) is written with the bit MSDIS at 1. Furthermore, the status bits TXCOMP and TXRDY in the Status Register (TWI_SR) are not reset.	ARM7	 	Two-wire Interface (TWI)	 	The user must wait for the end of transfer before disabling the TWI. In addition, the interrupts must be disabled before disabling the TWI.	 	TWI: Disabling Does not Operate Correctly	Not fixed	 	Atmel
SAM7S256	TWI: NACK Status Bit Lost During a master frame, if TWI_SR is read between the Non Acknowledge condition detection and the TXCOMP bit rising in the TWI_SR, the NACK bit is not set.	ARM7	 	Two-wire Interface (TWI)	 	The user must wait for the TXCOMP status bit by interrupt and must not read the TWI_SR as long as transmission is not completed. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 621 TXCOMP and NACK fields are set simultaneously and the NACK field is reset after the read of the TWI_SR.	 	TWI: NACK Status Bit Lost	Not fixed	 	Atmel
SAM7S256	TWI: Possible Receive Holding Register Corruption When loading the TWI_RHR, the transfer direction is ignored. The last data byte received in the TWI_RHR is corrupted at the end of the first subsequent transmit data byte . Neither RXRDY nor OVERRUN status bits are set if this occurs.	ARM7	 	Two-wire Interface (TWI)	 	The user must be sure that received data is read before transmitting any new data. 40.6.12 Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	TWI: Possible Receive Holding Register Corruption	Not fixed	 	Atmel
SAM7S256	USART: CTS in Hardware Handshaking When Hardware Handshaking is used and if CTS goes low near the end of the starting bit, a character can be lost.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	CTS must not go low during a time slot occurring between 2 Master Clock periods before the starting bit and 16 Master Clock periods after the rising edge of the starting bit.	 	USART: CTS in Hardware Handshaking	Not fixed	 	Atmel
SAM7S256	USART: Hardware Handshaking â Two Characters Sent If CTS switches from 0 to 1 during the TX of a character and if the holding register (US_THR) is not empty, the content of US_THR will also be transmitted.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	Don't use the PDC in transmit mode and do not fill US_THR before TXEMPTY is set at 1.	 	USART: Hardware Handshaking â Two Characters Sent	Not fixed	 	Atmel
SAM7S256	USART: XOFF Character Bad Behavior The XOFF character is sent only when the receive buffer is detected full. While the XOFF is being sent, the remote transmitter is still transmitting. As only one Holding register is available in the receiver, characters will be lost in reception. This makes the software handshaking functionality ineffective.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	None.	 	USART: XOFF Character Bad Behavior	Not fixed	 	Atmel
SAM7S256	USART: RXBRK Flag Error in Asynchronous Mode In receiver mode, when there are two consecutive characters (without timeguard in between), RXBRK is not taken into account. As a result, the RXBRK flag is not enabled correctly and the frame error flag is set.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	Constraints on the transmitter device connected to the SAM7S USART receiver side: The transmitter may use the timeguard feature or send two STOP conditions. Only one STOP condition is taken into account by the receiver state machine. After this STOP condition, as there is no valid data, the receiver state machine will go in idle mode and enable the RXBRK flag.	 	USART: RXBRK Flag Error in Asynchronous Mode	Not fixed	 	Atmel
SAM7S256	USART: DCD is active High instead of Low The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	Add an inverter. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 622 40.6.13 Voltage Regulator	 	USART: DCD is active High instead of Low	Not fixed	 	Atmel
SAM7S256	Voltage Regulator: Current Consumption in Deep Mode Current consumption in Deep Mode is maximum 60 ÂµA instead of 25 ÂµA. Due to current rejection from VDDIN to VDDCORE, the current consumption in Deep Mode cannot be guaranteed. Instead, 60 ÂµA is guaranteed whatever the condition.	ARM7	 	Voltage Regulator	 	None.	 	Voltage Regulator: Current Consumption in Deep Mode	Not fixed	 	Atmel
SAM7S256	Voltage Regulator: Load Versus Temperature Maximum load is 50 mA at 85 Â°C (instead of 100 mA). Maximum load is 100 mA at 70Â°C.	ARM7	 	Voltage Regulator	 	None. 40.6.14 Watchdog Timer (WDT)	 	Voltage Regulator: Load Versus Temperature	Not fixed	 	Atmel
SAM7S256	WDT: The Watchdog Timer May Lock the Device in a Reset State Under certain rare circumstances, if the Watchdog Timer is used with the Watchdog Reset enabled (WDRSTEN set at 1), the Watchdog Timer may lock the device in a reset state when the user restarts the watchdog (WDDRSTT). The only way to recover from this state is a power-on reset. The issue depends on the values of WDD and WDV in the WDT_MR register.	ARM7	 	Watchdog Timer (WDT)	 	Two workarounds are possible. 1. Either do not use the Watchdog Timer with the Watchdog Reset enabled (WDRSTEN set at 1), 2. or set WDD to 0xFFF and in addition use only one of the following values for WDV: 0xFFF, 0xDFF, 0xBFF, 0x9FF, 0x7FF, 0x77F, 0x6FF, 0x67F, 0x5FF, 0x57F, 0x4FF, 0x47F, 0x3FF, 0x37F, 0x2FF, 0x27F, 0x1FF, 0x1BF, 0x17F, 0x13F, 0x0FF, 0x0DF, 0x0BF, 0x09F, 0x07F, 0x06F, 0x05F, 0x04F, 0x03F, 0x037, 0x02f, 0x027, 0x01F, 0x01B, 0x017, 0x013 and 0x00F.	 	WDT: The Watchdog Timer May Lock the Device in a Reset State	Not fixed	 	Atmel
SAM7S256	WDT: The Watchdog Timer Status Register and Interrupt Under certain rare circumstances, if the Watchdog Timer is used with the Watchdog Fault Interrupt enabled (WDFIEN set at 1), the Watchdog Timer may trigger the interrupt (wdt_fault) erroneously. The Watchdog Timer Status Register may be wrong also (WDERR and WDUNF). The issue depends on the values of WDD and WDV in the WDT_MR register.	ARM7	 	Watchdog Timer (WDT)	 	Two workarounds are possible. 1. Either do not us the Watchdog Timer with the Watchdog fault Interrupt enabled (WDFIEN set at 1), 2. or set WDD to 0xFFF and in addition use only one of the following values for WDV: 0xFFF, 0xDFF, 0xBFF, 0x9FF, 0x7FF, 0x77F, 0x6FF, 0x67F, 0x5FF, 0x57F, 0x4FF, 0x47F, 0x3FF, 0x37F, 0x2FF, 0x27F, 0x1FF, 0x1BF, 0x17F, 0x13F, 0x0FF, 0x0DF, 0x0BF, 0x09F, 0x07F, 0x06F, 0x05F, 0x04F, 0x03F, 0x037, 0x02f, 0x027, 0x01F, 0x01B, 0x017, 0x013 and 0x00F. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 623 40.7 SAM7S256 Errata - Revision A Parts Refer to Section 40.1 âMarkingâ on page 595. Important: Section 40.7.13.1 âWDT: The Watchdog Timer May Lock the Device in a Reset Stateâ 40.7.1 Chip ID	 	WDT: The Watchdog Timer Status Register and Interrupt	Not fixed	 	Atmel
SAM7S256	Wrong Chip ID Value The Chip ID is 0x270D 0940 instead of 0x270B 0940.	ARM7	 	Chip ID	 	None. 40.7.2 Analog-to-Digital Converter (ADC)	 	Wrong Chip ID Value	Not fixed	 	Atmel
SAM7S256	ADC: DRDY Bit Cleared The DRDY Flag should be clear only after a read of ADC_LCDR (Last Converted Data Register). A read of any ADC_CDRx register (Channel Data Register) automatically clears the DRDY flag.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: DRDY Bit Cleared	Not fixed	 	Atmel
SAM7S256	ADC: DRDY not Cleared on Disable When reading LCDR at the same instant as an end of conversion, with DRDY already active, DRDY is kept active regardless of the enable status of the current channel. This sets DRDY, whereas new data is not stored.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: DRDY not Cleared on Disable	Not fixed	 	Atmel
SAM7S256	ADC: DRDY Possibly Skipped due to CDR Read Reading CDR for channel âyâ at the same instant as an end of conversion on channel âxâ with EOC[x] already active, leads to skipping to set the DRDY flag if channel âxâ is enabled.	ARM7	 	Analog-to-Digital Converter (ADC)	 	Use of DRDY functionality with access to CDR registers should be avoided.	 	ADC: DRDY Possibly Skipped due to CDR Read	Not fixed	 	Atmel
SAM7S256	ADC: Possible Skip on DRDY when Disabling a Channel DRDY does not rise when disabling channel âyâ at the same time as an end of âxâ channel conversion, although data is stored into CDRx and LCDR.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None.	 	ADC: Possible Skip on DRDY when Disabling a Channel	Not fixed	 	Atmel
SAM7S256	ADC: GOVRE Bit is not Updated Read of the Status Register at the same instant as an end of conversion leads to skipping the update of the GOVRE (general overrun) flag. GOVRE is neither reset nor set. For example, if reading the status while an end of conversion is occurring and: 1. GOVRE is active but DRDY is inactive, does not correspond to a new general overrun condition but the GOVRE flag is not reset. 2. GOVRE is inactive but DRDY is active, does correspond to a new general overrun condition but the GOVRE flag is not set.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 624	 	ADC: GOVRE Bit is not Updated	Not fixed	 	Atmel
SAM7S256	ADC: GOVRE Bit is not Set when Reading CDR When reading CDRy (Channel Data Register y) at the same instant as an end of conversion on channel âxâ with the following conditions: â¢ EOC[x] already active, â¢ DRDY already active, â¢ GOVRE inactive, â¢ previous data stored in LCDR being neither data from channel âyâ, nor data from channel âxâ. GOVRE should be set but is not.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Set when Reading CDR	Not fixed	 	Atmel
SAM7S256	ADC: GOVRE Bit is not Set when Disabling a Channel When disabling channel âyâ at the same instant as an end of conversion on channel âxâ, EOC[x] and DRDY being already active, GOVRE does not rise. Note: OVRE[x] rises as expected.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Set when Disabling a Channel	Not fixed	 	Atmel
SAM7S256	ADC: OVRE Flag Behavior When the OVRE flag (on channel i) has been set but the related EOC status (of channel i) has been cleared (by a read of CDRi or LCDR), reading the Status register at the same instant as an end of conversion (causing the set of EOC status on channel i), does not lead to a reset of the OVRE flag (on channel i) as expected.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: OVRE Flag Behavior	Not fixed	 	Atmel
SAM7S256	ADC: EOC Set although Channel Disabled If a channel is disabled while a conversi on is running and if a read of CDR is performed at the same time as an end of conversion of any channel occurs, the EOC of the channel with the conversion running may rise (whereas it has been disabled).	ARM7	 	Analog-to-Digital Converter (ADC)	 	Do not take into account the EOC of a disabled channel	 	ADC: EOC Set although Channel Disabled	Not fixed	 	Atmel
SAM7S256	ADC: Spurious Clear of EOC Flag If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ nor âyâ), reading CDR on channel âzâ at the same instant as an end of conversion on channel âyâ automatically clears EOC[x] instead of EOC[z].	ARM7	 	Analog-to-Digital Converter (ADC)	 	None.	 	ADC: Spurious Clear of EOC Flag	Not fixed	 	Atmel
SAM7S256	ADC: Sleep Mode If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	ARM7	 	Analog-to-Digital Converter (ADC)	 	To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit field); to start an analog-to-digital conversion, in order put ADC into sleep mode at the end of this conversion. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 625 40.7.3 Non Volatile Memory Bits (NVM Bits)	 	ADC: Sleep Mode	Not fixed	 	Atmel
SAM7S256	NVM Bits: Write/Erase Cycles Number The maximum number of write/erase cycles for Non Volatile Memory bits is 100. This includes Lock Bits (LOCKx), General Purpose NVM bits (GPNVMx) and the Security Bit. This maximum number of write/erase cycles is not applic able to 256 KB Flash memory, it remains at 10K for the Flash memory.	ARM7	 	Non Volatile Memory Bits (NVM Bits)	 	None. 40.7.4 Parallel Input/Output Controller (PIO)	 	NVM Bits: Write/Erase Cycles Number	Not fixed	 	Atmel
SAM7S256	PIO: Leakage on PA17 - PA20 When PA17, PA18, PA19 or PA20 (the I/O lines multiplexed with the analog inputs) are set as digital inputs with pull-up disabled, the leakage can be 9 ÂµA in worst case and 90 nA in typical case per I/O when the I/O is set externally at low level.	ARM7	 	Parallel Input/Output Controller (PIO)	 	Set the I/O to VDDIO by internal or external pull-up.	 	PIO: Leakage on PA17 - PA20	Not fixed	 	Atmel
SAM7S256	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31 When NRST or PA0-PA16 or PA21-PA31 are set as digital inputs with pull-up enabled, the voltage of the I/O stabilizes at VPull-up. Vpull-up VPull-up Min VPull-up Max VDDIO - 0.65 V VDDIO - 0.45 V This condition causes a leakage through VDDIO. This leakage is 45 ÂµA per pad in worst case at 3.3 V and 25 ÂµA at 1.8V. I Leakage Parameter Typ Max I Leakage at 3,3V 2.5 ÂµA 45 ÂµA I Leakage at 1.8V 1 ÂµA 25 ÂµA	ARM7	 	Parallel Input/Output Controller (PIO)	 	It is recommended to use an external pull-up if needed.	 	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31	Not fixed	 	Atmel
SAM7S256	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31 When NRST or PA0-PA16 and or PA21-PA31 are set as digital inputs with pull-up enabled, driving the I/O with an output impedance higher than 500 ohms may not drive the I/O to a logical zero.	ARM7	 	Parallel Input/Output Controller (PIO)	 	Output impedance must be lower than 500 ohms. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 626 40.7.5 Power Management Controller (PMC)	 	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31	Not fixed	 	Atmel
SAM7S256	PMC: Slow Clock Selected in PMC and a Transition Occurs on PA1 Under certain rare circumstances, when CSS = 00 in PMC_MCKR, and PA1 is set as an input and a transition occurs on PA1, device malfunction might occur.	ARM7	 	Power Management Controller (PMC)	 	Do not transition PA1 as an input when CSS = 00 in PMC_MCKR.	 	PMC: Slow Clock Selected in PMC and a Transition Occurs on PA1	Not fixed	 	Atmel
SAM7S256	PMC: Programming CSS in PMC_MCKR Register Under certain rare circumstances, reprogramming the CSS value in the PMC_MCKR register (i.e switching the main clock source) might generate malfunction of the device if the following two actions occur simultaneously. 1. Switching from: â PLL Clock to Slow Clock or â PLL Clock to Main Clock or â Main Clock to PLL Clock or â Main Clock to Slow Clock And 2. Program code is being executed out of flash, or a transition is occurring on PA1, either as an input or output. Note: This issue does not occur when transitioning from slow clock to main clock or from slow clock to PLL clock.	ARM7	 	Power Management Controller (PMC)	 	When changing CSS in the PMC_MCKR to switch from â PLL Clock to Slow Clock or â PLL Clock to Main Clock or â Main Clock to PLL Clock or â Main Clock to Slow Clock Ensure that the processor is executing out of SRAM and ensure no transition occurs on PA1, either as an input or output, starting from writing to the PMC_MCKR register until MCKRDY = 1. 40.7.6 Pulse Width Modulation Controller (PWM)	 	PMC: Programming CSS in PMC_MCKR Register	Not fixed	 	Atmel
SAM7S256	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Check the Channel Counter Register before writing the update register.	 	PWM: Update when PWM_CCNTx = 0 or 1	Not fixed	 	Atmel
SAM7S256	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not write 0 in the period register.	 	PWM: Update when PWM_CPRDx = 0	Not fixed	 	Atmel
SAM7S256	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 627 None.	 	PWM: Counter Start Value	Not fixed	 	Atmel
SAM7S256	PWM: Constraints on Duty Cycle Value Setting Channel Duty Cycle Register (PWM_CDTYx) at 0 in center aligned mode or at 0 or 1 in left aligned mode may change the polarity of the signal.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not set PWM_CDTYx at 0 in center aligned mode. Do not set PWM_CDTYx at 0 or 1 in left aligned mode.	 	PWM: Constraints on Duty Cycle Value	Not fixed	 	Atmel
SAM7S256	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register Erratic behavior of the CHIDx status bit in the PWM_SR Register. When a channel is disabled by writing in the PWM_DIS Register just after enabling it (before completion of a Clock Period of the clock selected for the channel), the PWM line is internally disabled but the CHIDx status bit in the PWM_SR stays at 1.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not disable a channel before completion of one period of the selected clock. 40.7.7 Real Time Timer (RTT)	 	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register	Not fixed	 	Atmel
SAM7S256	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	ARM7	 	Real Time Timer (RTT)	 	The software must handle the RTT event as an interrupt and should not poll RTT_SR.	 	RTT: Possible Event Loss when Reading RTT_SR	Not fixed	 	Atmel
SAM7S256	RTT: RTT_VR May be Corrupted Under certain rare circumstances, the Real-time Timer Value (RTT_VR) may be corrupted.	ARM7	 	Real Time Timer (RTT)	 	Use RTTINC as an increment for a software counter. 40.7.8 Serial Peripheral Interface (SPI)	 	RTT: RTT_VR May be Corrupted	Not fixed	 	Atmel
SAM7S256	SPI: Bad tx_ready Behavior when CSAAT = 1 and SCBR = 1 If the SPI is programmed with CSAAT = 1, SCBR(baudrate) = 1 and two transfers are performed consecutively on the same slave with an IDLE state between them, the tx_ready signal does not rise after the second data has been transferred in the shifter. This can imply for example, that the second data is sent twice.	ARM7	 	Serial Peripheral Interface (SPI)	 	Do not use the combination CSAAT = 1 and SCBR = 1.	 	SPI: Bad tx_ready Behavior when CSAAT = 1 and SCBR = 1	Not fixed	 	Atmel
SAM7S256	SPI: LASTXFER (Last Transfer) Behavior In FIXED Mode, with CSAAT bit set, and in âPDC modeâ the Chip Select can rise depending on the data written in the SPI_TDR when the TX_EMPTY flag is set. If for example, the PDC writes a â1â in the bit 24 (LASTXFER bit) of the SPI_TDR, the chip select will rise as soon as the TXEMPTY flag is set.	ARM7	 	Serial Peripheral Interface (SPI)	 	Use the CS in PIO mode when PDC mode is required and CS has to be maintained between transfers.	 	SPI: LASTXFER (Last Transfer) Behavior	Not fixed	 	Atmel
SAM7S256	SPI: SPCK Behavior in Master Mode SPCK pin can toggle out before the first transfer in Master Mode. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 628	ARM7	 	Serial Peripheral Interface (SPI)	 	In Master Mode, MSTR bit must be set (in SPI_MR register) before configuring SPI_CSRx registers.	 	SPI: SPCK Behavior in Master Mode	Not fixed	 	Atmel
SAM7S256	SPI: Chip Select and Fixed Mode In fixed Mode, if a transfer is performed through a PDC on a Chip select different from the Chip select 0, the output spi_size sampled by the PDC will depend on the field, BITS (Bits per Transfer) of SPI_CSR0 register, whatever the selected Chip select is. For example, if SPI_CSR0 is configured for a 10-bit transfer whereas SPI_CSR1 is configured for an 8-bit transfer, when a transfer is performed in Fixed mode through the PDC, on Chip select 1, the transfer will be considered as a HalfWord transfer.	ARM7	 	Serial Peripheral Interface (SPI)	 	If a PDC transfer has to be performed in 8 bits, on a Chip select y (y as different from 0), the BITS field of the SPI_CSR0 must be configured in 8 bits, in the same way as the BITS field of the CSRy Register.	 	SPI: Chip Select and Fixed Mode	Not fixed	 	Atmel
SAM7S256	SPI: Baudrate Set to 1 When Baudrate is set at 1 (i.e. when serial clock frequency equals the system clock frequency) and when the BITS field of the SPI_CSR register (number of bits to be transmitted) equals an ODD value (in this case 9,11,13 or 15), an additional pulse will be generated on output SPCK. Everything is OK if the BITS field equals 8,10,12,14 or 16 and Baudrate = 1.	ARM7	 	Serial Peripheral Interface (SPI)	 	None.	 	SPI: Baudrate Set to 1	Not fixed	 	Atmel
SAM7S256	SPI: Disable In Slave Mode The SPI disable is not possible in slave mode.	ARM7	 	Serial Peripheral Interface (SPI)	 	Read first the received data, then perform the software reset.	 	SPI: Disable In Slave Mode	Not fixed	 	Atmel
SAM7S256	SPI: Bad Serial Clock Generation on 2nd Chip Select Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0. This occurs using SPI with the following conditions: â¢ Master Mode â¢ CPOL = 1 and NCPHA = 0 â¢ Multiple chip selects are used with one transfer with Baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR are not equal to 1 â¢ Transmitting with the slowest chip select and then with the fastest one, then an additional on output SPCK during the second transfer. pulse is generated	ARM7	 	Serial Peripheral Interface (SPI)	 	Do not use a multiple Chip Select configuration where at least one SCRx register is configured with SCBR = 1 and the others differ from 1 if NCPHA = 0 and CPOL = 1. If all chip selects are configured with Baudrate = 1, the issue does not appear. 40.7.9 Synchronous Serial Controller (SSC)	 	SPI: Bad Serial Clock Generation on 2nd Chip Select	Not fixed	 	Atmel
SAM7S256	SSC: Periodic Transmission Limitations in Master Mode If the Least Significant Bit is sent first (MSBF = 0), the first TAG during the frame synchro is not sent.	ARM7	 	Synchronous Serial Controller (SSC)	 	SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 629 None.	 	SSC: Periodic Transmission Limitations in Master Mode	Not fixed	 	Atmel
SAM7S256	SSC: Transmitter Limitations in Slave Mode If TK is programmed as output and TF is programmed as input, it is impossible to emit data when the start of edge (rising or falling) of synchro has a Start Delay equal to zero.	ARM7	 	Synchronous Serial Controller (SSC)	 	None.	 	SSC: Transmitter Limitations in Slave Mode	Not fixed	 	Atmel
SAM7S256	SSC: Transmitter Limitations in Slave Mode If TK is programmed as an input and TF is programmed as an output and requested to be set to low/high during data emission, the Frame Synchro signal is generated one bit clock period after the data start and one data bit is lost. This problem does not exist when generating a periodic synchro.	ARM7	 	Synchronous Serial Controller (SSC)	 	The data need to be delayed for one bit clock period with an external assembly. In the following schematic, TD, TK and NRST are SAM7S signals, TXD is the delayed data to connect to the device. 40.7.10 Two-wire Interface (TWI)	 	SSC: Transmitter Limitations in Slave Mode	Not fixed	 	Atmel
SAM7S256	TWI: Clock Divider The value of CLDIV x 2 CKDIV must be less than or equal to 8191 the value of CHDIV x 2 CKDIV must be less than or equal to 8191	ARM7	 	Two-wire Interface (TWI)	 	None.	 	TWI: Clock Divider	Not fixed	 	Atmel
SAM7S256	TWI: Software Reset when a software reset is performed during a frame and when TWCK is low, it is impossible to initiate a new transfer in READ or WRITE mode.	ARM7	 	Two-wire Interface (TWI)	 	None. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 630	 	TWI: Software Reset	Not fixed	 	Atmel
SAM7S256	TWI: Disabling Does not Operate Correctly Any transfer in progress is immediately frozen if the Control Register (TWI_CR) is written with the bit MSDIS at 1. Furthermore, the status bits TXCOMP and TXRDY in the Status Register (TWI_SR) are not reset.	ARM7	 	Two-wire Interface (TWI)	 	The user must wait for the end of transfer before disabling the TWI. In addition, the interrupts must be disabled before disabling the TWI.	 	TWI: Disabling Does not Operate Correctly	Not fixed	 	Atmel
SAM7S256	TWI: NACK Status Bit Lost During a master frame, if TWI_SR is read between the Non Acknowledge condition detection and the TXCOMP bit rising in the TWI_SR, the NACK bit is not set.	ARM7	 	Two-wire Interface (TWI)	 	The user must wait for the TXCOMP status bit by interrupt and must not read the TWI_SR as long as transmission is not completed. TXCOMP and NACK fields are set simultaneously and the NACK field is reset after the read of the TWI_SR.	 	TWI: NACK Status Bit Lost	Not fixed	 	Atmel
SAM7S256	TWI: Possible Receive Holding Register Corruption When loading the TWI_RHR, the transfer direction is ignored. The last data byte received in the TWI_RHR is corrupted at the end of the first subsequent transmit data byte . Neither RXRDY nor OVERRUN status bits are set if this occurs.	ARM7	 	Two-wire Interface (TWI)	 	The user must be sure that received data is read before transmitting any new data. 40.7.11 Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	TWI: Possible Receive Holding Register Corruption	Not fixed	 	Atmel
SAM7S256	USART: CTS in Hardware Handshaking When Hardware Handshaking is used and if CTS goes low near the end of the starting bit, a character can be lost.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	CTS must not go low during a time slot occurring between 2 Master Clock periods before the starting bit and 16 Master Clock periods after the rising edge of the starting bit.	 	USART: CTS in Hardware Handshaking	Not fixed	 	Atmel
SAM7S256	USART: Hardware Handshaking â Two Characters Sent If CTS switches from 0 to 1 during the TX of a character and if the holding register (US_THR) is not empty, the content of US_THR will also be transmitted.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	Don't use the PDC in transmit mode and do not fill US_THR before TXEMPTY is set at 1.	 	USART: Hardware Handshaking â Two Characters Sent	Not fixed	 	Atmel
SAM7S256	USART: XOFF Character Bad Behavior The XOFF character is sent only when the receive buffer is detected full. While the XOFF is being sent, the remote transmitter is still transmitting. As only one Holding register is available in the receiver, characters will be lost in reception. This makes the software handshaking functionality ineffective.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	None.	 	USART: XOFF Character Bad Behavior	Not fixed	 	Atmel
SAM7S256	USART: RXBRK Flag Error in Asynchronous Mode In receiver mode, when there are two consecutive characters (without timeguard in between), RXBRK is not taken into account. As a result, the RXBRK flag is not enabled correctly and the frame error flag is set.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 631 Constraints on the transmitter device connected to the SAM7S USART receiver side: The transmitter may use the timeguard feature or send two STOP conditions. Only one STOP condition is taken into account by the receiver state machine. After this STOP condition, as there is no valid data, the receiver state machine will go in idle mode and enable the RXBRK flag.	 	USART: RXBRK Flag Error in Asynchronous Mode	Not fixed	 	Atmel
SAM7S256	USART: DCD is active High instead of Low The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	Add an inverter. 40.7.12 Voltage Regulator	 	USART: DCD is active High instead of Low	Not fixed	 	Atmel
SAM7S256	Voltage Regulator: Current Consumption in Deep Mode Current consumption in Deep Mode is maximum 60 ÂµA instead of 25 ÂµA. Due to current rejection from VDDIN to VDDCORE, the current consumption in Deep Mode cannot be guaranteed. Instead, 60 ÂµA is guaranteed whatever the condition.	ARM7	 	Voltage Regulator	 	None.	 	Voltage Regulator: Current Consumption in Deep Mode	Not fixed	 	Atmel
SAM7S256	Voltage Regulator: Load Versus Temperature Maximum load is 50 mA at 85 Â°C (instead of 100 mA). Maximum load is 100 mA at 70Â°C.	ARM7	 	Voltage Regulator	 	None. 40.7.13 Watchdog Timer (WDT)	 	Voltage Regulator: Load Versus Temperature	Not fixed	 	Atmel
SAM7S256	WDT: The Watchdog Timer May Lock the Device in a Reset State Under certain rare circumstances, if the Watchdog Timer is used with the Watchdog Reset enabled (WDRSTEN set at 1), the Watchdog Timer may lock the device in a reset state when the user restarts the watchdog (WDDRSTT). The only way to recover from this state is a power-on reset. The issue depends on the values of WDD and WDV in the WDT_MR register.	ARM7	 	Watchdog Timer (WDT)	 	Two workarounds are possible. 1. Either do not use the Watchdog Timer with the Watchdog Reset enabled (WDRSTEN set at 1), 2. or set WDD to 0xFFF and in addition use only one of the following values for WDV: 0xFFF, 0xDFF, 0xBFF, 0x9FF, 0x7FF, 0x77F, 0x6FF, 0x67F, 0x5FF, 0x57F, 0x4FF, 0x47F, 0x3FF, 0x37F, 0x2FF, 0x27F, 0x1FF, 0x1BF, 0x17F, 0x13F, 0x0FF, 0x0DF, 0x0BF, 0x09F, 0x07F, 0x06F, 0x05F, 0x04F, 0x03F, 0x037, 0x02f, 0x027, 0x01F, 0x01B, 0x017, 0x013 and 0x00F.	 	WDT: The Watchdog Timer May Lock the Device in a Reset State	Not fixed	 	Atmel
SAM7S256	WDT: The Watchdog Timer Status Register and Interrupt Under certain rare circumstances, if the Watchdog Timer is used with the Watchdog Fault Interrupt enabled (WDFIEN set at 1), the Watchdog Timer may trigger the interrupt (wdt_fault) erroneously. The Watchdog Timer Status Register may be wrong also (WDERR and WDUNF). The issue depends on the values of WDD and WDV in the WDT_MR register. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 632	ARM7	 	Watchdog Timer (WDT)	 	Two workarounds are possible. 1. Either do not use the Watchdog Timer with the Watchdog fault Interrupt enabled (WDFIEN set at 1), 2. or set WDD to 0xFFF and in addition use only one of the following values for WDV: 0xFFF, 0xDFF, 0xBFF, 0x9FF, 0x7FF, 0x77F, 0x6FF, 0x67F, 0x5FF, 0x57F, 0x4FF, 0x47F, 0x3FF, 0x37F, 0x2FF, 0x27F, 0x1FF, 0x1BF, 0x17F, 0x13F, 0x0FF, 0x0DF, 0x0BF, 0x09F, 0x07F, 0x06F, 0x05F, 0x04F, 0x03F, 0x037, 0x02f, 0x027, 0x01F, 0x01B, 0x017, 0x013 and 0x00F. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 633 40.8 SAM7S256 Errata - Revision B Parts Refer to Section 40.1 âMarkingâ on page 595. Note: AT91SAM7S256 Revision B chip ID is 0x270B 0941. 40.8.1 Analog-to-Digital Converter (ADC)	 	WDT: The Watchdog Timer Status Register and Interrupt	Not fixed	 	Atmel
SAM7S256	ADC: DRDY Bit Cleared The DRDY Flag should be clear only after a read of ADC_LCDR (Last Converted Data Register). A read of any ADC_CDRx register (Channel Data Register) automatically clears the DRDY flag.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: DRDY Bit Cleared	Not fixed	 	Atmel
SAM7S256	ADC: DRDY not Cleared on Disable When reading LCDR at the same instant as an end of conversion, with DRDY already active, DRDY is kept active regardless of the enable status of the current channel. This sets DRDY, whereas new data is not stored.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: DRDY not Cleared on Disable	Not fixed	 	Atmel
SAM7S256	ADC: DRDY Possibly Skipped due to CDR Read Reading CDR for channel âyâ at the same instant as an end of conversion on channel âxâ with EOC[x] already active, leads to skipping to set the DRDY flag if channel âxâ is enabled.	ARM7	 	Analog-to-Digital Converter (ADC)	 	Use of DRDY functionality with access to CDR registers should be avoided.	 	ADC: DRDY Possibly Skipped due to CDR Read	Not fixed	 	Atmel
SAM7S256	ADC: Possible Skip on DRDY when Disabling a Channel DRDY does not rise when disabling channel âyâ at the same time as an end of âxâ channel conversion, although data is stored into CDRx and LCDR.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None.	 	ADC: Possible Skip on DRDY when Disabling a Channel	Not fixed	 	Atmel
SAM7S256	ADC: GOVRE Bit is not Updated Read of the Status Register at the same instant as an end of conversion leads to skipping the update of the GOVRE (general overrun) flag. GOVRE is neither reset nor set. For example, if reading the status while an end of conversion is occurring and: 1. GOVRE is active but DRDY is inactive, does not correspond to a new general overrun condition but the GOVRE flag is not reset. 2. GOVRE is inactive but DRDY is active, does correspond to a new general overrun condition but the GOVRE flag is not set.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Updated	Not fixed	 	Atmel
SAM7S256	ADC: GOVRE Bit is not Set when Reading CDR When reading CDRy (Channel Data Register y) at the same instant as an end of conversion on channel âxâ with the following conditions: â¢ EOC[x] already active, â¢ DRDY already active, SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 634 â¢ GOVRE inactive, â¢ previous data stored in LCDR being neither data from channel âyâ, nor data from channel âxâ. GOVRE should be set but is not.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Set when Reading CDR	Not fixed	 	Atmel
SAM7S256	ADC: GOVRE Bit is not Set when Disabling a Channel When disabling channel âyâ at the same instant as an end of conversion on channel âxâ, EOC[x] and DRDY being already active, GOVRE does not rise. Note: OVRE[x] rises as expected.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Set when Disabling a Channel	Not fixed	 	Atmel
SAM7S256	ADC: OVRE Flag Behavior When the OVRE flag (on channel i) has been set but the related EOC status (of channel i) has been cleared (by a read of CDRi or LCDR), reading the Status register at the same instant as an end of conversion (causing the set of EOC status on channel i), does not lead to a reset of the OVRE flag (on channel i) as expected.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: OVRE Flag Behavior	Not fixed	 	Atmel
SAM7S256	ADC: EOC Set although Channel Disabled If a channel is disabled while a conversi on is running and if a read of CDR is performed at the same time as an end of conversion of any channel occurs, the EOC of the channel with the conversion running may rise (whereas it has been disabled).	ARM7	 	Analog-to-Digital Converter (ADC)	 	Do not take into account the EOC of a disabled channel	 	ADC: EOC Set although Channel Disabled	Not fixed	 	Atmel
SAM7S256	ADC: Spurious Clear of EOC Flag If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ nor âyâ), reading CDR on channel âzâ at the same instant as an end of conversion on channel âyâ automatically clears EOC[x] instead of EOC[z].	ARM7	 	Analog-to-Digital Converter (ADC)	 	None.	 	ADC: Spurious Clear of EOC Flag	Not fixed	 	Atmel
SAM7S256	ADC: Sleep Mode If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	ARM7	 	Analog-to-Digital Converter (ADC)	 	To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit field); to start an analog-to-digital conversion, in order put ADC into sleep mode at the end of this conversion. 40.8.2 Non Volatile Memory Bits (NVM Bits)	 	ADC: Sleep Mode	Not fixed	 	Atmel
SAM7S256	NVM Bits: Write/Erase Cycles Number The maximum number of write/erase cycles for Non Volatile Memory bits is 100. This includes Lock Bits (LOCKx), General Purpose NVM bits (GPNVMx) and the Security Bit. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 635 This maximum number of write/erase cycles is not applic able to 256 KB Flash memory, it remains at 10K for the Flash memory.	ARM7	 	Non Volatile Memory Bits (NVM Bits)	 	None. 40.8.3 Parallel Input/Output Controller (PIO)	 	NVM Bits: Write/Erase Cycles Number	Not fixed	 	Atmel
SAM7S256	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31 When NRST or PA0-PA16 or PA21-PA31 are set as digital inputs with pull-up enabled, the voltage of the I/O stabilizes at VPull-up. Vpull-up VPull-up Min VPull-up Max VDDIO - 0.65 V VDDIO - 0.45 V This condition causes a leakage through VDDIO. This leakage is 45 ÂµA per pad in worst case at 3.3 V and 25 ÂµA at 1.8V. I Leakage Parameter Typ Max I Leakage at 3,3V 2.5 ÂµA 45 ÂµA I Leakage at 1.8V 1 ÂµA 25 ÂµA	ARM7	 	Parallel Input/Output Controller (PIO)	 	It is recommended to use an external pull-up if needed.	 	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31	Not fixed	 	Atmel
SAM7S256	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31 When NRST or PA0-PA16 and or PA21-PA31 are set as digital inputs with pull-up enabled, driving the I/O with an output impedance higher than 500 ohms may not drive the I/O to a logical zero.	ARM7	 	Parallel Input/Output Controller (PIO)	 	Output impedance must be lower than 500 ohms. 40.8.4 Pulse Width Modulation Controller (PWM)	 	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31	Not fixed	 	Atmel
SAM7S256	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Check the Channel Counter Register before writing the update register.	 	PWM: Update when PWM_CCNTx = 0 or 1	Not fixed	 	Atmel
SAM7S256	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not write 0 in the period register.	 	PWM: Update when PWM_CPRDx = 0	Not fixed	 	Atmel
SAM7S256	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 636	ARM7	 	Pulse Width Modulation Controller (PWM)	 	None.	 	PWM: Counter Start Value	Not fixed	 	Atmel
SAM7S256	PWM: Constraints on Duty Cycle Value Setting Channel Duty Cycle Register (PWM_CDTYx) at 0 in center aligned mode or at 0 or 1 in left aligned mode may change the polarity of the signal.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not set PWM_CDTYx at 0 in center aligned mode. Do not set PWM_CDTYx at 0 or 1 in left aligned mode.	 	PWM: Constraints on Duty Cycle Value	Not fixed	 	Atmel
SAM7S256	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register Erratic behavior of the CHIDx status bit in the PWM_SR Register. When a channel is disabled by writing in the PWM_DIS Register just after enabling it (before completion of a Clock Period of the clock selected for the channel), the PWM line is internally disabled but the CHIDx status bit in the PWM_SR stays at 1.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not disable a channel before completion of one period of the selected clock. 40.8.5 Real Time Timer (RTT)	 	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register	Not fixed	 	Atmel
SAM7S256	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	ARM7	 	Real Time Timer (RTT)	 	The software must handle the RTT event as an interrupt and should not poll RTT_SR. 40.8.6 Serial Peripheral Interface (SPI)	 	RTT: Possible Event Loss when Reading RTT_SR	Not fixed	 	Atmel
SAM7S256	SPI: Software Reset Must be Written Twice If a software reset (SWRSTin the SPI Control Register) is performed, the SPI may not work properly (the clock is enabled before the chip select.	ARM7	 	Serial Peripheral Interface (SPI)	 	The SPI Control Register field, SWRST needs to be written twice to be set correctly.	 	SPI: Software Reset Must be Written Twice	Not fixed	 	Atmel
SAM7S256	SPI: Bad tx_ready Behavior when CSAAT = 1 and SCBR = 1 If the SPI is programmed with CSAAT = 1, SCBR(baudrate) = 1 and two transfers are performed consecutively on the same slave with an IDLE state between them, the tx_ready signal does not rise after the second data has been transferred in the shifter. This can imply for example, that the second data is sent twice.	ARM7	 	Serial Peripheral Interface (SPI)	 	Do not use the combination CSAAT = 1 and SCBR = 1.	 	SPI: Bad tx_ready Behavior when CSAAT = 1 and SCBR = 1	Not fixed	 	Atmel
SAM7S256	SPI: LASTXFER (Last Transfer) Behavior In FIXED Mode, with CSAAT bit set, and in âPDC modeâ the Chip Select can rise depending on the data written in the SPI_TDR when the TX_EMPTY flag is set. If for example, the PDC writes a â1â in the bit 24 (LASTXFER bit) of the SPI_TDR, the chip select will rise as soon as the TXEMPTY flag is set.	ARM7	 	Serial Peripheral Interface (SPI)	 	Use the CS in PIO mode when PDC mode is required and CS has to be maintained between transfers. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 637	 	SPI: LASTXFER (Last Transfer) Behavior	Not fixed	 	Atmel
SAM7S256	SPI: SPCK Behavior in Master Mode SPCK pin can toggle out before the first transfer in Master Mode.	ARM7	 	Serial Peripheral Interface (SPI)	 	In Master Mode, MSTR bit must be set (in SPI_MR register) before configuring SPI_CSRx registers.	 	SPI: SPCK Behavior in Master Mode	Not fixed	 	Atmel
SAM7S256	SPI: Chip Select and Fixed Mode In fixed Mode, if a transfer is performed through a PDC on a Chip select different from the Chip select 0, the output spi_size sampled by the PDC will depend on the field, BITS (Bits per Transfer) of SPI_CSR0 register, whatever the selected Chip select is. For example, if SPI_CSR0 is configured for a 10-bit transfer whereas SPI_CSR1 is configured for an 8-bit transfer, when a transfer is performed in Fixed mode through the PDC, on Chip select 1, the transfer will be considered as a HalfWord transfer.	ARM7	 	Serial Peripheral Interface (SPI)	 	If a PDC transfer has to be performed in 8 bits, on a Chip select y (y as different from 0), the BITS field of the SPI_CSR0 must be configured in 8 bits, in the same way as the BITS field of the CSRy Register.	 	SPI: Chip Select and Fixed Mode	Not fixed	 	Atmel
SAM7S256	SPI: Baudrate Set to 1 When Baudrate is set at 1 (i.e. when serial clock frequency equals the system clock frequency) and when the BITS field of the SPI_CSR register (number of bits to be transmitted) equals an ODD value (in this case 9,11,13 or 15), an additional pulse will be generated on output SPCK. Everything is OK if the BITS field equals 8,10,12,14 or 16 and Baudrate = 1.	ARM7	 	Serial Peripheral Interface (SPI)	 	None.	 	SPI: Baudrate Set to 1	Not fixed	 	Atmel
SAM7S256	SPI: Disable In Slave Mode The SPI disable is not possible in slave mode.	ARM7	 	Serial Peripheral Interface (SPI)	 	Read first the received data, then perform the software reset.	 	SPI: Disable In Slave Mode	Not fixed	 	Atmel
SAM7S256	SPI: Bad Serial Clock Generation on 2nd Chip Select Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0. This occurs using SPI with the following conditions: â¢ Master Mode â¢ CPOL = 1 and NCPHA = 0 â¢ Multiple chip selects are used with one transfer with Baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR are not equal to 1 â¢ Transmitting with the slowest chip select and then with the fastest one, then an additional on output SPCK during the second transfer. pulse is generated	ARM7	 	Serial Peripheral Interface (SPI)	 	Do not use a multiple Chip Select configuration where at least one SCRx register is configured with SCBR = 1 and the others differ from 1 if NCPHA = 0 and CPOL = 1. If all chip selects are configured with Baudrate = 1, the issue does not appear. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 638 40.8.7 Synchronous Serial Controller (SSC)	 	SPI: Bad Serial Clock Generation on 2nd Chip Select	Not fixed	 	Atmel
SAM7S256	SSC: Periodic Transmission Limitations in Master Mode If the Least Significant Bit is sent first (MSBF = 0), the first TAG during the frame synchro is not sent.	ARM7	 	Synchronous Serial Controller (SSC)	 	None.	 	SSC: Periodic Transmission Limitations in Master Mode	Not fixed	 	Atmel
SAM7S256	SSC: Transmitter Limitations in Slave Mode If TK is programmed as output and TF is programmed as input, it is impossible to emit data when the start of edge (rising or falling) of synchro has a Start Delay equal to zero.	ARM7	 	Synchronous Serial Controller (SSC)	 	None.	 	SSC: Transmitter Limitations in Slave Mode	Not fixed	 	Atmel
SAM7S256	SSC: Transmitter Limitations in Slave Mode If TK is programmed as an input and TF is programmed as an output and requested to be set to low/high during data emission, the Frame Synchro signal is generated one bit clock period after the data start and one data bit is lost. This problem does not exist when generating a periodic synchro.	ARM7	 	Synchronous Serial Controller (SSC)	 	The data need to be delayed for one bit clock period with an external assembly. In the following schematic, TD, TK and NRST are SAM7S signals, TXD is the delayed data to connect to the device. 40.8.8 Two-wire Interface (TWI)	 	SSC: Transmitter Limitations in Slave Mode	Not fixed	 	Atmel
SAM7S256	TWI: Clock Divider The value of CLDIV x 2 CKDIV must be less than or equal to 8191 the value of CHDIV x 2 CKDIV must be less than or equal to 8191	ARM7	 	Two-wire Interface (TWI)	 	None. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 639	 	TWI: Clock Divider	Not fixed	 	Atmel
SAM7S256	TWI: Software Reset when a software reset is performed during a frame and when TWCK is low, it is impossible to initiate a new transfer in READ or WRITE mode.	ARM7	 	Two-wire Interface (TWI)	 	None.	 	TWI: Software Reset	Not fixed	 	Atmel
SAM7S256	TWI: Disabling Does not Operate Correctly Any transfer in progress is immediately frozen if the Control Register (TWI_CR) is written with the bit MSDIS at 1. Furthermore, the status bits TXCOMP and TXRDY in the Status Register (TWI_SR) are not reset.	ARM7	 	Two-wire Interface (TWI)	 	The user must wait for the end of transfer before disabling the TWI. In addition, the interrupts must be disabled before disabling the TWI.	 	TWI: Disabling Does not Operate Correctly	Not fixed	 	Atmel
SAM7S256	TWI: NACK Status Bit Lost During a master frame, if TWI_SR is read between the Non Acknowledge condition detection and the TXCOMP bit rising in the TWI_SR, the NACK bit is not set.	ARM7	 	Two-wire Interface (TWI)	 	The user must wait for the TXCOMP status bit by interrupt and must not read the TWI_SR as long as transmission is not completed. TXCOMP and NACK fields are set simultaneously and the NACK field is reset after the read of the TWI_SR.	 	TWI: NACK Status Bit Lost	Not fixed	 	Atmel
SAM7S256	TWI: Possible Receive Holding Register Corruption When loading the TWI_RHR, the transfer direction is ignored. The last data byte received in the TWI_RHR is corrupted at the end of the first subsequent transmit data byte . Neither RXRDY nor OVERRUN status bits are set if this occurs.	ARM7	 	Two-wire Interface (TWI)	 	The user must be sure that received data is read before transmitting any new data. 40.8.9 Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	TWI: Possible Receive Holding Register Corruption	Not fixed	 	Atmel
SAM7S256	USART: CTS in Hardware Handshaking When Hardware Handshaking is used and if CTS goes low near the end of the starting bit, a character can be lost.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	CTS must not go low during a time slot occurring between 2 Master Clock periods before the starting bit and 16 Master Clock periods after the rising edge of the starting bit.	 	USART: CTS in Hardware Handshaking	Not fixed	 	Atmel
SAM7S256	USART: Hardware Handshaking â Two Characters Sent If CTS switches from 0 to 1 during the TX of a character and if the holding register (US_THR) is not empty, the content of US_THR will also be transmitted.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	Don't use the PDC in transmit mode and do not fill US_THR before TXEMPTY is set at 1.	 	USART: Hardware Handshaking â Two Characters Sent	Not fixed	 	Atmel
SAM7S256	USART: XOFF Character Bad Behavior The XOFF character is sent only when the receive buffer is detected full. While the XOFF is being sent, the remote transmitter is still transmitting. As only one Holding register is available in the receiver, characters will be lost in reception. This makes the software handshaking functionality ineffective.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 640 None.	 	USART: XOFF Character Bad Behavior	Not fixed	 	Atmel
SAM7S256	USART: RXBRK Flag Error in Asynchronous Mode In receiver mode, when there are two consecutive characters (without timeguard in between), RXBRK is not taken into account. As a result, the RXBRK flag is not enabled correctly and the frame error flag is set.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	Constraints on the transmitter device connected to the SAM7S USART receiver side: The transmitter may use the timeguard feature or send two STOP conditions. Only one STOP condition is taken into account by the receiver state machine. After this STOP condition, as there is no valid data, the receiver state machine will go in idle mode and enable the RXBRK flag.	 	USART: RXBRK Flag Error in Asynchronous Mode	Not fixed	 	Atmel
SAM7S256	USART: DCD is active High instead of Low The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	Add an inverter. 40.8.10 Voltage Regulator	 	USART: DCD is active High instead of Low	Not fixed	 	Atmel
SAM7S256	Voltage Regulator: Current Consumption in Deep Mode Current consumption in Deep Mode is maximum 60 ÂµA instead of 25 ÂµA. Due to current rejection from VDDIN to VDDCORE, the current consumption in Deep Mode cannot be guaranteed. Instead, 60 ÂµA is guaranteed whatever the condition.	ARM7	 	Voltage Regulator	 	None.	 	Voltage Regulator: Current Consumption in Deep Mode	Not fixed	 	Atmel
SAM7S256	Voltage Regulator: Load Versus Temperature Maximum load is 50 mA at 85 Â°C (instead of 100 mA). Maximum load is 100 mA at 70Â°C.	ARM7	 	Voltage Regulator	 	None. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 641 40.9 SAM7S256 Errata - Revision C Parts Refer to Section 40.1 âMarkingâ on page 595. Note: AT91SAM7S256 Revision C chip ID is 0x270B 0942. 40.9.1 Embedded Flash Controller (EFC)	 	Voltage Regulator: Load Versus Temperature	Not fixed	 	Atmel
SAM7S256	EFC: Embedded Flash Access Time 1 The embedded Flash maximum access time is 20 MHz (instead of 30 MHz) at zero Wait State (FWS = 0). The maximum operating frequency with one Wait State (FWS = 1) is 48.1 MHz (instead of 55 MHz). Above 48.1 MHz and up to 55 MHz, two Wait States (FWS = 2) are required.	ARM7	 	Embedded Flash Controller (EFC)	 	Set the number of Wait States (FWS) according to the frequency requirements described in this errata. 40.9.2 Parallel Input/Output Controller (PIO)	 	EFC: Embedded Flash Access Time 1	Not fixed	 	Atmel
SAM7S256	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31 When NRST or PA0-PA16 or PA21-PA31 are set as digital inputs with pull-up enabled, the voltage of the I/O stabilizes at VPull-up. Vpull-up VPull-up Min VPull-up Max VDDIO - 0.65 V VDDIO - 0.45 V This condition causes a leakage through VDDIO. This leakage is 45 ÂµA per pad in worst case at 3.3 V, and 25 ÂµA at 1.8V. I Leakage Parameter Typ Max I Leakage at 3,3V 2.5 ÂµA 45 ÂµA I Leakage at 1.8V 1 ÂµA 25 ÂµA	ARM7	 	Parallel Input/Output Controller (PIO)	 	It is recommended to use an external pull-up if needed.	 	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31	Not fixed	 	Atmel
SAM7S256	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31 When NRST or PA0-PA16 and or PA21-PA31 are set as digital inputs with pull-up enabled, driving the I/O with an output impedance higher than 500 ohms may not drive the I/O to a logical zero.	ARM7	 	Parallel Input/Output Controller (PIO)	 	Output impedance must be lower than 500 ohms. 40.9.3 Pulse Width Modulation Controller (PWM)	 	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31	Not fixed	 	Atmel
SAM7S256	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Check the Channel Counter Register before writing the update register. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 642	 	PWM: Update when PWM_CCNTx = 0 or 1	Not fixed	 	Atmel
SAM7S256	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not write 0 in the period register.	 	PWM: Update when PWM_CPRDx = 0	Not fixed	 	Atmel
SAM7S256	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	None. 40.9.4 Real Time Timer (RTT)	 	PWM: Counter Start Value	Not fixed	 	Atmel
SAM7S256	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	ARM7	 	Real Time Timer (RTT)	 	The software must handle the RTT event as an interrupt and should not poll RTT_SR. 40.9.5 USART: Universal Synchronous Asynchronous Receiver Transmitter	 	RTT: Possible Event Loss when Reading RTT_SR	Not fixed	 	Atmel
SAM7S256	USART: DCD is active High instead of Low The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	ARM7	 	USART: Universal Synchronous Asynchronous Receiver Transmitter	 	Add an inverter. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 643 40.10 SAM7S256 Errata - Revision D Parts Refer to Section 40.1 âMarkingâ on page 595. Note: AT91SAM7S256 Revision D chip ID is 0x270B0943. 40.10.1 Embedded Flash Controller (EFC)	 	USART: DCD is active High instead of Low	Not fixed	 	Atmel
SAM7S256	EFC: Embedded Flash Access Time 1 The embedded Flash maximum access time is 20 MHz (instead of 30 MHz) at zero Wait State (FWS = 0). The maximum operating frequency with one Wait State (FWS = 1) is 48.1 MHz (instead of 55 MHz). Above 48.1 MHz and up to 55 MHz, two Wait States (FWS = 2) are required.	ARM7	 	Embedded Flash Controller (EFC)	 	Set the number of Wait States (FWS) according to the frequency requirements described in this errata. 40.10.2 Parallel Input/Output Controller (PIO)	 	EFC: Embedded Flash Access Time 1	Not fixed	 	Atmel
SAM7S256	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31 When NRST or PA0-PA16 or PA21-PA31 are set as digital inputs with pull-up enabled, the voltage of the I/O stabilizes at VPull-up. Vpull-up VPull-up Min VPull-up Max VDDIO - 0.65 V VDDIO - 0.45 V This condition causes a leakage through VDDIO. This leakage is 45 ÂµA per pad in worst case at 3.3 V, and 25 ÂµA at 1.8V. I Leakage Parameter Typ Max I Leakage at 3,3V 2.5 ÂµA 45 ÂµA I Leakage at 1.8V 1 ÂµA 25 ÂµA	ARM7	 	Parallel Input/Output Controller (PIO)	 	It is recommended to use an external pull-up if needed.	 	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31	Not fixed	 	Atmel
SAM7S256	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31 When NRST or PA0-PA16 and or PA21-PA31 are set as digital inputs with pull-up enabled, driving the I/O with an output impedance higher than 500 ohms may not drive the I/O to a logical zero.	ARM7	 	Parallel Input/Output Controller (PIO)	 	Output impedance must be lower than 500 ohms. 40.10.3 Pulse Width Modulation Controller (PWM)	 	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31	Not fixed	 	Atmel
SAM7S256	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Check the Channel Counter Register before writing the update register. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 644	 	PWM: Update when PWM_CCNTx = 0 or 1	Not fixed	 	Atmel
SAM7S256	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not write 0 in the period register.	 	PWM: Update when PWM_CPRDx = 0	Not fixed	 	Atmel
SAM7S256	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	None. 40.10.4 Real Time Timer (RTT)	 	PWM: Counter Start Value	Not fixed	 	Atmel
SAM7S256	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	ARM7	 	Real Time Timer (RTT)	 	The software must handle the RTT event as an interrupt and should not poll RTT_SR. 40.10.5 USART: Universal Synchronous Asynchronous Receiver Transmitter	 	RTT: Possible Event Loss when Reading RTT_SR	Not fixed	 	Atmel
SAM7S256	USART: DCD is active High instead of Low The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	ARM7	 	USART: Universal Synchronous Asynchronous Receiver Transmitter	 	Add an inverter. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 645 40.11 SAM7S128 Errata - Manufacturing Number 58818C Refer to Section 40.1 âMarkingâ on page 595. Important: Section 40.11.14.1 âWDT: The Watchdog Timer May Lock the Device in a Reset Stateâ 40.11.1 Chip ID	 	USART: DCD is active High instead of Low	Not fixed	 	Atmel
SAM7S128	Wrong Chip ID Value The Chip ID is 0x270C0740 instead of 0x270A0740.	ARM7	 	Chip ID	 	None. 40.11.2 Analog-to-Digital Converter (ADC)	 	Wrong Chip ID Value	Not fixed	 	Atmel
SAM7S128	ADC: DRDY Bit Cleared The DRDY Flag should be clear only after a read of ADC_LCDR (Last Converted Data Register). A read of any ADC_CDRx register (Channel Data Register) automatically clears the DRDY flag.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: DRDY Bit Cleared	Not fixed	 	Atmel
SAM7S128	ADC: DRDY not Cleared on Disable When reading LCDR at the same instant as an end of conversion, with DRDY already active, DRDY is kept active regardless of the enable status of the current channel. This sets DRDY, whereas new data is not stored.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: DRDY not Cleared on Disable	Not fixed	 	Atmel
SAM7S128	ADC: DRDY Possibly Skipped due to CDR Read Reading CDR for channel âyâ at the same instant as an end of conversion on channel âxâ with EOC[x] already active, leads to skipping to set the DRDY flag if channel âxâ is enabled.	ARM7	 	Analog-to-Digital Converter (ADC)	 	Use of DRDY functionality with access to CDR registers should be avoided.	 	ADC: DRDY Possibly Skipped due to CDR Read	Not fixed	 	Atmel
SAM7S128	ADC: Possible Skip on DRDY when Disabling a Channel DRDY does not rise when disabling channel âyâ at the same time as an end of âxâ channel conversion, although data is stored into CDRx and LCDR.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None.	 	ADC: Possible Skip on DRDY when Disabling a Channel	Not fixed	 	Atmel
SAM7S128	ADC: GOVRE Bit is not Updated Read of the Status Register at the same instant as an end of conversion leads to skipping the update of the GOVRE (general overrun) flag. GOVRE is neither reset nor set. For example, if reading the status while an end of conversion is occurring and: 1. GOVRE is active but DRDY is inactive, does not correspond to a new general overrun condition but the GOVRE flag is not reset. 2. GOVRE is inactive but DRDY is active, does correspond to a new general overrun condition but the GOVRE flag is not set.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 646	 	ADC: GOVRE Bit is not Updated	Not fixed	 	Atmel
SAM7S128	ADC: GOVRE Bit is not Set when Reading CDR When reading CDRy (Channel Data Register y) at the same instant as an end of conversion on channel âxâ with the following conditions: â¢ EOC[x] already active, â¢ DRDY already active, â¢ GOVRE inactive, â¢ previous data stored in LCDR being neither data from channel âyâ, nor data from channel âxâ. GOVRE should be set but is not.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Set when Reading CDR	Not fixed	 	Atmel
SAM7S128	ADC: GOVRE Bit is not Set when Disabling a Channel When disabling channel âyâ at the same instant as an end of conversion on channel âxâ, EOC[x] and DRDY being already active, GOVRE does not rise. Note: OVRE[x] rises as expected.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Set when Disabling a Channel	Not fixed	 	Atmel
SAM7S128	ADC: OVRE Flag Behavior When the OVRE flag (on channel i) has been set but the related EOC status (of channel i) has been cleared (by a read of CDRi or LCDR), reading the Status register at the same instant as an end of conversion (causing the set of EOC status on channel i), does not lead to a reset of the OVRE flag (on channel i) as expected.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: OVRE Flag Behavior	Not fixed	 	Atmel
SAM7S128	ADC: EOC Set although Channel Disabled If a channel is disabled while a conversi on is running and if a read of CDR is performed at the same time as an end of conversion of any channel occurs, the EOC of the channel with the conversion running may rise (whereas it has been disabled).	ARM7	 	Analog-to-Digital Converter (ADC)	 	Do not take into account the EOC of a disabled channel	 	ADC: EOC Set although Channel Disabled	Not fixed	 	Atmel
SAM7S128	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ nor âyâ), reading CDR on channel âzâ at the same instant as an end of conversion on channel âyâ automatically clears EOC[x] instead of EOC[z].	ARM7	 	Analog-to-Digital Converter (ADC)	 	None.	 	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ	Not fixed	 	Atmel
SAM7S128	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	ARM7	 	Analog-to-Digital Converter (ADC)	 	To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit field); to start an analog-to-digital conversion, in order put ADC into sleep mode at the end of this conversion. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 647 40.11.3 Master Clock (MCK)	 	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after	Not fixed	 	Atmel
SAM7S128	MCK: Limited Master Clock Frequency Ranges If the Flash is operating without wait states, the frequency of the Master Clock MCK must be lower than 3 MHz or higher than 19 MHz. If the Flash is operating with one wait state, the frequency of the Master Clock MCK must be lower than 3 MHz or higher than 19 MHz. If the Flash is operating with two wait states, the frequency of the Master Clock MCK must be lower than 3 MHz or higher than 25 MHz. If the Flash is operating with three wait states, the frequency of the Master Clock MCK must be lower than 3 MHz or higher than 38 MHz. If these constraints are not respected, the correct operation of the system cannot be guaranteed and either data or prefetch abort might occur. The maximum operating frequencies (at 30 MHz @ 0 Wait States and 55 MHz @ 1 Wait State) as stated in Table 37-24, âEmbedded Flash Wait States,â on page 582, are still applicable. Note: It is not necessary to use 2 o 3 wait states because t he Flash can operate at maximum frequency with only 1 wait state.	ARM7	 	Master Clock (MCK)	 	The user must ensure that the device is running at the authorized frequency by programming the PLL properly to not run within the forbidden frequency range. 40.11.4 Non Volatile Memory Bits (NVM Bits)	 	MCK: Limited Master Clock Frequency Ranges	Not fixed	 	Atmel
SAM7S128	NVM Bits: Write/Erase Cycles Number The maximum number of write/erase cycles for Non Volatile Memory bits is 100. This includes Lock Bits (LOCKx), General Purpose NVM bits (GPNVMx) and the Security Bit. This maximum number of write/erase cycles is not applic able to 128 KB Flash memory, it remains at 10K for the Flash memory.	ARM7	 	Non Volatile Memory Bits (NVM Bits)	 	None. 40.11.5 Parallel Input/Output Controller (PIO)	 	NVM Bits: Write/Erase Cycles Number	Not fixed	 	Atmel
SAM7S128	PIO: Leakage on PA17 - PA20 When PA17, PA18, PA19 or PA20 (the I/O lines multiplexed with the analog inputs) are set as digital inputs with pull-up disabled, the leakage can be 9 ÂµA in worst case and 90 nA in typical case per I/O when the I/O is set externally at low level.	ARM7	 	Parallel Input/Output Controller (PIO)	 	Set the I/O to VDDIO by internal or external pull-up.	 	PIO: Leakage on PA17 - PA20	Not fixed	 	Atmel
SAM7S128	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31 When NRST or PA0-PA16 or PA21-PA31 are set as digital inputs with pull-up enabled, the voltage of the I/O stabilizes at VPull-up. Vpull-up VPull-up Min VPull-up Max VDDIO - 0.65 V VDDIO - 0.45 V SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 648 This condition causes a leakage through VDDIO. This leakage is 45 ÂµA per pad in worst case at 3.3 V and 25 ÂµA at 1.8V. I Leakage Parameter Typ Max I Leakage at 3,3V 2.5 ÂµA 45 ÂµA I Leakage at 1.8V 1 ÂµA 25 ÂµA	ARM7	 	Parallel Input/Output Controller (PIO)	 	It is recommended to use an external pull-up if needed.	 	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31	Not fixed	 	Atmel
SAM7S128	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31 When NRST or PA0-PA16 and or PA21-PA31 are set as digital inputs with pull-up enabled, driving the I/O with an output impedance higher than 500 ohms may not drive the I/O to a logical zero.	ARM7	 	Parallel Input/Output Controller (PIO)	 	Output impedance must be lower than 500 ohms. 40.11.6 Power Management Controller (PMC)	 	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31	Not fixed	 	Atmel
SAM7S128	PMC: Slow Clock Selected in PMC and a Transition Occurs on PA1 Under certain rare circumstances, when CSS = 00 in PMC_MCKR, and PA1 is set as an input and a transition occurs on PA1, device malfunction might occur.	ARM7	 	Power Management Controller (PMC)	 	Do not transition PA1 as an input when CSS = 00 in PMC_MCKR.	 	PMC: Slow Clock Selected in PMC and a Transition Occurs on PA1	Not fixed	 	Atmel
SAM7S128	PMC: Programming CSS in PMC_MCKR Register Under certain rare circumstances, reprogramming the CSS value in the PMC_MCKR register (i.e switching the main clock source) might generate malfunction of the device if the following two actions occur simultaneously. 1. Switching from: â PLL Clock to Slow Clock or â PLL Clock to Main Clock or â Main Clock to PLL Clock or â Main Clock to Slow Clock And 2. Program code is being executed out of flash, or a transition is occurring on PA1, either as an input or output. Note: This issue does not occur when transitioning from slow clock to main clock or from slow clock to PLL clock.	ARM7	 	Power Management Controller (PMC)	 	When changing CSS in the PMC_MCKR to switch from â PLL Clock to Slow Clock or â PLL Clock to Main Clock or â Main Clock to PLL Clock or â Main Clock to Slow Clock Ensure that the processor is executing out of SRAM and ensure no transition occurs on PA1, either as an input or output, starting from writing to the PMC_MCKR register until MCKRDY = 1. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 649 40.11.7 Pulse Width Modulation Controller (PWM)	 	PMC: Programming CSS in PMC_MCKR Register	Not fixed	 	Atmel
SAM7S128	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Check the Channel Counter Register before writing the update register.	 	PWM: Update when PWM_CCNTx = 0 or 1	Not fixed	 	Atmel
SAM7S128	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not write 0 in the period register.	 	PWM: Update when PWM_CPRDx = 0	Not fixed	 	Atmel
SAM7S128	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	None.	 	PWM: Counter Start Value	Not fixed	 	Atmel
SAM7S128	PWM: Constraints on Duty Cycle Value Setting Channel Duty Cycle Register (PWM_CDTYx) at 0 in center aligned mode or at 0 or 1 in left aligned mode may change the polarity of the signal.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not set PWM_CDTYx at 0 in center aligned mode. Do not set PWM_CDTYx at 0 or 1 in left aligned mode.	 	PWM: Constraints on Duty Cycle Value	Not fixed	 	Atmel
SAM7S128	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register Erratic behavior of the CHIDx status bit in the PWM_SR Register. When a channel is disabled by writing in the PWM_DIS Register just after enabling it (before completion of a Clock Period of the clock selected for the channel), the PWM line is internally disabled but the CHIDx status bit in the PWM_SR stays at 1.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not disable a channel before completion of one period of the selected clock. 40.11.8 Real Time Timer (RTT)	 	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register	Not fixed	 	Atmel
SAM7S128	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	ARM7	 	Real Time Timer (RTT)	 	The software must handle the RTT event as an interrupt and should not poll RTT_SR.	 	RTT: Possible Event Loss when Reading RTT_SR	Not fixed	 	Atmel
SAM7S128	RTT: RTT_VR May be Corrupted Under certain rare circumstances, the Real-time Timer Value (RTT_VR) may be corrupted.	ARM7	 	Real Time Timer (RTT)	 	Use RTTINC as an increment for a software counter. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 650 40.11.9 Serial Peripheral Interface (SPI)	 	RTT: RTT_VR May be Corrupted	Not fixed	 	Atmel
SAM7S128	SPI: Bad tx_ready behavior when CSAAT = 1 and SCBR = 1 If the SPI is programmed with CSAAT = 1, SCBR(baudrate) = 1 and two transfers are performed consecutively on the same slave with an IDLE state between them, the tx_ready signal does not rise after the second data has been transferred in the shifter. This can imply for example, that the second data is sent twice.	ARM7	 	Serial Peripheral Interface (SPI)	 	Do not use the combination CSAAT = 1 and SCBR = 1.	 	SPI: Bad tx_ready behavior when CSAAT = 1 and SCBR = 1	Not fixed	 	Atmel
SAM7S128	SPI: LASTXFER (Last Transfer) behavior In FIXED Mode, with CSAAT bit set, and in âPDC modeâ the Chip Select can rise depending on the data written in the SPI_TDR when the TX_EMPTY flag is set. If for example, the PDC writes a â1â in the bit 24 (LASTXFER bit) of the SPI_TDR, the chip select will rise as soon as the TXEMPTY flag is set.	ARM7	 	Serial Peripheral Interface (SPI)	 	Use the CS in PIO mode when PDC mode is required and CS has to be maintained between transfers.	 	SPI: LASTXFER (Last Transfer) behavior	Not fixed	 	Atmel
SAM7S128	SPI: SPCK Behavior in Master Mode SPCK pin can toggle out before the first transfer in Master Mode.	ARM7	 	Serial Peripheral Interface (SPI)	 	In Master Mode, MSTR bit must be set (in SPI_MR register) before configuring SPI_CSRx registers.	 	SPI: SPCK Behavior in Master Mode	Not fixed	 	Atmel
SAM7S128	SPI: Chip Select and Fixed Mode In fixed Mode, if a transfer is performed through a PDC on a Chip select different from the Chip select 0, the output spi_size sampled by the PDC will depend on the field, BITS (Bits per Transfer) of SPI_CSR0 register, whatever the selected Chip select is. For example, if SPI_CSR0 is configured for a 10-bit transfer whereas SPI_CSR1 is configured for an 8-bit transfer, when a transfer is performed in Fixed mode through the PDC, on Chip select 1, the transfer will be considered as a HalfWord transfer.	ARM7	 	Serial Peripheral Interface (SPI)	 	If a PDC transfer has to be performed in 8 bits, on a Chip select y (y as different from 0), the BITS field of the SPI_CSR0 must be configured in 8 bits, in the same way as the BITS field of the CSRy Register.	 	SPI: Chip Select and Fixed Mode	Not fixed	 	Atmel
SAM7S128	SPI: Baudrate Set to 1 When Baudrate is set at 1 (i.e. when serial clock frequency equals the system clock frequency) and when the BITS field of the SPI_CSR register (number of bits to be transmitted) equals an ODD value (in this case 9,11,13 or 15), an additional pulse will be generated on output SPCK. Everything is OK if the BITS field equals 8,10,12,14 or 16 and Baudrate = 1.	ARM7	 	Serial Peripheral Interface (SPI)	 	None.	 	SPI: Baudrate Set to 1	Not fixed	 	Atmel
SAM7S128	SPI: Disable In Slave Mode The SPI disable is not possible in slave mode.	ARM7	 	Serial Peripheral Interface (SPI)	 	Read first the received data, then perform the software reset.	 	SPI: Disable In Slave Mode	Not fixed	 	Atmel
SAM7S128	SPI: Bad Serial Clock Generation on 2nd Chip Select Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 651 This occurs using SPI with the following conditions: â¢ Master Mode â¢ CPOL = 1 and NCPHA = 0 â¢ Multiple chip selects are used with one transfer with Baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR are not equal to 1 â¢ Transmitting with the slowest chip select and then with the fastest one, then an additional on output SPCK during the second transfer. pulse is generated	ARM7	 	Serial Peripheral Interface (SPI)	 	Do not use a multiple Chip Select configuration where at least one SCRx register is configured with SCBR = 1 and the others differ from 1 if NCPHA = 0 and CPOL = 1. If all chip selects are configured with Baudrate = 1, the issue does not appear. 40.11.10 Synchronous Serial Controller (SSC)	 	SPI: Bad Serial Clock Generation on 2nd Chip Select	Not fixed	 	Atmel
SAM7S128	If the Least Significant Bit is sent first (MSBF = 0), the first TAG during the frame synchro is not sent.	ARM7	 	Synchronous Serial Controller (SSC)	 	None.	 	If the Least Significant Bit is sent first (MSBF = 0), the first TAG during the frame synchro is not sent.	Not fixed	 	Atmel
SAM7S128	If TK is programmed as output and TF is programmed as input, it is impossible to emit data when the start of edge (rising or falling) of synchro has a Start Delay equal to zero.	ARM7	 	Synchronous Serial Controller (SSC)	 	None.	 	If TK is programmed as output and TF is programmed as input, it is impossible to emit data when the start of edge	Not fixed	 	Atmel
SAM7S128	If TK is programmed as an input and TF is programmed as an output and requested to be set to low/high during data emission, the Frame Synchro signal is generated one bit clock period after the data start and one data bit is lost. This problem does not exist when generating a periodic synchro.	ARM7	 	Synchronous Serial Controller (SSC)	 	The data need to be delayed for one bit clock period with an external assembly. In the following schematic, TD, TK and NRST are SAM7S signals, TXD is the delayed data to connect to the device. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 652 40.11.11 Two-wire Interface (TWI)	 	If TK is programmed as an input and TF is programmed as an output and requested to be set to low/high during	Not fixed	 	Atmel
SAM7S128	The value of CLDIV x 2 CKDIV must be less than or equal to 8191 the value of CHDIV x 2 CKDIV must be less than or equal to 8191	ARM7	 	Two-wire Interface (TWI)	 	None.	 	The value of CLDIV x 2 CKDIV must be less than or equal to 8191 the value of CHDIV x 2 CKDIV must be less than or	Not fixed	 	Atmel
SAM7S128	When a software reset is performed during a frame and when TWCK is low, it is impossible to initiate a new transfer in READ or WRITE mode.	ARM7	 	Two-wire Interface (TWI)	 	None.	 	When a software reset is performed during a frame and when TWCK is low, it is impossible to initiate a new transfer in READ or WRITE mode.	Not fixed	 	Atmel
SAM7S128	Any transfer in progress is immediately frozen if the Control Register (TWI_CR) is written with the bit MSDIS at 1. Furthermore, the status bits TXCOMP and TXRDY in the Status Register (TWI_SR) are not reset.	ARM7	 	Two-wire Interface (TWI)	 	The user must wait for the end of transfer before disabling the TWI. In addition, the interrupts must be disabled before disabling the TWI.	 	Any transfer in progress is immediately frozen if the Control Register (TWI_CR) is written with the bit MSDIS at 1.	Not fixed	 	Atmel
SAM7S128	During a master frame, if TWI_SR is read between the Non Acknowledge condition detection and the TXCOMP bit rising in the TWI_SR, the NACK bit is not set.	ARM7	 	Two-wire Interface (TWI)	 	The user must wait for the TXCOMP status bit by interrupt and must not read the TWI_SR as long as transmission is not completed. TXCOMP and NACK fields are set simultaneously and the NACK field is reset after the read of the TWI_SR. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 653	 	During a master frame, if TWI_SR is read between the Non Acknowledge condition detection and the TXCOMP bit	Not fixed	 	Atmel
SAM7S128	When loading the TWI_RHR, the transfer direction is ignored. The last data byte received in the TWI_RHR is corrupted at the end of the first subsequent transmit data byte . Neither RXRDY nor OVERRUN status bits are set if this occurs.	ARM7	 	Two-wire Interface (TWI)	 	The user must be sure that received data is read before transmitting any new data. 40.11.12 USART: Universal Synchronous Asynchronous Receiver Transmitter	 	When loading the TWI_RHR, the transfer direction is ignored. The last data byte received in the TWI_RHR is corrupted at the end of the first subsequent transmit data byte . Neither RXRDY nor OVERRUN status bits are set if	Not fixed	 	Atmel
SAM7S128	When Hardware Handshaking is used and if CTS goes low near the end of the starting bit, a character can be lost.	ARM7	 	USART: Universal Synchronous Asynchronous Receiver Transmitter	 	CTS must not go low during a time slot occurring between 2 Master Clock periods before the starting bit and 16 Master Clock periods after the rising edge of the starting bit.	 	When Hardware Handshaking is used and if CTS goes low near the end of the starting bit, a character can be lost.	Not fixed	 	Atmel
SAM7S128	If CTS switches from 0 to 1 during the TX of a character and if the holding register (US_THR) is not empty, the content of US_THR will also be transmitted.	ARM7	 	USART: Universal Synchronous Asynchronous Receiver Transmitter	 	Don't use the PDC in transmit mode and do not fill US_THR before TXEMPTY is set at 1.	 	If CTS switches from 0 to 1 during the TX of a character and if the holding register (US_THR) is not empty, the content of US_THR will also be transmitted.	Not fixed	 	Atmel
SAM7S128	The XOFF character is sent only when the receive buffer is detected full. While the XOFF is being sent, the remote transmitter is still transmitting. As only one Holding register is available in the receiver, characters will be lost in reception. This makes the software handshaking functionality ineffective.	ARM7	 	USART: Universal Synchronous Asynchronous Receiver Transmitter	 	None.	 	The XOFF character is sent only when the receive buffer is detected full. While the XOFF is being sent, the remote	Not fixed	 	Atmel
SAM7S128	In receiver mode, when there are two consecutive characters (without timeguard in between), RXBRK is not taken into account. As a result, the RXBRK flag is not enabled correctly and the frame error flag is set.	ARM7	 	USART: Universal Synchronous Asynchronous Receiver Transmitter	 	Constraints on the transmitter device connected to the SAM7S USART receiver side: The transmitter may use the timeguard feature or send two STOP conditions. Only one STOP condition is taken into account by the receiver state machine. After this STOP condition, as there is no valid data, the receiver state machine will go in idle mode and enable the RXBRK flag.	 	In receiver mode, when there are two consecutive characters (without timeguard in between), RXBRK is not taken	Not fixed	 	Atmel
SAM7S128	The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	ARM7	 	USART: Universal Synchronous Asynchronous Receiver Transmitter	 	Add an inverter. 40.11.13 Voltage Regulator	 	The DCD signal is active at High level in the USART Modem Mode.	Not fixed	 	Atmel
SAM7S128	Current consumption in Deep Mode is maximum 60 ÂµA instead of 25 ÂµA. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 654 Due to current rejection from VDDIN to VDDCORE, the current consumption in Deep Mode cannot be guaranteed. Instead, 60 ÂµA is guaranteed whatever the condition.	ARM7	 	Voltage Regulator	 	None.	 	Current consumption in Deep Mode is maximum 60 ÂµA instead of 25 ÂµA.	Not fixed	 	Atmel
SAM7S128	Maximum load is 50 mA at 85 Â°C (instead of 100 mA). Maximum load is 100 mA at 70Â°C.	ARM7	 	Voltage Regulator	 	None. 40.11.14 Watchdog Timer (WDT)	 	Maximum load is 50 mA at 85 Â°C (instead of 100 mA).	Not fixed	 	Atmel
SAM7S128	Under certain rare circumstances, if the Watchdog Timer is used with the Watchdog Reset enabled (WDRSTEN set at 1), the Watchdog Timer may lock the device in a reset state when the user restarts the watchdog (WDDRSTT). The only way to recover from this state is a power-on reset. The issue depends on the values of WDD and WDV in the WDT_MR register.	ARM7	 	Watchdog Timer (WDT)	 	Two workarounds are possible. 1. Either do not use the Watchdog Timer with the Watchdog Reset enabled (WDRSTEN set at 1), 2. or set WDD to 0xFFF and in addition use only one of the following values for WDV: 0xFFF, 0xDFF, 0xBFF, 0x9FF, 0x7FF, 0x77F, 0x6FF, 0x67F, 0x5FF, 0x57F, 0x4FF, 0x47F, 0x3FF, 0x37F, 0x2FF, 0x27F, 0x1FF, 0x1BF, 0x17F, 0x13F, 0x0FF, 0x0DF, 0x0BF, 0x09F, 0x07F, 0x06F, 0x05F, 0x04F, 0x03F, 0x037, 0x02f, 0x027, 0x01F, 0x01B, 0x017, 0x013 and 0x00F.	 	Under certain rare circumstances, if the Watchdog Timer is used with the Watchdog Reset enabled (WDRSTEN	Not fixed	 	Atmel
SAM7S128	Under certain rare circumstances, if the Watchdog Timer is used with the Watchdog Fault Interrupt enabled (WDFIEN set at 1), the Watchdog Timer may trigger the interrupt (wdt_fault) erroneously. The Watchdog Timer Status Register may be wrong also (WDERR and WDUNF). The issue depends on the values of WDD and WDV in the WDT_MR register.	ARM7	 	Watchdog Timer (WDT)	 	Two workarounds are possible. 1. Either do not use the Watchdog Timer with the Watchdog fault Interrupt enabled (WDFIEN set at 1), 2. or set WDD to 0xFFF and in addition use only one of the following values for WDV: 0xFFF, 0xDFF, 0xBFF, 0x9FF, 0x7FF, 0x77F, 0x6FF, 0x67F, 0x5FF, 0x57F, 0x4FF, 0x47F, 0x3FF, 0x37F, 0x2FF, 0x27F, 0x1FF, 0x1BF, 0x17F, 0x13F, 0x0FF, 0x0DF, 0x0BF, 0x09F, 0x07F, 0x06F, 0x05F, 0x04F, 0x03F, 0x037, 0x02f, 0x027, 0x01F, 0x01B, 0x017, 0x013 and 0x00F. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 655 40.12 SAM7S128 Errata - Revision A Parts Refer to Section 40.1 âMarkingâ on page 595. Important: Section 40.12.13.1 âWDT: The Watchdog Timer May Lock the Device in a Reset Stateâ 40.12.1 Chip ID	 	Under certain rare circumstances, if the Watchdog Timer is used with the Watchdog Fault Interrupt enabled	Not fixed	 	Atmel
SAM7S128	Wrong Chip ID Value The Chip ID is 0x270C 0740 instead of 0x270A 0740.	ARM7	 	Chip ID	 	None. 40.12.2 Analog-to-Digital Converter (ADC)	 	Wrong Chip ID Value	Not fixed	 	Atmel
SAM7S128	ADC: DRDY Bit Cleared The DRDY Flag should be clear only after a read of ADC_LCDR (Last Converted Data Register). A read of any ADC_CDRx register (Channel Data Register) automatically clears the DRDY flag.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: DRDY Bit Cleared	Not fixed	 	Atmel
SAM7S128	ADC: DRDY not Cleared on Disable When reading LCDR at the same instant as an end of conversion, with DRDY already active, DRDY is kept active regardless of the enable status of the current channel. This sets DRDY, whereas new data is not stored.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: DRDY not Cleared on Disable	Not fixed	 	Atmel
SAM7S128	ADC: DRDY Possibly Skipped due to CDR Read Reading CDR for channel âyâ at the same instant as an end of conversion on channel âxâ with EOC[x] already active, leads to skipping to set the DRDY flag if channel âxâ is enabled.	ARM7	 	Analog-to-Digital Converter (ADC)	 	Use of DRDY functionality with access to CDR registers should be avoided.	 	ADC: DRDY Possibly Skipped due to CDR Read	Not fixed	 	Atmel
SAM7S128	ADC: Possible Skip on DRDY when Disabling a Channel DRDY does not rise when disabling channel âyâ at the same time as an end of âxâ channel conversion, although data is stored into CDRx and LCDR.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None.	 	ADC: Possible Skip on DRDY when Disabling a Channel	Not fixed	 	Atmel
SAM7S128	ADC: GOVRE Bit is not Updated Read of the Status Register at the same instant as an end of conversion leads to skipping the update of the GOVRE (general overrun) flag. GOVRE is neither reset nor set. For example, if reading the status while an end of conversion is occurring and: 1. GOVRE is active but DRDY is inactive, does not correspond to a new general overrun condition but the GOVRE flag is not reset. 2. GOVRE is inactive but DRDY is active, does correspond to a new general overrun condition but the GOVRE flag is not set.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 656	 	ADC: GOVRE Bit is not Updated	Not fixed	 	Atmel
SAM7S128	ADC: GOVRE Bit is not Set when Reading CDR When reading CDRy (Channel Data Register y) at the same instant as an end of conversion on channel âxâ with the following conditions: â¢ EOC[x] already active, â¢ DRDY already active, â¢ GOVRE inactive, â¢ previous data stored in LCDR being neither data from channel âyâ, nor data from channel âxâ. GOVRE should be set but is not.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Set when Reading CDR	Not fixed	 	Atmel
SAM7S128	ADC: GOVRE Bit is not Set when Disabling a Channel When disabling channel âyâ at the same instant as an end of conversion on channel âxâ, EOC[x] and DRDY being already active, GOVRE does not rise. Note: OVRE[x] rises as expected.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Set when Disabling a Channel	Not fixed	 	Atmel
SAM7S128	ADC: OVRE Flag Behavior When the OVRE flag (on channel i) has been set but the related EOC status (of channel i) has been cleared (by a read of CDRi or LCDR), reading the Status register at the same instant as an end of conversion (causing the set of EOC status on channel i), does not lead to a reset of the OVRE flag (on channel i) as expected.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: OVRE Flag Behavior	Not fixed	 	Atmel
SAM7S128	ADC: EOC Set although Channel Disabled If a channel is disabled while a conversi on is running and if a read of CDR is performed at the same time as an end of conversion of any channel occurs, the EOC of the channel with the conversion running may rise (whereas it has been disabled).	ARM7	 	Analog-to-Digital Converter (ADC)	 	Do not take into account the EOC of a disabled channel	 	ADC: EOC Set although Channel Disabled	Not fixed	 	Atmel
SAM7S128	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ nor âyâ), reading CDR on channel âzâ at the same instant as an end of conversion on channel âyâ automatically clears EOC[x] instead of EOC[z].	ARM7	 	Analog-to-Digital Converter (ADC)	 	None.	 	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ	Not fixed	 	Atmel
SAM7S128	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	ARM7	 	Analog-to-Digital Converter (ADC)	 	To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit field); to start an analog-to-digital conversion, in order put ADC into sleep mode at the end of this conversion. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 657 40.12.3 Non Volatile Memory Bits (NVM Bits)	 	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after	Not fixed	 	Atmel
SAM7S128	NVM Bits: Write/Erase Cycles Number The maximum number of write/erase cycles for Non Volatile Memory bits is 100. This includes Lock Bits (LOCKx), General Purpose NVM bits (GPNVMx) and the Security Bit. This maximum number of write/erase cycles is not applic able to 128 KB Flash memory, it remains at 10K for the Flash memory.	ARM7	 	Non Volatile Memory Bits (NVM Bits)	 	None. 40.12.4 Parallel Input/Output Controller (PIO)	 	NVM Bits: Write/Erase Cycles Number	Not fixed	 	Atmel
SAM7S128	PIO: Leakage on PA17 - PA20 When PA17, PA18, PA19 or PA20 (the I/O lines multiplexed with the analog inputs) are set as digital inputs with pull-up disabled, the leakage can be 5 ÂµA in worst case and 90 nA in typical case per I/O when the I/O is set externally at low level.	ARM7	 	Parallel Input/Output Controller (PIO)	 	Set the I/O to VDDIO by internal or external pull-up.	 	PIO: Leakage on PA17 - PA20	Not fixed	 	Atmel
SAM7S128	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31 When NRST or PA0-PA16 or PA21-PA31 are set as digital inputs with pull-up enabled, the voltage of the I/O stabilizes at VPull-up. Vpull-up VPull-up Min VPull-up Max VDDIO - 0.65 V VDDIO - 0.45 V This condition causes a leakage through VDDIO. This leakage is 45 ÂµA per pad in worst case at 3.3 V and 25 ÂµA at 1.8V. I Leakage Parameter Typ Max I Leakage at 3,3V 2.5 ÂµA 45 ÂµA I Leakage at 1.8V 1 ÂµA 25 ÂµA	ARM7	 	Parallel Input/Output Controller (PIO)	 	It is recommended to use an external pull-up if needed.	 	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31	Not fixed	 	Atmel
SAM7S128	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31 When NRST or PA0-PA16 and or PA21-PA31 are set as digital inputs with pull-up enabled, driving the I/O with an output impedance higher than 500 ohms may not drive the I/O to a logical zero.	ARM7	 	Parallel Input/Output Controller (PIO)	 	Output impedance must be lower than 500 ohms. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 658 40.12.5 Power Management Controller (PMC)	 	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31	Not fixed	 	Atmel
SAM7S128	PMC: Slow Clock Selected in PMC and a Transition Occurs on PA1 Under certain rare circumstances, when CSS = 00 in PMC_MCKR, and PA1 is set as an input and a transition occurs on PA1, device malfunction might occur.	ARM7	 	Power Management Controller (PMC)	 	Do not transition PA1 as an input when CSS = 00 in PMC_MCKR.	 	PMC: Slow Clock Selected in PMC and a Transition Occurs on PA1	Not fixed	 	Atmel
SAM7S128	PMC: Programming CSS in PMC_MCKR Register Under certain rare circumstances, reprogramming the CSS value in the PMC_MCKR register (i.e switching the main clock source) might generate malfunction of the device if the following two actions occur simultaneously. 1. Switching from: â PLL Clock to Slow Clock or â PLL Clock to Main Clock or â Main Clock to PLL Clock or â Main Clock to Slow Clock And 2. Program code is being executed out of flash, or a transition is occurring on PA1, either as an input or output. Note: This issue does not occur when transitioning from slow clock to main clock or from slow clock to PLL clock.	ARM7	 	Power Management Controller (PMC)	 	When changing CSS in the PMC_MCKR to switch from â PLL Clock to Slow Clock or â PLL Clock to Main Clock or â Main Clock to PLL Clock or â Main Clock to Slow Clock Ensure that the processor is executing out of SRAM and ensure no transition occurs on PA1, either as an input or output, starting from writing to the PMC_MCKR register until MCKRDY = 1. 40.12.6 Pulse Width Modulation Controller (PWM)	 	PMC: Programming CSS in PMC_MCKR Register	Not fixed	 	Atmel
SAM7S128	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Check the Channel Counter Register before writing the update register.	 	PWM: Update when PWM_CCNTx = 0 or 1	Not fixed	 	Atmel
SAM7S128	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not write 0 in the period register.	 	PWM: Update when PWM_CPRDx = 0	Not fixed	 	Atmel
SAM7S128	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 659 None.	 	PWM: Counter Start Value	Not fixed	 	Atmel
SAM7S128	PWM: Constraints on Duty Cycle Value Setting Channel Duty Cycle Register (PWM_CDTYx) at 0 in center aligned mode or at 0 or 1 in left aligned mode may change the polarity of the signal.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not set PWM_CDTYx at 0 in center aligned mode. Do not set PWM_CDTYx at 0 or 1 in left aligned mode.	 	PWM: Constraints on Duty Cycle Value	Not fixed	 	Atmel
SAM7S128	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register Erratic behavior of the CHIDx status bit in the PWM_SR Register. When a channel is disabled by writing in the PWM_DIS Register just after enabling it (before completion of a Clock Period of the clock selected for the channel), the PWM line is internally disabled but the CHIDx status bit in the PWM_SR stays at 1.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not disable a channel before completion of one period of the selected clock. 40.12.7 Real Time Timer (RTT)	 	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register	Not fixed	 	Atmel
SAM7S128	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	ARM7	 	Real Time Timer (RTT)	 	The software must handle the RTT event as an interrupt and should not poll RTT_SR.	 	RTT: Possible Event Loss when Reading RTT_SR	Not fixed	 	Atmel
SAM7S128	RTT: RTT_VR May be Corrupted Under certain rare circumstances, the Real-time Timer Value (RTT_VR) may be corrupted.	ARM7	 	Real Time Timer (RTT)	 	Use RTTINC as an increment for a software counter. 40.12.8 Serial Peripheral Interface (SPI)	 	RTT: RTT_VR May be Corrupted	Not fixed	 	Atmel
SAM7S128	SPI: Bad tx_ready behavior when CSAAT = 1 and SCBR = 1 If the SPI is programmed with CSAAT = 1, SCBR(baudrate) = 1 and two transfers are performed consecutively on the same slave with an IDLE state between them, the tx_ready signal does not rise after the second data has been transferred in the shifter. This can imply for example, that the second data is sent twice.	ARM7	 	Serial Peripheral Interface (SPI)	 	Do not use the combination CSAAT = 1 and SCBR = 1.	 	SPI: Bad tx_ready behavior when CSAAT = 1 and SCBR = 1	Not fixed	 	Atmel
SAM7S128	SPI: LASTXFER (Last Transfer) behavior In FIXED Mode, with CSAAT bit set, and in âPDC modeâ the Chip Select can rise depending on the data written in the SPI_TDR when the TX_EMPTY flag is set. If for example, the PDC writes a â1â in the bit 24 (LASTXFER bit) of the SPI_TDR, the chip select will rise as soon as the TXEMPTY flag is set.	ARM7	 	Serial Peripheral Interface (SPI)	 	Use the CS in PIO mode when PDC mode is required and CS has to be maintained between transfers.	 	SPI: LASTXFER (Last Transfer) behavior	Not fixed	 	Atmel
SAM7S128	SPI: SPCK Behavior in Master Mode SPCK pin can toggle out before the first transfer in Master Mode. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 660	ARM7	 	Serial Peripheral Interface (SPI)	 	In Master Mode, MSTR bit must be set (in SPI_MR register) before configuring SPI_CSRx registers.	 	SPI: SPCK Behavior in Master Mode	Not fixed	 	Atmel
SAM7S128	SPI: Chip Select and Fixed Mode In fixed Mode, if a transfer is performed through a PDC on a Chip select different from the Chip select 0, the output spi_size sampled by the PDC will depend on the field, BITS (Bits per Transfer) of SPI_CSR0 register, whatever the selected Chip select is. For example, if SPI_CSR0 is configured for a 10-bit transfer whereas SPI_CSR1 is configured for an 8-bit transfer, when a transfer is performed in Fixed mode through the PDC, on Chip select 1, the transfer will be considered as a HalfWord transfer.	ARM7	 	Serial Peripheral Interface (SPI)	 	If a PDC transfer has to be performed in 8 bits, on a Chip select y (y as different from 0), the BITS field of the SPI_CSR0 must be configured in 8 bits, in the same way as the BITS field of the CSRy Register.	 	SPI: Chip Select and Fixed Mode	Not fixed	 	Atmel
SAM7S128	SPI: Baudrate Set to 1 When Baudrate is set at 1 (i.e. when serial clock frequency equals the system clock frequency) and when the BITS field of the SPI_CSR register (number of bits to be transmitted) equals an ODD value (in this case 9,11,13 or 15), an additional pulse will be generated on output SPCK. Everything is OK if the BITS field equals 8,10,12,14 or 16 and Baudrate = 1.	ARM7	 	Serial Peripheral Interface (SPI)	 	None.	 	SPI: Baudrate Set to 1	Not fixed	 	Atmel
SAM7S128	SPI: Disable In Slave Mode The SPI disable is not possible in slave mode.	ARM7	 	Serial Peripheral Interface (SPI)	 	Read first the received data, then perform the software reset.	 	SPI: Disable In Slave Mode	Not fixed	 	Atmel
SAM7S128	SPI: Bad Serial Clock Generation on 2nd Chip Select Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0. This occurs using SPI with the following conditions: â¢ Master Mode â¢ CPOL = 1 and NCPHA = 0 â¢ Multiple chip selects are used with one transfer with Baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR are not equal to 1 â¢ Transmitting with the slowest chip select and then with the fastest one, then an additional on output SPCK during the second transfer. pulse is generated	ARM7	 	Serial Peripheral Interface (SPI)	 	Do not use a multiple Chip Select configuration where at least one SCRx register is configured with SCBR = 1 and the others differ from 1 if NCPHA = 0 and CPOL = 1. If all chip selects are configured with Baudrate = 1, the issue does not appear. 40.12.9 Synchronous Serial Controller (SSC)	 	SPI: Bad Serial Clock Generation on 2nd Chip Select	Not fixed	 	Atmel
SAM7S128	SSC: Periodic Transmission Limitations in Master Mode If the Least Significant Bit is sent first (MSBF = 0), the first TAG during the frame synchro is not sent.	ARM7	 	Synchronous Serial Controller (SSC)	 	None. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 661	 	SSC: Periodic Transmission Limitations in Master Mode	Not fixed	 	Atmel
SAM7S128	SSC: Transmitter Limitations in Slave Mode If TK is programmed as output and TF is programmed as input, it is impossible to emit data when the start of edge (rising or falling) of synchro has a Start Delay equal to zero.	ARM7	 	Synchronous Serial Controller (SSC)	 	None.	 	SSC: Transmitter Limitations in Slave Mode	Not fixed	 	Atmel
SAM7S128	SSC: Transmitter Limitations in Slave Mode If TK is programmed as an input and TF is programmed as an output and requested to be set to low/high during data emission, the Frame Synchro signal is generated one bit clock period after the data start and one data bit is lost. This problem does not exist when generating a periodic synchro.	ARM7	 	Synchronous Serial Controller (SSC)	 	The data need to be delayed for one bit clock period with an external assembly. In the following schematic, TD, TK and NRST are SAM7S signals, TXD is the delayed data to connect to the device. 40.12.10 Two-wire Interface (TWI)	 	SSC: Transmitter Limitations in Slave Mode	Not fixed	 	Atmel
SAM7S128	The value of CLDIV x 2 CKDIV must be less than or equal to 8191 the value of CHDIV x 2 CKDIV must be less than or equal to 8191	ARM7	 	Two-wire Interface (TWI)	 	None.	 	The value of CLDIV x 2 CKDIV must be less than or equal to 8191 the value of CHDIV x 2 CKDIV must be less than or	Not fixed	 	Atmel
SAM7S128	When a software reset is performed during a frame and when TWCK is low, it is impossible to initiate a new transfer in READ or WRITE mode.	ARM7	 	Two-wire Interface (TWI)	 	None. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 662	 	When a software reset is performed during a frame and when TWCK is low, it is impossible to initiate a new transfer in READ or WRITE mode.	Not fixed	 	Atmel
SAM7S128	Any transfer in progress is immediately frozen if the Control Register (TWI_CR) is written with the bit MSDIS at 1. Furthermore, the status bits TXCOMP and TXRDY in the Status Register (TWI_SR) are not reset.	ARM7	 	Two-wire Interface (TWI)	 	The user must wait for the end of transfer before disabling the TWI. In addition, the interrupts must be disabled before disabling the TWI.	 	Any transfer in progress is immediately frozen if the Control Register (TWI_CR) is written with the bit MSDIS at 1.	Not fixed	 	Atmel
SAM7S128	During a master frame, if TWI_SR is read between the Non Acknowledge condition detection and the TXCOMP bit rising in the TWI_SR, the NACK bit is not set.	ARM7	 	Two-wire Interface (TWI)	 	The user must wait for the TXCOMP status bit by interrupt and must not read the TWI_SR as long as transmission is not completed. TXCOMP and NACK fields are set simultaneously and the NACK field is reset after the read of the TWI_SR.	 	During a master frame, if TWI_SR is read between the Non Acknowledge condition detection and the TXCOMP bit	Not fixed	 	Atmel
SAM7S128	When loading the TWI_RHR, the transfer direction is ignored. The last data byte received in the TWI_RHR is corrupted at the end of the first subsequent transmit data byte . Neither RXRDY nor OVERRUN status bits are set if this occurs.	ARM7	 	Two-wire Interface (TWI)	 	The user must be sure that received data is read before transmitting any new data. 40.12.11 USART: Universal Synchronous Asynchronous Receiver Transmitter	 	When loading the TWI_RHR, the transfer direction is ignored. The last data byte received in the TWI_RHR is corrupted at the end of the first subsequent transmit data byte . Neither RXRDY nor OVERRUN status bits are set if	Not fixed	 	Atmel
SAM7S128	When Hardware Handshaking is used and if CTS goes low near the end of the starting bit, a character can be lost.	ARM7	 	USART: Universal Synchronous Asynchronous Receiver Transmitter	 	CTS must not go low during a time slot occurring between 2 Master Clock periods before the starting bit and 16 Master Clock periods after the rising edge of the starting bit.	 	When Hardware Handshaking is used and if CTS goes low near the end of the starting bit, a character can be lost.	Not fixed	 	Atmel
SAM7S128	If CTS switches from 0 to 1 during the TX of a character and if the holding register (US_THR) is not empty, the content of US_THR will also be transmitted.	ARM7	 	USART: Universal Synchronous Asynchronous Receiver Transmitter	 	Don't use the PDC in transmit mode and do not fill US_THR before TXEMPTY is set at 1.	 	If CTS switches from 0 to 1 during the TX of a character and if the holding register (US_THR) is not empty, the content of US_THR will also be transmitted.	Not fixed	 	Atmel
SAM7S128	The XOFF character is sent only when the receive buffer is detected full. While the XOFF is being sent, the remote transmitter is still transmitting. As only one Holding register is available in the receiver, characters will be lost in reception. This makes the software handshaking functionality ineffective.	ARM7	 	USART: Universal Synchronous Asynchronous Receiver Transmitter	 	None.	 	The XOFF character is sent only when the receive buffer is detected full. While the XOFF is being sent, the remote	Not fixed	 	Atmel
SAM7S128	In receiver mode, when there are two consecutive characters (without timeguard in between), RXBRK is not taken into account. As a result, the RXBRK flag is not enabled correctly and the frame error flag is set.	ARM7	 	USART: Universal Synchronous Asynchronous Receiver Transmitter	 	SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 663 Constraints on the transmitter device connected to the SAM7S USART receiver side: The transmitter may use the timeguard feature or send two STOP conditions. Only one STOP condition is taken into account by the receiver state machine. After this STOP condition, as there is no valid data, the receiver state machine will go in idle mode and enable the RXBRK flag.	 	In receiver mode, when there are two consecutive characters (without timeguard in between), RXBRK is not taken	Not fixed	 	Atmel
SAM7S128	The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	ARM7	 	USART: Universal Synchronous Asynchronous Receiver Transmitter	 	Add an inverter. 40.12.12 Voltage Regulator	 	The DCD signal is active at High level in the USART Modem Mode.	Not fixed	 	Atmel
SAM7S128	Current consumption in Deep Mode is maximum 60 ÂµA instead of 25 ÂµA. Due to current rejection from VDDIN to VDDCORE, the current consumption in Deep Mode cannot be guaranteed. Instead, 60 ÂµA is guaranteed whatever the condition.	ARM7	 	Voltage Regulator	 	None.	 	Current consumption in Deep Mode is maximum 60 ÂµA instead of 25 ÂµA.	Not fixed	 	Atmel
SAM7S128	Maximum load is 50 mA at 85 Â°C (instead of 100 mA). Maximum load is 100 mA at 70Â°C.	ARM7	 	Voltage Regulator	 	None. 40.12.13 Watchdog Timer (WDT)	 	Maximum load is 50 mA at 85 Â°C (instead of 100 mA).	Not fixed	 	Atmel
SAM7S128	Under certain rare circumstances, if the Watchdog Timer is used with the Watchdog Reset enabled (WDRSTEN set at 1), the Watchdog Timer may lock the device in a reset state when the user restarts the watchdog (WDDRSTT). The only way to recover from this state is a power-on reset. The issue depends on the values of WDD and WDV in the WDT_MR register.	ARM7	 	Watchdog Timer (WDT)	 	Two workarounds are possible. 1. Either do not use the Watchdog Timer with the Watchdog Reset enabled (WDRSTEN set at 1), 2. or set WDD to 0xFFF and in addition use only one of the following values for WDV: 0xFFF, 0xDFF, 0xBFF, 0x9FF, 0x7FF, 0x77F, 0x6FF, 0x67F, 0x5FF, 0x57F, 0x4FF, 0x47F, 0x3FF, 0x37F, 0x2FF, 0x27F, 0x1FF, 0x1BF, 0x17F, 0x13F, 0x0FF, 0x0DF, 0x0BF, 0x09F, 0x07F, 0x06F, 0x05F, 0x04F, 0x03F, 0x037, 0x02f, 0x027, 0x01F, 0x01B, 0x017, 0x013 and 0x00F.	 	Under certain rare circumstances, if the Watchdog Timer is used with the Watchdog Reset enabled (WDRSTEN	Not fixed	 	Atmel
SAM7S128	Under certain rare circumstances, if the Watchdog Timer is used with the Watchdog Fault Interrupt enabled (WDFIEN set at 1), the Watchdog Timer may trigger the interrupt (wdt_fault) erroneously. The Watchdog Timer Status Register may be wrong also (WDERR and WDUNF). The issue depends on the values of WDD and WDV in the WDT_MR register. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 664	ARM7	 	Watchdog Timer (WDT)	 	Two workarounds are possible. 1. Either do not use the Watchdog Timer with the Watchdog fault Interrupt enabled (WDFIEN set at 1), 2. or set WDD to 0xFFF and in addition use only one of the following values for WDV: 0xFFF, 0xDFF, 0xBFF, 0x9FF, 0x7FF, 0x77F, 0x6FF, 0x67F, 0x5FF, 0x57F, 0x4FF, 0x47F, 0x3FF, 0x37F, 0x2FF, 0x27F, 0x1FF, 0x1BF, 0x17F, 0x13F, 0x0FF, 0x0DF, 0x0BF, 0x09F, 0x07F, 0x06F, 0x05F, 0x04F, 0x03F, 0x037, 0x02f, 0x027, 0x01F, 0x01B, 0x017, 0x013 and 0x00F. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 665 40.13 SAM7S128 Errata - Revision B Parts Refer to Section 40.1 âMarkingâ on page 595. Note: AT91SAM7S128 Revision B chip ID is: 0x270A 0741. 40.13.1 Analog-to-Digital Converter (ADC)	 	Under certain rare circumstances, if the Watchdog Timer is used with the Watchdog Fault Interrupt enabled	Not fixed	 	Atmel
SAM7S128	ADC: DRDY Bit Cleared The DRDY Flag should be clear only after a read of ADC_LCDR (Last Converted Data Register). A read of any ADC_CDRx register (Channel Data Register) automatically clears the DRDY flag.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: DRDY Bit Cleared	Not fixed	 	Atmel
SAM7S128	ADC: DRDY not Cleared on Disable When reading LCDR at the same instant as an end of conversion, with DRDY already active, DRDY is kept active regardless of the enable status of the current channel. This sets DRDY, whereas new data is not stored.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: DRDY not Cleared on Disable	Not fixed	 	Atmel
SAM7S128	ADC: DRDY Possibly Skipped due to CDR Read Reading CDR for channel âyâ at the same instant as an end of conversion on channel âxâ with EOC[x] already active, leads to skipping to set the DRDY flag if channel âxâ is enabled.	ARM7	 	Analog-to-Digital Converter (ADC)	 	Use of DRDY functionality with access to CDR registers should be avoided.	 	ADC: DRDY Possibly Skipped due to CDR Read	Not fixed	 	Atmel
SAM7S128	ADC: Possible Skip on DRDY when Disabling a Channel DRDY does not rise when disabling channel âyâ at the same time as an end of âxâ channel conversion, although data is stored into CDRx and LCDR.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None.	 	ADC: Possible Skip on DRDY when Disabling a Channel	Not fixed	 	Atmel
SAM7S128	ADC: GOVRE Bit is not Updated Read of the Status Register at the same instant as an end of conversion leads to skipping the update of the GOVRE (general overrun) flag. GOVRE is neither reset nor set. For example, if reading the status while an end of conversion is occurring and: 1. GOVRE is active but DRDY is inactive, does not correspond to a new general overrun condition but the GOVRE flag is not reset. 2. GOVRE is inactive but DRDY is active, does correspond to a new general overrun condition but the GOVRE flag is not set.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Updated	Not fixed	 	Atmel
SAM7S128	ADC: GOVRE Bit is not Set when Reading CDR When reading CDRy (Channel Data Register y) at the same instant as an end of conversion on channel âxâ with the following conditions: â¢ EOC[x] already active, â¢ DRDY already active, SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 666 â¢ GOVRE inactive, â¢ previous data stored in LCDR being neither data from channel âyâ, nor data from channel âxâ. GOVRE should be set but is not.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Set when Reading CDR	Not fixed	 	Atmel
SAM7S128	ADC: GOVRE Bit is not Set when Disabling a Channel When disabling channel âyâ at the same instant as an end of conversion on channel âxâ, EOC[x] and DRDY being already active, GOVRE does not rise. Note: OVRE[x] rises as expected.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Set when Disabling a Channel	Not fixed	 	Atmel
SAM7S128	ADC: OVRE Flag Behavior When the OVRE flag (on channel i) has been set but the related EOC status (of channel i) has been cleared (by a read of CDRi or LCDR), reading the Status register at the same instant as an end of conversion (causing the set of EOC status on channel i), does not lead to a reset of the OVRE flag (on channel i) as expected.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: OVRE Flag Behavior	Not fixed	 	Atmel
SAM7S128	ADC: EOC Set although Channel Disabled If a channel is disabled while a conversi on is running and if a read of CDR is performed at the same time as an end of conversion of any channel occurs, the EOC of the channel with the conversion running may rise (whereas it has been disabled).	ARM7	 	Analog-to-Digital Converter (ADC)	 	Do not take into account the EOC of a disabled channel	 	ADC: EOC Set although Channel Disabled	Not fixed	 	Atmel
SAM7S128	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ nor âyâ), reading CDR on channel âzâ at the same instant as an end of conversion on channel âyâ automatically clears EOC[x] instead of EOC[z].	ARM7	 	Analog-to-Digital Converter (ADC)	 	None.	 	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ	Not fixed	 	Atmel
SAM7S128	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	ARM7	 	Analog-to-Digital Converter (ADC)	 	To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit field); to start an analog-to-digital conversion, in order put ADC into sleep mode at the end of this conversion. 40.13.2 Non Volatile Memory Bits (NVM Bits)	 	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after	Not fixed	 	Atmel
SAM7S128	NVM Bits: Write/Erase Cycles Number The maximum number of write/erase cycles for Non Volatile Memory bits is 100. This includes Lock Bits (LOCKx), General Purpose NVM bits (GPNVMx) and the Security Bit. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 667 This maximum number of write/erase cycles is not applic able to 128 KB Flash memory, it remains at 10K for the Flash memory.	ARM7	 	Non Volatile Memory Bits (NVM Bits)	 	None. 40.13.3 Parallel Input/Output Controller (PIO)	 	NVM Bits: Write/Erase Cycles Number	Not fixed	 	Atmel
SAM7S128	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31 When NRST or PA0-PA16 or PA21-PA31 are set as digital inputs with pull-up enabled, the voltage of the I/O stabilizes at VPull-up. Vpull-up VPull-up Min VPull-up Max VDDIO - 0.65 V VDDIO - 0.45 V This condition causes a leakage through VDDIO. This leakage is 45 ÂµA per pad in worst case at 3.3 V and 25 ÂµA at 1.8V. I Leakage Parameter Typ Max I Leakage at 3,3V 2.5 ÂµA 45 ÂµA I Leakage at 1.8V 1 ÂµA 25 ÂµA	ARM7	 	Parallel Input/Output Controller (PIO)	 	It is recommended to use an external pull-up if needed.	 	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31	Not fixed	 	Atmel
SAM7S128	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31 When NRST or PA0-PA16 and or PA21-PA31 are set as digital inputs with pull-up enabled, driving the I/O with an output impedance higher than 500 ohms may not drive the I/O to a logical zero.	ARM7	 	Parallel Input/Output Controller (PIO)	 	Output impedance must be lower than 500 ohms. 40.13.4 Pulse Width Modulation Controller (PWM)	 	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31	Not fixed	 	Atmel
SAM7S128	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Check the Channel Counter Register before writing the update register.	 	PWM: Update when PWM_CCNTx = 0 or 1	Not fixed	 	Atmel
SAM7S128	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not write 0 in the period register.	 	PWM: Update when PWM_CPRDx = 0	Not fixed	 	Atmel
SAM7S128	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 668	ARM7	 	Pulse Width Modulation Controller (PWM)	 	None.	 	PWM: Counter Start Value	Not fixed	 	Atmel
SAM7S128	PWM: Constraints on Duty Cycle Value Setting Channel Duty Cycle Register (PWM_CDTYx) at 0 in center aligned mode or at 0 or 1 in left aligned mode may change the polarity of the signal.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not set PWM_CDTYx at 0 in center aligned mode. Do not set PWM_CDTYx at 0 or 1 in left aligned mode.	 	PWM: Constraints on Duty Cycle Value	Not fixed	 	Atmel
SAM7S128	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register Erratic behavior of the CHIDx status bit in the PWM_SR Register. When a channel is disabled by writing in the PWM_DIS Register just after enabling it (before completion of a Clock Period of the clock selected for the channel), the PWM line is internally disabled but the CHIDx status bit in the PWM_SR stays at 1.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not disable a channel before completion of one period of the selected clock. 40.13.5 Real Time Timer (RTT)	 	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register	Not fixed	 	Atmel
SAM7S128	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	ARM7	 	Real Time Timer (RTT)	 	The software must handle the RTT event as an interrupt and should not poll RTT_SR. 40.13.6 Serial Peripheral Interface (SPI)	 	RTT: Possible Event Loss when Reading RTT_SR	Not fixed	 	Atmel
SAM7S128	SPI: Software Reset Must be Written Twice If a software reset (SWRSTin the SPI Control Register) is performed, the SPI may not work properly (the clock is enabled before the chip select.	ARM7	 	Serial Peripheral Interface (SPI)	 	The SPI Control Register field, SWRST needs to be written twice to be set correctly.	 	SPI: Software Reset Must be Written Twice	Not fixed	 	Atmel
SAM7S128	SPI: Bad tx_ready behavior when CSAAT = 1 and SCBR = 1 If the SPI is programmed with CSAAT = 1, SCBR(baudrate) = 1 and two transfers are performed consecutively on the same slave with an IDLE state between them, the tx_ready signal does not rise after the second data has been transferred in the shifter. This can imply for example, that the second data is sent twice.	ARM7	 	Serial Peripheral Interface (SPI)	 	Do not use the combination CSAAT = 1 and SCBR = 1.	 	SPI: Bad tx_ready behavior when CSAAT = 1 and SCBR = 1	Not fixed	 	Atmel
SAM7S128	SPI: LASTXFER (Last Transfer) behavior In FIXED Mode, with CSAAT bit set, and in âPDC modeâ the Chip Select can rise depending on the data written in the SPI_TDR when the TX_EMPTY flag is set. If for example, the PDC writes a â1â in the bit 24 (LASTXFER bit) of the SPI_TDR, the chip select will rise as soon as the TXEMPTY flag is set.	ARM7	 	Serial Peripheral Interface (SPI)	 	SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 669 Use the CS in PIO mode when PDC mode is required and CS has to be maintained between transfers.	 	SPI: LASTXFER (Last Transfer) behavior	Not fixed	 	Atmel
SAM7S128	SPI: SPCK Behavior in Master Mode SPCK pin can toggle out before the first transfer in Master Mode.	ARM7	 	Serial Peripheral Interface (SPI)	 	In Master Mode, MSTR bit must be set (in SPI_MR register) before configuring SPI_CSRx registers.	 	SPI: SPCK Behavior in Master Mode	Not fixed	 	Atmel
SAM7S128	SPI: Chip Select and Fixed Mode In fixed Mode, if a transfer is performed through a PDC on a Chip select different from the Chip select 0, the output spi_size sampled by the PDC will depend on the field, BITS (Bits per Transfer) of SPI_CSR0 register, whatever the selected Chip select is. For example, if SPI_CSR0 is configured for a 10-bit transfer whereas SPI_CSR1 is configured for an 8-bit transfer, when a transfer is performed in Fixed mode through the PDC, on Chip select 1, the transfer will be considered as a HalfWord transfer.	ARM7	 	Serial Peripheral Interface (SPI)	 	If a PDC transfer has to be performed in 8 bits, on a Chip select y (y as different from 0), the BITS field of the SPI_CSR0 must be configured in 8 bits, in the same way as the BITS field of the CSRy Register.	 	SPI: Chip Select and Fixed Mode	Not fixed	 	Atmel
SAM7S128	SPI: Baudrate Set to 1 When Baudrate is set at 1 (i.e. when serial clock frequency equals the system clock frequency) and when the BITS field of the SPI_CSR register (number of bits to be transmitted) equals an ODD value (in this case 9,11,13 or 15), an additional pulse will be generated on output SPCK. Everything is OK if the BITS field equals 8,10,12,14 or 16 and Baudrate = 1.	ARM7	 	Serial Peripheral Interface (SPI)	 	None.	 	SPI: Baudrate Set to 1	Not fixed	 	Atmel
SAM7S128	SPI: Disable In Slave Mode The SPI disable is not possible in slave mode.	ARM7	 	Serial Peripheral Interface (SPI)	 	Read first the received data, then perform the software reset.	 	SPI: Disable In Slave Mode	Not fixed	 	Atmel
SAM7S128	SPI: Bad Serial Clock Generation on 2nd Chip Select Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0. This occurs using SPI with the following conditions: â¢ Master Mode â¢ CPOL = 1 and NCPHA = 0 â¢ Multiple chip selects are used with one transfer with Baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR are not equal to 1 â¢ Transmitting with the slowest chip select and then with the fastest one, then an additional on output SPCK during the second transfer. pulse is generated	ARM7	 	Serial Peripheral Interface (SPI)	 	Do not use a multiple Chip Select configuration where at least one SCRx register is configured with SCBR = 1 and the others differ from 1 if NCPHA = 0 and CPOL = 1. If all chip selects are configured with Baudrate = 1, the issue does not appear. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 670 40.13.7 Synchronous Serial Controller (SSC)	 	SPI: Bad Serial Clock Generation on 2nd Chip Select	Not fixed	 	Atmel
SAM7S128	SSC: Periodic Transmission Limitations in Master Mode If the Least Significant Bit is sent first (MSBF = 0), the first TAG during the frame synchro is not sent.	ARM7	 	Synchronous Serial Controller (SSC)	 	None.	 	SSC: Periodic Transmission Limitations in Master Mode	Not fixed	 	Atmel
SAM7S128	SSC: Transmitter Limitations in Slave Mode If TK is programmed as output and TF is programmed as input, it is impossible to emit data when the start of edge (rising or falling) of synchro has a Start Delay equal to zero.	ARM7	 	Synchronous Serial Controller (SSC)	 	None.	 	SSC: Transmitter Limitations in Slave Mode	Not fixed	 	Atmel
SAM7S128	SSC: Transmitter Limitations in Slave Mode If TK is programmed as an input and TF is programmed as an output and requested to be set to low/high during data emission, the Frame Synchro signal is generated one bit clock period after the data start and one data bit is lost. This problem does not exist when generating a periodic synchro.	ARM7	 	Synchronous Serial Controller (SSC)	 	The data need to be delayed for one bit clock period with an external assembly. In the following schematic, TD, TK and NRST are SAM7S signals, TXD is the delayed data to connect to the device. 40.13.8 Two-wire Interface (TWI)	 	SSC: Transmitter Limitations in Slave Mode	Not fixed	 	Atmel
SAM7S128	TWI: Clock Divider The value of CLDIV x 2 CKDIV must be less than or equal to 8191 the value of CHDIV x 2 CKDIV must be less than or equal to 8191	ARM7	 	Two-wire Interface (TWI)	 	None. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 671	 	TWI: Clock Divider	Not fixed	 	Atmel
SAM7S128	TWI: Software Reset When a software reset is performed during a frame and when TWCK is low, it is impossible to initiate a new transfer in READ or WRITE mode.	ARM7	 	Two-wire Interface (TWI)	 	None.	 	TWI: Software Reset	Not fixed	 	Atmel
SAM7S128	TWI: Disabling Does not Operate Correctly Any transfer in progress is immediately frozen if the Control Register (TWI_CR) is written with the bit MSDIS at 1. Furthermore, the status bits TXCOMP and TXRDY in the Status Register (TWI_SR) are not reset.	ARM7	 	Two-wire Interface (TWI)	 	The user must wait for the end of transfer before disabling the TWI. In addition, the interrupts must be disabled before disabling the TWI.	 	TWI: Disabling Does not Operate Correctly	Not fixed	 	Atmel
SAM7S128	TWI: NACK Status Bit Lost During a master frame, if TWI_SR is read between the Non Acknowledge condition detection and the TXCOMP bit rising in the TWI_SR, the NACK bit is not set.	ARM7	 	Two-wire Interface (TWI)	 	The user must wait for the TXCOMP status bit by interrupt and must not read the TWI_SR as long as transmission is not completed. TXCOMP and NACK fields are set simultaneously and the NACK field is reset after the read of the TWI_SR.	 	TWI: NACK Status Bit Lost	Not fixed	 	Atmel
SAM7S128	TWI: Possible Receive Holding Register Corruption When loading the TWI_RHR, the transfer direction is ignored. The last data byte received in the TWI_RHR is corrupted at the end of the first subsequent transmit data byte . Neither RXRDY nor OVERRUN status bits are set if this occurs.	ARM7	 	Two-wire Interface (TWI)	 	The user must be sure that received data is read before transmitting any new data. 40.13.9 USART: Universal Synchronous Asynchronous Receiver Transmitter	 	TWI: Possible Receive Holding Register Corruption	Not fixed	 	Atmel
SAM7S128	USART: CTS in Hardware Handshaking When Hardware Handshaking is used and if CTS goes low near the end of the starting bit, a character can be lost.	ARM7	 	USART: Universal Synchronous Asynchronous Receiver Transmitter	 	CTS must not go low during a time slot occurring between 2 Master Clock periods before the starting bit and 16 Master Clock periods after the rising edge of the starting bit.	 	USART: CTS in Hardware Handshaking	Not fixed	 	Atmel
SAM7S128	USART: Hardware Handshaking â Two Characters Sent If CTS switches from 0 to 1 during the TX of a character and if the holding register (US_THR) is not empty, the content of US_THR will also be transmitted.	ARM7	 	USART: Universal Synchronous Asynchronous Receiver Transmitter	 	Don't use the PDC in transmit mode and do not fill US_THR before TXEMPTY is set at 1.	 	USART: Hardware Handshaking â Two Characters Sent	Not fixed	 	Atmel
SAM7S128	USART: XOFF Character Bad Behavior The XOFF character is sent only when the receive buffer is detected full. While the XOFF is being sent, the remote transmitter is still transmitting. As only one Holding register is available in the receiver, characters will be lost in reception. This makes the software handshaking functionality ineffective.	ARM7	 	USART: Universal Synchronous Asynchronous Receiver Transmitter	 	SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 672 None.	 	USART: XOFF Character Bad Behavior	Not fixed	 	Atmel
SAM7S128	USART: RXBRK Flag Error in Asynchronous Mode In receiver mode, when there are two consecutive characters (without timeguard in between), RXBRK is not taken into account. As a result, the RXBRK flag is not enabled correctly and the frame error flag is set.	ARM7	 	USART: Universal Synchronous Asynchronous Receiver Transmitter	 	Constraints on the transmitter device connected to the SAM7S USART receiver side: The transmitter may use the timeguard feature or send two STOP conditions. Only one STOP condition is taken into account by the receiver state machine. After this STOP condition, as there is no valid data, the receiver state machine will go in idle mode and enable the RXBRK flag.	 	USART: RXBRK Flag Error in Asynchronous Mode	Not fixed	 	Atmel
SAM7S128	USART: DCD is active High instead of Low The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	ARM7	 	USART: Universal Synchronous Asynchronous Receiver Transmitter	 	Add an inverter. 40.13.10 Voltage Regulator	 	USART: DCD is active High instead of Low	Not fixed	 	Atmel
SAM7S128	Current consumption in Deep Mode is maximum 60 ÂµA instead of 25 ÂµA. Due to current rejection from VDDIN to VDDCORE, the current consumption in Deep Mode cannot be guaranteed. Instead, 60 ÂµA is guaranteed whatever the condition.	ARM7	 	Voltage Regulator	 	None.	 	Current consumption in Deep Mode is maximum 60 ÂµA instead of 25 ÂµA.	Not fixed	 	Atmel
SAM7S128	Maximum load is 50 mA at 85 Â°C (instead of 100 mA). Maximum load is 100 mA at 70Â°C.	ARM7	 	Voltage Regulator	 	None. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 673 40.14 SAM7S128 Errata - Revision C Parts Refer to Section 40.1 âMarkingâ on page 595. Note: AT91SAM7S128 Revision C chip ID is 0x270A 0742. 40.14.1 Embedded Flash Controller (EFC)	 	Maximum load is 50 mA at 85 Â°C (instead of 100 mA).	Not fixed	 	Atmel
SAM7S128	EFC: Embedded Flash Access Time 1 The embedded Flash maximum access time is 20 MHz (instead of 30 MHz) at zero Wait State (FWS = 0). The maximum operating frequency with one Wait State (FWS = 1) is 48.1 MHz (instead of 55 MHz). Above 48.1 MHz and up to 55 MHz, two Wait States (FWS = 2) are required.	ARM7	 	Embedded Flash Controller (EFC)	 	Set the number of Wait States (FWS) according to the frequency requirements described in this errata. 40.14.2 Parallel Input/Output Controller (PIO)	 	EFC: Embedded Flash Access Time 1	Not fixed	 	Atmel
SAM7S128	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31 When NRST or PA0-PA16 or PA21-PA31 are set as digital inputs with pull-up enabled, the voltage of the I/O stabilizes at VPull-up. Vpull-up VPull-up Min VPull-up Max VDDIO - 0.65 V VDDIO - 0.45 V This condition causes a leakage through VDDIO. This leakage is 45 ÂµA per pad in worst case at 3.3 V, and 25 ÂµA at 1.8V. I Leakage Parameter Typ Max I Leakage at 3,3V 2.5 ÂµA 45 ÂµA I Leakage at 1.8V 1 ÂµA 25 ÂµA	ARM7	 	Parallel Input/Output Controller (PIO)	 	It is recommended to use an external pull-up if needed.	 	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31	Not fixed	 	Atmel
SAM7S128	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31 When NRST or PA0-PA16 and or PA21-PA31 are set as digital inputs with pull-up enabled, driving the I/O with an output impedance higher than 500 ohms may not drive the I/O to a logical zero.	ARM7	 	Parallel Input/Output Controller (PIO)	 	Output impedance must be lower than 500 ohms. 40.14.3 Pulse Width Modulation Controller (PWM)	 	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31	Not fixed	 	Atmel
SAM7S128	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Check the Channel Counter Register before writing the update register. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 674	 	PWM: Update when PWM_CCNTx = 0 or 1	Not fixed	 	Atmel
SAM7S128	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not write 0 in the period register.	 	PWM: Update when PWM_CPRDx = 0	Not fixed	 	Atmel
SAM7S128	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	None. 40.14.4 Real Time Timer (RTT)	 	PWM: Counter Start Value	Not fixed	 	Atmel
SAM7S128	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	ARM7	 	Real Time Timer (RTT)	 	The software must handle the RTT event as an interrupt and should not poll RTT_SR. 40.14.5 USART: Universal Synchronous Asynchronous Receiver Transmitter	 	RTT: Possible Event Loss when Reading RTT_SR	Not fixed	 	Atmel
SAM7S128	USART: DCD is active High instead of Low The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	ARM7	 	USART: Universal Synchronous Asynchronous Receiver Transmitter	 	Add an inverter. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 675 40.15 SAM7S128 Errata - Revision D Parts Refer to Section 40.1 âMarkingâ on page 595. Note: AT91SAM7S128 Revision C chip ID is 0x270A0743. 40.15.1 Embedded Flash Controller (EFC)	 	USART: DCD is active High instead of Low	Not fixed	 	Atmel
SAM7S128	EFC: Embedded Flash Access Time 1 The embedded Flash maximum access time is 20 MHz (instead of 30 MHz) at zero Wait State (FWS = 0). The maximum operating frequency with one Wait State (FWS = 1) is 48.1 MHz (instead of 55 MHz). Above 48.1 MHz and up to 55 MHz, two Wait States (FWS = 2) are required.	ARM7	 	Embedded Flash Controller (EFC)	 	Set the number of Wait States (FWS) according to the frequency requirements described in this errata. 40.15.2 Parallel Input/Output Controller (PIO)	 	EFC: Embedded Flash Access Time 1	Not fixed	 	Atmel
SAM7S128	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31 When NRST or PA0-PA16 or PA21-PA31 are set as digital inputs with pull-up enabled, the voltage of the I/O stabilizes at VPull-up. Vpull-up VPull-up Min VPull-up Max VDDIO - 0.65 V VDDIO - 0.45 V This condition causes a leakage through VDDIO. This leakage is 45 ÂµA per pad in worst case at 3.3 V, and 25 ÂµA at 1.8V. I Leakage Parameter Typ Max I Leakage at 3,3V 2.5 ÂµA 45 ÂµA I Leakage at 1.8V 1 ÂµA 25 ÂµA	ARM7	 	Parallel Input/Output Controller (PIO)	 	It is recommended to use an external pull-up if needed.	 	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31	Not fixed	 	Atmel
SAM7S128	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31 When NRST or PA0-PA16 and or PA21-PA31 are set as digital inputs with pull-up enabled, driving the I/O with an output impedance higher than 500 ohms may not drive the I/O to a logical zero.	ARM7	 	Parallel Input/Output Controller (PIO)	 	Output impedance must be lower than 500 ohms. 40.15.3 Pulse Width Modulation Controller (PWM)	 	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31	Not fixed	 	Atmel
SAM7S128	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Check the Channel Counter Register before writing the update register. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 676	 	PWM: Update when PWM_CCNTx = 0 or 1	Not fixed	 	Atmel
SAM7S128	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not write 0 in the period register.	 	PWM: Update when PWM_CPRDx = 0	Not fixed	 	Atmel
SAM7S128	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	None. 40.15.4 Real Time Timer (RTT)	 	PWM: Counter Start Value	Not fixed	 	Atmel
SAM7S128	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	ARM7	 	Real Time Timer (RTT)	 	The software must handle the RTT event as an interrupt and should not poll RTT_SR. 40.15.5 USART: Universal Synchronous Asynchronous Receiver Transmitter	 	RTT: Possible Event Loss when Reading RTT_SR	Not fixed	 	Atmel
SAM7S128	USART: DCD is active High instead of Low The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	ARM7	 	USART: Universal Synchronous Asynchronous Receiver Transmitter	 	Add an inverter. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 677 40.16 SAM7S64 Errata - Manufacturing Number 58814G Refer to Section 40.1 âMarkingâ on page 595. 40.16.1 Analog-to-Digital Converter (ADC)	 	USART: DCD is active High instead of Low	Not fixed	 	Atmel
SAM7S64	ADC: DRDY Bit Cleared The DRDY Flag should be clear only after a read of ADC_LCDR (Last Converted Data Register). A read of any ADC_CDRx register (Channel Data Register) automatically clears the DRDY flag.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: DRDY Bit Cleared	Not fixed	 	Atmel
SAM7S64	ADC: DRDY not Cleared on Disable When reading LCDR at the same instant as an end of conversion, with DRDY already active, DRDY is kept active regardless of the enable status of the current channel. This sets DRDY, whereas new data is not stored.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: DRDY not Cleared on Disable	Not fixed	 	Atmel
SAM7S64	ADC: DRDY Possibly Skipped due to CDR Read Reading CDR for channel âyâ at the same instant as an end of conversion on channel âxâ with EOC[x] already active, leads to skipping to set the DRDY flag if channel âxâ is enabled.	ARM7	 	Analog-to-Digital Converter (ADC)	 	Use of DRDY functionality with access to CDR registers should be avoided.	 	ADC: DRDY Possibly Skipped due to CDR Read	Not fixed	 	Atmel
SAM7S64	ADC: Possible Skip on DRDY when Disabling a Channel DRDY does not rise when disabling channel âyâ at the same time as an end of âxâ channel conversion, although data is stored into CDRx and LCDR.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None.	 	ADC: Possible Skip on DRDY when Disabling a Channel	Not fixed	 	Atmel
SAM7S64	ADC: GOVRE Bit is not Updated Read of the Status Register at the same instant as an end of conversion leads to skipping the update of the GOVRE (general overrun) flag. GOVRE is neither reset nor set. For example, if reading the status while an end of conversion is occurring and: 1. GOVRE is active but DRDY is inactive, does not correspond to a new general overrun condition but the GOVRE flag is not reset. 2. GOVRE is inactive but DRDY is active, does correspond to a new general overrun condition but the GOVRE flag is not set.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Updated	Not fixed	 	Atmel
SAM7S64	ADC: GOVRE Bit is not Set when Reading CDR When reading CDRy (Channel Data Register y) at the same instant as an end of conversion on channel âxâ with the following conditions: â¢ EOC[x] already active, â¢ DRDY already active, â¢ GOVRE inactive, SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 678 â¢ previous data stored in LCDR being neither data from channel âyâ, nor data from channel âxâ. GOVRE should be set but is not.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Set when Reading CDR	Not fixed	 	Atmel
SAM7S64	ADC: GOVRE Bit is not Set when Disabling a Channel When disabling channel âyâ at the same instant as an end of conversion on channel âxâ, EOC[x] and DRDY being already active, GOVRE does not rise. Note: OVRE[x] rises as expected.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Set when Disabling a Channel	Not fixed	 	Atmel
SAM7S64	ADC: OVRE Flag Behavior When the OVRE flag (on channel i) has been set but the related EOC status (of channel i) has been cleared (by a read of CDRi or LCDR), reading the Status register at the same instant as an end of conversion (causing the set of EOC status on channel i), does not lead to a reset of the OVRE flag (on channel i) as expected.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: OVRE Flag Behavior	Not fixed	 	Atmel
SAM7S64	ADC: EOC Set although Channel Disabled If a channel is disabled while a conversi on is running and if a read of CDR is performed at the same time as an end of conversion of any channel occurs, the EOC of the channel with the conversion running may rise (whereas it has been disabled).	ARM7	 	Analog-to-Digital Converter (ADC)	 	Do not take into account the EOC of a disabled channel	 	ADC: EOC Set although Channel Disabled	Not fixed	 	Atmel
SAM7S64	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ nor âyâ), reading CDR on channel âzâ at the same instant as an end of conversion on channel âyâ automatically clears EOC[x] instead of EOC[z].	ARM7	 	Analog-to-Digital Converter (ADC)	 	None.	 	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ	Not fixed	 	Atmel
SAM7S64	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	ARM7	 	Analog-to-Digital Converter (ADC)	 	To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit field); to start an analog-to-digital conversion, in order put ADC into sleep mode at the end of this conversion. 40.16.2 JTAG	 	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after	Not fixed	 	Atmel
SAM7S64	JTAG: Recommendation for TDI Pin TDI pin shows a weakness which does not effect the operation of the device. If this pin is driven over 2.0V or exposed to high electrostatic voltages, the pad might be partially destroyed and this can lead to additional continuous leakage on VDDCORE between 100 and 500 ÂµA. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 679 However, this does not prevent JTAG operations.	ARM7	 	JTAG	 	The JTAG port remains operational even if the failure on TDI has happened. Therefore the users can develop their applications in normal conditions, except the overall system power consumption might be higher. It is recommended to handle the devices carefully during PCB soldering and to correctly ground the manufacturing equipment. To prevent any failure on the final customer's systems, it is also recommended to tie the TDI pin at GND in the system production release and to not pull it up, as it is shown on the SAM7S-EK Evaluation Board schematics. 40.16.3 Master Clock (MCK)	 	JTAG: Recommendation for TDI Pin	Not fixed	 	Atmel
SAM7S64	MCK: Limited Master Clock Frequency Ranges If the Flash is operating without wait states, the frequency of the Master Clock MCK must be lower than 3 MHz or higher than 19 MHz. If the Flash is operating with one wait state, the frequency of the Master Clock MCK must be lower than 3 MHz or higher than 19 MHz. If the Flash is operating with two wait states, the frequency of the Master Clock MCK must be lower than 3 MHz or higher than 25 MHz. If the Flash is operating with three wait states, the frequency of the Master Clock MCK must be lower than 3 MHz or higher than 38 MHz. If these constraints are not respected, the correct operation of the system cannot be guaranteed and either data or prefetch abort might occur. The maximum operating frequencies (at 30 MHz @ 0 Wait States and 55 MHz @ 1 Wait State) as stated in Table 37-24, âEmbedded Flash Wait States,â on page 582, are still applicable. Note: It is not necessary to use 2 o 3 wait states because t he Flash can operate at maximum frequency with only 1 wait state.	ARM7	 	Master Clock (MCK)	 	The user must ensure that the device is running at the authorized frequency by programming the PLL properly to not run within the forbidden frequency range. 40.16.4 Non Volatile Memory Bits (NVM Bits)	 	MCK: Limited Master Clock Frequency Ranges	Not fixed	 	Atmel
SAM7S64	NVM Bits: Write/Erase Cycles Number The maximum number of write/erase cycles for Non Volatile Memory bits is 100. This includes Lock Bits (LOCKx), General Purpose NVM bits (GPNVMx) and the Security Bit. This maximum number of write/erase cycles is not applicable to 64 KB Flash memory, it remains at10K for the Flash memory.	ARM7	 	Non Volatile Memory Bits (NVM Bits)	 	None. 40.16.5 Parallel Input/Output Controller (PIO)	 	NVM Bits: Write/Erase Cycles Number	Not fixed	 	Atmel
SAM7S64	PIO: Leakage on PA17 - PA20 When PA17, PA18, PA19 or PA20 (the I/O lines multiplexed with the analog inputs) are set as digital inputs with pull-up disabled, the leakage can be 9 ÂµA in worst case and 90 nA in typical case per I/O when the I/O is set externally at low level.	ARM7	 	Parallel Input/Output Controller (PIO)	 	SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 680 Set the I/O to VDDIO by internal or external pull-up.	 	PIO: Leakage on PA17 - PA20	Not fixed	 	Atmel
SAM7S64	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31 When NRST or PA0-PA16 or PA21-PA31 are set as digital inputs with pull-up enabled, the voltage of the I/O stabilizes at VPull-up. Vpull-up VPull-up Min VPull-up Max VDDIO - 0.65 V VDDIO - 0.45 V This condition causes a leakage through VDDIO. This leakage is 45 ÂµA per pad in worst case at 3.3 V and 25 ÂµA at 1.8V. I Leakage Parameter Typ Max I Leakage at 3,3V 2.5 ÂµA 45 ÂµA I Leakage at 1.8V 1 ÂµA 25 ÂµA	ARM7	 	Parallel Input/Output Controller (PIO)	 	It is recommended to use an external pull-up if needed.	 	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31	Not fixed	 	Atmel
SAM7S64	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31 When NRST or PA0-PA16 and or PA21-PA31 are set as digital inputs with pull-up enabled, driving the I/O with an output impedance higher than 500 ohms may not drive the I/O to a logical zero.	ARM7	 	Parallel Input/Output Controller (PIO)	 	Output impedance must be lower than 500 ohms. 40.16.6 Pulse Width Modulation Controller (PWM)	 	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31	Not fixed	 	Atmel
SAM7S64	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Check the Channel Counter Register before writing the update register.	 	PWM: Update when PWM_CCNTx = 0 or 1	Not fixed	 	Atmel
SAM7S64	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not write 0 in the period register.	 	PWM: Update when PWM_CPRDx = 0	Not fixed	 	Atmel
SAM7S64	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	None.	 	PWM: Counter Start Value	Not fixed	 	Atmel
SAM7S64	PWM: Constraints on Duty Cycle Value Setting Channel Duty Cycle Register (PWM_CDTYx) at 0 in center aligned mode or at 0 or 1 in left aligned mode may change the polarity of the signal. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 681	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not set PWM_CDTYx at 0 in center aligned mode. Do not set PWM_CDTYx at 0 or 1 in left aligned mode.	 	PWM: Constraints on Duty Cycle Value	Not fixed	 	Atmel
SAM7S64	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register Erratic behavior of the CHIDx status bit in the PWM_SR Register. When a channel is disabled by writing in the PWM_DIS Register just after enabling it (before completion of a Clock Period of the clock selected for the channel), the PWM line is internally disabled but the CHIDx status bit in the PWM_SR stays at 1.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not disable a channel before completion of one period of the selected clock. 40.16.7 Real Time Timer (RTT)	 	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register	Not fixed	 	Atmel
SAM7S64	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	ARM7	 	Real Time Timer (RTT)	 	The software must handle the RTT event as an interrupt and should not poll RTT_SR. 40.16.8 Serial Peripheral Interface (SPI)	 	RTT: Possible Event Loss when Reading RTT_SR	Not fixed	 	Atmel
SAM7S64	20. SPI: Pulse Generation on SPCK In Master Mode, there is an additional pulse generated on SPCK when the SPI is configured as follows: â The Baudrate is odd and different from 1 â The Polarity is set to 1 â The Phase is set to 0	ARM7	 	Serial Peripheral Interface (SPI)	 	None.	 	20. SPI: Pulse Generation on SPCK	Not fixed	 	Atmel
SAM7S64	SPI: Bad tx_ready behavior when CSAAT=1 and SCBR = 1 If the SPI is programmed with CSAAT = 1, SCBR(baudrate) = 1 and two transfers are performed consecutively on the same slave with an IDLE state between them, the tx_ready signal does not rise after the second data has been transferred in the shifter. This can imply for example, that the second data is sent twice.	ARM7	 	Serial Peripheral Interface (SPI)	 	Do not use the combination CSAAT=1 and SCBR =1.	 	SPI: Bad tx_ready behavior when CSAAT=1 and SCBR = 1	Not fixed	 	Atmel
SAM7S64	SPI: LASTXFER (Last Transfer) behavior In FIXED Mode, with CSAAT bit set, and in âPDC modeâ the Chip Select can rise depending on the data written in the SPI_TDR when the TX_EMPTY flag is set. If for example, the PDC writes a â1â in the bit 24 (LASTXFER bit) of the SPI_TDR, the chip select will rise as soon as the TXEMPTY flag is set.	ARM7	 	Serial Peripheral Interface (SPI)	 	Use the CS in PIO mode when PDC mode is required and CS has to be maintained between transfers.	 	SPI: LASTXFER (Last Transfer) behavior	Not fixed	 	Atmel
SAM7S64	SPI: SPCK Behavior in Master Mode SPCK pin can toggle out before the first transfer in Master Mode.	ARM7	 	Serial Peripheral Interface (SPI)	 	In Master Mode, MSTR bit must be set (in SPI_MR register) before configuring SPI_CSRx registers. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 682	 	SPI: SPCK Behavior in Master Mode	Not fixed	 	Atmel
SAM7S64	SPI: Chip Select and Fixed Mode In fixed Mode, if a transfer is performed through a PDC on a Chip select different from the Chip select 0, the output spi_size sampled by the PDC will depend on the field, BITS (Bits per Transfer) of SPI_CSR0 register, whatever the selected Chip select is. For example, if SPI_CSR0 is configured for a 10-bit transfer whereas SPI_CSR1 is configured for an 8-bit transfer, when a transfer is performed in Fixed mode through the PDC, on Chip select 1, the transfer will be considered as a HalfWord transfer.	ARM7	 	Serial Peripheral Interface (SPI)	 	If a PDC transfer has to be performed in 8 bits, on a Chip select y (y as different from 0), the BITS field of the SPI_CSR0 must be configured in 8 bits, in the same way as the BITS field of the CSRy Register.	 	SPI: Chip Select and Fixed Mode	Not fixed	 	Atmel
SAM7S64	SPI: Baudrate Set to 1 When Baudrate is set at 1 (i.e. when serial clock frequency equals the system clock frequency) and when the BITS field of the SPI_CSR register (number of bits to be transmitted) equals an ODD value (in this case 9,11,13 or 15), an additional pulse will be generated on output SPCK. Everything is OK if the BITS field equals 8,10,12,14 or 16 and Baudrate = 1.	ARM7	 	Serial Peripheral Interface (SPI)	 	None.	 	SPI: Baudrate Set to 1	Not fixed	 	Atmel
SAM7S64	SPI: Disable In Slave Mode The SPI disable is not possible in slave mode.	ARM7	 	Serial Peripheral Interface (SPI)	 	Read first the received data, then perform the software reset.	 	SPI: Disable In Slave Mode	Not fixed	 	Atmel
SAM7S64	SPI: Disable Issue The SPI Command âSPI Disableâ is not possible during a transfer, it must be performed only after TX_EMPTY rising else there is everlasting dummy transfers occur.	ARM7	 	Serial Peripheral Interface (SPI)	 	None.	 	SPI: Disable Issue	Not fixed	 	Atmel
SAM7S64	SPI: Software Reset and SPIEN Bit The SPI Command âsoftware resetâ does not reset the SPIEN config bit. Therefore rewriting an SPI enable command does not set TX_READY, TX_EMPTY flags.	ARM7	 	Serial Peripheral Interface (SPI)	 	Send SPI disable command after a software reset.	 	SPI: Software Reset and SPIEN Bit	Not fixed	 	Atmel
SAM7S64	If CSAAT = 1 for current access and there is no more TX request for a time greater than DLYBCT + DLYBCS, then if an access is requested on another slave, the NPCS bus switches from one CS to the one requested without DLYBCS. External Slaves may reach a contention on SPI_MISO line for a short period.	ARM7	 	Serial Peripheral Interface (SPI)	 	Assert the Last Transfer Command (NPCS de-activation) for the last character of each slave.	 	If CSAAT = 1 for current access and there is no more TX request for a time greater than DLYBCT + DLYBCS, then	Not fixed	 	Atmel
SAM7S64	Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0. This occurs using SPI with the following conditions: â¢ Master Mode SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 683 â¢ CPOL = 1 and NCPHA = 0 â¢ Multiple chip selects are used with one transfer with Baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR are not equal to 1 â¢ Transmitting with the slowest chip select and then with the fastest one, then an additional on output SPCK during the second transfer. pulse is generated	ARM7	 	Serial Peripheral Interface (SPI)	 	Do not use a multiple Chip Select configuration where at least one SCRx register is configured with SCBR = 1 and the others differ from 1 if NCPHA = 0 and CPOL = 1. If all chip selects are configured with Baudrate = 1, the issue does not appear. 40.16.9 Synchronous Serial Controller (SSC)	 	Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0.	Not fixed	 	Atmel
SAM7S64	SSC: Periodic Transmission Limitations in Master Mode If the Least Significant Bit is sent first (MSBF = 0), the first TAG during the frame synchro is not sent.	ARM7	 	Synchronous Serial Controller (SSC)	 	None.	 	SSC: Periodic Transmission Limitations in Master Mode	Not fixed	 	Atmel
SAM7S64	SSC: Transmitter Limitations in Slave Mode If TK is programmed as output and TF is programmed as input, it is impossible to emit data when the start of edge (rising or falling) of synchro has a Start Delay equal to zero.	ARM7	 	Synchronous Serial Controller (SSC)	 	None.	 	SSC: Transmitter Limitations in Slave Mode	Not fixed	 	Atmel
SAM7S64	SSC: Transmitter Limitations in Slave Mode If TK is programmed as an input and TF is programmed as an output and requested to be set to low/high during data emission, the Frame Synchro signal is generated one bit clock period after the data start and one data bit is lost. This problem does not exist when generating a periodic synchro.	ARM7	 	Synchronous Serial Controller (SSC)	 	The data need to be delayed for one bit clock period with an external assembly. In the following schematic, TD, TK and NRST are SAM7S signals, TXD is the delayed data to connect to the device. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 684 40.16.10 Two-wire Interface (TWI)	 	SSC: Transmitter Limitations in Slave Mode	Not fixed	 	Atmel
SAM7S64	The value of CLDIV x 2 CKDIV must be less than or equal to 8191 the value of CHDIV x 2 CKDIV must be less than or equal to 8191	ARM7	 	Two-wire Interface (TWI)	 	None.	 	The value of CLDIV x 2 CKDIV must be less than or equal to 8191 the value of CHDIV x 2 CKDIV must be less than or	Not fixed	 	Atmel
SAM7S64	When a software reset is performed during a frame and when TWCK is low, it is impossible to initiate a new transfer in READ or WRITE mode.	ARM7	 	Two-wire Interface (TWI)	 	None.	 	When a software reset is performed during a frame and when TWCK is low, it is impossible to initiate a new transfer in READ or WRITE mode.	Not fixed	 	Atmel
SAM7S64	Any transfer in progress is immediately frozen if the Control Register (TWI_CR) is written with the bit MSDIS at 1. Furthermore, the status bits TXCOMP and TXRDY in the Status Register (TWI_SR) are not reset.	ARM7	 	Two-wire Interface (TWI)	 	The user must wait for the end of transfer before disabling the TWI. In addition, the interrupts must be disabled before disabling the TWI.	 	Any transfer in progress is immediately frozen if the Control Register (TWI_CR) is written with the bit MSDIS at 1.	Not fixed	 	Atmel
SAM7S64	During a master frame, if TWI_SR is read between the Non Acknowledge condition detection and the TXCOMP bit rising in the TWI_SR, the NACK bit is not set.	ARM7	 	Two-wire Interface (TWI)	 	The user must wait for the TXCOMP status bit by interrupt and must not read the TWI_SR as long as transmission is not completed. TXCOMP and NACK fields are set simultaneously and the NACK field is reset after the read of the TWI_SR. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 685	 	During a master frame, if TWI_SR is read between the Non Acknowledge condition detection and the TXCOMP bit	Not fixed	 	Atmel
SAM7S64	When loading the TWI_RHR, the transfer direction is ignored. The last data byte received in the TWI_RHR is corrupted at the end of the first subsequent transmit data byte . Neither RXRDY nor OVERRUN status bits are set if this occurs.	ARM7	 	Two-wire Interface (TWI)	 	The user must be sure that received data is read before transmitting any new data. 40.16.11 Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	When loading the TWI_RHR, the transfer direction is ignored. The last data byte received in the TWI_RHR is corrupted at the end of the first subsequent transmit data byte . Neither RXRDY nor OVERRUN status bits are set if	Not fixed	 	Atmel
SAM7S64	The Hardware Handshake does not work at speeds higher than 750 kbauds.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	None.	 	The Hardware Handshake does not work at speeds higher than 750 kbauds.	Not fixed	 	Atmel
SAM7S64	When Hardware Handshaking is used and if CTS goes low near the end of the starting bit, a character can be lost.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	CTS must not go low during a time slot occurring between 2 Master Clock periods before the starting bit and 16 Master Clock periods after the rising edge of the starting bit.	 	When Hardware Handshaking is used and if CTS goes low near the end of the starting bit, a character can be lost.	Not fixed	 	Atmel
SAM7S64	If CTS switches from 0 to 1 during the TX of a character and if the holding register (US_THR) is not empty, the content of US_THR will also be transmitted.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	Don't use the PDC in transmit mode and do not fill US_THR before TXEMPTY is set at 1.	 	If CTS switches from 0 to 1 during the TX of a character and if the holding register (US_THR) is not empty, the content of US_THR will also be transmitted.	Not fixed	 	Atmel
SAM7S64	The XOFF character is sent only when the receive buffer is detected full. While the XOFF is being sent, the remote transmitter is still transmitting. As only one Holding register is available in the receiver, characters will be lost in reception. This makes the software handshaking functionality ineffective.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	None.	 	The XOFF character is sent only when the receive buffer is detected full. While the XOFF is being sent, the remote	Not fixed	 	Atmel
SAM7S64	The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	Add an inverter. 40.16.12 Voltage Regulator	 	The DCD signal is active at High level in the USART Modem Mode.	Not fixed	 	Atmel
SAM7S64	Current consumption in Deep Mode is maximum 60 ÂµA instead of 25 ÂµA. Due to current rejection from VDDIN to VDDCORE, the current consumption in Deep Mode cannot be guaranteed. Instead, 60 ÂµA is guaranteed whatever the condition.	ARM7	 	Voltage Regulator	 	SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 686 None.	 	Current consumption in Deep Mode is maximum 60 ÂµA instead of 25 ÂµA.	Not fixed	 	Atmel
SAM7S64	Maximum load is 50 mA at 85 Â°C (instead of 100 mA). Maximum load is 100 mA at 70Â°C.	ARM7	 	Voltage Regulator	 	None. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 687 40.17 SAM7S64 Errata - Revision A Parts Refer to Section 40.1 âMarkingâ on page 595. Note: AT91SAM7S64 Revision A chip ID is 0x2709 0540. 40.17.1 Analog-to-Digital Converter (ADC)	 	Maximum load is 50 mA at 85 Â°C (instead of 100 mA).	Not fixed	 	Atmel
SAM7S64	ADC: DRDY Bit Cleared The DRDY Flag should be clear only after a read of ADC_LCDR (Last Converted Data Register). A read of any ADC_CDRx register (Channel Data Register) automatically clears the DRDY flag.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: DRDY Bit Cleared	Not fixed	 	Atmel
SAM7S64	ADC: DRDY not Cleared on Disable When reading LCDR at the same instant as an end of conversion, with DRDY already active, DRDY is kept active regardless of the enable status of the current channel. This sets DRDY, whereas new data is not stored.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: DRDY not Cleared on Disable	Not fixed	 	Atmel
SAM7S64	ADC: DRDY Possibly Skipped due to CDR Read Reading CDR for channel âyâ at the same instant as an end of conversion on channel âxâ with EOC[x] already active, leads to skipping to set the DRDY flag if channel âxâ is enabled.	ARM7	 	Analog-to-Digital Converter (ADC)	 	Use of DRDY functionality with access to CDR registers should be avoided.	 	ADC: DRDY Possibly Skipped due to CDR Read	Not fixed	 	Atmel
SAM7S64	ADC: Possible Skip on DRDY when Disabling a Channel DRDY does not rise when disabling channel âyâ at the same time as an end of âxâ channel conversion, although data is stored into CDRx and LCDR.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None.	 	ADC: Possible Skip on DRDY when Disabling a Channel	Not fixed	 	Atmel
SAM7S64	ADC: GOVRE Bit is not Updated Read of the Status Register at the same instant as an end of conversion leads to skipping the update of the GOVRE (general overrun) flag. GOVRE is neither reset nor set. For example, if reading the status while an end of conversion is occurring and: 1. GOVRE is active but DRDY is inactive, does not correspond to a new general overrun condition but the GOVRE flag is not reset. 2. GOVRE is inactive but DRDY is active, does correspond to a new general overrun condition but the GOVRE flag is not set.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Updated	Not fixed	 	Atmel
SAM7S64	ADC: GOVRE Bit is not Set when Reading CDR When reading CDRy (Channel Data Register y) at the same instant as an end of conversion on channel âxâ with the following conditions: â¢ EOC[x] already active, â¢ DRDY already active, SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 688 â¢ GOVRE inactive, â¢ previous data stored in LCDR being neither data from channel âyâ, nor data from channel âxâ. GOVRE should be set but is not.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Set when Reading CDR	Not fixed	 	Atmel
SAM7S64	ADC: GOVRE Bit is not Set when Disabling a Channel When disabling channel âyâ at the same instant as an end of conversion on channel âxâ, EOC[x] and DRDY being already active, GOVRE does not rise. Note: OVRE[x] rises as expected.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Set when Disabling a Channel	Not fixed	 	Atmel
SAM7S64	ADC: OVRE Flag Behavior When the OVRE flag (on channel i) has been set but the related EOC status (of channel i) has been cleared (by a read of CDRi or LCDR), reading the Status register at the same instant as an end of conversion (causing the set of EOC status on channel i), does not lead to a reset of the OVRE flag (on channel i) as expected.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: OVRE Flag Behavior	Not fixed	 	Atmel
SAM7S64	ADC: EOC Set although Channel Disabled If a channel is disabled while a conversi on is running and if a read of CDR is performed at the same time as an end of conversion of any channel occurs, the EOC of the channel with the conversion running may rise (whereas it has been disabled).	ARM7	 	Analog-to-Digital Converter (ADC)	 	Do not take into account the EOC of a disabled channel	 	ADC: EOC Set although Channel Disabled	Not fixed	 	Atmel
SAM7S64	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ nor âyâ), reading CDR on channel âzâ at the same instant as an end of conversion on channel âyâ automatically clears EOC[x] instead of EOC[z].	ARM7	 	Analog-to-Digital Converter (ADC)	 	None.	 	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ	Not fixed	 	Atmel
SAM7S64	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	ARM7	 	Analog-to-Digital Converter (ADC)	 	To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit field); to start an analog-to-digital conversion, in order put ADC into sleep mode at the end of this conversion. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 689 40.17.2 Non Volatile Memory Bits (NVM Bits)	 	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after	Not fixed	 	Atmel
SAM7S64	NVM Bits: Write/Erase Cycles Number The maximum number of write/erase cycles for Non Volatile Memory bits is 100. This includes Lock Bits (LOCKx), General Purpose NVM bits (GPNVMx) and the Security Bit. This maximum number of write/erase cycles is not applicable to 64 KB Flash memory, it remains at10K for the Flash memory.	ARM7	 	Non Volatile Memory Bits (NVM Bits)	 	None. 40.17.3 Parallel Input/Output Controller (PIO)	 	NVM Bits: Write/Erase Cycles Number	Not fixed	 	Atmel
SAM7S64	PIO: Leakage on PA17 - PA20 When PA17, PA18, PA19 or PA20 (the I/O lines multiplexed with the analog inputs) are set as digital inputs with pull-up disabled, the leakage can be 9 ÂµA in worst case and 90 nA in typical case per I/O when the I/O is set externally at low level.	ARM7	 	Parallel Input/Output Controller (PIO)	 	Set the I/O to VDDIO by internal or external pull-up.	 	PIO: Leakage on PA17 - PA20	Not fixed	 	Atmel
SAM7S64	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31 When NRST or PA0-PA16 or PA21-PA31 are set as digital inputs with pull-up enabled, the voltage of the I/O stabilizes at VPull-up. Vpull-up VPull-up Min VPull-up Max VDDIO - 0.65 V VDDIO - 0.45 V This condition causes a leakage through VDDIO. This leakage is 45 ÂµA per pad in worst case at 3.3 V, and 25 ÂµA at 1.8V. I Leakage Parameter Typ Max I Leakage at 3,3V 2.5 ÂµA 45 ÂµA I Leakage at 1.8V 1 ÂµA 25 ÂµA	ARM7	 	Parallel Input/Output Controller (PIO)	 	It is recommended to use an external pull-up if needed.	 	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31	Not fixed	 	Atmel
SAM7S64	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31 When NRST or PA0-PA16 and or PA21-PA31 are set as digital inputs with pull-up enabled, driving the I/O with an output impedance higher than 500 ohms may not drive the I/O to a logical zero.	ARM7	 	Parallel Input/Output Controller (PIO)	 	Output impedance must be lower than 500 ohms. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 690 40.17.4 Pulse Width Modulation Controller (PWM)	 	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31	Not fixed	 	Atmel
SAM7S64	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Check the Channel Counter Register before writing the update register.	 	PWM: Update when PWM_CCNTx = 0 or 1	Not fixed	 	Atmel
SAM7S64	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not write 0 in the period register.	 	PWM: Update when PWM_CPRDx = 0	Not fixed	 	Atmel
SAM7S64	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	None.	 	PWM: Counter Start Value	Not fixed	 	Atmel
SAM7S64	PWM: Constraints on Duty Cycle Value Setting Channel Duty Cycle Register (PWM_CDTYx) at 0 in center aligned mode or at 0 or 1 in left aligned mode may change the polarity of the signal.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not set PWM_CDTYx at 0 in center aligned mode. Do not set PWM_CDTYx at 0 or 1 in left aligned mode.	 	PWM: Constraints on Duty Cycle Value	Not fixed	 	Atmel
SAM7S64	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register Erratic behavior of the CHIDx status bit in the PWM_SR Register. When a channel is disabled by writing in the PWM_DIS Register just after enabling it (before completion of a Clock Period of the clock selected for the channel), the PWM line is internally disabled but the CHIDx status bit in the PWM_SR stays at 1.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not disable a channel before completion of one period of the selected clock. 40.17.5 Real Time Timer (RTT)	 	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register	Not fixed	 	Atmel
SAM7S64	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	ARM7	 	Real Time Timer (RTT)	 	The software must handle the RTT event as an interrupt and should not poll RTT_SR. 40.17.6 Serial Peripheral Interface (SPI)	 	RTT: Possible Event Loss when Reading RTT_SR	Not fixed	 	Atmel
SAM7S64	20. SPI: Pulse Generation on SPCK In Master Mode, there is an additional pulse generated on SPCK when the SPI is configured as follows: â The Baudrate is odd and different from 1 â The Polarity is set to 1 â The Phase is set to 0 SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 691	ARM7	 	Serial Peripheral Interface (SPI)	 	None.	 	20. SPI: Pulse Generation on SPCK	Not fixed	 	Atmel
SAM7S64	SPI: Bad tx_ready behavior when CSAAT=1 and SCBR = 1 If the SPI is programmed with CSAAT = 1, SCBR(baudrate) = 1 and two transfers are performed consecutively on the same slave with an IDLE state between them, the tx_ready signal does not rise after the second data has been transferred in the shifter. This can imply for example, that the second data is sent twice.	ARM7	 	Serial Peripheral Interface (SPI)	 	Do not use the combination CSAAT=1 and SCBR =1.	 	SPI: Bad tx_ready behavior when CSAAT=1 and SCBR = 1	Not fixed	 	Atmel
SAM7S64	SPI: LASTXFER (Last Transfer) behavior In FIXED Mode, with CSAAT bit set, and in âPDC modeâ the Chip Select can rise depending on the data written in the SPI_TDR when the TX_EMPTY flag is set. If for example, the PDC writes a â1â in the bit 24 (LASTXFER bit) of the SPI_TDR, the chip select will rise as soon as the TXEMPTY flag is set.	ARM7	 	Serial Peripheral Interface (SPI)	 	Use the CS in PIO mode when PDC mode is required and CS has to be maintained between transfers.	 	SPI: LASTXFER (Last Transfer) behavior	Not fixed	 	Atmel
SAM7S64	SPI: SPCK Behavior in Master Mode SPCK pin can toggle out before the first transfer in Master Mode.	ARM7	 	Serial Peripheral Interface (SPI)	 	In Master Mode, MSTR bit must be set (in SPI_MR register) before configuring SPI_CSRx registers.	 	SPI: SPCK Behavior in Master Mode	Not fixed	 	Atmel
SAM7S64	SPI: Chip Select and Fixed Mode In fixed Mode, if a transfer is performed through a PDC on a Chip select different from the Chip select 0, the output spi_size sampled by the PDC will depend on the field, BITS (Bits per Transfer) of SPI_CSR0 register, whatever the selected Chip select is. For example, if SPI_CSR0 is configured for a 10-bit transfer whereas SPI_CSR1 is configured for an 8-bit transfer, when a transfer is performed in Fixed mode through the PDC, on Chip select 1, the transfer will be considered as a HalfWord transfer.	ARM7	 	Serial Peripheral Interface (SPI)	 	If a PDC transfer has to be performed in 8 bits, on a Chip select y (y as different from 0), the BITS field of the SPI_CSR0 must be configured in 8 bits, in the same way as the BITS field of the CSRy Register.	 	SPI: Chip Select and Fixed Mode	Not fixed	 	Atmel
SAM7S64	SPI: Baudrate Set to 1 When Baudrate is set at 1 (i.e. when serial clock frequency equals the system clock frequency) and when the BITS field of the SPI_CSR register (number of bits to be transmitted) equals an ODD value (in this case 9,11,13 or 15), an additional pulse will be generated on output SPCK. Everything is OK if the BITS field equals 8,10,12,14 or 16 and Baudrate = 1.	ARM7	 	Serial Peripheral Interface (SPI)	 	None.	 	SPI: Baudrate Set to 1	Not fixed	 	Atmel
SAM7S64	SPI: Disable In Slave Mode The SPI disable is not possible in slave mode.	ARM7	 	Serial Peripheral Interface (SPI)	 	Read first the received data, then perform the software reset. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 692	 	SPI: Disable In Slave Mode	Not fixed	 	Atmel
SAM7S64	SPI: Disable Issue The SPI Command âSPI Disableâ is not possible during a transfer, it must be performed only after TX_EMPTY rising else there is everlasting dummy transfers occur.	ARM7	 	Serial Peripheral Interface (SPI)	 	None.	 	SPI: Disable Issue	Not fixed	 	Atmel
SAM7S64	SPI: Software Reset and SPIEN Bit The SPI Command âsoftware resetâ does not reset the SPIEN config bit. Therefore rewriting an SPI enable command does not set TX_READY, TX_EMPTY flags.	ARM7	 	Serial Peripheral Interface (SPI)	 	Send SPI disable command after a software reset.	 	SPI: Software Reset and SPIEN Bit	Not fixed	 	Atmel
SAM7S64	If CSAAT = 1 for current access and there is no more TX request for a time greater than DLYBCT + DLYBCS, then if an access is requested on another slave, the NPCS bus switches from one CS to the one requested without DLYBCS. External Slaves may reach a contention on SPI_MISO line for a short period.	ARM7	 	Serial Peripheral Interface (SPI)	 	Assert the Last Transfer Command (NPCS de-activation) for the last character of each slave.	 	If CSAAT = 1 for current access and there is no more TX request for a time greater than DLYBCT + DLYBCS, then	Not fixed	 	Atmel
SAM7S64	Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0. This occurs using SPI with the following conditions: â¢ Master Mode â¢ CPOL = 1 and NCPHA = 0 â¢ Multiple chip selects are used with one transfer with Baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR are not equal to 1 â¢ Transmitting with the slowest chip select and then with the fastest one, then an additional on output SPCK during the second transfer. pulse is generated	ARM7	 	Serial Peripheral Interface (SPI)	 	Do not use a multiple Chip Select configuration where at least one SCRx register is configured with SCBR = 1 and the others differ from 1 if NCPHA = 0 and CPOL = 1. If all chip selects are configured with Baudrate = 1, the issue does not appear. 40.17.7 Synchronous Serial Controller (SSC)	 	Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0.	Not fixed	 	Atmel
SAM7S64	SSC: Periodic Transmission Limitations in Master Mode If the Least Significant Bit is sent first (MSBF = 0), the first TAG during the frame synchro is not sent.	ARM7	 	Synchronous Serial Controller (SSC)	 	None.	 	SSC: Periodic Transmission Limitations in Master Mode	Not fixed	 	Atmel
SAM7S64	SSC: Transmitter Limitations in Slave Mode If TK is programmed as output and TF is programmed as input, it is impossible to emit data when the start of edge (rising or falling) of synchro has a Start Delay equal to zero.	ARM7	 	Synchronous Serial Controller (SSC)	 	None. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 693	 	SSC: Transmitter Limitations in Slave Mode	Not fixed	 	Atmel
SAM7S64	SSC: Transmitter Limitations in Slave Mode If TK is programmed as an input and TF is programmed as an output and requested to be set to low/high during data emission, the Frame Synchro signal is generated one bit clock period after the data start and one data bit is lost. This problem does not exist when generating a periodic synchro.	ARM7	 	Synchronous Serial Controller (SSC)	 	The data need to be delayed for one bit clock period with an external assembly. In the following schematic, TD, TK and NRST are SAM7S signals, TXD is the delayed data to connect to the device. 40.17.8 Two-wire Interface (TWI)	 	SSC: Transmitter Limitations in Slave Mode	Not fixed	 	Atmel
SAM7S64	TWI: Clock Divider The value of CLDIV x 2 CKDIV must be less than or equal to 8191 the value of CHDIV x 2 CKDIV must be less than or equal to 8191	ARM7	 	Two-wire Interface (TWI)	 	None.	 	TWI: Clock Divider	Not fixed	 	Atmel
SAM7S64	TWI: Software Reset When a software reset is performed during a frame and when TWCK is low, it is impossible to initiate a new transfer in READ or WRITE mode.	ARM7	 	Two-wire Interface (TWI)	 	None.	 	TWI: Software Reset	Not fixed	 	Atmel
SAM7S64	TWI: Disabling Does not Operate Correctly Any transfer in progress is immediately frozen if the Control Register (TWI_CR) is written with the bit MSDIS at 1. Furthermore, the status bits TXCOMP and TXRDY in the Status Register (TWI_SR) are not reset.	ARM7	 	Two-wire Interface (TWI)	 	The user must wait for the end of transfer before disabling the TWI. In addition, the interrupts must be disabled before disabling the TWI. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 694	 	TWI: Disabling Does not Operate Correctly	Not fixed	 	Atmel
SAM7S64	TWI: NACK Status Bit Lost During a master frame, if TWI_SR is read between the Non Acknowledge condition detection and the TXCOMP bit rising in the TWI_SR, the NACK bit is not set.	ARM7	 	Two-wire Interface (TWI)	 	The user must wait for the TXCOMP status bit by interrupt and must not read the TWI_SR as long as transmission is not completed. TXCOMP and NACK fields are set simultaneously and the NACK field is reset after the read of the TWI_SR.	 	TWI: NACK Status Bit Lost	Not fixed	 	Atmel
SAM7S64	TWI: Possible Receive Holding Register Corruption When loading the TWI_RHR, the transfer direction is ignored. The last data byte received in the TWI_RHR is corrupted at the end of the first subsequent transmit data byte . Neither RXRDY nor OVERRUN status bits are set if this occurs.	ARM7	 	Two-wire Interface (TWI)	 	The user must be sure that received data is read before transmitting any new data. 40.17.9 Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	TWI: Possible Receive Holding Register Corruption	Not fixed	 	Atmel
SAM7S64	USART: Hardware Handshake The Hardware Handshake does not work at speeds higher than 750 kbauds.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	None.	 	USART: Hardware Handshake	Not fixed	 	Atmel
SAM7S64	USART: CTS in Hardware Handshaking When Hardware Handshaking is used and if CTS goes low near the end of the starting bit, a character can be lost.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	CTS must not go low during a time slot occurring between 2 Master Clock periods before the starting bit and 16 Master Clock periods after the rising edge of the starting bit.	 	USART: CTS in Hardware Handshaking	Not fixed	 	Atmel
SAM7S64	USART: Hardware Handshaking â Two Characters Sent If CTS switches from 0 to 1 during the TX of a character and if the holding register (US_THR) is not empty, the content of US_THR will also be transmitted.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	Don't use the PDC in transmit mode and do not fill US_THR before TXEMPTY is set at 1.	 	USART: Hardware Handshaking â Two Characters Sent	Not fixed	 	Atmel
SAM7S64	USART: XOFF Character Bad Behavior The XOFF character is sent only when the receive buffer is detected full. While the XOFF is being sent, the remote transmitter is still transmitting. As only one Holding register is available in the receiver, characters will be lost in reception. This makes the software handshaking functionality ineffective.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	None.	 	USART: XOFF Character Bad Behavior	Not fixed	 	Atmel
SAM7S64	USART: DCD is active High instead of Low The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	Add an inverter. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 695 40.17.10 Voltage Regulator	 	USART: DCD is active High instead of Low	Not fixed	 	Atmel
SAM7S64	Current consumption in Deep Mode is maximum 60 ÂµA instead of 25 ÂµA. Due to current rejection from VDDIN to VDDCORE, the current consumption in Deep Mode cannot be guaranteed. Instead, 60 ÂµA is guaranteed whatever the condition.	ARM7	 	Voltage Regulator	 	None.	 	Current consumption in Deep Mode is maximum 60 ÂµA instead of 25 ÂµA.	Not fixed	 	Atmel
SAM7S64	Maximum load is 50 mA at 85 Â°C (instead of 100 mA). Maximum load is 100 mA at 70Â°C.	ARM7	 	Voltage Regulator	 	None. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 696 40.18 SAM7S64 Errata - Revision B Parts Refer to Section 40.1 âMarkingâ on page 595. Note: AT91SAM7S64 Revision B chip ID is: 0x2709 0543. 40.18.1 Analog-to-Digital Converter (ADC)	 	Maximum load is 50 mA at 85 Â°C (instead of 100 mA).	Not fixed	 	Atmel
SAM7S64	ADC: DRDY Bit Cleared The DRDY Flag should be clear only after a read of ADC_LCDR (Last Converted Data Register). A read of any ADC_CDRx register (Channel Data Register) automatically clears the DRDY flag.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: DRDY Bit Cleared	Not fixed	 	Atmel
SAM7S64	ADC: DRDY not Cleared on Disable When reading LCDR at the same instant as an end of conversion, with DRDY already active, DRDY is kept active regardless of the enable status of the current channel. This sets DRDY, whereas new data is not stored.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: DRDY not Cleared on Disable	Not fixed	 	Atmel
SAM7S64	ADC: DRDY Possibly Skipped due to CDR Read Reading CDR for channel âyâ at the same instant as an end of conversion on channel âxâ with EOC[x] already active, leads to skipping to set the DRDY flag if channel âxâ is enabled.	ARM7	 	Analog-to-Digital Converter (ADC)	 	Use of DRDY functionality with access to CDR registers should be avoided.	 	ADC: DRDY Possibly Skipped due to CDR Read	Not fixed	 	Atmel
SAM7S64	ADC: Possible Skip on DRDY when Disabling a Channel DRDY does not rise when disabling channel âyâ at the same time as an end of âxâ channel conversion, although data is stored into CDRx and LCDR.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None.	 	ADC: Possible Skip on DRDY when Disabling a Channel	Not fixed	 	Atmel
SAM7S64	ADC: GOVRE Bit is not Updated Read of the Status Register at the same instant as an end of conversion leads to skipping the update of the GOVRE (general overrun) flag. GOVRE is neither reset nor set. For example, if reading the status while an end of conversion is occurring and: 1. GOVRE is active but DRDY is inactive, does not correspond to a new general overrun condition but the GOVRE flag is not reset. 2. GOVRE is inactive but DRDY is active, does correspond to a new general overrun condition but the GOVRE flag is not set.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Updated	Not fixed	 	Atmel
SAM7S64	ADC: GOVRE Bit is not Set when Reading CDR When reading CDRy (Channel Data Register y) at the same instant as an end of conversion on channel âxâ with the following conditions: â¢ EOC[x] already active, â¢ DRDY already active, SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 697 â¢ GOVRE inactive, â¢ previous data stored in LCDR being neither data from channel âyâ, nor data from channel âxâ. GOVRE should be set but is not.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Set when Reading CDR	Not fixed	 	Atmel
SAM7S64	ADC: GOVRE Bit is not Set when Disabling a Channel When disabling channel âyâ at the same instant as an end of conversion on channel âxâ, EOC[x] and DRDY being already active, GOVRE does not rise. Note: OVRE[x] rises as expected.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Set when Disabling a Channel	Not fixed	 	Atmel
SAM7S64	ADC: OVRE Flag Behavior When the OVRE flag (on channel i) has been set but the related EOC status (of channel i) has been cleared (by a read of CDRi or LCDR), reading the Status register at the same instant as an end of conversion (causing the set of EOC status on channel i), does not lead to a reset of the OVRE flag (on channel i) as expected.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: OVRE Flag Behavior	Not fixed	 	Atmel
SAM7S64	ADC: EOC Set although Channel Disabled If a channel is disabled while a conversi on is running and if a read of CDR is performed at the same time as an end of conversion of any channel occurs, the EOC of the channel with the conversion running may rise (whereas it has been disabled).	ARM7	 	Analog-to-Digital Converter (ADC)	 	Do not take into account the EOC of a disabled channel	 	ADC: EOC Set although Channel Disabled	Not fixed	 	Atmel
SAM7S64	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ nor âyâ), reading CDR on channel âzâ at the same instant as an end of conversion on channel âyâ automatically clears EOC[x] instead of EOC[z].	ARM7	 	Analog-to-Digital Converter (ADC)	 	None.	 	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ	Not fixed	 	Atmel
SAM7S64	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	ARM7	 	Analog-to-Digital Converter (ADC)	 	To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit field); to start an analog-to-digital conversion, in order put ADC into sleep mode at the end of this conversion. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 698 40.18.2 Non Volatile Memory Bits (NVM Bits)	 	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after	Not fixed	 	Atmel
SAM7S64	NVM Bits: Write/Erase Cycles Number The maximum number of write/erase cycles for Non Volatile Memory bits is 100. This includes Lock Bits (LOCKx), General Purpose NVM bits (GPNVMx) and the Security Bit. This maximum number of write/erase cycles is not applicable to 64 KB Flash memory, it remains at10K for the Flash memory.	ARM7	 	Non Volatile Memory Bits (NVM Bits)	 	None. 40.18.3 Parallel Input/Output Controller (PIO)	 	NVM Bits: Write/Erase Cycles Number	Not fixed	 	Atmel
SAM7S64	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31 When NRST or PA0-PA16 or PA21-PA31 are set as digital inputs with pull-up enabled, the voltage of the I/O stabilizes at VPull-up. Vpull-up VPull-up Min VPull-up Max VDDIO - 0.65 V VDDIO - 0.45 V This condition causes a leakage through VDDIO. This leakage is 45 ÂµA per pad in worst case at 3.3 V and 25 ÂµA at 1.8V. I Leakage Parameter Typ Max I Leakage at 3,3V 2.5 ÂµA 45 ÂµA I Leakage at 1.8V 1 ÂµA 25 ÂµA	ARM7	 	Parallel Input/Output Controller (PIO)	 	It is recommended to use an external pull-up if needed.	 	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31	Not fixed	 	Atmel
SAM7S64	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31 When NRST or PA0-PA16 and or PA21-PA31 are set as digital inputs with pull-up enabled, driving the I/O with an output impedance higher than 500 ohms may not drive the I/O to a logical zero.	ARM7	 	Parallel Input/Output Controller (PIO)	 	Output impedance must be lower than 500 ohms. 40.18.4 Pulse Width Modulation Controller (PWM)	 	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31	Not fixed	 	Atmel
SAM7S64	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Check the Channel Counter Register before writing the update register.	 	PWM: Update when PWM_CCNTx = 0 or 1	Not fixed	 	Atmel
SAM7S64	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 699	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not write 0 in the period register.	 	PWM: Update when PWM_CPRDx = 0	Not fixed	 	Atmel
SAM7S64	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	None.	 	PWM: Counter Start Value	Not fixed	 	Atmel
SAM7S64	PWM: Constraints on Duty Cycle Value Setting Channel Duty Cycle Register (PWM_CDTYx) at 0 in center aligned mode or at 0 or 1 in left aligned mode may change the polarity of the signal.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not set PWM_CDTYx at 0 in center aligned mode. Do not set PWM_CDTYx at 0 or 1 in left aligned mode.	 	PWM: Constraints on Duty Cycle Value	Not fixed	 	Atmel
SAM7S64	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register Erratic behavior of the CHIDx status bit in the PWM_SR Register. When a channel is disabled by writing in the PWM_DIS Register just after enabling it (before completion of a Clock Period of the clock selected for the channel), the PWM line is internally disabled but the CHIDx status bit in the PWM_SR stays at 1.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not disable a channel before completion of one period of the selected clock. 40.18.5 Real Time Timer (RTT)	 	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register	Not fixed	 	Atmel
SAM7S64	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	ARM7	 	Real Time Timer (RTT)	 	The software must handle the RTT event as an interrupt and should not poll RTT_SR. 40.18.6 Serial Peripheral Interface (SPI)	 	RTT: Possible Event Loss when Reading RTT_SR	Not fixed	 	Atmel
SAM7S64	SPI: Software Reset Must be Written Twice If a software reset (SWRSTin the SPI Control Register) is performed, the SPI may not work properly (the clock is enabled before the chip select.	ARM7	 	Serial Peripheral Interface (SPI)	 	The SPI Control Register field, SWRST needs to be written twice to be set correctly.	 	SPI: Software Reset Must be Written Twice	Not fixed	 	Atmel
SAM7S64	SPI: Pulse Generation on SPCK In Master Mode, there is an additional pulse generated on SPCK when the SPI is configured as follows: â The Baudrate is odd and different from 1 â The Polarity is set to 1 â The Phase is set to 0	ARM7	 	Serial Peripheral Interface (SPI)	 	None. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 700	 	SPI: Pulse Generation on SPCK	Not fixed	 	Atmel
SAM7S64	SPI: Bad tx_ready behavior when CSAAT=1 and SCBR = 1 If the SPI is programmed with CSAAT = 1, SCBR(baudrate) = 1 and two transfers are performed consecutively on the same slave with an IDLE state between them, the tx_ready signal does not rise after the second data has been transferred in the shifter. This can imply for example, that the second data is sent twice.	ARM7	 	Serial Peripheral Interface (SPI)	 	Do not use the combination CSAAT=1 and SCBR =1.	 	SPI: Bad tx_ready behavior when CSAAT=1 and SCBR = 1	Not fixed	 	Atmel
SAM7S64	SPI: LASTXFER (Last Transfer) behavior In FIXED Mode, with CSAAT bit set, and in âPDC modeâ the Chip Select can rise depending on the data written in the SPI_TDR when the TX_EMPTY flag is set. If for example, the PDC writes a â1â in the bit 24 (LASTXFER bit) of the SPI_TDR, the chip select will rise as soon as the TXEMPTY flag is set.	ARM7	 	Serial Peripheral Interface (SPI)	 	Use the CS in PIO mode when PDC mode is required and CS has to be maintained between transfers.	 	SPI: LASTXFER (Last Transfer) behavior	Not fixed	 	Atmel
SAM7S64	SPI: SPCK Behavior in Master Mode SPCK pin can toggle out before the first transfer in Master Mode.	ARM7	 	Serial Peripheral Interface (SPI)	 	In Master Mode, MSTR bit must be set (in SPI_MR register) before configuring SPI_CSRx registers.	 	SPI: SPCK Behavior in Master Mode	Not fixed	 	Atmel
SAM7S64	SPI: Chip Select and Fixed Mode In fixed Mode, if a transfer is performed through a PDC on a Chip select different from the Chip select 0, the output spi_size sampled by the PDC will depend on the field, BITS (Bits per Transfer) of SPI_CSR0 register, whatever the selected Chip select is. For example, if SPI_CSR0 is configured for a 10-bit transfer whereas SPI_CSR1 is configured for an 8-bit transfer, when a transfer is performed in Fixed mode through the PDC, on Chip select 1, the transfer will be considered as a HalfWord transfer.	ARM7	 	Serial Peripheral Interface (SPI)	 	If a PDC transfer has to be performed in 8 bits, on a Chip select y (y as different from 0), the BITS field of the SPI_CSR0 must be configured in 8 bits, in the same way as the BITS field of the CSRy Register.	 	SPI: Chip Select and Fixed Mode	Not fixed	 	Atmel
SAM7S64	SPI: Baudrate Set to 1 When Baudrate is set at 1 (i.e. when serial clock frequency equals the system clock frequency) and when the BITS field of the SPI_CSR register (number of bits to be transmitted) equals an ODD value (in this case 9,11,13 or 15), an additional pulse will be generated on output SPCK. Everything is OK if the BITS field equals 8,10,12,14 or 16 and Baudrate = 1.	ARM7	 	Serial Peripheral Interface (SPI)	 	None.	 	SPI: Baudrate Set to 1	Not fixed	 	Atmel
SAM7S64	SPI: Disable In Slave Mode The SPI disable is not possible in slave mode.	ARM7	 	Serial Peripheral Interface (SPI)	 	Read first the received data, then perform the software reset.	 	SPI: Disable In Slave Mode	Not fixed	 	Atmel
SAM7S64	SPI: Disable Issue The SPI Command âSPI Disableâ is not possible during a transfer, it must be performed only after TX_EMPTY rising else there is everlasting dummy transfers occur.	ARM7	 	Serial Peripheral Interface (SPI)	 	SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 701 None.	 	SPI: Disable Issue	Not fixed	 	Atmel
SAM7S64	The SPI Command âsoftware resetâ does not reset the SPIEN config bit. Therefore rewriting an SPI enable command does not set TX_READY, TX_EMPTY flags.	ARM7	 	Serial Peripheral Interface (SPI)	 	Send SPI disable command after a software reset.	 	The SPI Command âsoftware resetâ does not reset the SPIEN config bit. Therefore rewriting an SPI enable command does not set TX_READY, TX_EMPTY flags.	Not fixed	 	Atmel
SAM7S64	If CSAAT = 1 for current access and there is no more TX request for a time greater than DLYBCT + DLYBCS, then if an access is requested on another slave, the NPCS bus switches from one CS to the one requested without DLYBCS. External Slaves may reach a contention on SPI_MISO line for a short period.	ARM7	 	Serial Peripheral Interface (SPI)	 	Assert the Last Transfer Command (NPCS de-activation) for the last character of each slave.	 	If CSAAT = 1 for current access and there is no more TX request for a time greater than DLYBCT + DLYBCS, then	Not fixed	 	Atmel
SAM7S64	Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0. This occurs using SPI with the following conditions: â¢ Master Mode â¢ CPOL = 1 and NCPHA = 0 â¢ Multiple chip selects are used with one transfer with Baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR are not equal to 1 â¢ Transmitting with the slowest chip select and then with the fastest one, then an additional on output SPCK during the second transfer. pulse is generated	ARM7	 	Serial Peripheral Interface (SPI)	 	Do not use a multiple Chip Select configuration where at least one SCRx register is configured with SCBR = 1 and the others differ from 1 if NCPHA = 0 and CPOL = 1. If all chip selects are configured with Baudrate = 1, the issue does not appear. 40.18.7 Synchronous Serial Controller (SSC)	 	Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0.	Not fixed	 	Atmel
SAM7S64	SSC: Periodic Transmission Limitations in Master Mode If the Least Significant Bit is sent first (MSBF = 0), the first TAG during the frame synchro is not sent.	ARM7	 	Synchronous Serial Controller (SSC)	 	None.	 	SSC: Periodic Transmission Limitations in Master Mode	Not fixed	 	Atmel
SAM7S64	SSC: Transmitter Limitations in Slave Mode If TK is programmed as output and TF is programmed as input, it is impossible to emit data when the start of edge (rising or falling) of synchro has a Start Delay equal to zero.	ARM7	 	Synchronous Serial Controller (SSC)	 	None.	 	SSC: Transmitter Limitations in Slave Mode	Not fixed	 	Atmel
SAM7S64	SSC: Transmitter Limitations in Slave Mode If TK is programmed as an input and TF is programmed as an output and requested to be set to low/high during data emission, the Frame Synchro signal is generated one bit clock period after the data start and one data bit is lost. This problem does not exist when generating a periodic synchro. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 702	ARM7	 	Synchronous Serial Controller (SSC)	 	The data need to be delayed for one bit clock period with an external assembly. In the following schematic, TD, TK and NRST are SAM7S signals, TXD is the delayed data to connect to the device. 40.18.8 Two-wire Interface (TWI)	 	SSC: Transmitter Limitations in Slave Mode	Not fixed	 	Atmel
SAM7S64	TWI: Clock Divider The value of CLDIV x 2 CKDIV must be less than or equal to 8191 the value of CHDIV x 2 CKDIV must be less than or equal to 8191	ARM7	 	Two-wire Interface (TWI)	 	None.	 	TWI: Clock Divider	Not fixed	 	Atmel
SAM7S64	TWI: Software Reset When a software reset is performed during a frame and when TWCK is low, it is impossible to initiate a new transfer in READ or WRITE mode.	ARM7	 	Two-wire Interface (TWI)	 	None.	 	TWI: Software Reset	Not fixed	 	Atmel
SAM7S64	TWI: Disabling Does not Operate Correctly Any transfer in progress is immediately frozen if the Control Register (TWI_CR) is written with the bit MSDIS at 1. Furthermore, the status bits TXCOMP and TXRDY in the Status Register (TWI_SR) are not reset.	ARM7	 	Two-wire Interface (TWI)	 	The user must wait for the end of transfer before disabling the TWI. In addition, the interrupts must be disabled before disabling the TWI.	 	TWI: Disabling Does not Operate Correctly	Not fixed	 	Atmel
SAM7S64	TWI: NACK Status Bit Lost During a master frame, if TWI_SR is read between the Non Acknowledge condition detection and the TXCOMP bit rising in the TWI_SR, the NACK bit is not set.	ARM7	 	Two-wire Interface (TWI)	 	The user must wait for the TXCOMP status bit by interrupt and must not read the TWI_SR as long as transmission is not completed. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 703 TXCOMP and NACK fields are set simultaneously and the NACK field is reset after the read of the TWI_SR.	 	TWI: NACK Status Bit Lost	Not fixed	 	Atmel
SAM7S64	TWI: Possible Receive Holding Register Corruption When loading the TWI_RHR, the transfer direction is ignored. The last data byte received in the TWI_RHR is corrupted at the end of the first subsequent transmit data byte . Neither RXRDY nor OVERRUN status bits are set if this occurs.	ARM7	 	Two-wire Interface (TWI)	 	The user must be sure that received data is read before transmitting any new data. 40.18.9 Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	TWI: Possible Receive Holding Register Corruption	Not fixed	 	Atmel
SAM7S64	USART: Hardware Handshake The Hardware Handshake does not work at speeds higher than 750 kbauds.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	None.	 	USART: Hardware Handshake	Not fixed	 	Atmel
SAM7S64	USART: CTS in Hardware Handshaking When Hardware Handshaking is used and if CTS goes low near the end of the starting bit, a character can be lost.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	CTS must not go low during a time slot occurring between 2 Master Clock periods before the starting bit and 16 Master Clock periods after the rising edge of the starting bit.	 	USART: CTS in Hardware Handshaking	Not fixed	 	Atmel
SAM7S64	USART: Hardware Handshaking â Two Characters Sent If CTS switches from 0 to 1 during the TX of a character and if the holding register (US_THR) is not empty, the content of US_THR will also be transmitted.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	Don't use the PDC in transmit mode and do not fill US_THR before TXEMPTY is set at 1.	 	USART: Hardware Handshaking â Two Characters Sent	Not fixed	 	Atmel
SAM7S64	USART: XOFF Character Bad Behavior The XOFF character is sent only when the receive buffer is detected full. While the XOFF is being sent, the remote transmitter is still transmitting. As only one Holding register is available in the receiver, characters will be lost in reception. This makes the software handshaking functionality ineffective.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	None.	 	USART: XOFF Character Bad Behavior	Not fixed	 	Atmel
SAM7S64	USART: DCD is active High instead of Low The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	Add an inverter. 40.18.10 Voltage Regulator	 	USART: DCD is active High instead of Low	Not fixed	 	Atmel
SAM7S64	Current consumption in Deep Mode is maximum 60 ÂµA instead of 25 ÂµA. Due to current rejection from VDDIN to VDDCORE, the current consumption in Deep Mode cannot be guaranteed. Instead, 60 ÂµA is guaranteed whatever the condition. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 704	ARM7	 	Voltage Regulator	 	None.	 	Current consumption in Deep Mode is maximum 60 ÂµA instead of 25 ÂµA.	Not fixed	 	Atmel
SAM7S64	Maximum load is 50 mA at 85 Â°C (instead of 100 mA). Maximum load is 100 mA at 70Â°C.	ARM7	 	Voltage Regulator	 	None. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 705 40.19 SAM7S64 Errata - Revision C Parts Refer to Section 40.1 âMarkingâ on page 595. Note: AT91SAM7S64 Revision C chip ID is 0x27090544 40.19.1 Parallel Input/Output Controller (PIO)	 	Maximum load is 50 mA at 85 Â°C (instead of 100 mA).	Not fixed	 	Atmel
SAM7S64	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31 When NRST or PA0-PA16 or PA21-PA31 are set as digital inputs with pull-up enabled, the voltage of the I/O stabilizes at VPull-up. Vpull-up VPull-up Min VPull-up Max VDDIO - 0.65 V VDDIO - 0.45 V This condition causes a leakage through VDDIO. This leakage is 45 ÂµA per pad in worst case at 3.3 V, and 25 ÂµA at 1.8V. I Leakage Parameter Typ Max I Leakage at 3,3V 2.5 ÂµA 45 ÂµA I Leakage at 1.8V 1 ÂµA 25 ÂµA	ARM7	 	Parallel Input/Output Controller (PIO)	 	It is recommended to use an external pull-up if needed.	 	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31	Not fixed	 	Atmel
SAM7S64	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31 When NRST or PA0-PA16 and or PA21-PA31 are set as digital inputs with pull-up enabled, driving the I/O with an output impedance higher than 500 ohms may not drive the I/O to a logical zero.	ARM7	 	Parallel Input/Output Controller (PIO)	 	Output impedance must be lower than 500 ohms. 40.19.2 Pulse Width Modulation Controller (PWM)	 	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31	Not fixed	 	Atmel
SAM7S64	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Check the Channel Counter Register before writing the update register.	 	PWM: Update when PWM_CCNTx = 0 or 1	Not fixed	 	Atmel
SAM7S64	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not write 0 in the period register.	 	PWM: Update when PWM_CPRDx = 0	Not fixed	 	Atmel
SAM7S64	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 706 None. 40.19.3 Real Time Timer (RTT)	 	PWM: Counter Start Value	Not fixed	 	Atmel
SAM7S64	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	ARM7	 	Real Time Timer (RTT)	 	The software must handle the RTT event as an interrupt and should not poll RTT_SR. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 707 40.20 SAM7S321 Errata - Revision A Parts Refer to Section 40.1 âMarkingâ on page 595. Note: AT91SAM7S321 Revision A chip ID is: 0x2708 0342. 40.20.1 Analog-to-Digital Converter (ADC)	 	RTT: Possible Event Loss when Reading RTT_SR	Not fixed	 	Atmel
SAM7S321	ADC: DRDY Bit Cleared The DRDY Flag should be clear only after a read of ADC_LCDR (Last Converted Data Register). A read of any ADC_CDRx register (Channel Data Register) automatically clears the DRDY flag.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: DRDY Bit Cleared	Not fixed	 	Atmel
SAM7S321	ADC: DRDY not Cleared on Disable When reading LCDR at the same instant as an end of conversion, with DRDY already active, DRDY is kept active regardless of the enable status of the current channel. This sets DRDY, whereas new data is not stored.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: DRDY not Cleared on Disable	Not fixed	 	Atmel
SAM7S321	ADC: DRDY Possibly Skipped due to CDR Read Reading CDR for channel âyâ at the same instant as an end of conversion on channel âxâ with EOC[x] already active, leads to skipping to set the DRDY flag if channel âxâ is enabled.	ARM7	 	Analog-to-Digital Converter (ADC)	 	Use of DRDY functionality with access to CDR registers should be avoided.	 	ADC: DRDY Possibly Skipped due to CDR Read	Not fixed	 	Atmel
SAM7S321	ADC: Possible Skip on DRDY when Disabling a Channel DRDY does not rise when disabling channel âyâ at the same time as an end of âxâ channel conversion, although data is stored into CDRx and LCDR.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None.	 	ADC: Possible Skip on DRDY when Disabling a Channel	Not fixed	 	Atmel
SAM7S321	ADC: GOVRE Bit is not Updated Read of the Status Register at the same instant as an end of conversion leads to skipping the update of the GOVRE (general overrun) flag. GOVRE is neither reset nor set. For example, if reading the status while an end of conversion is occurring and: 1. GOVRE is active but DRDY is inactive, does not correspond to a new general overrun condition but the GOVRE flag is not reset. 2. GOVRE is inactive but DRDY is active, does correspond to a new general overrun condition but the GOVRE flag is not set.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Updated	Not fixed	 	Atmel
SAM7S321	ADC: GOVRE Bit is not Set when Reading CDR When reading CDRy (Channel Data Register y) at the same instant as an end of conversion on channel âxâ with the following conditions: â¢ EOC[x] already active, â¢ DRDY already active, SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 708 â¢ GOVRE inactive, â¢ previous data stored in LCDR being neither data from channel âyâ, nor data from channel âxâ. GOVRE should be set but is not.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Set when Reading CDR	Not fixed	 	Atmel
SAM7S321	ADC: GOVRE Bit is not Set when Disabling a Channel When disabling channel âyâ at the same instant as an end of conversion on channel âxâ, EOC[x] and DRDY being already active, GOVRE does not rise. Note: OVRE[x] rises as expected.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Set when Disabling a Channel	Not fixed	 	Atmel
SAM7S321	ADC: OVRE Flag Behavior When the OVRE flag (on channel i) has been set but the related EOC status (of channel i) has been cleared (by a read of CDRi or LCDR), reading the Status register at the same instant as an end of conversion (causing the set of EOC status on channel i), does not lead to a reset of the OVRE flag (on channel i) as expected.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: OVRE Flag Behavior	Not fixed	 	Atmel
SAM7S321	ADC: EOC Set although Channel Disabled If a channel is disabled while a conversi on is running and if a read of CDR is performed at the same time as an end of conversion of any channel occurs, the EOC of the channel with the conversion running may rise (whereas it has been disabled).	ARM7	 	Analog-to-Digital Converter (ADC)	 	Do not take into account the EOC of a disabled channel	 	ADC: EOC Set although Channel Disabled	Not fixed	 	Atmel
SAM7S321	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ nor âyâ), reading CDR on channel âzâ at the same instant as an end of conversion on channel âyâ automatically clears EOC[x] instead of EOC[z].	ARM7	 	Analog-to-Digital Converter (ADC)	 	None.	 	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ	Not fixed	 	Atmel
SAM7S321	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	ARM7	 	Analog-to-Digital Converter (ADC)	 	To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit field); to start an analog-to-digital conversion, in order put ADC into sleep mode at the end of this conversion. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 709 40.20.2 Parallel Input/Output Controller (PIO)	 	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after	Not fixed	 	Atmel
SAM7S321	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31 When NRST or PA0-PA16 or PA21-PA31 are set as digital inputs with pull-up enabled, the voltage of the I/O stabilizes at VPull-up. Vpull-up VPull-up Min VPull-up Max VDDIO - 0.65 V VDDIO - 0.45 V This condition causes a leakage through VDDIO. This leakage is 45 ÂµA per pad in worst case at 3.3 V and 25 ÂµA at 1.8V. I Leakage Parameter Typ Max I Leakage at 3,3V 2.5 ÂµA 45 ÂµA I Leakage at 1.8V 1 ÂµA 25 ÂµA	ARM7	 	Parallel Input/Output Controller (PIO)	 	It is recommended to use an external pull-up if needed.	 	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31	Not fixed	 	Atmel
SAM7S321	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31 When NRST or PA0-PA16 and or PA21-PA31 are set as digital inputs with pull-up enabled, driving the I/O with an output impedance higher than 500 ohms may not drive the I/O to a logical zero.	ARM7	 	Parallel Input/Output Controller (PIO)	 	Output impedance must be lower than 500 ohms. 40.20.3 Pulse Width Modulation Controller (PWM)	 	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31	Not fixed	 	Atmel
SAM7S321	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Check the Channel Counter Register before writing the update register.	 	PWM: Update when PWM_CCNTx = 0 or 1	Not fixed	 	Atmel
SAM7S321	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not write 0 in the period register.	 	PWM: Update when PWM_CPRDx = 0	Not fixed	 	Atmel
SAM7S321	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	None.	 	PWM: Counter Start Value	Not fixed	 	Atmel
SAM7S321	PWM: Constraints on Duty Cycle Value Setting Channel Duty Cycle Register (PWM_CDTYx) at 0 in center aligned mode or at 0 or 1 in left aligned mode may change the polarity of the signal. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 710	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not set PWM_CDTYx at 0 in center aligned mode. Do not set PWM_CDTYx at 0 or 1 in left aligned mode.	 	PWM: Constraints on Duty Cycle Value	Not fixed	 	Atmel
SAM7S321	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register Erratic behavior of the CHIDx status bit in the PWM_SR Register. When a channel is disabled by writing in the PWM_DIS Register just after enabling it (before completion of a Clock Period of the clock selected for the channel), the PWM line is internally disabled but the CHIDx status bit in the PWM_SR stays at 1.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not disable a channel before completion of one period of the selected clock. 40.20.4 Real Time Timer (RTT)	 	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register	Not fixed	 	Atmel
SAM7S321	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	ARM7	 	Real Time Timer (RTT)	 	The software must handle the RTT event as an interrupt and should not poll RTT_SR. 40.20.5 Serial Peripheral Interface (SPI)	 	RTT: Possible Event Loss when Reading RTT_SR	Not fixed	 	Atmel
SAM7S321	SPI: Software Reset Must be Written Twice If a software reset (SWRSTin the SPI Control Register) is performed, the SPI may not work properly (the clock is enabled before the chip select.	ARM7	 	Serial Peripheral Interface (SPI)	 	The SPI Control Register field, SWRST needs to be written twice to be set correctly.	 	SPI: Software Reset Must be Written Twice	Not fixed	 	Atmel
SAM7S321	SPI: Pulse Generation on SPCK In Master Mode, there is an additional pulse generated on SPCK when the SPI is configured as follows: â The Baudrate is odd and different from 1 â The Polarity is set to 1 â The Phase is set to 0	ARM7	 	Serial Peripheral Interface (SPI)	 	None.	 	SPI: Pulse Generation on SPCK	Not fixed	 	Atmel
SAM7S321	SPI: Bad tx_ready behavior when CSAAT=1 and SCBR = 1 If the SPI is programmed with CSAAT = 1, SCBR(baudrate) = 1 and two transfers are performed consecutively on the same slave with an IDLE state between them, the tx_ready signal does not rise after the second data has been transferred in the shifter. This can imply for example, that the second data is sent twice.	ARM7	 	Serial Peripheral Interface (SPI)	 	Do not use the combination CSAAT=1 and SCBR =1.	 	SPI: Bad tx_ready behavior when CSAAT=1 and SCBR = 1	Not fixed	 	Atmel
SAM7S321	SPI: LASTXFER (Last Transfer) behavior In FIXED Mode, with CSAAT bit set, and in âPDC modeâ the Chip Select can rise depending on the data written in the SPI_TDR when the TX_EMPTY flag is set. If for example, the PDC writes a â1â in the bit 24 (LASTXFER bit) of the SPI_TDR, the chip select will rise as soon as the TXEMPTY flag is set. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 711	ARM7	 	Serial Peripheral Interface (SPI)	 	Use the CS in PIO mode when PDC mode is required and CS has to be maintained between transfers.	 	SPI: LASTXFER (Last Transfer) behavior	Not fixed	 	Atmel
SAM7S321	SPI: SPCK Behavior in Master Mode SPCK pin can toggle out before the first transfer in Master Mode.	ARM7	 	Serial Peripheral Interface (SPI)	 	In Master Mode, MSTR bit must be set (in SPI_MR register) before configuring SPI_CSRx registers.	 	SPI: SPCK Behavior in Master Mode	Not fixed	 	Atmel
SAM7S321	SPI: Chip Select and Fixed Mode In fixed Mode, if a transfer is performed through a PDC on a Chip select different from the Chip select 0, the output spi_size sampled by the PDC will depend on the field, BITS (Bits per Transfer) of SPI_CSR0 register, whatever the selected Chip select is. For example, if SPI_CSR0 is configured for a 10-bit transfer whereas SPI_CSR1 is configured for an 8-bit transfer, when a transfer is performed in Fixed mode through the PDC, on Chip select 1, the transfer will be considered as a HalfWord transfer.	ARM7	 	Serial Peripheral Interface (SPI)	 	If a PDC transfer has to be performed in 8 bits, on a Chip select y (y as different from 0), the BITS field of the SPI_CSR0 must be configured in 8 bits, in the same way as the BITS field of the CSRy Register.	 	SPI: Chip Select and Fixed Mode	Not fixed	 	Atmel
SAM7S321	SPI: Baudrate Set to 1 When Baudrate is set at 1 (i.e. when serial clock frequency equals the system clock frequency) and when the BITS field of the SPI_CSR register (number of bits to be transmitted) equals an ODD value (in this case 9,11,13 or 15), an additional pulse will be generated on output SPCK. Everything is OK if the BITS field equals 8,10,12,14 or 16 and Baudrate = 1.	ARM7	 	Serial Peripheral Interface (SPI)	 	None.	 	SPI: Baudrate Set to 1	Not fixed	 	Atmel
SAM7S321	SPI: Disable In Slave Mode The SPI disable is not possible in slave mode.	ARM7	 	Serial Peripheral Interface (SPI)	 	Read first the received data, then perform the software reset.	 	SPI: Disable In Slave Mode	Not fixed	 	Atmel
SAM7S321	SPI: Bad Serial Clock Generation on 2nd Chip Select Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0. This occurs using SPI with the following conditions: â¢ Master Mode â¢ CPOL = 1 and NCPHA = 0 â¢ Multiple chip selects are used with one transfer with Baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR are not equal to 1 â¢ Transmitting with the slowest chip select and then with the fastest one, then an additional on output SPCK during the second transfer. pulse is generated	ARM7	 	Serial Peripheral Interface (SPI)	 	Do not use a multiple Chip Select configuration where at least one SCRx register is configured with SCBR = 1 and the others differ from 1 if NCPHA = 0 and CPOL = 1. If all chip selects are configured with Baudrate = 1, the issue does not appear. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 712 40.20.6 Synchronous Serial Controller (SSC)	 	SPI: Bad Serial Clock Generation on 2nd Chip Select	Not fixed	 	Atmel
SAM7S321	SSC: Periodic Transmission Limitations in Master Mode If the Least Significant Bit is sent first (MSBF = 0), the first TAG during the frame synchro is not sent.	ARM7	 	Synchronous Serial Controller (SSC)	 	None.	 	SSC: Periodic Transmission Limitations in Master Mode	Not fixed	 	Atmel
SAM7S321	SSC: Transmitter Limitations in Slave Mode If TK is programmed as output and TF is programmed as input, it is impossible to emit data when the start of edge (rising or falling) of synchro has a Start Delay equal to zero.	ARM7	 	Synchronous Serial Controller (SSC)	 	None.	 	SSC: Transmitter Limitations in Slave Mode	Not fixed	 	Atmel
SAM7S321	SSC: Transmitter Limitations in Slave Mode If TK is programmed as an input and TF is programmed as an output and requested to be set to low/high during data emission, the Frame Synchro signal is generated one bit clock period after the data start and one data bit is lost. This problem does not exist when generating a periodic synchro.	ARM7	 	Synchronous Serial Controller (SSC)	 	The data need to be delayed for one bit clock period with an external assembly. In the following schematic, TD, TK and NRST are SAM7S signals, TXD is the delayed data to connect to the device. 40.20.7 Two-wire Interface (TWI)	 	SSC: Transmitter Limitations in Slave Mode	Not fixed	 	Atmel
SAM7S321	TWI: Clock Divider The value of CLDIV x 2 CKDIV must be less than or equal to 8191 the value of CHDIV x 2 CKDIV must be less than or equal to 8191	ARM7	 	Two-wire Interface (TWI)	 	None.	 	TWI: Clock Divider	Not fixed	 	Atmel
SAM7S321	TWI: Software Reset When a software reset is performed during a frame and when TWCK is low, it is impossible to initiate a new transfer in READ or WRITE mode. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 713	ARM7	 	Two-wire Interface (TWI)	 	None.	 	TWI: Software Reset	Not fixed	 	Atmel
SAM7S321	TWI: Disabling Does not Operate Correctly Any transfer in progress is immediately frozen if the Control Register (TWI_CR) is written with the bit MSDIS at 1. Furthermore, the status bits TXCOMP and TXRDY in the Status Register (TWI_SR) are not reset.	ARM7	 	Two-wire Interface (TWI)	 	The user must wait for the end of transfer before disabling the TWI. In addition, the interrupts must be disabled before disabling the TWI.	 	TWI: Disabling Does not Operate Correctly	Not fixed	 	Atmel
SAM7S321	TWI: NACK Status Bit Lost During a master frame, if TWI_SR is read between the Non Acknowledge condition detection and the TXCOMP bit rising in the TWI_SR, the NACK bit is not set.	ARM7	 	Two-wire Interface (TWI)	 	The user must wait for the TXCOMP status bit by interrupt and must not read the TWI_SR as long as transmission is not completed. TXCOMP and NACK fields are set simultaneously and the NACK field is reset after the read of the TWI_SR.	 	TWI: NACK Status Bit Lost	Not fixed	 	Atmel
SAM7S321	TWI: Possible Receive Holding Register Corruption When loading the TWI_RHR, the transfer direction is ignored. The last data byte received in the TWI_RHR is corrupted at the end of the first subsequent transmit data byte . Neither RXRDY nor OVERRUN status bits are set if this occurs.	ARM7	 	Two-wire Interface (TWI)	 	The user must be sure that received data is read before transmitting any new data. 40.20.8 Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	TWI: Possible Receive Holding Register Corruption	Not fixed	 	Atmel
SAM7S321	USART: Hardware Handshake The Hardware Handshake does not work at speeds higher than 750 kbauds.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	None.	 	USART: Hardware Handshake	Not fixed	 	Atmel
SAM7S321	USART: CTS in Hardware Handshaking When Hardware Handshaking is used and if CTS goes low near the end of the starting bit, a character can be lost.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	CTS must not go low during a time slot occurring between 2 Master Clock periods before the starting bit and 16 Master Clock periods after the rising edge of the starting bit.	 	USART: CTS in Hardware Handshaking	Not fixed	 	Atmel
SAM7S321	USART: Hardware Handshaking â Two Characters Sent If CTS switches from 0 to 1 during the TX of a character and if the holding register (US_THR) is not empty, the content of US_THR will also be transmitted.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	Don't use the PDC in transmit mode and do not fill US_THR before TXEMPTY is set at 1. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 714	 	USART: Hardware Handshaking â Two Characters Sent	Not fixed	 	Atmel
SAM7S321	USART: XOFF Character Bad Behavior The XOFF character is sent only when the receive buffer is detected full. While the XOFF is being sent, the remote transmitter is still transmitting. As only one Holding register is available in the receiver, characters will be lost in reception. This makes the software handshaking functionality ineffective.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	None.	 	USART: XOFF Character Bad Behavior	Not fixed	 	Atmel
SAM7S321	USART: DCD is active High instead of Low The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	Add an inverter. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 715 40.21 SAM7S32 Errata - Manufacturing Number 58814G Refer to Section 40.1 âMarkingâ on page 595. 40.21.1 Analog-to-Digital Converter (ADC)	 	USART: DCD is active High instead of Low	Not fixed	 	Atmel
SAM7S32	ADC: DRDY Bit Cleared The DRDY Flag should be clear only after a read of ADC_LCDR (Last Converted Data Register). A read of any ADC_CDRx register (Channel Data Register) automatically clears the DRDY flag.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: DRDY Bit Cleared	Not fixed	 	Atmel
SAM7S32	ADC: DRDY not Cleared on Disable When reading LCDR at the same instant as an end of conversion, with DRDY already active, DRDY is kept active regardless of the enable status of the current channel. This sets DRDY, whereas new data is not stored.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: DRDY not Cleared on Disable	Not fixed	 	Atmel
SAM7S32	ADC: DRDY Possibly Skipped due to CDR Read Reading CDR for channel âyâ at the same instant as an end of conversion on channel âxâ with EOC[x] already active, leads to skipping to set the DRDY flag if channel âxâ is enabled.	ARM7	 	Analog-to-Digital Converter (ADC)	 	Use of DRDY functionality with access to CDR registers should be avoided.	 	ADC: DRDY Possibly Skipped due to CDR Read	Not fixed	 	Atmel
SAM7S32	ADC: Possible Skip on DRDY when Disabling a Channel DRDY does not rise when disabling channel âyâ at the same time as an end of âxâ channel conversion, although data is stored into CDRx and LCDR.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None.	 	ADC: Possible Skip on DRDY when Disabling a Channel	Not fixed	 	Atmel
SAM7S32	ADC: GOVRE Bit is not Updated Read of the Status Register at the same instant as an end of conversion leads to skipping the update of the GOVRE (general overrun) flag. GOVRE is neither reset nor set. For example, if reading the status while an end of conversion is occurring and: 1. GOVRE is active but DRDY is inactive, does not correspond to a new general overrun condition but the GOVRE flag is not reset. 2. GOVRE is inactive but DRDY is active, does correspond to a new general overrun condition but the GOVRE flag is not set.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Updated	Not fixed	 	Atmel
SAM7S32	ADC: GOVRE Bit is not Set when Reading CDR When reading CDRy (Channel Data Register y) at the same instant as an end of conversion on channel âxâ with the following conditions: â¢ EOC[x] already active, â¢ DRDY already active, â¢ GOVRE inactive, SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 716 â¢ previous data stored in LCDR being neither data from channel âyâ, nor data from channel âxâ. GOVRE should be set but is not.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Set when Reading CDR	Not fixed	 	Atmel
SAM7S32	ADC: GOVRE Bit is not Set when Disabling a Channel When disabling channel âyâ at the same instant as an end of conversion on channel âxâ, EOC[x] and DRDY being already active, GOVRE does not rise. Note: OVRE[x] rises as expected.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Set when Disabling a Channel	Not fixed	 	Atmel
SAM7S32	ADC: OVRE Flag Behavior When the OVRE flag (on channel i) has been set but the related EOC status (of channel i) has been cleared (by a read of CDRi or LCDR), reading the Status register at the same instant as an end of conversion (causing the set of EOC status on channel i), does not lead to a reset of the OVRE flag (on channel i) as expected.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: OVRE Flag Behavior	Not fixed	 	Atmel
SAM7S32	ADC: EOC Set although Channel Disabled If a channel is disabled while a conversi on is running and if a read of CDR is performed at the same time as an end of conversion of any channel occurs, the EOC of the channel with the conversion running may rise (whereas it has been disabled).	ARM7	 	Analog-to-Digital Converter (ADC)	 	Do not take into account the EOC of a disabled channel	 	ADC: EOC Set although Channel Disabled	Not fixed	 	Atmel
SAM7S32	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ nor âyâ), reading CDR on channel âzâ at the same instant as an end of conversion on channel âyâ automatically clears EOC[x] instead of EOC[z].	ARM7	 	Analog-to-Digital Converter (ADC)	 	None.	 	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ	Not fixed	 	Atmel
SAM7S32	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	ARM7	 	Analog-to-Digital Converter (ADC)	 	To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit field); to start an analog-to-digital conversion, in order put ADC into sleep mode at the end of this conversion. 40.21.2 JTAG	 	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after	Not fixed	 	Atmel
SAM7S32	JTAG: Recommendation for TDI Pin TDI pin shows a weakness which does not effect the operation of the device. If this pin is driven over 2.0V or exposed to high electrostatic voltages, the pad might be partially destroyed and this can lead to additional continuous leakage on VDDCORE between 100 and 500 ÂµA. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 717 However, this does not prevent JTAG operations.	ARM7	 	JTAG	 	The JTAG port remains operational even if the failure on TDI has happened. Therefore the users can develop their applications in normal conditions, except the overall system power consumption might be higher. It is recommended to handle the devices carefully during PCB soldering and to correctly ground the manufacturing equipment. To prevent any failure on the final customer's systems, it is also recommended to tie the TDI pin at GND in the system production release and to not pull it up, as it is shown on the SAM7S-EK Evaluation Board schematics. 40.21.3 Master Clock (MCK)	 	JTAG: Recommendation for TDI Pin	Not fixed	 	Atmel
SAM7S32	MCK: Limited Master Clock Frequency Ranges If the Flash is operating without wait states, the frequency of the Master Clock MCK must be lower than 3 MHz or higher than 19 MHz. If the Flash is operating with one wait state, the frequency of the Master Clock MCK must be lower than 3 MHz or higher than 19 MHz. If the Flash is operating with two wait states, the frequency of the Master Clock MCK must be lower than 3 MHz or higher than 25 MHz. If the Flash is operating with three wait states, the frequency of the Master Clock MCK must be lower than 3 MHz or higher than 38 MHz. If these constraints are not respected, the correct operation of the system cannot be guaranteed and either data or prefetch abort might occur. The maximum operating frequencies (at 30 MHz @ 0 Wait States and 55 MHz @ 1 Wait State) as stated in Table 37-24, âEmbedded Flash Wait States,â on page 582, are still applicable. Note: It is not necessary to use 2 o 3 wait states because t he Flash can operate at maximum frequency with only 1 wait state.	ARM7	 	Master Clock (MCK)	 	The user must ensure that the device is running at the authorized frequency by programming the PLL properly to not run within the forbidden frequency range. 40.21.4 Non Volatile Memory Bits (NVM Bits)	 	MCK: Limited Master Clock Frequency Ranges	Not fixed	 	Atmel
SAM7S32	NVM Bits: Write/Erase Cycles Number The maximum number of write/erase cycles for Non Volatile Memory bits is 100. This includes Lock Bits (LOCKx), General Purpose NVM bits (GPNVMx) and the Security Bit. This maximum number of write/erase cycles is not applicable to 32 KB Flash memory, it remains at10K for the Flash memory.	ARM7	 	Non Volatile Memory Bits (NVM Bits)	 	None. 40.21.5 Parallel Input/Output Controller (PIO)	 	NVM Bits: Write/Erase Cycles Number	Not fixed	 	Atmel
SAM7S32	PIO: Leakage on PA17 - PA20 When PA17, PA18, PA19 or PA20 (the I/O lines multiplexed with the analog inputs) are set as digital inputs with pull-up disabled, the leakage can be 9 ÂµA in worst case and 90 nA in typical case per I/O when the I/O is set externally at low level. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 718	ARM7	 	Parallel Input/Output Controller (PIO)	 	Set the I/O to VDDIO by internal or external pull-up.	 	PIO: Leakage on PA17 - PA20	Not fixed	 	Atmel
SAM7S32	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31 When NRST or PA0-PA16 or PA21-PA31 are set as digital inputs with pull-up enabled, the voltage of the I/O stabilizes at VPull-up. Vpull-up VPull-up Min VPull-up Max VDDIO - 0.65 V VDDIO - 0.45 V This condition causes a leakage through VDDIO. This leakage is 45 ÂµA per pad in worst case at 3.3 V and 25 ÂµA at 1.8V. I Leakage Parameter Typ Max I Leakage at 3,3V 2.5 ÂµA 45 ÂµA I Leakage at 1.8V 1 ÂµA 25 ÂµA	ARM7	 	Parallel Input/Output Controller (PIO)	 	It is recommended to use an external pull-up if needed.	 	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31	Not fixed	 	Atmel
SAM7S32	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31 When NRST or PA0-PA16 and or PA21-PA31 are set as digital inputs with pull-up enabled, driving the I/O with an output impedance higher than 500 ohms may not drive the I/O to a logical zero.	ARM7	 	Parallel Input/Output Controller (PIO)	 	Output impedance must be lower than 500 ohms. 40.21.6 Pulse Width Modulation Controller (PWM)	 	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31	Not fixed	 	Atmel
SAM7S32	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Check the Channel Counter Register before writing the update register.	 	PWM: Update when PWM_CCNTx = 0 or 1	Not fixed	 	Atmel
SAM7S32	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not write 0 in the period register.	 	PWM: Update when PWM_CPRDx = 0	Not fixed	 	Atmel
SAM7S32	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	None. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 719	 	PWM: Counter Start Value	Not fixed	 	Atmel
SAM7S32	PWM: Constraints on Duty Cycle Value Setting Channel Duty Cycle Register (PWM_CDTYx) at 0 in center aligned mode or at 0 or 1 in left aligned mode may change the polarity of the signal.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not set PWM_CDTYx at 0 in center aligned mode. Do not set PWM_CDTYx at 0 or 1 in left aligned mode.	 	PWM: Constraints on Duty Cycle Value	Not fixed	 	Atmel
SAM7S32	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register Erratic behavior of the CHIDx status bit in the PWM_SR Register. When a channel is disabled by writing in the PWM_DIS Register just after enabling it (before completion of a Clock Period of the clock selected for the channel), the PWM line is internally disabled but the CHIDx status bit in the PWM_SR stays at 1.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not disable a channel before completion of one period of the selected clock. 40.21.7 Serial Peripheral Interface (SPI)	 	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register	Not fixed	 	Atmel
SAM7S32	SPI: Pulse Generation on SPCK In Master Mode, there is an additional pulse generated on SPCK when the SPI is configured as follows: â The Baudrate is odd and different from 1 â The Polarity is set to 1 â The Phase is set to 0	ARM7	 	Serial Peripheral Interface (SPI)	 	None.	 	SPI: Pulse Generation on SPCK	Not fixed	 	Atmel
SAM7S32	SPI: Bad tx_ready behavior when CSAAT=1 and SCBR = 1 If the SPI is programmed with CSAAT = 1, SCBR(baudrate) = 1 and two transfers are performed consecutively on the same slave with an IDLE state between them, the tx_ready signal does not rise after the second data has been transferred in the shifter. This can imply for example, that the second data is sent twice.	ARM7	 	Serial Peripheral Interface (SPI)	 	Do not use the combination CSAAT=1 and SCBR =1.	 	SPI: Bad tx_ready behavior when CSAAT=1 and SCBR = 1	Not fixed	 	Atmel
SAM7S32	SPI: LASTXFER (Last Transfer) behavior In FIXED Mode, with CSAAT bit set, and in âPDC modeâ the Chip Select can rise depending on the data written in the SPI_TDR when the TX_EMPTY flag is set. If for example, the PDC writes a â1â in the bit 24 (LASTXFER bit) of the SPI_TDR, the chip select will rise as soon as the TXEMPTY flag is set.	ARM7	 	Serial Peripheral Interface (SPI)	 	Use the CS in PIO mode when PDC mode is required and CS has to be maintained between transfers.	 	SPI: LASTXFER (Last Transfer) behavior	Not fixed	 	Atmel
SAM7S32	SPI: SPCK Behavior in Master Mode SPCK pin can toggle out before the first transfer in Master Mode.	ARM7	 	Serial Peripheral Interface (SPI)	 	In Master Mode, MSTR bit must be set (in SPI_MR register) before configuring SPI_CSRx registers.	 	SPI: SPCK Behavior in Master Mode	Not fixed	 	Atmel
SAM7S32	SPI: Chip Select and Fixed Mode In fixed Mode, if a transfer is performed through a PDC on a Chip select different from the Chip select 0, the output spi_size sampled by the PDC will depend on the field, BITS (Bits per Transfer) of SPI_CSR0 register, whatever the SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 720 selected Chip select is. For example, if SPI_CSR0 is configured for a 10-bit transfer whereas SPI_CSR1 is configured for an 8-bit transfer, when a transfer is performed in Fixed mode through the PDC, on Chip select 1, the transfer will be considered as a HalfWord transfer.	ARM7	 	Serial Peripheral Interface (SPI)	 	If a PDC transfer has to be performed in 8 bits, on a Chip select y (y as different from 0), the BITS field of the SPI_CSR0 must be configured in 8 bits, in the same way as the BITS field of the CSRy Register.	 	SPI: Chip Select and Fixed Mode	Not fixed	 	Atmel
SAM7S32	SPI: Baudrate Set to 1 When Baudrate is set at 1 (i.e. when serial clock frequency equals the system clock frequency) and when the BITS field of the SPI_CSR register (number of bits to be transmitted) equals an ODD value (in this case 9,11,13 or 15), an additional pulse will be generated on output SPCK. Everything is OK if the BITS field equals 8,10,12,14 or 16 and Baudrate = 1.	ARM7	 	Serial Peripheral Interface (SPI)	 	None.	 	SPI: Baudrate Set to 1	Not fixed	 	Atmel
SAM7S32	SPI: Disable In Slave Mode The SPI disable is not possible in slave mode.	ARM7	 	Serial Peripheral Interface (SPI)	 	Read first the received data, then perform the software reset.	 	SPI: Disable In Slave Mode	Not fixed	 	Atmel
SAM7S32	SPI: Disable Issue The SPI Command âSPI Disableâ is not possible during a transfer, it must be performed only after TX_EMPTY rising else there is everlasting dummy transfers occur.	ARM7	 	Serial Peripheral Interface (SPI)	 	None.	 	SPI: Disable Issue	Not fixed	 	Atmel
SAM7S32	SPI: Software Reset and SPIEN Bit The SPI Command âsoftware resetâ does not reset the SPIEN config bit. Therefore rewriting an SPI enable command does not set TX_READY, TX_EMPTY flags.	ARM7	 	Serial Peripheral Interface (SPI)	 	Send SPI disable command after a software reset.	 	SPI: Software Reset and SPIEN Bit	Not fixed	 	Atmel
SAM7S32	If CSAAT = 1 for current access and there is no more TX request for a time greater than DLYBCT + DLYBCS, then if an access is requested on another slave, the NPCS bus switches from one CS to the one requested without DLYBCS. External Slaves may reach a contention on SPI_MISO line for a short period.	ARM7	 	Serial Peripheral Interface (SPI)	 	Assert the Last Transfer Command (NPCS de-activation) for the last character of each slave.	 	If CSAAT = 1 for current access and there is no more TX request for a time greater than DLYBCT + DLYBCS, then	Not fixed	 	Atmel
SAM7S32	Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0. This occurs using SPI with the following conditions: â¢ Master Mode â¢ CPOL = 1 and NCPHA = 0 â¢ Multiple chip selects are used with one transfer with Baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR are not equal to 1 SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 721 â¢ Transmitting with the slowest chip select and then with the fastest one, then an additional on output SPCK during the second transfer. pulse is generated	ARM7	 	Serial Peripheral Interface (SPI)	 	Do not use a multiple Chip Select configuration where at least one SCRx register is configured with SCBR = 1 and the others differ from 1 if NCPHA = 0 and CPOL = 1. If all chip selects are configured with Baudrate = 1, the issue does not appear. 40.21.8 Synchronous Serial Controller (SSC)	 	Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0.	Not fixed	 	Atmel
SAM7S32	SSC: Periodic Transmission Limitations in Master Mode If the Least Significant Bit is sent first (MSBF = 0), the first TAG during the frame synchro is not sent.	ARM7	 	Synchronous Serial Controller (SSC)	 	None.	 	SSC: Periodic Transmission Limitations in Master Mode	Not fixed	 	Atmel
SAM7S32	SSC: Transmitter Limitations in Slave Mode If TK is programmed as output and TF is programmed as input, it is impossible to emit data when the start of edge (rising or falling) of synchro has a Start Delay equal to zero.	ARM7	 	Synchronous Serial Controller (SSC)	 	None.	 	SSC: Transmitter Limitations in Slave Mode	Not fixed	 	Atmel
SAM7S32	SSC: Transmitter Limitations in Slave Mode If TK is programmed as an input and TF is programmed as an output and requested to be set to low/high during data emission, the Frame Synchro signal is generated one bit clock period after the data start and one data bit is lost. This problem does not exist when generating a periodic synchro.	ARM7	 	Synchronous Serial Controller (SSC)	 	The data need to be delayed for one bit clock period with an external assembly. In the following schematic, TD, TK and NRST are SAM7S signals, TXD is the delayed data to connect to the device. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 722 40.21.9 Two-wire Interface (TWI)	 	SSC: Transmitter Limitations in Slave Mode	Not fixed	 	Atmel
SAM7S32	TWI: Clock Divider The value of CLDIV x 2 CKDIV must be less than or equal to 8191 the value of CHDIV x 2 CKDIV must be less than or equal to 8191	ARM7	 	Two-wire Interface (TWI)	 	None.	 	TWI: Clock Divider	Not fixed	 	Atmel
SAM7S32	TWI: Software Reset When a software reset is performed during a frame and when TWCK is low, it is impossible to initiate a new transfer in READ or WRITE mode.	ARM7	 	Two-wire Interface (TWI)	 	None.	 	TWI: Software Reset	Not fixed	 	Atmel
SAM7S32	TWI: Disabling Does not Operate Correctly Any transfer in progress is immediately frozen if the Control Register (TWI_CR) is written with the bit MSDIS at 1. Furthermore, the status bits TXCOMP and TXRDY in the Status Register (TWI_SR) are not reset.	ARM7	 	Two-wire Interface (TWI)	 	The user must wait for the end of transfer before disabling the TWI. In addition, the interrupts must be disabled before disabling the TWI.	 	TWI: Disabling Does not Operate Correctly	Not fixed	 	Atmel
SAM7S32	TWI: NACK Status Bit Lost During a master frame, if TWI_SR is read between the Non Acknowledge condition detection and the TXCOMP bit rising in the TWI_SR, the NACK bit is not set.	ARM7	 	Two-wire Interface (TWI)	 	The user must wait for the TXCOMP status bit by interrupt and must not read the TWI_SR as long as transmission is not completed. TXCOMP and NACK fields are set simultaneously and the NACK field is reset after the read of the TWI_SR.	 	TWI: NACK Status Bit Lost	Not fixed	 	Atmel
SAM7S32	TWI: Possible Receive Holding Register Corruption When loading the TWI_RHR, the transfer direction is ignored. The last data byte received in the TWI_RHR is corrupted at the end of the first subsequent transmit data byte. Neither RXRDY nor OVERRUN status bits are set if this occurs.	ARM7	 	Two-wire Interface (TWI)	 	The user must be sure that received data is read before transmitting any new data. 40.21.10 Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	TWI: Possible Receive Holding Register Corruption	Not fixed	 	Atmel
SAM7S32	The Hardware Handshake does not work at speeds higher than 750 kbauds.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	None.	 	The Hardware Handshake does not work at speeds higher than 750 kbauds.	Not fixed	 	Atmel
SAM7S32	When Hardware Handshaking is used and if CTS goes low near the end of the starting bit, a character can be lost.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 723 CTS must not go low during a time slot occurring between 2 Master Clock periods before the starting bit and 16 Master Clock periods after the rising edge of the starting bit.	 	When Hardware Handshaking is used and if CTS goes low near the end of the starting bit, a character can be lost.	Not fixed	 	Atmel
SAM7S32	If CTS switches from 0 to 1 during the TX of a character and if the holding register (US_THR) is not empty, the content of US_THR will also be transmitted.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	Don't use the PDC in transmit mode and do not fill US_THR before TXEMPTY is set at 1.	 	If CTS switches from 0 to 1 during the TX of a character and if the holding register (US_THR) is not empty, the content of US_THR will also be transmitted.	Not fixed	 	Atmel
SAM7S32	The XOFF character is sent only when the receive buffer is detected full. While the XOFF is being sent, the remote transmitter is still transmitting. As only one Holding register is available in the receiver, characters will be lost in reception. This makes the software handshaking functionality ineffective.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	None.	 	The XOFF character is sent only when the receive buffer is detected full. While the XOFF is being sent, the remote	Not fixed	 	Atmel
SAM7S32	The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	Add an inverter. 40.21.11 Voltage Regulator	 	The DCD signal is active at High level in the USART Modem Mode.	Not fixed	 	Atmel
SAM7S32	Current consumption in Deep Mode is maximum 60 ÂµA instead of 25 ÂµA. Due to current rejection from VDDIN to VDDCORE, the current consumption in Deep Mode cannot be guaranteed. Instead, 60 ÂµA is guaranteed whatever the condition.	ARM7	 	Voltage Regulator	 	None.	 	Current consumption in Deep Mode is maximum 60 ÂµA instead of 25 ÂµA.	Not fixed	 	Atmel
SAM7S32	Maximum load is 50 mA at 85 Â°C (instead of 100 mA). Maximum load is 100 mA at 70Â°C.	ARM7	 	Voltage Regulator	 	None. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 724 40.22 SAM7S32 Errata - Revision A Parts Refer to Section 40.1 âMarkingâ on page 595. Note: AT91SAM7S32 Revision A chip ID is 0x2708 0340. 40.22.1 Analog-to-Digital Converter (ADC)	 	Maximum load is 50 mA at 85 Â°C (instead of 100 mA).	Not fixed	 	Atmel
SAM7S32	ADC: DRDY Bit Cleared The DRDY Flag should be clear only after a read of ADC_LCDR (Last Converted Data Register). A read of any ADC_CDRx register (Channel Data Register) automatically clears the DRDY flag.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: DRDY Bit Cleared	Not fixed	 	Atmel
SAM7S32	ADC: DRDY not Cleared on Disable When reading LCDR at the same instant as an end of conversion, with DRDY already active, DRDY is kept active regardless of the enable status of the current channel. This sets DRDY, whereas new data is not stored.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: DRDY not Cleared on Disable	Not fixed	 	Atmel
SAM7S32	ADC: DRDY Possibly Skipped due to CDR Read Reading CDR for channel âyâ at the same instant as an end of conversion on channel âxâ with EOC[x] already active, leads to skipping to set the DRDY flag if channel âxâ is enabled.	ARM7	 	Analog-to-Digital Converter (ADC)	 	Use of DRDY functionality with access to CDR registers should be avoided.	 	ADC: DRDY Possibly Skipped due to CDR Read	Not fixed	 	Atmel
SAM7S32	ADC: Possible Skip on DRDY when Disabling a Channel DRDY does not rise when disabling channel âyâ at the same time as an end of âxâ channel conversion, although data is stored into CDRx and LCDR.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None.	 	ADC: Possible Skip on DRDY when Disabling a Channel	Not fixed	 	Atmel
SAM7S32	ADC: GOVRE Bit is not Updated Read of the Status Register at the same instant as an end of conversion leads to skipping the update of the GOVRE (general overrun) flag. GOVRE is neither reset nor set. For example, if reading the status while an end of conversion is occurring and: 1. GOVRE is active but DRDY is inactive, does not correspond to a new general overrun condition but the GOVRE flag is not reset. 2. GOVRE is inactive but DRDY is active, does correspond to a new general overrun condition but the GOVRE flag is not set.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Updated	Not fixed	 	Atmel
SAM7S32	ADC: GOVRE Bit is not Set when Reading CDR When reading CDRy (Channel Data Register y) at the same instant as an end of conversion on channel âxâ with the following conditions: â¢ EOC[x] already active, â¢ DRDY already active, SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 725 â¢ GOVRE inactive, â¢ previous data stored in LCDR being neither data from channel âyâ, nor data from channel âxâ. GOVRE should be set but is not.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Set when Reading CDR	Not fixed	 	Atmel
SAM7S32	ADC: GOVRE Bit is not Set when Disabling a Channel When disabling channel âyâ at the same instant as an end of conversion on channel âxâ, EOC[x] and DRDY being already active, GOVRE does not rise. Note: OVRE[x] rises as expected.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Set when Disabling a Channel	Not fixed	 	Atmel
SAM7S32	ADC: OVRE Flag Behavior When the OVRE flag (on channel i) has been set but the related EOC status (of channel i) has been cleared (by a read of CDRi or LCDR), reading the Status register at the same instant as an end of conversion (causing the set of EOC status on channel i), does not lead to a reset of the OVRE flag (on channel i) as expected.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: OVRE Flag Behavior	Not fixed	 	Atmel
SAM7S32	ADC: EOC Set although Channel Disabled If a channel is disabled while a conversi on is running and if a read of CDR is performed at the same time as an end of conversion of any channel occurs, the EOC of the channel with the conversion running may rise (whereas it has been disabled).	ARM7	 	Analog-to-Digital Converter (ADC)	 	Do not take into account the EOC of a disabled channel	 	ADC: EOC Set although Channel Disabled	Not fixed	 	Atmel
SAM7S32	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ nor âyâ), reading CDR on channel âzâ at the same instant as an end of conversion on channel âyâ automatically clears EOC[x] instead of EOC[z].	ARM7	 	Analog-to-Digital Converter (ADC)	 	None.	 	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ	Not fixed	 	Atmel
SAM7S32	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	ARM7	 	Analog-to-Digital Converter (ADC)	 	To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit field); to start an analog-to-digital conversion, in order put ADC into sleep mode at the end of this conversion. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 726 40.22.2 Non Volatile Memory Bits (NVM Bits)	 	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after	Not fixed	 	Atmel
SAM7S32	NVM Bits: Write/Erase Cycles Number The maximum number of write/erase cycles for Non Volatile Memory bits is 100. This includes Lock Bits (LOCKx), General Purpose NVM bits (GPNVMx) and the Security Bit. This maximum number of write/erase cycles is not applicable to 64 KB Flash memory, it remains at10K for the Flash memory.	ARM7	 	Non Volatile Memory Bits (NVM Bits)	 	None. 40.22.3 Parallel Input/Output Controller (PIO)	 	NVM Bits: Write/Erase Cycles Number	Not fixed	 	Atmel
SAM7S32	PIO: Leakage on PA17 - PA20 When PA17, PA18, PA19 or PA20 (the I/O lines multiplexed with the analog inputs) are set as digital inputs with pull-up disabled, the leakage can be 9 ÂµA in worst case and 90 nA in typical case per I/O when the I/O is set externally at low level.	ARM7	 	Parallel Input/Output Controller (PIO)	 	Set the I/O to VDDIO by internal or external pull-up.	 	PIO: Leakage on PA17 - PA20	Not fixed	 	Atmel
SAM7S32	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31 When NRST or PA0-PA16 or PA21-PA31 are set as digital inputs with pull-up enabled, the voltage of the I/O stabilizes at VPull-up. Vpull-up VPull-up Min VPull-up Max VDDIO - 0.65 V VDDIO - 0.45 V This condition causes a leakage through VDDIO. This leakage is 45 ÂµA per pad in worst case at 3.3 V and 25 ÂµA at 1.8V. I Leakage Parameter Typ Max I Leakage at 3,3V 2.5 ÂµA 45 ÂµA I Leakage at 1.8V 1 ÂµA 25 ÂµA	ARM7	 	Parallel Input/Output Controller (PIO)	 	It is recommended to use an external pull-up if needed.	 	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31	Not fixed	 	Atmel
SAM7S32	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31 When NRST or PA0-PA16 and or PA21-PA31 are set as digital inputs with pull-up enabled, driving the I/O with an output impedance higher than 500 ohms may not drive the I/O to a logical zero.	ARM7	 	Parallel Input/Output Controller (PIO)	 	Output impedance must be lower than 500 ohms. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 727 40.22.4 Pulse Width Modulation Controller (PWM)	 	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31	Not fixed	 	Atmel
SAM7S32	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Check the Channel Counter Register before writing the update register.	 	PWM: Update when PWM_CCNTx = 0 or 1	Not fixed	 	Atmel
SAM7S32	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not write 0 in the period register.	 	PWM: Update when PWM_CPRDx = 0	Not fixed	 	Atmel
SAM7S32	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	None.	 	PWM: Counter Start Value	Not fixed	 	Atmel
SAM7S32	PWM: Constraints on Duty Cycle Value Setting Channel Duty Cycle Register (PWM_CDTYx) at 0 in center aligned mode or at 0 or 1 in left aligned mode may change the polarity of the signal.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not set PWM_CDTYx at 0 in center aligned mode. Do not set PWM_CDTYx at 0 or 1 in left aligned mode.	 	PWM: Constraints on Duty Cycle Value	Not fixed	 	Atmel
SAM7S32	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register Erratic behavior of the CHIDx status bit in the PWM_SR Register. When a channel is disabled by writing in the PWM_DIS Register just after enabling it (before completion of a Clock Period of the clock selected for the channel), the PWM line is internally disabled but the CHIDx status bit in the PWM_SR stays at 1.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not disable a channel before completion of one period of the selected clock. 40.22.5 Real Time Timer (RTT)	 	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register	Not fixed	 	Atmel
SAM7S32	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	ARM7	 	Real Time Timer (RTT)	 	The software must handle the RTT event as an interrupt and should not poll RTT_SR. 40.22.6 Serial Peripheral Interface (SPI)	 	RTT: Possible Event Loss when Reading RTT_SR	Not fixed	 	Atmel
SAM7S32	20. SPI: Pulse Generation on SPCK In Master Mode, there is an additional pulse generated on SPCK when the SPI is configured as follows: â The Baudrate is odd and different from 1 â The Polarity is set to 1 â The Phase is set to 0 SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 728	ARM7	 	Serial Peripheral Interface (SPI)	 	None.	 	20. SPI: Pulse Generation on SPCK	Not fixed	 	Atmel
SAM7S32	SPI: Bad tx_ready behavior when CSAAT=1 and SCBR = 1 If the SPI is programmed with CSAAT = 1, SCBR(baudrate) = 1 and two transfers are performed consecutively on the same slave with an IDLE state between them, the tx_ready signal does not rise after the second data has been transferred in the shifter. This can imply for example, that the second data is sent twice.	ARM7	 	Serial Peripheral Interface (SPI)	 	Do not use the combination CSAAT=1 and SCBR =1.	 	SPI: Bad tx_ready behavior when CSAAT=1 and SCBR = 1	Not fixed	 	Atmel
SAM7S32	SPI: LASTXFER (Last Transfer) behavior In FIXED Mode, with CSAAT bit set, and in âPDC modeâ the Chip Select can rise depending on the data written in the SPI_TDR when the TX_EMPTY flag is set. If for example, the PDC writes a â1â in the bit 24 (LASTXFER bit) of the SPI_TDR, the chip select will rise as soon as the TXEMPTY flag is set.	ARM7	 	Serial Peripheral Interface (SPI)	 	Use the CS in PIO mode when PDC mode is required and CS has to be maintained between transfers.	 	SPI: LASTXFER (Last Transfer) behavior	Not fixed	 	Atmel
SAM7S32	SPI: SPCK Behavior in Master Mode SPCK pin can toggle out before the first transfer in Master Mode.	ARM7	 	Serial Peripheral Interface (SPI)	 	In Master Mode, MSTR bit must be set (in SPI_MR register) before configuring SPI_CSRx registers.	 	SPI: SPCK Behavior in Master Mode	Not fixed	 	Atmel
SAM7S32	SPI: Chip Select and Fixed Mode In fixed Mode, if a transfer is performed through a PDC on a Chip select different from the Chip select 0, the output spi_size sampled by the PDC will depend on the field, BITS (Bits per Transfer) of SPI_CSR0 register, whatever the selected Chip select is. For example, if SPI_CSR0 is configured for a 10-bit transfer whereas SPI_CSR1 is configured for an 8-bit transfer, when a transfer is performed in Fixed mode through the PDC, on Chip select 1, the transfer will be considered as a HalfWord transfer.	ARM7	 	Serial Peripheral Interface (SPI)	 	If a PDC transfer has to be performed in 8 bits, on a Chip select y (y as different from 0), the BITS field of the SPI_CSR0 must be configured in 8 bits, in the same way as the BITS field of the CSRy Register.	 	SPI: Chip Select and Fixed Mode	Not fixed	 	Atmel
SAM7S32	SPI: Baudrate Set to 1 When Baudrate is set at 1 (i.e. when serial clock frequency equals the system clock frequency) and when the BITS field of the SPI_CSR register (number of bits to be transmitted) equals an ODD value (in this case 9,11,13 or 15), an additional pulse will be generated on output SPCK. Everything is OK if the BITS field equals 8,10,12,14 or 16 and Baudrate = 1.	ARM7	 	Serial Peripheral Interface (SPI)	 	None.	 	SPI: Baudrate Set to 1	Not fixed	 	Atmel
SAM7S32	SPI: Disable In Slave Mode The SPI disable is not possible in slave mode.	ARM7	 	Serial Peripheral Interface (SPI)	 	Read first the received data, then perform the software reset. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 729	 	SPI: Disable In Slave Mode	Not fixed	 	Atmel
SAM7S32	SPI: Disable Issue The SPI Command âSPI Disableâ is not possible during a transfer, it must be performed only after TX_EMPTY rising else there is everlasting dummy transfers occur.	ARM7	 	Serial Peripheral Interface (SPI)	 	None.	 	SPI: Disable Issue	Not fixed	 	Atmel
SAM7S32	SPI: Software Reset and SPIEN Bit The SPI Command âsoftware resetâ does not reset the SPIEN config bit. Therefore rewriting an SPI enable command does not set TX_READY, TX_EMPTY flags.	ARM7	 	Serial Peripheral Interface (SPI)	 	Send SPI disable command after a software reset.	 	SPI: Software Reset and SPIEN Bit	Not fixed	 	Atmel
SAM7S32	If CSAAT = 1 for current access and there is no more TX request for a time greater than DLYBCT + DLYBCS, then if an access is requested on another slave, the NPCS bus switches from one CS to the one requested without DLYBCS. External Slaves may reach a contention on SPI_MISO line for a short period.	ARM7	 	Serial Peripheral Interface (SPI)	 	Assert the Last Transfer Command (NPCS de-activation) for the last character of each slave.	 	If CSAAT = 1 for current access and there is no more TX request for a time greater than DLYBCT + DLYBCS, then	Not fixed	 	Atmel
SAM7S32	Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0. This occurs using SPI with the following conditions: â¢ Master Mode â¢ CPOL = 1 and NCPHA = 0 â¢ Multiple chip selects are used with one transfer with Baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR are not equal to 1 â¢ Transmitting with the slowest chip select and then with the fastest one, then an additional on output SPCK during the second transfer. pulse is generated	ARM7	 	Serial Peripheral Interface (SPI)	 	Do not use a multiple Chip Select configuration where at least one SCRx register is configured with SCBR = 1 and the others differ from 1 if NCPHA = 0 and CPOL = 1. If all chip selects are configured with Baudrate = 1, the issue does not appear. 40.22.7 Synchronous Serial Controller (SSC)	 	Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0.	Not fixed	 	Atmel
SAM7S32	SSC: Periodic Transmission Limitations in Master Mode If the Least Significant Bit is sent first (MSBF = 0), the first TAG during the frame synchro is not sent.	ARM7	 	Synchronous Serial Controller (SSC)	 	None.	 	SSC: Periodic Transmission Limitations in Master Mode	Not fixed	 	Atmel
SAM7S32	SSC: Transmitter Limitations in Slave Mode If TK is programmed as output and TF is programmed as input, it is impossible to emit data when the start of edge (rising or falling) of synchro has a Start Delay equal to zero.	ARM7	 	Synchronous Serial Controller (SSC)	 	None. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 730	 	SSC: Transmitter Limitations in Slave Mode	Not fixed	 	Atmel
SAM7S32	SSC: Transmitter Limitations in Slave Mode If TK is programmed as an input and TF is programmed as an output and requested to be set to low/high during data emission, the Frame Synchro signal is generated one bit clock period after the data start and one data bit is lost. This problem does not exist when generating a periodic synchro.	ARM7	 	Synchronous Serial Controller (SSC)	 	The data need to be delayed for one bit clock period with an external assembly. In the following schematic, TD, TK and NRST are SAM7S signals, TXD is the delayed data to connect to the device. 40.22.8 Two-wire Interface (TWI)	 	SSC: Transmitter Limitations in Slave Mode	Not fixed	 	Atmel
SAM7S32	TWI: Clock Divider The value of CLDIV x 2 CKDIV must be less than or equal to 8191 the value of CHDIV x 2 CKDIV must be less than or equal to 8191	ARM7	 	Two-wire Interface (TWI)	 	None.	 	TWI: Clock Divider	Not fixed	 	Atmel
SAM7S32	TWI: Software Reset When a software reset is performed during a frame and when TWCK is low, it is impossible to initiate a new transfer in READ or WRITE mode.	ARM7	 	Two-wire Interface (TWI)	 	None.	 	TWI: Software Reset	Not fixed	 	Atmel
SAM7S32	TWI: Disabling Does not Operate Correctly Any transfer in progress is immediately frozen if the Control Register (TWI_CR) is written with the bit MSDIS at 1. Furthermore, the status bits TXCOMP and TXRDY in the Status Register (TWI_SR) are not reset.	ARM7	 	Two-wire Interface (TWI)	 	The user must wait for the end of transfer before disabling the TWI. In addition, the interrupts must be disabled before disabling the TWI. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 731	 	TWI: Disabling Does not Operate Correctly	Not fixed	 	Atmel
SAM7S32	TWI: NACK Status Bit Lost During a master frame, if TWI_SR is read between the Non Acknowledge condition detection and the TXCOMP bit rising in the TWI_SR, the NACK bit is not set.	ARM7	 	Two-wire Interface (TWI)	 	The user must wait for the TXCOMP status bit by interrupt and must not read the TWI_SR as long as transmission is not completed. TXCOMP and NACK fields are set simultaneously and the NACK field is reset after the read of the TWI_SR.	 	TWI: NACK Status Bit Lost	Not fixed	 	Atmel
SAM7S32	TWI: Possible Receive Holding Register Corruption When loading the TWI_RHR, the transfer direction is ignored. The last data byte received in the TWI_RHR is corrupted at the end of the first subsequent transmit data byte . Neither RXRDY nor OVERRUN status bits are set if this occurs.	ARM7	 	Two-wire Interface (TWI)	 	The user must be sure that received data is read before transmitting any new data. 40.22.9 Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	TWI: Possible Receive Holding Register Corruption	Not fixed	 	Atmel
SAM7S32	USART: Hardware Handshake The Hardware Handshake does not work at speeds higher than 750 kbauds.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	None.	 	USART: Hardware Handshake	Not fixed	 	Atmel
SAM7S32	USART: CTS in Hardware Handshaking When Hardware Handshaking is used and if CTS goes low near the end of the starting bit, a character can be lost.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	CTS must not go low during a time slot occurring between 2 Master Clock periods before the starting bit and 16 Master Clock periods after the rising edge of the starting bit.	 	USART: CTS in Hardware Handshaking	Not fixed	 	Atmel
SAM7S32	USART: Hardware Handshaking â Two Characters Sent If CTS switches from 0 to 1 during the TX of a character and if the holding register (US_THR) is not empty, the content of US_THR will also be transmitted.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	Don't use the PDC in transmit mode and do not fill US_THR before TXEMPTY is set at 1.	 	USART: Hardware Handshaking â Two Characters Sent	Not fixed	 	Atmel
SAM7S32	USART: XOFF Character Bad Behavior The XOFF character is sent only when the receive buffer is detected full. While the XOFF is being sent, the remote transmitter is still transmitting. As only one Holding register is available in the receiver, characters will be lost in reception. This makes the software handshaking functionality ineffective.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	None.	 	USART: XOFF Character Bad Behavior	Not fixed	 	Atmel
SAM7S32	USART: DCD is active High instead of Low The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	Add an inverter. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 732 40.22.10 Voltage Regulator	 	USART: DCD is active High instead of Low	Not fixed	 	Atmel
SAM7S32	Current consumption in Deep Mode is maximum 60 ÂµA instead of 25 ÂµA. Due to current rejection from VDDIN to VDDCORE, the current consumption in Deep Mode cannot be guaranteed. Instead, 60 ÂµA is guaranteed whatever the condition.	ARM7	 	Voltage Regulator	 	None.	 	Current consumption in Deep Mode is maximum 60 ÂµA instead of 25 ÂµA.	Not fixed	 	Atmel
SAM7S32	Maximum load is 50 mA at 85 Â°C (instead of 100 mA). Maximum load is 100 mA at 70Â°C.	ARM7	 	Voltage Regulator	 	None. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 733 40.23 SAM7S32 Errata - Revision B Parts Refer to Section 40.1 âMarkingâ on page 595. Note: AT91SAM7S32 Revision B chip ID is 0x2708 0341. 40.23.1 Analog-to-Digital Converter (ADC)	 	Maximum load is 50 mA at 85 Â°C (instead of 100 mA).	Not fixed	 	Atmel
SAM7S32	ADC: DRDY Bit Cleared The DRDY Flag should be clear only after a read of ADC_LCDR (Last Converted Data Register). A read of any ADC_CDRx register (Channel Data Register) automatically clears the DRDY flag.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: DRDY Bit Cleared	Not fixed	 	Atmel
SAM7S32	ADC: DRDY not Cleared on Disable When reading LCDR at the same instant as an end of conversion, with DRDY already active, DRDY is kept active regardless of the enable status of the current channel. This sets DRDY, whereas new data is not stored.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: DRDY not Cleared on Disable	Not fixed	 	Atmel
SAM7S32	ADC: DRDY Possibly Skipped due to CDR Read Reading CDR for channel âyâ at the same instant as an end of conversion on channel âxâ with EOC[x] already active, leads to skipping to set the DRDY flag if channel âxâ is enabled.	ARM7	 	Analog-to-Digital Converter (ADC)	 	Use of DRDY functionality with access to CDR registers should be avoided.	 	ADC: DRDY Possibly Skipped due to CDR Read	Not fixed	 	Atmel
SAM7S32	ADC: Possible Skip on DRDY when Disabling a Channel DRDY does not rise when disabling channel âyâ at the same time as an end of âxâ channel conversion, although data is stored into CDRx and LCDR.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None.	 	ADC: Possible Skip on DRDY when Disabling a Channel	Not fixed	 	Atmel
SAM7S32	ADC: GOVRE Bit is not Updated Read of the Status Register at the same instant as an end of conversion leads to skipping the update of the GOVRE (general overrun) flag. GOVRE is neither reset nor set. For example, if reading the status while an end of conversion is occurring and: 1. GOVRE is active but DRDY is inactive, does not correspond to a new general overrun condition but the GOVRE flag is not reset. 2. GOVRE is inactive but DRDY is active, does correspond to a new general overrun condition but the GOVRE flag is not set.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Updated	Not fixed	 	Atmel
SAM7S32	ADC: GOVRE Bit is not Set when Reading CDR When reading CDRy (Channel Data Register y) at the same instant as an end of conversion on channel âxâ with the following conditions: â¢ EOC[x] already active, â¢ DRDY already active, SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 734 â¢ GOVRE inactive, â¢ previous data stored in LCDR being neither data from channel âyâ, nor data from channel âxâ. GOVRE should be set but is not.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Set when Reading CDR	Not fixed	 	Atmel
SAM7S32	ADC: GOVRE Bit is not Set when Disabling a Channel When disabling channel âyâ at the same instant as an end of conversion on channel âxâ, EOC[x] and DRDY being already active, GOVRE does not rise. Note: OVRE[x] rises as expected.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Set when Disabling a Channel	Not fixed	 	Atmel
SAM7S32	ADC: OVRE Flag Behavior When the OVRE flag (on channel i) has been set but the related EOC status (of channel i) has been cleared (by a read of CDRi or LCDR), reading the Status register at the same instant as an end of conversion (causing the set of EOC status on channel i), does not lead to a reset of the OVRE flag (on channel i) as expected.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: OVRE Flag Behavior	Not fixed	 	Atmel
SAM7S32	ADC: EOC Set although Channel Disabled If a channel is disabled while a conversi on is running and if a read of CDR is performed at the same time as an end of conversion of any channel occurs, the EOC of the channel with the conversion running may rise (whereas it has been disabled).	ARM7	 	Analog-to-Digital Converter (ADC)	 	Do not take into account the EOC of a disabled channel	 	ADC: EOC Set although Channel Disabled	Not fixed	 	Atmel
SAM7S32	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ nor âyâ), reading CDR on channel âzâ at the same instant as an end of conversion on channel âyâ automatically clears EOC[x] instead of EOC[z].	ARM7	 	Analog-to-Digital Converter (ADC)	 	None.	 	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ	Not fixed	 	Atmel
SAM7S32	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	ARM7	 	Analog-to-Digital Converter (ADC)	 	To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit field); to start an analog-to-digital conversion, in order put ADC into sleep mode at the end of this conversion. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 735 40.23.2 Parallel Input/Output Controller (PIO)	 	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after	Not fixed	 	Atmel
SAM7S32	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31 When NRST or PA0-PA16 or PA21-PA31 are set as digital inputs with pull-up enabled, the voltage of the I/O stabilizes at VPull-up. Vpull-up VPull-up Min VPull-up Max VDDIO - 0.65 V VDDIO - 0.45 V This condition causes a leakage through VDDIO. This leakage is 45 ÂµA per pad in worst case at 3.3 V and 25 ÂµA at 1.8V. I Leakage Parameter Typ Max I Leakage at 3,3V 2.5 ÂµA 45 ÂµA I Leakage at 1.8V 1 ÂµA 25 ÂµA	ARM7	 	Parallel Input/Output Controller (PIO)	 	It is recommended to use an external pull-up if needed.	 	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31	Not fixed	 	Atmel
SAM7S32	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31 When NRST or PA0-PA16 and or PA21-PA31 are set as digital inputs with pull-up enabled, driving the I/O with an output impedance higher than 500 ohms may not drive the I/O to a logical zero.	ARM7	 	Parallel Input/Output Controller (PIO)	 	Output impedance must be lower than 500 ohms. 40.23.3 Pulse Width Modulation Controller (PWM)	 	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31	Not fixed	 	Atmel
SAM7S32	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Check the Channel Counter Register before writing the update register.	 	PWM: Update when PWM_CCNTx = 0 or 1	Not fixed	 	Atmel
SAM7S32	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not write 0 in the period register.	 	PWM: Update when PWM_CPRDx = 0	Not fixed	 	Atmel
SAM7S32	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	None.	 	PWM: Counter Start Value	Not fixed	 	Atmel
SAM7S32	PWM: Constraints on Duty Cycle Value Setting Channel Duty Cycle Register (PWM_CDTYx) at 0 in center aligned mode or at 0 or 1 in left aligned mode may change the polarity of the signal. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 736	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not set PWM_CDTYx at 0 in center aligned mode. Do not set PWM_CDTYx at 0 or 1 in left aligned mode.	 	PWM: Constraints on Duty Cycle Value	Not fixed	 	Atmel
SAM7S32	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register Erratic behavior of the CHIDx status bit in the PWM_SR Register. When a channel is disabled by writing in the PWM_DIS Register just after enabling it (before completion of a Clock Period of the clock selected for the channel), the PWM line is internally disabled but the CHIDx status bit in the PWM_SR stays at 1.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not disable a channel before completion of one period of the selected clock. 40.23.4 Real Time Timer (RTT)	 	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register	Not fixed	 	Atmel
SAM7S32	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	ARM7	 	Real Time Timer (RTT)	 	The software must handle the RTT event as an interrupt and should not poll RTT_SR. 40.23.5 Serial Peripheral Interface (SPI)	 	RTT: Possible Event Loss when Reading RTT_SR	Not fixed	 	Atmel
SAM7S32	SPI: Software Reset Must be Written Twice If a software reset (SWRSTin the SPI Control Register) is performed, the SPI may not work properly (the clock is enabled before the chip select.	ARM7	 	Serial Peripheral Interface (SPI)	 	The SPI Control Register field, SWRST needs to be written twice to be set correctly.	 	SPI: Software Reset Must be Written Twice	Not fixed	 	Atmel
SAM7S32	20. SPI: Pulse Generation on SPCK In Master Mode, there is an additional pulse generated on SPCK when the SPI is configured as follows: â The Baudrate is odd and different from 1 â The Polarity is set to 1 â The Phase is set to 0	ARM7	 	Serial Peripheral Interface (SPI)	 	None.	 	20. SPI: Pulse Generation on SPCK	Not fixed	 	Atmel
SAM7S32	SPI: Bad tx_ready behavior when CSAAT=1 and SCBR = 1 If the SPI is programmed with CSAAT = 1, SCBR(baudrate) = 1 and two transfers are performed consecutively on the same slave with an IDLE state between them, the tx_ready signal does not rise after the second data has been transferred in the shifter. This can imply for example, that the second data is sent twice.	ARM7	 	Serial Peripheral Interface (SPI)	 	Do not use the combination CSAAT=1 and SCBR =1.	 	SPI: Bad tx_ready behavior when CSAAT=1 and SCBR = 1	Not fixed	 	Atmel
SAM7S32	SPI: LASTXFER (Last Transfer) behavior In FIXED Mode, with CSAAT bit set, and in âPDC modeâ the Chip Select can rise depending on the data written in the SPI_TDR when the TX_EMPTY flag is set. If for example, the PDC writes a â1â in the bit 24 (LASTXFER bit) of the SPI_TDR, the chip select will rise as soon as the TXEMPTY flag is set.	ARM7	 	Serial Peripheral Interface (SPI)	 	SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 737 Use the CS in PIO mode when PDC mode is required and CS has to be maintained between transfers.	 	SPI: LASTXFER (Last Transfer) behavior	Not fixed	 	Atmel
SAM7S32	SPI: SPCK Behavior in Master Mode SPCK pin can toggle out before the first transfer in Master Mode.	ARM7	 	Serial Peripheral Interface (SPI)	 	In Master Mode, MSTR bit must be set (in SPI_MR register) before configuring SPI_CSRx registers.	 	SPI: SPCK Behavior in Master Mode	Not fixed	 	Atmel
SAM7S32	SPI: Chip Select and Fixed Mode In fixed Mode, if a transfer is performed through a PDC on a Chip select different from the Chip select 0, the output spi_size sampled by the PDC will depend on the field, BITS (Bits per Transfer) of SPI_CSR0 register, whatever the selected Chip select is. For example, if SPI_CSR0 is configured for a 10-bit transfer whereas SPI_CSR1 is configured for an 8-bit transfer, when a transfer is performed in Fixed mode through the PDC, on Chip select 1, the transfer will be considered as a HalfWord transfer.	ARM7	 	Serial Peripheral Interface (SPI)	 	If a PDC transfer has to be performed in 8 bits, on a Chip select y (y as different from 0), the BITS field of the SPI_CSR0 must be configured in 8 bits, in the same way as the BITS field of the CSRy Register.	 	SPI: Chip Select and Fixed Mode	Not fixed	 	Atmel
SAM7S32	SPI: Baudrate Set to 1 When Baudrate is set at 1 (i.e. when serial clock frequency equals the system clock frequency) and when the BITS field of the SPI_CSR register (number of bits to be transmitted) equals an ODD value (in this case 9,11,13 or 15), an additional pulse will be generated on output SPCK. Everything is OK if the BITS field equals 8,10,12,14 or 16 and Baudrate = 1.	ARM7	 	Serial Peripheral Interface (SPI)	 	None.	 	SPI: Baudrate Set to 1	Not fixed	 	Atmel
SAM7S32	SPI: Disable In Slave Mode The SPI disable is not possible in slave mode.	ARM7	 	Serial Peripheral Interface (SPI)	 	Read first the received data, then perform the software reset.	 	SPI: Disable In Slave Mode	Not fixed	 	Atmel
SAM7S32	SPI: Disable Issue The SPI Command âSPI Disableâ is not possible during a transfer, it must be performed only after TX_EMPTY rising else there is everlasting dummy transfers occur.	ARM7	 	Serial Peripheral Interface (SPI)	 	None.	 	SPI: Disable Issue	Not fixed	 	Atmel
SAM7S32	The SPI Command âsoftware resetâ does not reset the SPIEN config bit. Therefore rewriting an SPI enable command does not set TX_READY, TX_EMPTY flags.	ARM7	 	Serial Peripheral Interface (SPI)	 	Send SPI disable command after a software reset.	 	The SPI Command âsoftware resetâ does not reset the SPIEN config bit. Therefore rewriting an SPI enable command does not set TX_READY, TX_EMPTY flags.	Not fixed	 	Atmel
SAM7S32	If CSAAT = 1 for current access and there is no more TX request for a time greater than DLYBCT + DLYBCS, then if an access is requested on another slave, the NPCS bus switches from one CS to the one requested without DLYBCS. External Slaves may reach a contention on SPI_MISO line for a short period.	ARM7	 	Serial Peripheral Interface (SPI)	 	SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 738 Assert the Last Transfer Command (NPCS de-activation) for the last character of each slave.	 	If CSAAT = 1 for current access and there is no more TX request for a time greater than DLYBCT + DLYBCS, then	Not fixed	 	Atmel
SAM7S32	Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0. This occurs using SPI with the following conditions: â¢ Master Mode â¢ CPOL = 1 and NCPHA = 0 â¢ Multiple chip selects are used with one transfer with Baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR are not equal to 1 â¢ Transmitting with the slowest chip select and then with the fastest one, then an additional on output SPCK during the second transfer. pulse is generated	ARM7	 	Serial Peripheral Interface (SPI)	 	Do not use a multiple Chip Select configuration where at least one SCRx register is configured with SCBR = 1 and the others differ from 1 if NCPHA = 0 and CPOL = 1. If all chip selects are configured with Baudrate = 1, the issue does not appear. 40.23.6 Synchronous Serial Controller (SSC)	 	Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0.	Not fixed	 	Atmel
SAM7S32	SSC: Periodic Transmission Limitations in Master Mode If the Least Significant Bit is sent first (MSBF = 0), the first TAG during the frame synchro is not sent.	ARM7	 	Synchronous Serial Controller (SSC)	 	None.	 	SSC: Periodic Transmission Limitations in Master Mode	Not fixed	 	Atmel
SAM7S32	SSC: Transmitter Limitations in Slave Mode If TK is programmed as output and TF is programmed as input, it is impossible to emit data when the start of edge (rising or falling) of synchro has a Start Delay equal to zero.	ARM7	 	Synchronous Serial Controller (SSC)	 	None.	 	SSC: Transmitter Limitations in Slave Mode	Not fixed	 	Atmel
SAM7S32	SSC: Transmitter Limitations in Slave Mode If TK is programmed as an input and TF is programmed as an output and requested to be set to low/high during data emission, the Frame Synchro signal is generated one bit clock period after the data start and one data bit is lost. This problem does not exist when generating a periodic synchro.	ARM7	 	Synchronous Serial Controller (SSC)	 	The data need to be delayed for one bit clock period with an external assembly. In the following schematic, TD, TK and NRST are SAM7S signals, TXD is the delayed data to connect to the device. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 739 40.23.7 Two-wire Interface (TWI)	 	SSC: Transmitter Limitations in Slave Mode	Not fixed	 	Atmel
SAM7S32	TWI: Clock Divider The value of CLDIV x 2 CKDIV must be less than or equal to 8191 the value of CHDIV x 2 CKDIV must be less than or equal to 8191	ARM7	 	Two-wire Interface (TWI)	 	None.	 	TWI: Clock Divider	Not fixed	 	Atmel
SAM7S32	TWI: Software Reset When a software reset is performed during a frame and when TWCK is low, it is impossible to initiate a new transfer in READ or WRITE mode.	ARM7	 	Two-wire Interface (TWI)	 	None.	 	TWI: Software Reset	Not fixed	 	Atmel
SAM7S32	TWI: Disabling Does not Operate Correctly Any transfer in progress is immediately frozen if the Control Register (TWI_CR) is written with the bit MSDIS at 1. Furthermore, the status bits TXCOMP and TXRDY in the Status Register (TWI_SR) are not reset.	ARM7	 	Two-wire Interface (TWI)	 	The user must wait for the end of transfer before disabling the TWI. In addition, the interrupts must be disabled before disabling the TWI.	 	TWI: Disabling Does not Operate Correctly	Not fixed	 	Atmel
SAM7S32	TWI: NACK Status Bit Lost During a master frame, if TWI_SR is read between the Non Acknowledge condition detection and the TXCOMP bit rising in the TWI_SR, the NACK bit is not set.	ARM7	 	Two-wire Interface (TWI)	 	The user must wait for the TXCOMP status bit by interrupt and must not read the TWI_SR as long as transmission is not completed. TXCOMP and NACK fields are set simultaneously and the NACK field is reset after the read of the TWI_SR. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 740	 	TWI: NACK Status Bit Lost	Not fixed	 	Atmel
SAM7S32	TWI: Possible Receive Holding Register Corruption When loading the TWI_RHR, the transfer direction is ignored. The last data byte received in the TWI_RHR is corrupted at the end of the first subsequent transmit data byte . Neither RXRDY nor OVERRUN status bits are set if this occurs.	ARM7	 	Two-wire Interface (TWI)	 	The user must be sure that received data is read before transmitting any new data. 40.23.8 Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	TWI: Possible Receive Holding Register Corruption	Not fixed	 	Atmel
SAM7S32	USART: Hardware Handshake The Hardware Handshake does not work at speeds higher than 750 kbauds.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	None.	 	USART: Hardware Handshake	Not fixed	 	Atmel
SAM7S32	USART: CTS in Hardware Handshaking When Hardware Handshaking is used and if CTS goes low near the end of the starting bit, a character can be lost.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	CTS must not go low during a time slot occurring between 2 Master Clock periods before the starting bit and 16 Master Clock periods after the rising edge of the starting bit.	 	USART: CTS in Hardware Handshaking	Not fixed	 	Atmel
SAM7S32	USART: Hardware Handshaking â Two Characters Sent If CTS switches from 0 to 1 during the TX of a character and if the holding register (US_THR) is not empty, the content of US_THR will also be transmitted.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	Don't use the PDC in transmit mode and do not fill US_THR before TXEMPTY is set at 1.	 	USART: Hardware Handshaking â Two Characters Sent	Not fixed	 	Atmel
SAM7S32	USART: XOFF Character Bad Behavior The XOFF character is sent only when the receive buffer is detected full. While the XOFF is being sent, the remote transmitter is still transmitting. As only one Holding register is available in the receiver, characters will be lost in reception. This makes the software handshaking functionality ineffective.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	None.	 	USART: XOFF Character Bad Behavior	Not fixed	 	Atmel
SAM7S32	USART: DCD is active High instead of Low The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	Add an inverter. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 741 40.24 SAM7S161 Errata - Revision A Parts Refer to Section 40.1 âMarkingâ on page 595. Note: AT91SAM7S161 Revision A chip ID is 0x2705 0241. 40.24.1 Analog-to-Digital Converter (ADC)	 	USART: DCD is active High instead of Low	Not fixed	 	Atmel
SAM7S161	ADC: DRDY Bit Cleared The DRDY Flag should be clear only after a read of ADC_LCDR (Last Converted Data Register). A read of any ADC_CDRx register (Channel Data Register) automatically clears the DRDY flag.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: DRDY Bit Cleared	Not fixed	 	Atmel
SAM7S161	ADC: DRDY not Cleared on Disable When reading LCDR at the same instant as an end of conversion, with DRDY already active, DRDY is kept active regardless of the enable status of the current channel. This sets DRDY, whereas new data is not stored.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: DRDY not Cleared on Disable	Not fixed	 	Atmel
SAM7S161	ADC: DRDY Possibly Skipped due to CDR Read Reading CDR for channel âyâ at the same instant as an end of conversion on channel âxâ with EOC[x] already active, leads to skipping to set the DRDY flag if channel âxâ is enabled.	ARM7	 	Analog-to-Digital Converter (ADC)	 	Use of DRDY functionality with access to CDR registers should be avoided.	 	ADC: DRDY Possibly Skipped due to CDR Read	Not fixed	 	Atmel
SAM7S161	ADC: Possible Skip on DRDY when Disabling a Channel DRDY does not rise when disabling channel âyâ at the same time as an end of âxâ channel conversion, although data is stored into CDRx and LCDR.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None.	 	ADC: Possible Skip on DRDY when Disabling a Channel	Not fixed	 	Atmel
SAM7S161	ADC: GOVRE Bit is not Updated Read of the Status Register at the same instant as an end of conversion leads to skipping the update of the GOVRE (general overrun) flag. GOVRE is neither reset nor set. For example, if reading the status while an end of conversion is occurring and: 1. GOVRE is active but DRDY is inactive, does not correspond to a new general overrun condition but the GOVRE flag is not reset. 2. GOVRE is inactive but DRDY is active, does correspond to a new general overrun condition but the GOVRE flag is not set.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Updated	Not fixed	 	Atmel
SAM7S161	ADC: GOVRE Bit is not Set when Reading CDR When reading CDRy (Channel Data Register y) at the same instant as an end of conversion on channel âxâ with the following conditions: â¢ EOC[x] already active, â¢ DRDY already active, SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 742 â¢ GOVRE inactive, â¢ previous data stored in LCDR being neither data from channel âyâ, nor data from channel âxâ. GOVRE should be set but is not.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Set when Reading CDR	Not fixed	 	Atmel
SAM7S161	ADC: GOVRE Bit is not Set when Disabling a Channel When disabling channel âyâ at the same instant as an end of conversion on channel âxâ, EOC[x] and DRDY being already active, GOVRE does not rise. Note: OVRE[x] rises as expected.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Set when Disabling a Channel	Not fixed	 	Atmel
SAM7S161	ADC: OVRE Flag Behavior When the OVRE flag (on channel i) has been set but the related EOC status (of channel i) has been cleared (by a read of CDRi or LCDR), reading the Status register at the same instant as an end of conversion (causing the set of EOC status on channel i), does not lead to a reset of the OVRE flag (on channel i) as expected.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: OVRE Flag Behavior	Not fixed	 	Atmel
SAM7S161	ADC: EOC Set although Channel Disabled If a channel is disabled while a conversi on is running and if a read of CDR is performed at the same time as an end of conversion of any channel occurs, the EOC of the channel with the conversion running may rise (whereas it has been disabled).	ARM7	 	Analog-to-Digital Converter (ADC)	 	Do not take into account the EOC of a disabled channel	 	ADC: EOC Set although Channel Disabled	Not fixed	 	Atmel
SAM7S161	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ nor âyâ), reading CDR on channel âzâ at the same instant as an end of conversion on channel âyâ automatically clears EOC[x] instead of EOC[z].	ARM7	 	Analog-to-Digital Converter (ADC)	 	None.	 	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ	Not fixed	 	Atmel
SAM7S161	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	ARM7	 	Analog-to-Digital Converter (ADC)	 	To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit field); to start an analog-to-digital conversion, in order put ADC into sleep mode at the end of this conversion. 40.24.2 Pulse Width Modulation Controller (PWM)	 	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after	Not fixed	 	Atmel
SAM7S161	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 743	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Check the Channel Counter Register before writing the update register.	 	PWM: Update when PWM_CCNTx = 0 or 1	Not fixed	 	Atmel
SAM7S161	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not write 0 in the period register.	 	PWM: Update when PWM_CPRDx = 0	Not fixed	 	Atmel
SAM7S161	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	None.	 	PWM: Counter Start Value	Not fixed	 	Atmel
SAM7S161	PWM: Constraints on Duty Cycle Value Setting Channel Duty Cycle Register (PWM_CDTYx) at 0 in center aligned mode or at 0 or 1 in left aligned mode may change the polarity of the signal.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not set PWM_CDTYx at 0 in center aligned mode. Do not set PWM_CDTYx at 0 or 1 in left aligned mode.	 	PWM: Constraints on Duty Cycle Value	Not fixed	 	Atmel
SAM7S161	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register Erratic behavior of the CHIDx status bit in the PWM_SR Register. When a channel is disabled by writing in the PWM_DIS Register just after enabling it (before completion of a Clock Period of the clock selected for the channel), the PWM line is internally disabled but the CHIDx status bit in the PWM_SR stays at 1.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not disable a channel before completion of one period of the selected clock. 40.24.3 Real Time Timer (RTT)	 	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register	Not fixed	 	Atmel
SAM7S161	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	ARM7	 	Real Time Timer (RTT)	 	The software must handle the RTT event as an interrupt and should not poll RTT_SR. 40.24.4 Serial Peripheral Interface (SPI)	 	RTT: Possible Event Loss when Reading RTT_SR	Not fixed	 	Atmel
SAM7S161	SPI: Bad Serial Clock Generation on 2nd Chip Select Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0. This occurs using SPI with the following conditions: â¢ Master Mode â¢ CPOL = 1 and NCPHA = 0 â¢ Multiple chip selects are used with one transfer with Baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR are not equal to 1 â¢ Transmitting with the slowest chip select and then with the fastest one, then an additional on output SPCK during the second transfer. pulse is generated SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 744	ARM7	 	Serial Peripheral Interface (SPI)	 	Do not use a multiple Chip Select configuration where at least one SCRx register is configured with SCBR = 1 and the others differ from 1 if NCPHA = 0 and CPOL = 1. If all chip selects are configured with Baudrate = 1, the issue does not appear. 40.24.5 Synchronous Serial Controller (SSC)	 	SPI: Bad Serial Clock Generation on 2nd Chip Select	Not fixed	 	Atmel
SAM7S161	SSC: Periodic Transmission Limitations in Master Mode If the Least Significant Bit is sent first (MSBF = 0), the first TAG during the frame synchro is not sent.	ARM7	 	Synchronous Serial Controller (SSC)	 	None.	 	SSC: Periodic Transmission Limitations in Master Mode	Not fixed	 	Atmel
SAM7S161	SSC: Transmitter Limitations in Slave Mode If TK is programmed as output and TF is programmed as input, it is impossible to emit data when the start of edge (rising or falling) of synchro has a Start Delay equal to zero.	ARM7	 	Synchronous Serial Controller (SSC)	 	None.	 	SSC: Transmitter Limitations in Slave Mode	Not fixed	 	Atmel
SAM7S161	SSC: Transmitter Limitations in Slave Mode If TK is programmed as an input and TF is programmed as an output and requested to be set to low/high during data emission, the Frame Synchro signal is generated one bit clock period after the data start and one data bit is lost. This problem does not exist when generating a periodic synchro.	ARM7	 	Synchronous Serial Controller (SSC)	 	The data need to be delayed for one bit clock period with an external assembly. In the following schematic, TD, TK and NRST are SAM7S signals, TXD is the delayed data to connect to the device. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 745 40.24.6 Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	SSC: Transmitter Limitations in Slave Mode	Not fixed	 	Atmel
SAM7S161	USART: DCD is active High instead of Low The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	Add an inverter. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 746 40.25 SAM7S16 Errata - Revision A Parts Refer to Section 40.1 âMarkingâ on page 595. Note: AT91SAM7S16 Revision A chip ID is 0x2705 0240. 40.25.1 Analog-to-Digital Converter (ADC)	 	USART: DCD is active High instead of Low	Not fixed	 	Atmel
SAM7S16	ADC: DRDY Bit Cleared The DRDY Flag should be clear only after a read of ADC_LCDR (Last Converted Data Register). A read of any ADC_CDRx register (Channel Data Register) automatically clears the DRDY flag.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: DRDY Bit Cleared	Not fixed	 	Atmel
SAM7S16	ADC: DRDY not Cleared on Disable When reading LCDR at the same instant as an end of conversion, with DRDY already active, DRDY is kept active regardless of the enable status of the current channel. This sets DRDY, whereas new data is not stored.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: DRDY not Cleared on Disable	Not fixed	 	Atmel
SAM7S16	ADC: DRDY Possibly Skipped due to CDR Read Reading CDR for channel âyâ at the same instant as an end of conversion on channel âxâ with EOC[x] already active, leads to skipping to set the DRDY flag if channel âxâ is enabled.	ARM7	 	Analog-to-Digital Converter (ADC)	 	Use of DRDY functionality with access to CDR registers should be avoided.	 	ADC: DRDY Possibly Skipped due to CDR Read	Not fixed	 	Atmel
SAM7S16	ADC: Possible Skip on DRDY when Disabling a Channel DRDY does not rise when disabling channel âyâ at the same time as an end of âxâ channel conversion, although data is stored into CDRx and LCDR.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None.	 	ADC: Possible Skip on DRDY when Disabling a Channel	Not fixed	 	Atmel
SAM7S16	ADC: GOVRE Bit is not Updated Read of the Status Register at the same instant as an end of conversion leads to skipping the update of the GOVRE (general overrun) flag. GOVRE is neither reset nor set. For example, if reading the status while an end of conversion is occurring and: 1. GOVRE is active but DRDY is inactive, does not correspond to a new general overrun condition but the GOVRE flag is not reset. 2. GOVRE is inactive but DRDY is active, does correspond to a new general overrun condition but the GOVRE flag is not set.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Updated	Not fixed	 	Atmel
SAM7S16	ADC: GOVRE Bit is not Set when Reading CDR When reading CDRy (Channel Data Register y) at the same instant as an end of conversion on channel âxâ with the following conditions: â¢ EOC[x] already active, â¢ DRDY already active, SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 747 â¢ GOVRE inactive, â¢ previous data stored in LCDR being neither data from channel âyâ, nor data from channel âxâ. GOVRE should be set but is not.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Set when Reading CDR	Not fixed	 	Atmel
SAM7S16	ADC: GOVRE Bit is not Set when Disabling a Channel When disabling channel âyâ at the same instant as an end of conversion on channel âxâ, EOC[x] and DRDY being already active, GOVRE does not rise. Note: OVRE[x] rises as expected.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: GOVRE Bit is not Set when Disabling a Channel	Not fixed	 	Atmel
SAM7S16	ADC: OVRE Flag Behavior When the OVRE flag (on channel i) has been set but the related EOC status (of channel i) has been cleared (by a read of CDRi or LCDR), reading the Status register at the same instant as an end of conversion (causing the set of EOC status on channel i), does not lead to a reset of the OVRE flag (on channel i) as expected.	ARM7	 	Analog-to-Digital Converter (ADC)	 	None	 	ADC: OVRE Flag Behavior	Not fixed	 	Atmel
SAM7S16	ADC: EOC Set although Channel Disabled If a channel is disabled while a conversi on is running and if a read of CDR is performed at the same time as an end of conversion of any channel occurs, the EOC of the channel with the conversion running may rise (whereas it has been disabled).	ARM7	 	Analog-to-Digital Converter (ADC)	 	Do not take into account the EOC of a disabled channel	 	ADC: EOC Set although Channel Disabled	Not fixed	 	Atmel
SAM7S16	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ nor âyâ), reading CDR on channel âzâ at the same instant as an end of conversion on channel âyâ automatically clears EOC[x] instead of EOC[z].	ARM7	 	Analog-to-Digital Converter (ADC)	 	None.	 	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ	Not fixed	 	Atmel
SAM7S16	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	ARM7	 	Analog-to-Digital Converter (ADC)	 	To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit field); to start an analog-to-digital conversion, in order put ADC into sleep mode at the end of this conversion. 40.25.2 Pulse Width Modulation Controller (PWM)	 	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after	Not fixed	 	Atmel
SAM7S16	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 748	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Check the Channel Counter Register before writing the update register.	 	PWM: Update when PWM_CCNTx = 0 or 1	Not fixed	 	Atmel
SAM7S16	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not write 0 in the period register.	 	PWM: Update when PWM_CPRDx = 0	Not fixed	 	Atmel
SAM7S16	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	None.	 	PWM: Counter Start Value	Not fixed	 	Atmel
SAM7S16	PWM: Constraints on Duty Cycle Value Setting Channel Duty Cycle Register (PWM_CDTYx) at 0 in center aligned mode or at 0 or 1 in left aligned mode may change the polarity of the signal.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not set PWM_CDTYx at 0 in center aligned mode. Do not set PWM_CDTYx at 0 or 1 in left aligned mode.	 	PWM: Constraints on Duty Cycle Value	Not fixed	 	Atmel
SAM7S16	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register Erratic behavior of the CHIDx status bit in the PWM_SR Register. When a channel is disabled by writing in the PWM_DIS Register just after enabling it (before completion of a Clock Period of the clock selected for the channel), the PWM line is internally disabled but the CHIDx status bit in the PWM_SR stays at 1.	ARM7	 	Pulse Width Modulation Controller (PWM)	 	Do not disable a channel before completion of one period of the selected clock. 40.25.3 Real Time Timer (RTT)	 	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register	Not fixed	 	Atmel
SAM7S16	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	ARM7	 	Real Time Timer (RTT)	 	The software must handle the RTT event as an interrupt and should not poll RTT_SR. 40.25.4 Serial Peripheral Interface (SPI)	 	RTT: Possible Event Loss when Reading RTT_SR	Not fixed	 	Atmel
SAM7S16	SPI: Bad Serial Clock Generation on 2nd Chip Select Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0. This occurs using SPI with the following conditions: â¢ Master Mode â¢ CPOL = 1 and NCPHA = 0 â¢ Multiple chip selects are used with one transfer with Baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR are not equal to 1 â¢ Transmitting with the slowest chip select and then with the fastest one, then an additional on output SPCK during the second transfer. pulse is generated SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 749	ARM7	 	Serial Peripheral Interface (SPI)	 	Do not use a multiple Chip Select configuration where at least one SCRx register is configured with SCBR = 1 and the others differ from 1 if NCPHA = 0 and CPOL = 1. If all chip selects are configured with Baudrate = 1, the issue does not appear. 40.25.5 Synchronous Serial Controller (SSC)	 	SPI: Bad Serial Clock Generation on 2nd Chip Select	Not fixed	 	Atmel
SAM7S16	SSC: Periodic Transmission Limitations in Master Mode If the Least Significant Bit is sent first (MSBF = 0), the first TAG during the frame synchro is not sent.	ARM7	 	Synchronous Serial Controller (SSC)	 	None.	 	SSC: Periodic Transmission Limitations in Master Mode	Not fixed	 	Atmel
SAM7S16	SSC: Transmitter Limitations in Slave Mode If TK is programmed as output and TF is programmed as input, it is impossible to emit data when the start of edge (rising or falling) of synchro has a Start Delay equal to zero.	ARM7	 	Synchronous Serial Controller (SSC)	 	None.	 	SSC: Transmitter Limitations in Slave Mode	Not fixed	 	Atmel
SAM7S16	SSC: Transmitter Limitations in Slave Mode If TK is programmed as an input and TF is programmed as an output and requested to be set to low/high during data emission, the Frame Synchro signal is generated one bit clock period after the data start and one data bit is lost. This problem does not exist when generating a periodic synchro.	ARM7	 	Synchronous Serial Controller (SSC)	 	The data need to be delayed for one bit clock period with an external assembly. In the following schematic, TD, TK and NRST are SAM7S signals, TXD is the delayed data to connect to the device. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 750 40.25.6 Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	SSC: Transmitter Limitations in Slave Mode	Not fixed	 	Atmel
SAM7SX	The DCD signal is active at High level in the USART Modem Mode.DCD should be active at Low level.	ARM7	 	Universal Synchronous Asynchronous Receiver Transmitter (USART)	 	Add an inverter.	 	USART: DCD is active High instead of Low	Not fixed	 	Atmel
AT91M55800A	The tracking time has a theoretical minimum duration. It equals one ADC Clock period and is normally ensured by the ADC Controller.It might randomly happen that this minimum duration cannot be guaranteed on the first enabled channel. When this happens, the sampling and hold process is too short and the conversion result is wrong.	ARM7	 	ADC	 	To use only one channel, the user has to enable two channels and then must use the second channel only.In the event that all of the ADC channels need to be used, only three channels will be available. A software work around allows all the channels to be used. It consists of performing several conversions and averaging the samples on the first enabled channel. This method does not support fast conversion. However, signals from temperature sensors, which are slow signals, can be handled by averaging a number of samples.	 	ADC Characteristics and Behavior	Not fixed	 	Atmel
AT91M55800A	An automatic switch from the main oscillator output (CSS = 1) may cause an unpredictable result in the APMC state machine. The automatic PLL to PLL transition is also effected by this problem.	ARM7	 	APMC	 	The user must either wait for the PLL lock flag to be set in the APMC status register or switch to an intermediate 32 kHz oscillator output (CSS = 0).	 	Unpredictable Result in APMC State Machine on Switch from Oscillator to PLL	Not fixed	 	Atmel
AT91M55800A	(PRES = 3) or 64 (PRES = 6) may lead to unpredictable results.	ARM7	 	APMC	 	First, the user should switch to any other value (PRES = 1, 4 or 5) and wait for the actual switch to perform (at least 64 cycles of the selected clock). Then, the user can write the final prescaler value.	 	Clock Switching with the Prescaler in the APMC is not Permitted Switching from the selected clock (PRES = 0) to the selected clock divided by 4 (PRES = 2), 8	Not fixed	 	Atmel
AT91M55800A	 	ARM7	 	SPI	 	In order to prevent this error, the user must pull up the PA26/NPCS0/NSS pin to the V	 	SPI: Initializing SPI in Master Mode May Cause a Mode Fault Detection	Not fixed	 	Atmel
AT91M55800A	In transmission, the data to be transmitted (written in SP_TDR) is transferred in the shift register and, consequently, the TDRE bit in SP_SR is set to 1. Though the transfer has not begun, when the following data are written in SP_TDR, they are also transferred into the shift register, crush-ing the precedent data and setting the bit TDRE to 1.	ARM7	 	SPI	 	No problem fix/workaround to propose.	 	SPI in Slave Mode does not Work	Not fixed	 	Atmel
AT91M55800A	The battery supply voltage consumption is not guaranteed in the case of internal peripheral accesses.	ARM7	 	DDBU	 	The user should minimally access the Advanced Peripheral Bus by using an interrupt-driven driver rather than polling methods.	 	V DDBU Consumption is not guaranteed	Not fixed	 	Atmel
AT91M55800A	If the PLL is not used, an excessive current consumption can be seen on V DDPL(about 2 mA).	ARM7	 	DDCORE	 	At start-up, set the PLL on (set MUL at 2 and PLLCOUNT at 2, for example), wait for the PLL LOCK and then disable the PLL (MUL = 0).	 	V DDCORE Current Consumption when PLL is not Used	Not fixed	 	Atmel
LPC2102	 If the processor is in Thumb state and executing the code sequence STR, STMIA or PUSH followed by a PC relative load, and the STR, STMIA or PUSH is aborted, the PC is saved to the abort link register.  In this situation the PC is saved to the abort link register in word resolution, instead of half-word resolution. Conditions: The processor must be in Thumb state, and the following sequence must occur: <any instruction> <STR, STMIA, PUSH> <---- data abort on this instruction LDR rn, [pc,#offset] In this case the PC is saved to the link register R14_abt in only word resolution, not half-word resolution. The effect is that the link register holds an address that could be #2 less than it should be, so any abort handler could return to one instruction earlier than intended. 	ARM7				 In a system that does not use Thumb state, there will be no problem. In a system that uses Thumb state but does not use data aborts, or does not try to use data aborts in a recoverable manner, there will be no problem. Otherwise the workaround is to ensure that a STR, STMIA or PUSH cannot precede a PC-relative load. One method for this is to add a NOP before any PC-relative load instruction. However this is would have to be done manually. ES_LPC2102 . Â©   Rev. 2 â 1 March 2011 4 of 13  ES_LPC2102  LPC2102 		3.1 Core.1: Incorrect update of the Abort Link register in Thumb state 			NXP
LPC2102	 The Memory Accelerator Module (MAM) provides accelerated execution from the on-chip flash at higher frequencies.  If code is running from on-chip Flash, a write to an SRAM location followed by an immediate read from the same SRAM location corrupts the data been read. For instance, a stack push operation immediately followed by a stack pop operation. 	ARM7				 User code should enable the MAM after Reset and before any RAM accesses; this means MAMTIM and MAMCR should be set as follows: MAMTIM: For CPU clock frequencies slower than 20 MHz, set MAMTIM to 0x01. For CPU clock frequencies between 20 MHz and 40 MHz, set MAMTIM to 0x02, and for values above 40 MHz set MAMTIM to 0x03. MAMCR: Set MAMCR to 0x02 (MAM functions fully enabled) MAMTIM should be written before MAMCR. 		3.2 MAM.1: Incorrect read of data from SRAM after Reset and MAM is not enabled or partially enabled 			NXP
LPC2102	 The MAM block maximizes the performance of the ARM processor when it is running code in Flash memory. It includes three 128-bit buffers called the Prefetch Buffer, the Branch Trail Buffer and the data buffer. It can operate in 3 modes; Mode 0 (MAM off), Mode 1 (MAM partially enabled) and Mode 2 (MAM fully enabled).  Under certain conditions when the MAM is fully enabled (Mode 2) code execution from internal Flash can fail. The conditions under which the problem can occur is dependent on the code itself along with its positioning within the Flash memory. 	ARM7				 If the above problem is encountered then Mode 2 should not be used. Instead, partially enable the MAM using Mode 1. ES_LPC2102 . Â©   Rev. 2 â 1 March 2011 5 of 13  ES_LPC2102  LPC2102 		3.3 MAM.2: Under certain conditions in MAM Mode 2 code execution out of internal Flash can fail 			NXP
LPC2102	 In slave mode, the SPI can set the clock phase (CPHA) to 0 or 1.  Consider the following conditions: 1. SPI is configured as a slave (with CPHA=0). 2. SPI is running at a low frequency. In slave mode, the SPIF (SPI Transfer Complete Flag) bit is set on the last sampling edge of SCK. If CPHA is set to 0 then the last sampling edge of SCK would be the rising edge. Under the above conditions, if the SPI Data Register (SPDR) is written to less than a half SCLK cycle after the SPIF bit is set (this would happen if the SPI frequency is low) then the SPDR will shift data one clock early for the upcoming transfers. Lowering the SPI frequency would increase the likelihood of the SPDR write happening in the first half SCK cycle of the last sampling clock. 	ARM7				 There are two possible workarounds: 1. Use CPHA=1. 2. If the data is shifted incorrectly when CPHA is set to 0 then delaying the write to SPDR after the half SCK cycle of the last sampling clock would resolve this issue. ES_LPC2102 . Â©   Rev. 2 â 1 March 2011 6 of 13  ES_LPC2102  LPC2102 		3.4 SPI.1: Incorrect shifting of data in slave mode at lower frequencies 			NXP
LPC2102	 The SSP is a Synchronous Serial Port (SSP) controller capable of operation on a SPI, 4-wire SSI or a Microwire bus. The SSP can operate at a maximum speed of 30MHz and it referred to as SPI1 in the device documentation.  At high SSP frequencies, it is found that the first four pulses are shorter than the subsequent pulses. At 30 MHz, the first pulse can be expected to be approximately 10 ns shorter and the second pulse around 5 ns shorter. The remaining two pulses are around 2 ns shorter than subsequent pulses. At 25 MHz, the length of the first pulse would be around 7 ns shorter. The subsequent three pulses are around 2 ns shorter. At 20 MHz only the first pulse is affected and it is around 2 ns shorter. All subsequent pulses are fine. The deviation of the initial data bits/clocks will decrease as the SSP frequency decreases. 	ARM7				 None. ES_LPC2102 . Â©   Rev. 2 â 1 March 2011 7 of 13  ES_LPC2102  LPC2102 		3.5 SSP.1: Initial data bits/clocks of the SSP transmission are shorter than subsequent pulses at higher frequencies 			NXP
LPC2102	 Timer0 and Timer1 can be used in a counter mode. In this mode, the Timer Counter register can be incremented on rising, falling or both edges which occur on a selected CAP input pin. This counter mode can be combined with the match functionality to provide additional features. One of the features would be to reset the Timer Counter register on a match. The same would also apply for Timer1.  The Timer Counter reset does not trigger on the same incoming edge when the match takes place between the corresponding Match register and the Timer Counter register. The Timer Counter register will be reset only on the next incoming edge. 	ARM7				 There are two possible workarounds: 1. Combine the Timer Counter reset feature with the âinterrupt on matchâ feature. The interrupt on match occurs on the correct incoming edge. In the ISR, the Timer Counter register can also be reset. This solution can only work if no edges are expected during the duration of the ISR. 2. In this solution, the âinterrupt on matchâ feature is not used. Instead, the following specific initialization can achieve the counting operation: a. Initialize the Timer Counter register to 0xFFFFFFFF. b. If ânâ edges have to be counted then initialize the corresponding Match register with value n-1. For instance, if 2 edges need to be counted then load the Match register with value 1. More details on the above example: 1. Edge 1 - Timer overflows and Timer Counter (TC) is set to 0. 2. Edge 2 - TC = 1. Match takes place. 3. Edge 3 - TC = 0. 4. Edge 4 - TC = 1. Match takes place. 5. Edge 5 - TC = 0. ES_LPC2102 . Â©   Rev. 2 â 1 March 2011 8 of 13  ES_LPC2102  LPC2102 		3.6 Timer.1: In counter mode, the Timer Counter reset does not occur on the correct incoming edge 			NXP
LPC2102	 From the Vdd1V8 pin to the ARM7 core, there is a voltage drop. This voltage drop increases with higher currents (or higher power consumption). Higher system frequency and/or faster peripherals increase power consumption thereby increasing the voltage drop from the Vdd1V8 pin to the core.  Under increased power consumption conditions, the device may not work properly. The likelihood of the problem showing up increases if the device is run at higher speeds (approaching 70MHz) and/or if the peripherals are running at close to system frequency speed (i.e If the APBDIV register is set to a value lower than 4 which would imply that the peripherals are run faster than 1/4 of the system frequency). Also, having a lower voltage on Vdd1V8 pin (e.g. below 1.8 V) can cause this issue to surface. 	ARM7				 Increase the voltage on Vdd1V8 to 1.95 V. It is not harmful to the device if this voltage reaches 2 V. 		3.7 Vdd.1: Device may not work properly under increased power consumption conditions 			NXP
LPC2102	 There are two I2C interfaces, I2C0 and I2C1. I2C0 functions are shared as alternate functions on port pins P0.2 and P0.3. I2C1 functions are shared on port pins P0.17 and P0.18.  I2C1 pins are currently open-drain output pins but they should be regular bi-directional GPIO pins. I2C0 pins are configured as open-drain output pins (for I2C bus compliance). 	ARM7				 None. ES_LPC2102 . Â©   Rev. 2 â 1 March 2011 9 of 13  ES_LPC2102  LPC2102 		3.8 I2C1.1: I2C1 pins are not bi-directional GPIO pins 			NXP
LPC2102	 In software-controlled mode (BURST bit is 0), the 10-bit ADC can start conversion by using the following options in the A/D Control Register: Fig 1. A/D control register options  The external start conversion feature, AD0CR:START = 0x2 or 0x3, may not work reliably and ADC external trigger edges on P0.16 or P0.22 may be missed. The occurrence of this problem is peripheral clock (pclk) dependent. The probability of error (missing an ADC trigger from GPIO) is estimated as follows: â¢ For PCLK_ADC = 72 MHz, probability error = 12 % â¢ For PCLK_ADC = 50 MHz, probability error = 6 % â¢ For PCLK_ADC = 12 MHz, probability error = 1.5 % The probability of error is not affected by the frequency of ADC start conversion edges. 	ARM7				 In software-controlled mode (BURST bit is 0), the START conversion options (bits 26:24 set to 0x1 or 0x4 or 0x5 or 0x6 or 0x7) can be used. The user can also start a conversion by connecting an external trigger signal to a capture input pin (CAPx) from a Timer peripheral to generate an interrupt. The timer interrupt routine can then start the ADC conversion by setting the START bits (26:24) to 0x1. The trigger can also be generated from a timer match register. ES_LPC2102 . Â©   Rev. 2 â 1 March 2011 10 of 13  ES_LPC2102  LPC2102 4. AC/DC deviations detail 		3.9 ADC.1: External sync inputs not operational 			NXP
LPC2102	 The LPC2102 is rated for 2 kV ESD.The RTCX1 pin is the input pin for the RTC oscillator circuit.  The LPC2102 does not meet the required 2 kV ESD specified. 	ARM7				 Observe proper ESD handling precautions for the RTCX1 pin. 		4.1 ESD.1: The device does not meet the 2 kV ESD requirements on the RTCX1 pin 			NXP
LPC2102	 The LPC2102 has a VDD(1V8) core pin which provides power to the internal circuitry and also, has a VBAT pin which provides power only to the RTC (Real Time Clock). VBAT pin can be to an external battery or to the 3.3 V I/O port supply (VDD(3V3) pin) used by the device.  When the VDD(1V8) core pin is floated, power consumption increases on the VBAT pin. 	ARM9				 VDD(1V8) core pin must always be connected to its power supply or to ground.		4.2 VBAT.1: Increased power consumption on the VBAT pin when the VDD(1V8) core pin is left floating 			NXP
LPC2114	 The Flash memory on the LPC2114/24 offers In-Application Programming (IAP) functionality. The IAP routines are part of the on-chip boot loader software, which controls the interface between the digital logic and the Flash memory. Please note that all programming methods (JTAG, ISP, IAP) use IAP calls.  Due to a timing problem in the interface between the Flash block and the digital logic the following problem may occur: If the boot loader revision in the device is previous to V1.63 then in up to 10% of the devices the Flash memory interface, at some point during an IAP programming or erase operation, may never return from the IAP call. Please note that devices that pass the IAP programming are functional and do not suffer from any long-term reliability problems. Devices with a date code prior to 0425 (manufactured before week 25 in 2004) are generally affected by this problem unless you receive devices with updated boot loader software from your distributor. Parts marked with date code 0425 or later are not affected by this problem. Please refer to page 3 of this document for details on how to identify the date code. 	ARM7				 1. The on-chip boot-loader software can be updated via ISP to correct this issue. The boot loader update files can be downloaded here: http://www.nxp.com/files/products/standard/microcontrollers/utilities/lpc2000_bl_update.zip The boot-loader version can be read out using the NXP Flash ISP Utility which can be found here: http://www.nxp.com/files/products/standard/microcontrollers/utilities/lpc2000_flash_utility.zip 2. Limiting the external clock frequency to 12 MHz AND making sure the on-chip PLL is turned OFF while programming any part of the Flash memory reduces the likelihood of the occurrence significantly. During In-System-Programming the PLL is turned off by default. ES_LPC2114_24_00 . Â©   Rev. 3 â 1 April 2011 5 of 22  ES_LPC2114/24; LPC2114/24/00  LPC2114/24, LPC2114/00, LPC2124/00 		3.1 IAP.1: Flash memory programming interface timing problem 			NXP
LPC2114	 In burst mode the A/D converter does repeated conversions at the rate selected by the CLKS field in the ADCR, scanning (if necessary) through the pins selected by 1s in the SEL field. The first conversion after the start corresponds to the least-significant 1 in the SEL field, then higher numbered 1-bits (pins) if applicable. Repeated conversions can be terminated by clearing this bit.  In burst conversion mode, the first two conversions (after setting the mode) will be of the same, lowest-numbered, of the selected channels. 	ARM7				 Ignore the first conversion, always check the CHN bits to confirm the channel converted. 		3.2 ADC.1: First two ADC conversions in burst mode from same channel 			NXP
LPC2114	 The ADCR SFR contains bits to enable the ADC burst mode (BURST), start the conversion in software control mode (START), and to select the channel to begin converting (SEL).  In burst mode, If the BURST bit is set before or simultaneously to (using the STR instruction for example), the SEL bits, then the first channel converted will correspond to the previous SEL bit settings. In software control mode (only when using external trigger), if the START bits are set before or simultaneously to (using the STR instruction for example) the SEL bits, then the first channel converted will correspond to the previous SEL bit settings. 	ARM7				 Set the BURST/START bit(s) after setting the SEL bits. ES_LPC2114_24_00 . Â©   Rev. 3 â 1 April 2011 6 of 22  ES_LPC2114/24; LPC2114/24/00  LPC2114/24, LPC2114/00, LPC2124/00 		3.3 ADC.2: First conversion from channel specified by previous SEL setting 			NXP
LPC2114	 In hardware scan mode multiple ADC channels may be selected as part of the scan by selecting the appropriate bits in the SEL field in the ADCR register.  Certain hardware scanning patterns for the A/D Converter do not operate properly. Selecting channel 2 only leads to alternate sampling of channels 2 and 3. Selecting channels 1 and 2 leads to sampling channel 1 for the first conversion, then sampling channel 2 on every subsequent conversion. 	ARM7				 None. Do not use the sampling patterns âchannel 2 onlyâ or âchannels 1 and 2â. This problem has no effect on software conversion, nor on any other patterns other than the two noted above. 		3.4 ADC.3: Incorrect scan pattern 			NXP
LPC2114	 Setting the PD bit (bit 1) in PCON stops all clocks and powers down the peripherals. The ADC is powered down by clearing the PDN bit (bit 21) in the ADCR register, setting the bit powers up (enables) the ADC.  If the PDN in ADCR is set, setting the PD bit in PCON will not power down the ADC. 	ARM7				 Clear the PDN bit in the ADCR SFR to turn off the ADC prior to setting the PD bit in PCON. ES_LPC2114_24_00 . Â©   Rev. 3 â 1 April 2011 7 of 22  ES_LPC2114/24; LPC2114/24/00  LPC2114/24, LPC2114/00, LPC2124/00 		3.5 ADC.4: Global power down does not power down the ADC 			NXP
LPC2114	 When the START field of the ADCR register contains 010-111 the EDGE bit in ADCR will determine whether a conversion is started on a rising or falling edge of the selected CAP/MAT signal. EDGE=0 selects rising edge detection, EDGE=1 selects falling edge detection (On CAP/MAT pin).  If the state of the selected CAP/MAT signal is 1 and EDGE is set to detect rising edges (EDGE = 0) or, if detection of falling edges is selected (EDGE = 1) and the state of the selected CAP/MAT signal is 0, an ADC conversion will immediately be initiated when the START bits are written to. So the first conversion behaves as a level triggered event rather than edge triggered. 	ARM7				 Clear the selected CAP/MAT signal for EDGE = 0 or set the selected CAP/MAT signal for EDGE = 1 before writing 010-111 to START field. Alternatively, discard the first conversion after writing to the start bits. 		3.6 ADC.5: Edge triggered ADC conversion start error 			NXP
LPC2114	 Writing to ADCR while a conversion is in progress should set the DONE bit and start a new conversion.  In actuality, if the ADCR is written to within 2.5 ADC_clock cycles, a new conversion is started but the DONE bit is not set. If the ADCR is written to after 2.5 ADC_clocks, but within a conversion time, the DONE bit is set within one ADC_clock and a new conversion is started. 	ARM7				 Do not write to ADCR until the conversion is complete. 		3.7 ADC.6: Writing to ADCR while conversion in progress 			NXP
LPC2114	 The SPI interrupt flag is set by the SPI interface to generate an interrupt. It is cleared by writing a 1 to this bit.  A write to any register associated with the SPI peripheral will clear the SPI interrupt register. 	ARM7				 Avoid writing to SPI registers while transmissions are in progress or while SPI interrupts are pending. ES_LPC2114_24_00 . Â©   Rev. 3 â 1 April 2011 8 of 22  ES_LPC2114/24; LPC2114/24/00  LPC2114/24, LPC2114/00, LPC2124/00 		3.8 SPI.1: Unintentional clearing of SPI interrupt flag 			NXP
LPC2114	 In slave mode, the SPI can set the clock phase (CPHA) to 0 or 1.  Consider the following conditions: 1. SPI is configured as a slave (with CPHA=0). 2. SPI is running at a low frequency. In slave mode, the SPIF (SPI Transfer Complete Flag) bit is set on the last sampling edge of SCK. If CPHA is set to 0 then the last sampling edge of SCK would be the rising edge. Under the above conditions, if the SPI Data Register (SPDR) is written to less than a half SCLK cycle after the SPIF bit is set (this would happen if the SPI frequency is low) then the SPDR will shift data one clock early for the upcoming transfers. Lowering the SPI frequency would increase the likelihood of the SPDR write happening in the first half SCK cycle of the last sampling clock. 	ARM7				 There are two possible workarounds: 1. Use CPHA=1. 2. If the data is shifted incorrectly when CPHA is set to 0 then delaying the write to SPDR after the half SCK cycle of the last sampling clock would resolve this issue. 		3.9 SPI.2: Incorrect shifting of data in slave mode at lower frequencies 			NXP
LPC2114	 The VPBDIV register controls the rate of the VPB clock in relation to the processor clock. EXTPOLAR and EXTMODE determine the operating parameters of the external interrupts.  A write to either the external interrupt polarity register (EXTPOLAR) or the external interrupt mode register (EXTMODE) will corrupt the VPBDIV register. A read of either EXTPOLAR or EXTMODE will be corrupted BY the VPBDIV register. If VPBDIV is â1â or â2â prior to any write to EXTPOLAR or EXTMODE, the CPU will hang up on the write to EXTPOLAR or EXTMODE. 	ARM7				 If VPBDIV is non-zero, write all zeroes to VPBDIV before reading or writing EXTMODE or EXTPOLAR, then write the proper value back to VPBDIV. In most applications this is a known and fixed value, but if there is a possibility of dynamic changes in VPBDIV, software will need to read VPBDIV, write zero to VPBDIV, read or write EXTMODE and/or EXTPOLAR, and then rewrite the value previously read from VPBDIV. ES_LPC2114_24_00 . Â©   Rev. 3 â 1 April 2011 9 of 22  ES_LPC2114/24; LPC2114/24/00  LPC2114/24, LPC2114/00, LPC2124/00 		3.10 EXTINT.1: Corruption of VPBDIV via EXTPOLAR or EXTMODE 			NXP
LPC2114	 EXTPOLAR and EXTMODE determine the operating parameters of the external interrupts.  As an illustration, trying to set EXTMODE to 0x1 or 0xd would result in EXTMODE to be set to 0x0 instead. 	ARM7				 This problem is related to EXTINT.1 and hence the same workaround applies with an additional step. The steps involved in the configuration of the EXTMODE and/or EXTPOLAR would be as follows: 1. Write 0x0 to VPBDIV 2. Write the desired value to EXTMODE or EXTPOLAR register 3. Write the same value to VPBDIV (additional step) 4. Restore the VPBDIV to the previously saved value or simply write to the register again with the desired value. Code sample for setting EXTMODE and EXTPOLAR to 0x1: VPBDIV = 0x0; /* EXTMODE */ EXTMODE = 0x1; VPBDIV = 0x1; VPBDIV = 0x0; /* EXTPOLAR */ EXTPOLAR = 0x1; VPBDIV = 0x1; VPBDIV = 0x0; /* Setting VPBDIV */ Note: While testing this in a debugger environment, please donât single-step through these steps. A breakpoint could be placed after Step 4 and you would see the EXTMODE and EXTPOLAR registers reflecting the correct values. 		3.11 EXTINT.2: Incorrect setting of EXTMODE and/or EXTPOLAR register while trying to set them to desired value 			NXP
LPC2114	 P0.21 and P0.19 may be configured as capture inputs via the PINSEL register.  When PINSEL(11:10) is set to â11â P0.21 is not internally connected as capture 1.3 	ARM7				 To use P0.21 as capture 1.3, PINSEL(7:6) must also be set to â11â which means that P0.19 must be selected as capture input 1.2. ES_LPC2114_24_00 . Â©   Rev. 3 â 1 April 2011 10 of 22  ES_LPC2114/24; LPC2114/24/00  LPC2114/24, LPC2114/00, LPC2124/00 		3.12 CAP.1: Problem when selecting P0.21 as a capture 1.3 input (timer1) 			NXP
LPC2114	 The Peripheral Bus Divider (VPBDIV) divides the processor clock (CCLK) by one, two, or four. This is the clock that is provided to the peripheral bus.  Reading the VPBDIV register may return an incorrect value. 	ARM7				 Performing two consecutive reads of the VPBDIV assures that the correct value is returned. 		3.13 VPBDIV.1: Incorrect read of VPBDIV 			NXP
LPC2114	 If the processor is in Thumb state and executing the code sequence STR, STMIA or PUSH followed by a PC relative load, and the STR, STMIA or PUSH is aborted, the PC is saved to the abort link register.  In this situation the PC is saved to the abort link register in word resolution, instead of half-word resolution. Conditions: The processor must be in Thumb state, and the following sequence must occur: <any instruction> <STR, STMIA, PUSH> <---- data abort on this instruction LDR rn, [pc,#offset] In this case the PC is saved to the link register R14_abt in only word resolution, not half-word resolution. The effect is that the link register holds an address that could be #2 less than it should be, so any abort handler could return to one instruction earlier than intended. 	ARM7				 In a system that does not use Thumb state, there will be no problem. In a system that uses Thumb state but does not use data aborts, or does not try to use data aborts in a recoverable manner, there will be no problem. Otherwise the workaround is to ensure that a STR, STMIA or PUSH cannot precede a PC-relative load. One method for this is to add a NOP before any PC-relative load instruction. However this would have to be done manually. ES_LPC2114_24_00 . Â©   Rev. 3 â 1 April 2011 11 of 22  ES_LPC2114/24; LPC2114/24/00  LPC2114/24, LPC2114/00, LPC2124/00 		3.14 Core.1: Incorrect update of the Abort Link register in Thumb state 			NXP
LPC2114	 The Timers may be configured so that events such as Match and Capture, cause interrupts. Bits in the Interrupt Register (IR) indicate the source of the interrupt, whether from Capture or Match.  If more than one interrupt for multiple Match events using the same Timer are enabled, it is possible that one of the match interrupts may not be recognized. If this occurs no more interrupts from that specific match register will be recognized. This could happen in a scenario where the match events are very close to each other. This issue also affects the Capture functionality. Specific details: Suppose that two match events are very close to each other (Say Match0 and Match1). Also assume that the Match0 event occurs first. When the Match0 interrupt occurs the 0th bit of the Interrupt Register will be set. To exit the Interrupt Service Routine of Match0, this bit has to be cleared in the Interrupt Register. The clearing of this bit might be done by using the following statement: T0_IR = 0x1; It is possible that software will be writing a 1 to bit 0 of the Interrupt Register while a Match1 event occurs, meaning that hardware needs to set the bit 1 of the Interrupt Register. In this case, since hardware is accessing the register at the same time as software, bit 1 for Match1 never gets set, causing the interrupt to be missed. In summary, while software is writing to the Interrupt Register, any Match or Capture event (which are configured to interrupt the core) occurring at the same time may result in the subsequent interrupt not being recognized. Similarly for the Capture event, if a capture event occurs while a Match event is being is serviced then the Capture event might be missed if the software and hardware accesses coincide. Affected features: 1. Interrupt on Match for Timer0/1. 2. Interrupt on Capture for Timer0/1. 3. These same features will be affected when using PWM. ES_LPC2114_24_00 . Â©   Rev. 3 â 1 April 2011 12 of 22  ES_LPC2114/24; LPC2114/24/00  LPC2114/24, LPC2114/00, LPC2124/00 	ARM7				 There is no clear workaround for this problem but some of the below mentioned solutions could work with some applications. Possible work-aroundâs for Match functionality: 1. If the application only needs two Match registers then distribute them between Timer 0 and Timer 1 to avoid this problem. 2. Stop the timer before accessing the Interrupt register for clearing the interrupt and then start timer again after the access is completed. 3. Polling for interrupt: Supposing that there are two Match events (Match X and Match Y). At the end of the Interrupt Service Routine (ISR) for Match X, compare the Timer Counter value with the Match Register Y value. If the Timer Counter value is more than the Match Register Y value then it is possible that this event might have been missed. In this case jump to the ISR directly and service Match event Y. Possible workarounds for Capture functionality: 1. Try to spread the capture events between both timers if there are two capture events. If the application also has a match event then one of the capture events may suffer. 2. Polling for Capture: At the end of a Match interrupt ISR or Capture event ISR compare the previous Capture value with the current Capture value. If the Capture value has changed then the Capture event might have been missed. In this case, jump to the ISR directly and service the Capture event. 		3.15 TIMER.1: Missed Interrupt Potential 			NXP
LPC2114		ARM7						3.16 PWM.1: Missed Interrupt Potential for the Match functionality. The description is the same as above.			NXP
LPC2114	 Timer0 has four external match outputs corresponding to match registers with various capabilities. Match 0.0 can be configured as an alternate function on P0.3 and P0.22. Match 0.1 can be configured as an alternate function on Port 0.5 and P0.27. The alternate functions can be configured by using the respective PINSELx register.  Match 0.0 should have been only connected to P0.3 and P0.22 but it is also connected to P0.5. Match 0.1 is only connected to P0.27. Hence if the application configures the External Match alternate function on both P0.3 (Match 0.0) and P0.5 (Match 0.1) then the Match 0.0 output can be seen on two port pins, namely P0.3 and P0.5. 	ARM7				 Only P0.27 can be used for Match 0.1. ES_LPC2114_24_00 . Â©   Rev. 3 â 1 April 2011 13 of 22  ES_LPC2114/24; LPC2114/24/00  LPC2114/24, LPC2114/00, LPC2124/00 		3.17 Timer0.1: Match 0.1 output cannot be seen on port pin P0.5 if configured as an alternate function. 			NXP
LPC2114	 Reading the contents of the IIR,LSR and MSR registers will clear certain bits in the register. 1. Reading the IIR should clear the THRE status if THRE is the highest priority pending interrupt (Only affects UART1). 2. Reading LSR should clear the OE/PE/FE/BI bits (affects both UART0 and UART1). 3. Reading MSR should clear the Delta DCD/Trailing Edge RI/Delta DSR/Delta CTS bits (Only affects UART1).  If hardware is setting one of these above bits while the software is reading the contents of the register the reading process clears all bits in the register including the bit that got set by hardware. The software reads the old value though and the bit that got set by hardware is lost. Specific details: Suppose IIR has a modem status interrupt while the other interrupts are inactive and software reads the IIR value (polling) while hardware sets the THRE interrupt then software will read the Modem Interrupt value while the THRE interrupt is cleared i.e the THRE interrupt is lost. Suppose the LSR is all zeros and software is reading the register while hardware is generating a parity error then the parity error bit is cleared while the software reads the old value (all zeros) i.e. the parity error is lost. Suppose MSR is all zeros and software is polling the value of the register while the value of CTS is changing then the change in CTS value should result in the Delta CTS bit getting set. Instead software will read all zeros and the Delta CTS bit in the MSR register will be cleared i.e. the Delta CTS status is lost. 	ARM7				 IIR reading: The IIR bug can be worked around by disabling the modem status interrupt effectively making THRE the lowest priority interrupt. The work-around does not work in software interrupt polling mode. Modem status has to be handled by software polling MSR. Now there are two cases: 1. A THRE interrupt is pending, software responds to the interrupt by reading the IIR while another, higher priority interrupt is set (e.g. RDA). In this case software will read the THRE status although the status will not be cleared where it should have been. After handling the THRE and RDA interrupt another dummy THRE interrupt may occur, unless in the meantime software has filled THR. This is considered an error although not fatal. ES_LPC2114_24_00 . Â©   Rev. 3 â 1 April 2011 14 of 22  ES_LPC2114/24; LPC2114/24/00  LPC2114/24, LPC2114/00, LPC2124/00 2. A high priority interrupt is pending, software responds to the interrupt by reading the IIR register while a THRE interrupt is set. In this case, software will read the higher priority interrupt and the THRE interrupt will be handled later. This behavior is as expected. LSR reading: A work-around for this problem is to service the OE/PE/FE/BI condition before another character is received which will trigger an LSR update. So basically, service the interrupt in one-character time. MSR reading: The MSR bug can be worked-around by not using the Delta DCD/Trailing Edge RI/Delta DSR/Delta CTS bits in the MSR but instead use the DCD/TRI/DSR/CTS bits in the same register. To prevent, a transition from being missed software should poll the registerâs value at a sufficiently high rate. ES_LPC2114_24_00 . Â©   Rev. 3 â 1 April 2011 15 of 22  ES_LPC2114/24; LPC2114/24/00  LPC2114/24, LPC2114/00, LPC2124/00 3.19 Reset.1: Device does not power up correctly under certain internal conditions Problem: If certain rare chip-internal conditions are met, the device will not start up correctly when executing a power-on reset. The crystal oscillator will be running but the device will not execute code. Work-around: Apply a second (warm) reset pulse (without power-on cycle). The minimum time requirement between the first (unsuccessful) reset and the second reset is 4105 external oscillator clock cycles, which means that the assertion of the second reset should occur 4105 cycles or more after the deassertion of the first reset. For example, at 10 MHz, this is equal to 411 ï­s; at 20 MHz, this is equal to 206 ï­s.This can be achieved by using an external watchdog timer or by any other circuitry in the application that is able to assert a second reset pulse. The root cause for this problem has been identified and will be fixed from Revision B of this device onwards. This problem will also be fixed in the LPC21x4/00 version of this device which will have a dedicated order number (LPC21x4FBD64/00). ES_LPC2114_24_00 . Â©   Rev. 3 â 1 April 2011 16 of 22  ES_LPC2114/24; LPC2114/24/00  LPC2114/24, LPC2114/00, LPC2124/00 3.20 ADC.7: External sync inputs not operational Introduction: In software-controlled mode (BURST bit is 0), the 10-bit ADC can start conversion by using the following options in the A/D Control Register: Fig 1. A/D control register options Problem: The external start conversion feature, ADCR:START = 0x2 or 0x3, may not work reliably and ADC external trigger edges on P0.16 or P0.22 may be missed. The occurrence of this problem is peripheral clock (pclk) dependent. The probability of error (missing a ADC trigger from GPIO) is estimated as follows: â¢ For PCLK_ADC = 60 MHz, probability error = 12 % â¢ For PCLK_ADC = 50 MHz, probability error = 6 % â¢ For PCLK_ADC = 12 MHz, probability error = 1.5 % The probability of error is not affected by the frequency of ADC start conversion edges. Work-around: In software-controlled mode (BURST bit is 0), the START conversion options (bits 26:24 set to 0x1 or 0x4 or 0x5 or 0x6 or 0x7) can be used. The user can also start a conversion by connecting an external trigger signal to a capture input pin (CAPx) from a Timer peripheral to generate an interrupt. The timer interrupt routine can then start the ADC conversion by setting the START bits (26:24) to 0x1. The trigger can also be generated from a timer match register. ES_LPC2114_24_00 . Â©   Rev. 3 â 1 April 2011 17 of 22  ES_LPC2114/24; LPC2114/24/00  LPC2114/24, LPC2114/00, LPC2124/00 4. AC/DC deviations detail 		3.18 UART.1: Coinciding VPB read and hardware register update 			NXP
LPC2114	 The specified, minimum, value for VIH is 2.0 V.  Any pin associated with either an external interrupt input or an analog to digital converter (ADC) input has a VIH of 2.4 V, not 2.0 V. The pins that are affected are the ones that can be configured as either an ADC input or and external interrupt input, not just the ones that are configured as such. 	ARM7				 Make sure that high logic levels are at least 2.4 V at these pins. 		4.1 VIH.1: Incompatibility of actual VIH levels as compared to those specified 			NXP
LPC2114	 V3 is the power supply voltage for the I/O ports. External interrupt pins are general purpose interrupt pins which are level and edge sensitive. They can optionally wake up the device from power down mode. The ADC block can produce 10-bit samples with conversion time as low as 2.44 us.  If the external interrupt and/or ADC pins are pulled higher than 1.8 V then it will lead to increased current consumption from V3. If V3 is 3.0 V and V1.8 is 1.8 V then the leakage current will increase to a typical number of 200 uA (per pin). Note: The ADC pins wonât contribute to the leakage if they are not configured as digital inputs using the PINSELx register. External interrupt pins will contribute to the leakage irrespective of their pin configuration. 	ARM9				 None.		4.2 V3.1: Leakage current on V3 due to External Interrupt and/or Analog to Digital Converter (ADC) pins. 			NXP
LPC2220	 If the processor is in Thumb state and executing the code sequence STR, STMIA or PUSH followed by a PC relative load, and the STR, STMIA or PUSH is aborted, the PC is saved to the abort link register.  In this situation the PC is saved to the abort link register in word resolution, instead of half-word resolution. Conditions: The processor must be in Thumb state, and the following sequence must occur: <any instruction> <STR, STMIA, PUSH> <---- data abort on this instruction LDR rn, [pc,#offset] In this case the PC is saved to the link register R14_abt in only word resolution, not half-word resolution. The effect is that the link register holds an address that could be #2 less than it should be, so any abort handler could return to one instruction earlier than intended. 	ARM7				 In a system that does not use Thumb state, there will be no problem. In a system that uses Thumb state but does not use data aborts, or does not try to use data aborts in a recoverable manner, there will be no problem. Otherwise the workaround is to ensure that a STR, STMIA or PUSH cannot precede a PC-relative load. One method for this is to add a NOP before any PC-relative load instruction. However this would have to be done manually. ES_LPC2220 . Â©   Rev. 2 â 1 April 2011 4 of 11  ES_LPC2220  LPC2220 		3.1 Core.1: Incorrect update of the Abort Link register in Thumb state 			NXP
LPC2220	 In slave mode, the SPI can set the clock phase (CPHA) to 0 or 1.  Consider the following conditions: 1. SPI is configured as a slave (with CPHA=0). 2. SPI is running at a low frequency. In slave mode, the SPIF (SPI Transfer Complete Flag) bit is set on the last sampling edge of SCK. If CPHA is set to 0 then the last sampling edge of SCK would be the rising edge. Under the above conditions, if the SPI Data Register (SPDR) is written to less than a half SCLK cycle after the SPIF bit is set (this would happen if the SPI frequency is low) then the SPDR will shift data one clock early for the upcoming transfers. Lowering the SPI frequency would increase the likelihood of the SPDR write happening in the first half SCK cycle of the last sampling clock. 	ARM7				 There are two possible workarounds: 1. Use CPHA=1. 2. If the data is shifted incorrectly when CPHA is set to 0 then delaying the write to SPDR after the half SCK cycle of the last sampling clock would resolve this issue. ES_LPC2220 . Â©   Rev. 2 â 1 April 2011 5 of 11  ES_LPC2220  LPC2220 		3.2 SPI.1: Incorrect shifting of data in slave mode at lower frequencies 			NXP
LPC2220	 The SSP is a Synchronous Serial Port (SSP) controller capable of operation on a SPI, 4-wire SSI or a Microwire bus. The SSP can operate at a maximum speed of 30 MHz and it referred to as SPI1 in the device documentation.  At high SSP frequencies, it is found that the first four pulses are shorter than the subsequent pulses. At 30 MHz, the first pulse can be expected to be approximately 10 ns shorter and the second pulse around 5 ns shorter. The remaining two pulses are around 2 ns shorter than subsequent pulses. At 25 MHz, the length of the first pulse would be around 7 ns shorter. The subsequent three pulses are around 2 ns shorter. At 20 MHz only the first pulse is affected and it is around 2 ns shorter. All subsequent pulses are fine. The deviation of the initial data bits/clocks will decrease as the SSP frequency decreases. 	ARM7				 None. 		3.3 SSP.1: Initial data bits/clocks of the SSP transmission are shorter than subsequent pulses at higher frequencies 			NXP
LPC2220	 Timer0 has four external match outputs corresponding to match registers with various capabilities. Match 0.0 can be configured as an alternate function on P0.3 and P0.22. Match 0.1 can be configured as an alternate function on Port 0.5 and P0.27. The alternate functions can be configured by using the respective PINSELx register.  Match 0.0 should have been only connected to P0.3 and P0.22 but it is also connected to P0.5. Match 0.1 is only connected to P0.27. Hence if the application configures the External Match alternate function on both P0.3 (Match 0.0) and P0.5 (Match 0.1) then the Match 0.0 output can be seen on two port pins, namely P0.3 and P0.5. 	ARM7				 Only P0.27 can be used for Match 0.1. ES_LPC2220 . Â©   Rev. 2 â 1 April 2011 6 of 11  ES_LPC2220  LPC2220 		3.4 Timer0.1: Match 0.1 output cannot be seen on port pin P0.5 if configured as an alternate function 			NXP
LPC2220		ARM7						3.5 Timer.1: In counter mode, the Timer Counter reset does not occur on the correct incoming edge Problem: Timer0 and Timer1 can be used in a counter mode. In this mode, the Timer Counter register can be incremented on rising, falling or both edges which occur on a selected CAP input pin. This counter mode can be combined with the match functionality to provide additional features. One of the features would be to reset the Timer Counter register on a match. The same would also apply for Timer1. Work-around: There are two possible workarounds: 1. Combine the Timer Counter reset feature with the âinterrupt on matchâ feature. The interrupt on match occurs on the correct incoming edge. In the ISR, the Timer Counter register can also be reset. This solution can only work if no edges are expected during the duration of the ISR. 2. In this solution, the âinterrupt on matchâ feature is not used. Instead, the following specific initialization can achieve the counting operation: a. Initialize the Timer Counter register to 0xFFFFFFFF. b. If ânâ edges have to be counted then initialize the corresponding Match register with value n-1. For instance, if 2 edges need to be counted then load the Match register with value 1. More details on the above example: 1. Edge 1 - Timer overflows and Timer Counter (TC) is set to 0. 2. Edge 2 - TC=1. Match takes place. 3. Edge 3 - TC=0. 4. Edge 4 - TC=1. Match takes place. 5. Edge 5 - TC=0. ES_LPC2220 . Â©   Rev. 2 â 1 April 2011 7 of 11  ES_LPC2220  LPC2220			NXP
LPC2220	 In software-controlled mode (BURST bit is 0), the 10-bit ADC can start conversion by using the following options in the A/D Control Register: Fig 1. A/D control register options  The external start conversion feature, ADCR:START = 0x2 or 0x3, may not work reliably and ADC external trigger edges on P0.16 or P0.22 may be missed. The occurrence of this problem is peripheral clock (pclk) dependent. The probability of error (missing a ADC trigger from GPIO) is estimated as follows: â¢ For PCLK_ADC = 60 MHz, probability error = 12 % â¢ For PCLK_ADC = 50 MHz, probability error = 6 % â¢ For PCLK_ADC = 12 MHz, probability error = 1.5 % The probability of error is not affected by the frequency of ADC start conversion edges. 	ARM7				 In software-controlled mode (BURST bit is 0), the START conversion options (bits 26:24 set to 0x1 or 0x4 or 0x5 or 0x6 or 0x7) can be used. The user can also start a conversion by connecting an external trigger signal to a capture input pin (CAPx) from a Timer peripheral to generate an interrupt. The timer interrupt routine can then start the ADC conversion by setting the START bits (26:24) to 0x1. The trigger can also be generated from a timer match register		3.6 ADC.1: External sync inputs not operational 			NXP
LPC2220		ARM7									NXP
LPC2220		ARM7									NXP
LPC2220		ARM7									NXP
LPC2220		ARM7									NXP
LPC2220		ARM9									NXP
LPC2378	 The LPC2378/88 has a 10-bit ADC, which can be used to measure analog signals and convert the signals into a 10-bit digital result. There are eight A/D channels and each channel has its own individual A/D Data Register (ADDR0 to ADDR7). The A/D Data Register holds the result when an A/D conversion is complete, and also includes the flags that indicate when a conversion has been completed (DONE bit) and when a conversion overrun has occurred. The DONE bit is cleared when the respective A/D Data Register is read.  If a software read of ADDRx conflicts with the hardware setting of the DONE bit in the same register (once a conversion is completed) then the DONE bit gets cleared automatically, thereby clearing the indication that a conversion was completed. 	ARM7				 For software controlled mode or burst mode with only one channel selected, the DONE bit in the A/D Global Data Register (located at 0xE003 4004) can be used instead of the individual ADDRx result register with no impact on performance. For burst mode with multiple channels selected, the DONE bit together with the CHN field in the A/D Global Data Register can be used with some impact on throughput. ES_LPC2378_88 . Â© NXP B.V. 2012. All rights reserved.  Rev. 6.1 â 1 July 201		3.1 ADC.1: ADDRx read conflicts with hardware setting of the DONE bit 			NXP
LPC2378		ARM7									NXP
LPC2378		ARM7									NXP
LPC2378		ARM7									NXP
LPC2378		ARM7									NXP
LPC2378		ARM7									NXP
LPC2378		ARM7									NXP
LPC2378		ARM7									NXP
LPC2378		ARM7									NXP
LPC2378		ARM7									NXP
LPC2378		ARM7									NXP
LPC2378		ARM7									NXP
LPC2378		ARM7									NXP
LPC2378		ARM7									NXP
LPC2378		ARM7									NXP
LPC2378		ARM7									NXP
LPC2378		ARM7									NXP
LPC2378		ARM7									NXP
LPC2378		ARM7									NXP
LPC2378		ARM7									NXP
LPC2378		ARM7									NXP
LPC2378		ARM7									NXP
LPC2378		ARM7									NXP
LPC2378		ARM9									NXP
LPC2119	 The Flash memory on the LPC2119/29 offers In-Application Programming (IAP) functionality. The IAP routines are part of the on-chip boot loader software, which controls the interface between the digital logic and the Flash memory. Please note that all programming methods (JTAG, ISP, IAP) use IAP calls.  Due to a timing problem in the interface between the Flash block and the digital logic the following problem may occur: If the boot loader revision in the device is previous to V1.63 then in up to 10 % of the devices the Flash memory interface, at some point during an IAP programming or erase operation, may never return from the IAP call. Please note that devices that pass the IAP programming are functional and do not suffer from any long-term reliability problems. LPC2119 devices with a date code prior to 0423 (manufactured before week 23 in 2004) or LPC2129 devices with a date code prior to 0425 (manufactured before week 25 in 2004) are generally affected by this problem unless you receive devices with updated boot loader software from your distributor. Parts marked with a date code later than 0423 (LPC2119) or 0425 (LPC2129) are not affected by this problem. Please refer to page 3 of this document for details on how to identify the date code. 	ARM7				 1. The on-chip boot-loader software can be updated via ISP to correct this issue. The boot loader update files can be downloaded here: http://www.nxp.com/files/products/standard/microcontrollers/utilities/lpc2000_bl_update.zip The boot-loader version can be read out using the NXP Flash ISP Utility which can be found here: http://www.nxp.com/files/products/standard/microcontrollers/utilities/lpc2000_flash_utility.zip 2. Limiting the external clock frequency to 12 MHz AND making sure the on-chip PLL is turned OFF while programming any part of the Flash memory reduces the likelihood of the occurrence significantly. During In-System-Programming the PLL is turned off by default. ES_LPC2109_19_29_00 . Â©   Rev. 3 â 1 April 2011 5 of 25  ES_LPC21x9; LPC21x9/00  LPC21x9; LPC21x9/00 		3.1 IAP.1: Flash memory programming interface timing problem 			NXP
LPC2119	 In burst mode the A/D converter does repeated conversions at the rate selected by the CLKS field in the ADCR, scanning (if necessary) through the pins selected by 1s in the SEL field. The first conversion after the start corresponds to the least-significant 1 in the SEL field, then higher numbered 1-bits (pins) if applicable. Repeated conversions can be terminated by clearing this bit.  In burst conversion mode, the first two conversions (after setting the mode) will be of the same, lowest-numbered, of the selected channels. 	ARM7				 Ignore the first conversion, always check the CHN bits to confirm the channel converted. 		3.2 ADC.1: First two ADC conversions in burst mode from same channel 			NXP
LPC2119	 The ADCR SFR contains bits to enable the ADC burst mode (BURST), start the conversion in software control mode (START), and to select the channel to begin converting (SEL).  In burst mode, If the BURST bit is set before or simultaneously to (using the STR instruction for example), the SEL bits, then the first channel converted will correspond to the previous SEL bit settings. In software control mode (only when using external trigger), if the START bits are set before or simultaneously to (using the STR instruction for example) the SEL bits, then the first channel converted will correspond to the previous SEL bit settings. 	ARM7				 Set the BURST/START bit(s) after setting the SEL bits. ES_LPC2109_19_29_00 . Â©   Rev. 3 â 1 April 2011 6 of 25  ES_LPC21x9; LPC21x9/00  LPC21x9; LPC21x9/00 		3.3 ADC.2: First conversion from channel specified by previous SEL setting 			NXP
LPC2119	 In hardware scan mode multiple ADC channels may be selected as part of the scan by selecting the appropriate bits in the SEL field in the ADCR register.  Certain hardware scanning patterns for the A/D Converter do not operate properly. Selecting channel 2 only leads to alternate sampling of channels 2 and 3. Selecting channels 1 and 2 leads to sampling channel 1 for the first conversion, then sampling channel 2 on every subsequent conversion. 	ARM7				 None. Do not use the sampling patterns âchannel 2 onlyâ or âchannels 1 and 2â. This problem has no effect on software conversion, nor on any other patterns other than the two noted above. 		3.4 ADC.3: Incorrect scan pattern 			NXP
LPC2119	 Setting the PD bit (bit 1) in PCON stops all clocks and powers down the peripherals. The ADC is powered down by clearing the PDN bit (bit 21) in the ADCR register, setting the bit powers up (enables) the ADC.  If the PDN in ADCR is set, setting the PD bit in PCON will not power down the ADC. 	ARM7				 Clear the PDN bit in the ADCR SFR to turn off the ADC prior to setting the PD bit in PCON. ES_LPC2109_19_29_00 . Â©   Rev. 3 â 1 April 2011 7 of 25  ES_LPC21x9; LPC21x9/00  LPC21x9; LPC21x9/00 		3.5 ADC.4: Global power down does not power down the ADC 			NXP
LPC2119	 When the START field of the ADCR register contains 010-111 the EDGE bit in ADCR will determine whether a conversion is started on a rising or falling edge of the selected CAP/MAT signal. EDGE=0 selects rising edge detection, EDGE=1 selects falling edge detection (On CAP/MAT pin).  If the state of the selected CAP/MAT signal is 1 and EDGE is set to detect rising edges (EDGE = 0) or, if detection of falling edges is selected (EDGE = 1) and the state of the selected CAP/MAT signal is 0, an ADC conversion will immediately be initiated when the START bits are written to. So the first conversion behaves as a level triggered event rather than edge triggered. 	ARM7				 Clear the selected CAP/MAT signal for EDGE = 0 or set the selected CAP/MAT signal for EDGE = 1 before writing 010-111 to START field. Alternatively, discard the first conversion after writing to the start bits. 		3.6 ADC.5: Edge triggered ADC conversion start error 			NXP
LPC2119	 Writing to ADCR while a conversion is in progress should set the DONE bit and start a new conversion.  In actuality, if the ADCR is written to within 2.5 ADC_clock cycles, a new conversion is started but the DONE bit is not set. If the ADCR is written to after 2.5 ADC_clocks, but within a conversion time, the DONE bit is set within one ADC_clock and a new conversion is started. 	ARM7				 Do not write to ADCR until the conversion is complete. 		3.7 ADC.6: Writing to ADCR while conversion in progress 			NXP
LPC2119	 The SPI interrupt flag is set by the SPI interface to generate an interrupt. It is cleared by writing a 1 to this bit.  A write to any register associated with the SPI peripheral will clear the SPI interrupt register. 	ARM7				 Avoid writing to SPI registers while transmissions are in progress or while SPI interrupts are pending. ES_LPC2109_19_29_00 . Â©   Rev. 3 â 1 April 2011 8 of 25  ES_LPC21x9; LPC21x9/00  LPC21x9; LPC21x9/00 		3.8 SPI.1: Unintentional clearing of SPI interrupt flag 			NXP
LPC2119	 In slave mode, the SPI can set the clock phase (CPHA) to 0 or 1.  Consider the following conditions: 1. SPI is configured as a slave (with CPHA=0). 2. SPI is running at a low frequency. In slave mode, the SPIF (SPI Transfer Complete Flag) bit is set on the last sampling edge of SCK. If CPHA is set to 0 then the last sampling edge of SCK would be the rising edge. Under the above conditions, if the SPI Data Register (SPDR) is written to less than a half SCLK cycle after the SPIF bit is set (this would happen if the SPI frequency is low) then the SPDR will shift data one clock early for the upcoming transfers. Lowering the SPI frequency would increase the likelihood of the SPDR write happening in the first half SCK cycle of the last sampling clock. 	ARM7				 There are two possible workarounds: 1. Use CPHA=1. 2. If the data is shifted incorrectly when CPHA is set to 0 then delaying the write to SPDR after the half SCK cycle of the last sampling clock would resolve this issue. 		3.9 SPI.2: Incorrect shifting of data in slave mode at lower frequencies 			NXP
LPC2119	 The VPBDIV register controls the rate of the VPB clock in relation to the processor clock. EXTPOLAR and EXTMODE determine the operating parameters of the external interrupts.  A write to either the external interrupt polarity register (EXTPOLAR) or the external interrupt mode register (EXTMODE) will corrupt the VPBDIV register. A read of either EXTPOLAR or EXTMODE will be corrupted BY the VPBDIV register. If VPBDIV is â1â or â2â prior to any write to EXTPOLAR or EXTMODE, the CPU will hang up on the write to EXTPOLAR or EXTMODE. 	ARM7				 If VPBDIV is non-zero, write all zeroes to VPBDIV before reading or writing EXTMODE or EXTPOLAR, then write the proper value back to VPBDIV. In most applications this is a known and fixed value, but if there is a possibility of dynamic changes in VPBDIV, software will need to read VPBDIV, write zero to VPBDIV, read or write EXTMODE and/or EXTPOLAR, and then rewrite the value previously read from VPBDIV. ES_LPC2109_19_29_00 . Â©   Rev. 3 â 1 April 2011 9 of 25  ES_LPC21x9; LPC21x9/00  LPC21x9; LPC21x9/00 		3.10 EXTINT.1: Corruption of VPBDIV via EXTPOLAR or EXTMODE 			NXP
LPC2119	 EXTPOLAR and EXTMODE determine the operating parameters of the external interrupts.  As an illustration, trying to set EXTMODE to 0x1 or 0xd would result in EXTMODE to be set to 0x0 instead. 	ARM7				 This problem is related to EXTINT.1 and hence the same workaround applies with an additional step. The steps involved in the configuration of the EXTMODE and/or EXTPOLAR would be as follows: 1. Write 0x0 to VPBDIV 2. Write the desired value to EXTMODE or EXTPOLAR register 3. Write the same value to VPBDIV (additional step) 4. Restore the VPBDIV to the previously saved value or simply write to the register again with the desired value. Code sample for setting EXTMODE and EXTPOLAR to 0x1: VPBDIV = 0x0; /* EXTMODE */ EXTMODE = 0x1; VPBDIV = 0x1; VPBDIV = 0x0; /* EXTPOLAR */ EXTPOLAR = 0x1; VPBDIV = 0x1; VPBDIV = 0x0; /* Setting VPBDIV */ Note: While testing this in a debugger environment, please donât single-step through these steps. A breakpoint could be placed after Step 4 and you would see the EXTMODE and EXTPOLAR registers reflecting the correct values. 		3.11 EXTINT.2: Incorrect setting of EXTMODE and/or EXTPOLAR register while trying to set them to desired value 			NXP
LPC2119	 P0.21 and P0.19 may be configured as capture inputs via the PINSEL register.  When PINSEL(11:10) is set to â11â P0.21 is not internally connected as capture 1.3 	ARM7				 To use P0.21 as capture 1.3, PINSEL(7:6) must also be set to â11â which means that P0.19 must be selected as capture input 1.2. ES_LPC2109_19_29_00 . Â©   Rev. 3 â 1 April 2011 10 of 25  ES_LPC21x9; LPC21x9/00  LPC21x9; LPC21x9/00 		3.12 CAP.1: Problem when selecting P0.21 as a capture 1.3 input (timer1) 			NXP
LPC2119	 The Peripheral Bus Divider (VPBDIV) divides the processor clock (CCLK) by one, two, or four. This is the clock that is provided to the peripheral bus.  Reading the VPBDIV register may return an incorrect value. 	ARM7				 Performing two consecutive reads of the VPBDIV assures that the correct value is returned. 		3.13 VPBDIV.1: Incorrect read of VPBDIV 			NXP
LPC2119	 If the processor is in Thumb state and executing the code sequence STR, STMIA or PUSH followed by a PC relative load, and the STR, STMIA or PUSH is aborted, the PC is saved to the abort link register.  In this situation the PC is saved to the abort link register in word resolution, instead of half-word resolution. Conditions: The processor must be in Thumb state, and the following sequence must occur: <any instruction> <STR, STMIA, PUSH> <---- data abort on this instruction LDR rn, [pc,#offset] In this case the PC is saved to the link register R14_abt in only word resolution, not half-word resolution. The effect is that the link register holds an address that could be #2 less than it should be, so any abort handler could return to one instruction earlier than intended. 	ARM7				 In a system that does not use Thumb state, there will be no problem. In a system that uses Thumb state but does not use data aborts, or does not try to use data aborts in a recoverable manner, there will be no problem. Otherwise the workaround is to ensure that a STR, STMIA or PUSH cannot precede a PC-relative load. One method for this is to add a NOP before any PC-relative load instruction. However this would have to be done manually. ES_LPC2109_19_29_00 . Â©   Rev. 3 â 1 April 2011 11 of 25  ES_LPC21x9; LPC21x9/00  LPC21x9; LPC21x9/00 		3.14 Core.1: Incorrect update of the Abort Link register in Thumb state 			NXP
LPC2119	 The Timers may be configured so that events such as Match and Capture, cause interrupts. Bits in the Interrupt Register (IR) indicate the source of the interrupt, whether from Capture or Match.  If more than one interrupt for multiple Match events using the same Timer are enabled, it is possible that one of the match interrupts may not be recognized. If this occurs no more interrupts from that specific match register will be recognized. This could happen in a scenario where the match events are very close to each other. This issue also affects the Capture functionality. Specific details: Suppose that two match events are very close to each other (Say Match0 and Match1). Also assume that the Match0 event occurs first. When the Match0 interrupt occurs the 0th bit of the Interrupt Register will be set. To exit the Interrupt Service Routine of Match0, this bit has to be cleared in the Interrupt Register. The clearing of this bit might be done by using the following statement: T0_IR = 0x1; It is possible that software will be writing a 1 to bit 0 of the Interrupt Register while a Match1 event occurs, meaning that hardware needs to set the bit 1 of the Interrupt Register. In this case, since hardware is accessing the register at the same time as software, bit 1 for Match1 never gets set, causing the interrupt to be missed. In summary, while software is writing to the Interrupt Register, any Match or Capture event (which are configured to interrupt the core) occurring at the same time may result in the subsequent interrupt not being recognized. Similarly for the Capture event, if a capture event occurs while a Match event is being is serviced then the Capture event might be missed if the software and hardware accesses coincide. Affected features: 1. Interrupt on Match for Timer0/1. 2. Interrupt on Capture for Timer0/1. 3. These same features will be affected when using PWM. ES_LPC2109_19_29_00 . Â©   Rev. 3 â 1 April 2011 12 of 25  ES_LPC21x9; LPC21x9/00  LPC21x9; LPC21x9/00 	ARM7				 There is no clear workaround for this problem but some of the below mentioned solutions could work with some applications. Possible work-aroundâs for Match functionality: 1. If the application only needs two Match registers then distribute them between Timer 0 and Timer 1 to avoid this problem. 2. Stop the timer before accessing the Interrupt register for clearing the interrupt and then start timer again after the access is completed. 3. Polling for interrupt: Supposing that there are two Match events (Match X and Match Y). At the end of the Interrupt Service Routine (ISR) for Match X, compare the Timer Counter value with the Match Register Y value. If the Timer Counter value is more than the Match Register Y value then it is possible that this event might have been missed. In this case jump to the ISR directly and service Match event Y. Possible workarounds for Capture functionality: 1. Try to spread the capture events between both timers if there are two capture events. If the application also has a match event then one of the capture events may suffer. 2. Polling for Capture: At the end of a Match interrupt ISR or Capture event ISR compare the previous Capture value with the current Capture value. If the Capture value has changed then the Capture event might have been missed. In this case, jump to the ISR directly and service the Capture event. 		3.15 TIMER.1: Missed Interrupt Potential 			NXP
LPC2119		ARM7						3.16 PWM.1: Missed Interrupt Potential for the Match functionality. The description is the same as above.			NXP
LPC2119	 Timer0 has four external match outputs corresponding to match registers with various capabilities. Match 0.0 can be configured as an alternate function on P0.3 and P0.22. Match 0.1 can be configured as an alternate function on Port 0.5 and P0.27. The alternate functions can be configured by using the respective PINSELx register.  Match 0.0 should have been only connected to P0.3 and P0.22 but it is also connected to P0.5. Match 0.1 is only connected to P0.27. Hence if the application configures the External Match alternate function on both P0.3 (Match 0.0) and P0.5 (Match 0.1) then the Match 0.0 output can be seen on two port pins, namely P0.3 and P0.5. 	ARM7				 Only P0.27 can be used for Match 0.1. ES_LPC2109_19_29_00 . Â©   Rev. 3 â 1 April 2011 13 of 25  ES_LPC21x9; LPC21x9/00  LPC21x9; LPC21x9/00 		3.17 Timer0.1: Match 0.1 output cannot be seen on port pin P0.5 if configured as an alternate function. 			NXP
LPC2119	 Reading the contents of the IIR,LSR and MSR registers will clear certain bits in the register. 1. Reading the IIR should clear the THRE status if THRE is the highest priority pending interrupt (Only affects UART1). 2. Reading LSR should clear the OE/PE/FE/BI bits (affects both UART0 and UART1). 3. Reading MSR should clear the Delta DCD/Trailing Edge RI/Delta DSR/Delta CTS bits (Only affects UART1).  If hardware is setting one of these above bits while the software is reading the contents of the register the reading process clears all bits in the register including the bit that got set by hardware. The software reads the old value though and the bit that got set by hardware is lost. Specific details: Suppose IIR has a modem status interrupt while the other interrupts are inactive and software reads the IIR value (polling) while hardware sets the THRE interrupt then software will read the Modem Interrupt value while the THRE interrupt is cleared i.e the THRE interrupt is lost. Suppose the LSR is all zeros and software is reading the register while hardware is generating a parity error then the parity error bit is cleared while the software reads the old value (all zeros) i.e. the parity error is lost. Suppose MSR is all zeros and software is polling the value of the register while the value of CTS is changing then the change in CTS value should result in the Delta CTS bit getting set. Instead software will read all zeros and the Delta CTS bit in the MSR register will be cleared i.e. the Delta CTS status is lost. 	ARM7				 IIR reading: The IIR bug can be worked around by disabling the modem status interrupt effectively making THRE the lowest priority interrupt. The work-around does not work in software interrupt polling mode. Modem status has to be handled by software polling MSR. Now there are two cases: 1. A THRE interrupt is pending, software responds to the interrupt by reading the IIR while another, higher priority interrupt is set (e.g. RDA). In this case software will read the THRE status although the status will not be cleared where it should have been. After handling the THRE and RDA interrupt another dummy THRE interrupt may occur, unless in the meantime software has filled THR. This is considered an error although not fatal. ES_LPC2109_19_29_00 . Â©   Rev. 3 â 1 April 2011 14 of 25  ES_LPC21x9; LPC21x9/00  LPC21x9; LPC21x9/00 2. A high priority interrupt is pending, software responds to the interrupt by reading the IIR register while a THRE interrupt is set. In this case, software will read the higher priority interrupt and the THRE interrupt will be handled later. This behavior is as expected. LSR reading: A work-around for this problem is to service the OE/PE/FE/BI condition before another character is received which will trigger an LSR update. So basically, service the interrupt in one-character time. MSR reading: The MSR bug can be worked-around by not using the Delta DCD/Trailing Edge RI/Delta DSR/Delta CTS bits in the MSR but instead use the DCD/TRI/DSR/CTS bits in the same register. To prevent, a transition from being missed software should poll the registerâs value at a sufficiently high rate. 		3.18 UART.1: Coinciding VPB read and hardware register update 			NXP
LPC2119	 The CAN interface may be configured such that activity on the CAN bus lines will wake the part from power-down mode.  CAN bus activity fails to wake the part from power-down. 	ARM7				 CAN bus pins may be tied to external interrupt inputs which will wake the part from power-down. 		3.19 CAN.1: CAN bus activity does not wake from power-down mode 			NXP
LPC2119	 The CAN Controller will enter sleep mode if the SM bit in the CAN Mode register is set to 1, no CAN interrupt is pending, and there is no activity on the CAN bus. The CAN Controller wakes up (and sets the WUI bit in the CAN Interrupt register if the WUIE bit in the CAN Interrupt Enable register is set to 1), in response to a dominant bit on the CAN bus or software clearing the SM bit in the CAN Mode register.  Clearing the SM bit does not cause the CAN module to wakeup from CAN sleep mode. 	ARM7				 None, the SM bit cannot be used as a source of CAN wakeup. ES_LPC2109_19_29_00 . Â©   Rev. 3 â 1 April 2011 15 of 25  ES_LPC21x9; LPC21x9/00  LPC21x9; LPC21x9/00 		3.20 CAN.2: No wake-up from CAN sleep mode using SM bit 			NXP
LPC2119	 In FullCAN mode, CAN messages are automatically stored in a special section of the LUT RAM. In the Acceptance filter Look-Up Table, CAN message identifiers can be enabled/disabled by clearing/setting the Message Disable bit.  When the CPU accesses the LUT while a message is being received, the Acceptance Filter may not work correctly and messages can be lost. 	ARM7				 1. The CPU should not access the LUT during operation. Since the FullCAN mode would cause the CPU to access the LUT during operation, the problem does not occur when the FullCAN mode is not used. 2. Do not enable/disable the Message Identifiers in the LUT while the CAN module is enabled. 		3.21 CAN.3: Shared access for Identifier Look-Up Table (LUT) 			NXP
LPC2119	 The CAN block provides three transmit buffers. Each of them has a length of four 32-bit words and is able to store one complete CAN message.  The Triple Transmit Buffer function cannot be used. 	ARM7				 Use any one Transmit buffer only (Use either Transmit Buffer 1, Transmit Buffer 2 or Transmit Buffer 3 exclusively). The buffer you decided to use should be loaded only when there is no pending transmission. 		3.22 CAN.4: Triple Transmit Buffer function not working correctly 			NXP
LPC2119	 In Reset Mode, the CAN operations are disabled and writable registers can be written. If an Abort Transmission command is issued then a pending transmission request is cancelled if not already in progress.  Normal operation cannot be resumed after reset or abort transmission without using one of the workarounds below. 	ARM7				 Two possible workarounds are possible: ES_LPC2109_19_29_00 . Â©   Rev. 3 â 1 April 2011 16 of 25  ES_LPC21x9; LPC21x9/00  LPC21x9; LPC21x9/00 1. After exiting the Reset Mode, before sending the first actual message, a dummy message should be transmitted with identifier 0x0 (Standard Frame Format). This message should be transmitted by setting both the Self Reception Request bit and the Abort Transmission bit in the Command register simultaneously. (Note: CAN Identifier 0x0 should not be used in the application) 2. If CAN Identifier 0x0 is used by the application then the above workaround cannot be used. This second workaround is not applicable to CAN Controller 1 since this solution needs the TDx pin to be shared with a port pin. Before normal operation is started: 1. Initialize the CAN Controller and Acceptance Filter. 2. Load CAN Transmit Buffer with a CAN message. Make sure that the Acceptance filter is configured to receive this message. 3. Switch P0.xx/TD pin to Port function by configuring the appropriate bits in the PINSELx register. 4. Start transmission of a message with the Single Shot Transmission and Self Reception Command (Command=0x12). 5. Wait until message is received (configure Receive Interrupt). 6. Switch P0.xx/TD pin function back to TD function. Continue with normal operation. Please note that the Transmit Buffer used for initial message must be used for all further CAN transmissions (see CAN.4). 		3.23 CAN.5: Handling Reset Mode and Abort Transmission 			NXP
LPC2119	 When a syntax error in the LUT is encountered, the LUT address of the incorrect line is reported in the LUTerrAd register  If there is a syntax error then the address line is not reported and the acceptance filtering is disabled. 	ARM7				 Add two disabled dummy message identifiers to the last possible address of the 2K LUT RAM (address 0xE003 87FC). Also, if an explicit Standard Frame Format section is enabled, add two disabled dummy message identifiers at the end of that section. 		3.24 CAN.6: Look-up Table Error Address (LUTerrAd) register does not function. 			NXP
LPC2119	 The CAN module can lose arbitration to another CAN node during an attempt to transmit a CAN message. The message of the CAN node the arbitration was lost to is supposed to be received correctly by the CAN module.  ES_LPC2109_19_29_00 . Â©   Rev. 3 â 1 April 2011 17 of 25  ES_LPC21x9; LPC21x9/00  LPC21x9; LPC21x9/00 Messages might not be received correctly if during a CAN Transmission the CAN bus arbitration is lost to another CAN node. 	ARM7				 Use the Self Reception Request command instead of the Transmission Request command. However, it has to be taken into account that now all transmitted messages may be received if not prevented by appropriate Acceptance Filter settings. (Donât set up Acceptance Filter Message Identifiers for the messages you are transmitting yourself.) ES_LPC2109_19_29_00 . Â©   Rev. 3 â 1 April 2011 18 of 25  ES_LPC21x9; LPC21x9/00  LPC21x9; LPC21x9/00 		3.25 CAN.7: Receiving messages while arbitration is lost. 			NXP
LPC2119		ARM7						3.26 Reset.1: Device does not power up correctly under certain internal conditions Problem: If certain rare chip-internal conditions are met, the device will not start up correctly when executing a power-on reset. The crystal oscillator will be running but the device will not execute code. Work-around: Apply a second (warm) reset pulse (without power-on cycle). The minimum time requirement between the first (unsuccessful) reset and the second reset is 4105 external oscillator clock cycles, which means that the assertion of the second reset should occur 4105 cycles or more after the deassertion of the first reset. For example, at 10 MHz, this is equal to 411 ï­s; at 20 MHz, this is equal to 206 ï­s. This can be achieved by using an external watchdog timer or by any other circuitry in the application that is able to assert a second reset pulse. The root cause for this problem has been identified and will be fixed from Revision B of this device onwards. This problem will also be fixed in the LPC21x9/00 version of this device which will have a dedicated order number (LPC21x9FBD64/00). ES_LPC2109_19_29_00 . Â©   Rev. 3 â 1 April 2011 19 of 25  ES_LPC21x9; LPC21x9/00  LPC21x9; LPC21x9/00			NXP
LPC2119	 In software-controlled mode (BURST bit is 0), the 10-bit ADC can start conversion by using the following options in the A/D Control Register: Fig 1. A/D control register options  The external start conversion feature, ADCR:START = 0x2 or 0x3, may not work reliably and ADC external trigger edges on P0.16 or P0.22 may be missed. The occurrence of this problem is peripheral clock (pclk) dependent. The probability of error (missing a ADC trigger from GPIO) is estimated as follows: â¢ For PCLK_ADC = 60 MHz, probability error = 12 % â¢ For PCLK_ADC = 50 MHz, probability error = 6 % â¢ For PCLK_ADC = 12 MHz, probability error = 1.5 % The probability of error is not affected by the frequency of ADC start conversion edges. 	ARM7				 In software-controlled mode (BURST bit is 0), the START conversion options (bits 26:24 set to 0x1 or 0x4 or 0x5 or 0x6 or 0x7) can be used. The user can also start a conversion by connecting an external trigger signal to a capture input pin (CAPx) from a Timer peripheral to generate an interrupt. The timer interrupt routine can then start the ADC conversion by setting the START bits (26:24) to 0x1. The trigger can also be generated from a timer match register. ES_LPC2109_19_29_00 . Â©   Rev. 3 â 1 April 2011 20 of 25  ES_LPC21x9; LPC21x9/00  LPC21x9; LPC21x9/00 4. AC/DC deviations detail 		3.27 ADC.7: External sync inputs not operational 			NXP
LPC2119	 The specified, minimum, value for VIH is 2.0 V.  Any pin associated with either an external interrupt input or an analog to digital converter (ADC) input has a VIH of 2.4 V, not 2.0 V. The pins that are affected are the ones that can be configured as either an ADC input or and external interrupt input, not just the ones that are configured as such. 	ARM7				 Make sure that high logic levels are at least 2.4 V at these pins. 		4.1 VIH.1: Incompatibility of actual VIH levels as compared to those specified 			NXP
LPC2119	 V3 is the power supply voltage for the I/O ports. External interrupt pins are general purpose interrupt pins which are level and edge sensitive. They can optionally wake up the device from power down mode. The ADC block can produce 10-bit samples with conversion time as low as 2.44 us.  If the external interrupt and/or ADC pins are pulled higher than 1.8 V then it will lead to increased current consumption from V3. If V3 is 3.0 V and V1.8 is 1.8 V then the leakage current will increase to a typical number of 200 uA (per pin). Note: The ADC pins wonât contribute to the leakage if they are not configured as digital inputs using the PINSELx register. External interrupt pins will contribute to the leakage irrespective of their pin configuration. 	ARM9				 None.		4.2 V3.1: Leakage current on V3 due to External Interrupt and/or Analog to Digital Converter (ADC) pins. 			NXP
LPC2470	 In software-controlled mode (BURST bit is 0), the 10-bit ADC can start conversion by using the following options in the A/D Control Register: Fig 1. A/D control register options  The external start conversion feature, AD0CR:START = 0x2 or 0x3, may not work reliably and ADC external trigger edges on P2.10 or P1.27 may be missed. The occurrence of this problem is peripheral clock (pclk) dependent. The probability of error (missing a ADC trigger from GPIO) is estimated as follows: â¢ For PCLK_ADC = 72 MHz, probability error = 12 % â¢ For PCLK_ADC = 50 MHz, probability error = 6 % â¢ For PCLK_ADC = 12 MHz, probability error = 1.5 % The probability of error is not affected by the frequency of ADC start conversion edges. 	ARM7				 In software-controlled mode (BURST bit is 0), the START conversion options (bits 26:24 set to 0x1 or 0x4 or 0x5 or 0x6 or 0x7) can be used. The user can also start a conversion by connecting an external trigger signal to a capture input pin (CAPx) from a Timer peripheral to generate an interrupt. The timer interrupt routine can then start the ADC conversion by setting the START bits (26:24) to 0x1. The trigger can also be generated from a timer match register. ES_LPC2470_78 . Â© NXP B.V. 2012. All rights reserved.  Rev. 8.1 â 1 July 2012 5 of 13  ES_LPC2470_78  LPC2470/78 		3.1 ADC.1: External sync inputs not operational 			NXP
LPC2470	 If the processor is in Thumb state and executing the code sequence STR, STMIA or PUSH followed by a PC relative load, and the STR, STMIA or PUSH is aborted, the PC is saved to the abort link register.  In this situation the PC is saved to the abort link register in word resolution, instead of half-word resolution. Conditions: The processor must be in Thumb state, and the following sequence must occur: <any instruction> <STR, STMIA, PUSH> <---- data abort on this instruction LDR rn, [pc,#offset] In this case the PC is saved to the link register R14_abt in only word resolution, not half-word resolution. The effect is that the link register holds an address that could be #2 less than it should be, so any abort handler could return to one instruction earlier than intended. 	ARM7				 In a system that does not use Thumb state, there will be no problem. In a system that uses Thumb state but does not use data aborts, or does not try to use data aborts in a recoverable manner, there will be no problem. Otherwise the workaround is to ensure that a STR, STMIA or PUSH cannot precede a PC-relative load. One method for this is to add a NOP before any PC-relative load instruction. However this would have to be done manually. ES_LPC2470_78 . Â© NXP B.V. 2012. All rights reserved.  Rev. 8.1 â 1 July 2012 6 of 13  ES_LPC2470_78  LPC2470/78 		3.2 Core.1: Incorrect update of the Abort Link register in Thumb state 			NXP
LPC2470	 The transmit consume index register defines the descriptor that is going to be transmitted next by the hardware transmit process. After a frame has been transmitted hardware increments the index, wrapping the value to 0 once the value of TxDescriptorNumber has been reached. If the TxConsumeIndex equals TxProduceIndex the descriptor array is empty and the transmit channel will stop transmitting until software produces new descriptors.  The TxConsumeIndex register is not updated correctly (from 0 to 1) after the first frame is sent. After the next frame sent, the TxConsumeIndex register is updated by two (from 0 to 2). This only happens the very first time, so subsequent updates are correct (even those from 0 to 1, after wrapping the value to 0 once the value of TxDescriptorNumber has been reached) 	ARM7				 Software can correct this situation in many ways; for example, sending a dummy frame after initialization. ES_LPC2470_78 . Â© NXP B.V. 2012. All rights reserved.  Rev. 8.1 â 1 July 2012 7 of 13  ES_LPC2470_78  LPC2470/78 		3.3 Ethernet.1: Ethernet TxConsumeIndex register does not update correctly after the first frame is sent 			NXP
LPC2470	 Full-/low-speed signaling uses bit stuffing throughout the packet without exception. If the receiver sees seven consecutive ones anywhere in the packet, then a bit stuffing error has occurred and the packet should be ignored. The time interval just before an EOP is a special case. The last data bit before the EOP can become stretched by hub switching skews. This is known as dribble and can lead to a situation where dribble introduces a sixth bit that does not require a bit stuff. Therefore, the receiver must accept a packet for which there are up to six full bit times at the port with no transitions prior to the EOP.  The USB host controller will hang indefinitely if it sees a dribble bit on the USB bus. It will hang the first time a dribble bit is seen. Once it is in this state there is no recovery other than a hard chip reset. This problem has no effect on the USB device controller. 	ARM7				 None. ES_LPC2470_78 . Â© NXP B.V. 2012. All rights reserved.  Rev. 8.1 â 1 July 2012 8 of 13  ES_LPC2470_78  LPC2470/78 		3.4 USB.1: USB host controller hangs on a dribble bit 			NXP
LPC2470	 The device has a VBAT pin which provides power only to the Real Time Clock (RTC) and Battery RAM. VBAT can be connected to a battery or the same supply used by rest of the device (VDD(3V3) pin, VDD(DCDC)(3V3) pin). The input voltage range on the VBAT pin is 2.0 V minimum to 3.6 V maximum for temperature ï­40 ï°C to +85 ï°C. Normally, if the RTC and the Battery RAM are not used, the VBAT pin can be left floating.  If the VBAT pin is left floating, the internal reset signal within the RTC domain may get corrupted and as a result, prevents the device from starting-up. 	ARM7				 The VBAT should be connected to a battery or the same supply used by rest of the device (VDD(3V3) pin, VDD(DCDC)(3V3) pin). ES_LPC2470_78 . Â© NXP B.V. 2012. All rights reserved.  Rev. 8.1 â 1 July 2012 9 of 13  ES_LPC2470_78  LPC2470/78 4. AC/DC deviations detail 		3.5 VBAT.1: The VBAT pin cannot be left floating 			NXP
LPC2470	 The device has a 4 MHz internal RC oscillator (IRC) which can be optionally used as the clock source for the Watch Dog Timer (WDT), and/or as the clock that drives the PLL and subsequently the CPU. The IRC frequency spec is 4 MHz +/ï­ 1 % accuracy over the entire voltage and temperature range. During In-System Programming (ISP), the auto-baud routine is expecting the IRC frequency to be 4 MHz +/ï­ 1 % and is used to synchronize with the host via serial port 0.  On the LPC247X Rev C device only, the accuracy of internal RC oscillator (IRC) frequency meets 4 MHz +/ï­ 1 % specification only at room temperature however, at extreme temperatures, the accuracy of internal RC oscillator (IRC) frequency may be 4 MHz +/ï­ 10 %. As a result, at extreme temperatures, this may affect the auto-baud routine's ability to synchronize with the host via serial port 0 during In-System Programming (ISP) at higher baud rates. 	ARM9				 None ES_LPC2470_78 . Â© NXP B.V. 2012. All rights reserved.  Rev. 8.1 â 1 July 2012 10 of 13  ES_LPC2470_78  LPC2470/78 4.2 IRC.2: Accuracy of the Internal RC Oscillator (IRC) frequency for devices only with date codes 0949 and before are outside of the 4 MHz +/ï­ 1 % specification only at temperatures between ï­20 ï°C and ï­40 ï°C Introduction: The device has a 4 MHz internal RC oscillator (IRC) which can be optionally used as the clock source for the Watch Dog Timer (WDT), and/or as the clock that drives the PLL and subsequently the CPU. The IRC frequency spec is 4 MHz +/ï­ 1 % accuracy over the entire voltage and temperature range. During In-System Programming (ISP), the auto-baud routine is expecting the IRC frequency to be 4 MHz +/ï­ 1 % and is used to synchronize with the host via serial port 0. Problem: On the LPC247X Rev D device (only with date codes 0949 and before), the accuracy of internal RC oscillator (IRC) frequency does not meet the 4 MHz +/ï­ 1 % specification for temperatures between ï­20 ï°C and ï­40 ï°C and the accuracy of internal RC oscillator (IRC) frequency is 4 MHz +/ï­ 5 % instead. As a result, only at these temperatures, this may affect the auto-baud routine's ability to synchronize with the host via serial port 0 during In-System Programming (ISP) at higher baud rates. For temperatures above ï­20 ï°C, the accuracy of internal RC oscillator (IRC) frequency meets the 4 MHz +/ï­ 1 % specification. Work-around: None 5. Errata notes detail 5.1 Note.1 On each of the following port pins P0.23, P0.24, P0.25, P0.26, P1.30, P1.31, P0.12, and P0.13 (when configured as general purpose input pin (s)), leakage current increases when the input voltage is Vi ï³ VDD I/O + 0.5 V. Care must be taken to limit the current to less than 4 mA by using a series limiting resistor. 5.2 Note.2 On the LPC2470/78 Rev D, design changes to the Memory Accelerator Module were made to enhance timing and general performance. Design changes are intended to enhance performance in general and will result in minor differences in the code execution timing between the previous device revisions and rev D. Actual performance impact is code dependent, some code sequences may speed up while other code sequences may slow down between the previous device revisions and rev D. This might be observed when using software delays and in such cases, a hardware timer should be used to generate a delay instead of a software delay. ES_LPC2470_78 . Â© NXP B.V. 2012. All rights reserved.  Rev. 8.1 â 1 July 2012 11 of 13		4.1 IRC.1: Accuracy of the Internal RC oscillator (IRC) frequency may be outside of the 4 MHz +/ï­ 1 % specification only at extreme temperatures 			NXP
LPC2109	 If the processor is in Thumb state and executing the code sequence STR, STMIA or PUSH followed by a PC relative load, and the STR, STMIA or PUSH is aborted, the PC is saved to the abort link register.  In this situation the PC is saved to the abort link register in word resolution, instead of half-word resolution. Conditions: The processor must be in Thumb state, and the following sequence must occur: <any instruction> <STR, STMIA, PUSH> <---- data abort on this instruction LDR rn, [pc,#offset] In this case the PC is saved to the link register R14_abt in only word resolution, not half-word resolution. The effect is that the link register holds an address that could be #2 less than it should be, so any abort handler could return to one instruction earlier than intended. 	ARM7				 In a system that does not use Thumb state, there will be no problem. In a system that uses Thumb state but does not use data aborts, or does not try to use data aborts in a recoverable manner, there will be no problem. Otherwise the workaround is to ensure that a STR, STMIA or PUSH cannot precede a PC-relative load. One method for this is to add a NOP before any PC-relative load instruction. However this would have to be done manually. ES_LPC21X9/01 . Â©   Rev. 3 â 1 October 2011 4 of 9  ES_LPC21x9/01  LPC2109/01, LPC2119/01, LPC2129/01 		3.1 CORE.1: Incorrect update of the Abort Link register in Thumb state 			NXP
LPC2109	 Each CAN controller provides a double Receive Buffer (RBX) per CAN channel to store incoming messages until they are processed by the CPU. Software task should read and save received data as soon as a message reception is signaled. In cases where both receive buffers are filled and the contents are not read before the third message comes in, a CAN Data Overrun situation is signaled. This condition is signaled via the Status register and the Data Overrun Interrupt (if enabled).  In a Data Overrun condition, the CAN controller is locked from further message reception. 	ARM7				 1. Recovering from this situation is only possible with a soft reset to the CAN controller. 2. If software cannot read all messages in time before a third message comes in, it is recommend to change the acceptance filtering by adding further acceptance filter group(s) for messages, which are normally rejected. With this approach, the third incoming message is accepted and the Data Overrun condition is avoided. These additional messages are received with the corresponding group index number can be easily identified and rejected by software. ES_LPC21X9/01 . Â©   Rev. 3 â 1 October 2011 5 of 9  ES_LPC21x9/01  LPC2109/01, LPC2119/01, LPC2129/01 		3.2 CAN.1: Data Overrun condition can lock the CAN controller 			NXP
LPC2109	 In software-controlled mode (BURST bit is 0), the 10-bit ADC can start conversion by using the following options in the A/D Control Register: Fig 1. A/D control register options  The external start conversion feature, ADCR:START = 0x2 or 0x3, may not work reliably and ADC external trigger edges on P0.16 or P0.22 may be missed. The occurrence of this problem is peripheral clock (pclk) dependent. The probability of error (missing a ADC trigger from GPIO) is estimated as follows: â¢ For PCLK_ADC = 60 MHz, probability error = 12 % â¢ For PCLK_ADC = 50 MHz, probability error = 6 % â¢ For PCLK_ADC = 12 MHz, probability error = 1.5 % The probability of error is not affected by the frequency of ADC start conversion edges. 	ARM9				 In software-controlled mode (BURST bit is 0), the START conversion options (bits 26:24 set to 0x1 or 0x4 or 0x5 or 0x6 or 0x7) can be used. The user can also start a conversion by connecting an external trigger signal to a capture input pin (CAPx) from a Timer peripheral to generate an interrupt. The timer interrupt routine can then start the ADC conversion by setting the START bits (26:24) to 0x1. The trigger can also be generated from a timer match register.		3.3 ADC.1: External sync inputs not operational 			NXP
LPC2131	 If the processor is in Thumb state and executing the code sequence STR, STMIA or PUSH followed by a PC relative load, and the STR, STMIA or PUSH is aborted, the PC is saved to the abort link register.  In this situation the PC is saved to the abort link register in word resolution, instead of half-word resolution. Conditions: The processor must be in Thumb state, and the following sequence must occur: <any instruction> <STR, STMIA, PUSH> <---- data abort on this instruction LDR rn, [pc,#offset] In this case the PC is saved to the link register R14_abt in only word resolution, not half-word resolution. The effect is that the link register holds an address that could be #2 less than it should be, so any abort handler could return to one instruction earlier than intended. 	ARM7				 In a system that does not use Thumb state, there will be no problem. In a system that uses Thumb state but does not use data aborts, or does not try to use data aborts in a recoverable manner, there will be no problem. Otherwise the workaround is to ensure that a STR, STMIA or PUSH cannot precede a PC-relative load. One method for this is to add a NOP before any PC-relative load instruction. However this would have to be done manually. ES_LPC2131_01 . Â© NXP B.V. 2012. All rights reserved.  Rev. 2.1 â 1 May 2012 5 of 13  ES_LPC2131/01  LPC2131/01 		3.1 Core.1: Incorrect update of the Abort Link register in Thumb state 			NXP
LPC2131	 Timer0 and Timer1 can be used in a counter mode. In this mode, the Timer Counter register can be incremented on rising, falling or both edges which occur on a selected CAP input pin. This counter mode can be combined with the match functionality to provide additional features. One of the features would be to reset the Timer Counter register on a match. The same would also apply for Timer1.  The Timer Counter reset does not trigger on the same incoming edge when the match takes place between the corresponding Match register and the Timer Counter register. The Timer Counter register will be reset only on the next incoming edge. Workaround: There are two possible workarounds: 1. Combine the Timer Counter reset feature with the âinterrupt on matchâ feature. The interrupt on match occurs on the correct incoming edge. In the ISR, the Timer Counter register can also be reset. This solution can only work if no edges are expected during the duration of the ISR. 2. In this solution, the âinterrupt on matchâ feature is not used. Instead, the following specific initialization can achieve the counting operation: a. Initialize the Timer Counter register to 0xFFFFFFFF. b. If ânâ edges have to be counted then initialize the corresponding Match register with value n-1. For instance, if 2 edges need to be counted then load the Match register with value 1. More details on the above example: 1. Edge 1 - Timer overflows and Timer Counter (TC) is set to 0. 2. Edge 2 - TC = 1. Match takes place. 3. Edge 3 - TC = 0. 4. Edge 4 - TC = 1. Match takes place. 5. Edge 5 - TC = 0. ES_LPC2131_01 . Â© NXP B.V. 2012. All rights reserved.  Rev. 2.1 â 1 May 2012 6 of 13  ES_LPC2131/01  LPC2131/01	ARM7						3.2 Timer.1: In counter mode, the Timer Counter reset does not occur on the correct incoming edge 			NXP
LPC2131	 The SSP is a Synchronous Serial Port (SSP) controller capable of operation on a SPI, 4-wire SSI or a Microwire bus. The SSP can operate at a maximum speed of 30 MHz and is referred to as SPI1 in the device documentation.  At high SSP frequencies, it is found that the first four pulses are shorter than the subsequent pulses. At 30 MHz, the first pulse can be expected to be approximately 10 ns shorter and the second pulse around 5 ns shorter. The remaining two pulses are around 2 ns shorter than subsequent pulses. At 25 MHz, the length of the first pulse would be around 7 ns shorter. The subsequent three pulses are around 2 ns shorter. At 20 MHz only the first pulse is affected and it is around 2 ns shorter. All subsequent pulses are fine. The deviation of the initial data bits/clocks will decrease as the SSP frequency decreases. 	ARM7				 None. ES_LPC2131_01 . Â© NXP B.V. 2012. All rights reserved.  Rev. 2.1 â 1 May 2012 7 of 13  ES_LPC2131/01  LPC2131/01 		3.3 SSP.1: Initial data bits/clocks of the SSP transmission are shorter than subsequent pulses at higher frequencies 			NXP
LPC2131	 The device operating voltage range is 3.0 V to 3.6 V and it is an internal DC/DC converter that provides 1.8 V to the ARM7 Core.  If during a power-on reset the voltage on Vdd takes longer than 200 ms to ramp from below 0.8 V to above 2.0 V, the chip-internal DC/DC converter might not start up correctly. If this happens, the crystal oscillator will not be running, resulting in no code execution. As an example, having a Vdd rise time of less than 10 V/s might trigger this problem. The same problem might occur during a supply voltage drop during which Vdd remains between 300 mV and 80 mV for more than 200 ms before going back to the specified Vdd level. As an example, having a residual battery voltage of less than 0.3 V but more than 0.08 V in a rechargeable battery application might trigger this problem when the charger providing the 3 V supply is being connected. 	ARM7				 Apply another power-on Reset during which Vdd rises from below 0.8 V to above 2.0 V in less than 200 ms. 		3.4 DC/DC.1: DC/DC converter start-up issue 			NXP
LPC2131	 The MAM block maximizes the performance of the ARM processor when it is running code in Flash memory. It includes three 128-bit buffers called the Prefetch Buffer, the Branch Trail Buffer and the data buffer. It can operate in 3 modes; Mode 0 (MAM off), Mode 1 (MAM partially enabled) and Mode 2 (MAM fully enabled).  Under certain conditions when the MAM is fully enabled (Mode 2) code execution from internal Flash can fail. The conditions under which the problem can occur is dependent on the code itself along with its positioning within the Flash memory. 	ARM7				 If the above problem is encountered then Mode 2 should not be used. Instead, partially enable the MAM using Mode 1. ES_LPC2131_01 . Â© NXP B.V. 2012. All rights reserved.  Rev. 2.1 â 1 May 2012 8 of 13  ES_LPC2131/01  LPC2131/01 		3.5 MAM.1: Under certain conditions in MAM Mode 2 code execution out of internal Flash can fail 			NXP
LPC2131	 The Watchdog timer can reset the microcontroller within a reasonable amount of time if it enters an erroneous state.  After writing 0xAA to WDFEED, any APB register access other than writing 0x55 to WDFEED may cause an immediate reset. 	ARM7				 Avoid APB accesses in the middle of the feed sequence. This implies that interrupts and the GPDMA should be disabled while feeding the Watchdog. ES_LPC2131_01 . Â© NXP B.V. 2012. All rights reserved.  Rev. 2.1 â 1 May 2012 9 of 13  ES_LPC2131/01  LPC2131/01 		3.6 WDT.1: Accessing non-Watchdog APB registers during the feed sequence causes a reset 			NXP
LPC2131	 In software-controlled mode (BURST bit is 0), the 10-bit ADCs can start conversion by using the following options in the A/D Control Register: Fig 1. A/D control register options  The external start conversion feature, ADxCR:START = 0x2 or 0x3, may not work reliably and ADC external trigger edges on P0.16 or P0.22 may be missed. The occurrence of this problem is peripheral clock (pclk) dependent. The probability of error (missing an ADC trigger from GPIO) is estimated as follows: â¢ For PCLK_ADC = 60 MHz, probability error = 12 % â¢ For PCLK_ADC = 50 MHz, probability error = 6 % â¢ For PCLK_ADC = 12 MHz, probability error = 1.5 % The probability of error is not affected by the frequency of ADC start conversion edges. 	ARM7				 In software-controlled mode (BURST bit is 0), the START conversion options (bits 26:24 set to 0x1 or 0x4 or 0x5 or 0x6 or 0x7) can be used. The user can also start a conversion by connecting an external trigger signal to a capture input pin (CAPx) from a Timer peripheral to generate an interrupt. The timer interrupt routine can then start the ADC conversion by setting the START bits (26:24) to 0x1. The trigger can also be generated from a timer match register. ES_LPC2131_01 . Â© NXP B.V. 2012. All rights reserved.  Rev. 2.1 â 1 May 2012 10 of 13  ES_LPC2131/01  LPC2131/01 4. AC/DC deviations detail 		3.7 ADC.1: External sync inputs not operational 			NXP
LPC2131	 The LPC2131/01 is rated for 2 kV ESD. The RTCX1 pin is the input pin for the RTC oscillator circuit.  The LPC2131/01 does not meet the required 2 kV ESD specified. 	ARM9				 Observe proper ESD handling precautions for the RTCX1 pin.		4.1 ESD.1: The device does not meet the 2 kV ESD requirements on the RTCX1 pin 			NXP
LPC2364	 The LPC2364/66/68 has a 10-bit ADC, which can be used to measure analog signals and convert the signals into a 10-bit digital result. There are eight A/D channels and each channel has its own individual A/D Data Register (ADDR0 to ADDR7). The A/D Data Register holds the result when an A/D conversion is complete, and also includes the flags that indicate when a conversion has been completed (DONE bit) and when a conversion overrun has occurred. The DONE bit is cleared when the respective A/D Data Register is read.  If a software read of ADDRx conflicts with the hardware setting of the DONE bit in the same register (once a conversion is completed) then the DONE bit gets cleared automatically, thereby clearing the indication that a conversion was completed. 	ARM7				 For software controlled mode or burst mode with only one channel selected, the DONE bit in the A/D Global Data Register (located at 0xE003 4004) can be used instead of the individual ADDRx result register with no impact on performance. For burst mode with multiple channels selected, the DONE bit together with the CHN field in the A/D Global Data Register can be used with some impact on throughput. ES_LPC2364_66_68 . Â© NXP B.V. 2012. All rights reserved.  Rev. 9.1 â 1 July 2012 5 of 20  ES_LPC2364_66_68  LPC2364/66/68 		3.1 ADC.1: ADDRx read conflicts with hardware setting of the DONE bit 			NXP
LPC2364	 In software-controlled mode (BURST bit is 0), the 10-bit ADC can start conversion by using the following options in the A/D Control Register: Fig 1. A/D control register options  The external start conversion feature, AD0CR:START = 0x2 or 0x3, may not work reliably and ADC external trigger edges on P2.10 or P1.27 may be missed. The occurrence of this problem is peripheral clock (pclk) dependent. The probability of error (missing a ADC trigger from GPIO) is estimated as follows: â¢ For PCLK_ADC = 72 MHz, probability error = 12 % â¢ For PCLK_ADC = 50 MHz, probability error = 6 % â¢ For PCLK_ADC = 12 MHz, probability error = 1.5 % The probability of error is not affected by the frequency of ADC start conversion edges. 	ARM7				 In software-controlled mode (BURST bit is 0), the START conversion options (bits 26:24 set to 0x1 or 0x4 or 0x5 or 0x6 or 0x7) can be used. The user can also start a conversion by connecting an external trigger signal to a capture input pin (CAPx) from a Timer peripheral to generate an interrupt. The timer interrupt routine can then start the ADC conversion by setting the START bits (26:24) to 0x1. The trigger can also be generated from a timer match register. ES_LPC2364_66_68 . Â© NXP B.V. 2012. All rights reserved.  Rev. 9.1 â 1 July 2012 6 of 20  ES_LPC2364_66_68  LPC2364/66/68 		3.2 ADC.2: External sync inputs not operational 			NXP
LPC2364	 Each CAN controller provides a double Receive Buffer (RBX) per CAN channel to store incoming messages until they are processed by the CPU. Software task should read and save received data as soon as a message reception is signaled. In cases where both receive buffers are filled and the contents are not read before the third message comes in, a CAN Data Overrun situation is signaled. This condition is signaled via the Status register and the Data Overrun Interrupt (if enabled).  If both receive buffers are full and a third message arrives which is rejected by the CAN Acceptance Filter, the CAN controller is locked from further message reception. 	ARM7				 1. Recovering from this situation is only possible with a soft reset to the CAN controller. 2. If software cannot read all messages in time before a third message comes in, it is recommend to change the acceptance filtering by adding further acceptance filter group(s) for messages which are normally rejected. With this approach, the third incoming message is accepted, and while it does cause a Data Overrun condition, the lockup condition is avoided. These additional messages are received with the corresponding group index number can be easily identified and rejected by software. ES_LPC2364_66_68 . Â© NXP B.V. 2012. All rights reserved.  Rev. 9.1 â 1 July 2012 7 of 20  ES_LPC2364_66_68  LPC2364/66/68 		3.3 CAN.1: Data Overrun condition can lock the CAN controller 			NXP
LPC2364	 If the processor is in Thumb state and executing the code sequence STR, STMIA or PUSH followed by a PC relative load, and the STR, STMIA or PUSH is aborted, the PC is saved to the abort link register.  In this situation the PC is saved to the abort link register in word resolution, instead of half-word resolution. Conditions: The processor must be in Thumb state, and the following sequence must occur: <any instruction> <STR, STMIA, PUSH> <---- data abort on this instruction LDR rn, [pc,#offset] In this case the PC is saved to the link register R14_abt in only word resolution, not half-word resolution. The effect is that the link register holds an address that could be #2 less than it should be, so any abort handler could return to one instruction earlier than intended. 	ARM7				 In a system that does not use Thumb state, there will be no problem. In a system that uses Thumb state but does not use data aborts, or does not try to use data aborts in a recoverable manner, there will be no problem. Otherwise the workaround is to ensure that a STR, STMIA or PUSH cannot precede a PC-relative load. One method for this is to add a NOP before any PC-relative load instruction. However this is would have to be done manually. ES_LPC2364_66_68 . Â© NXP B.V. 2012. All rights reserved.  Rev. 9.1 â 1 July 2012 8 of 20  ES_LPC2364_66_68  LPC2364/66/68 		3.4 Core.1: Incorrect update of the Abort Link register in Thumb state 			NXP
LPC2364	 Deep power-down mode is like Power-down mode, but the on-chip regulator that supplies power to internal logic is also shut off. This produces the lowest possible power consumption without actually removing power from the entire chip.  The power consumption in Deep power-down mode does not meet the specifications. 	ARM7				 None. 		3.5 Deep power-down.1: Deep power-down mode is not functional 			NXP
LPC2364	 The LPC2364/66/68 has an Ethernet interface, which can be interfaced with an off-chip PHY using the RMII interface.  The default configuration of the device does not enable the RMII interface. 	ARM7				 To use the Ethernet interface in RMII mode write a 1 to bit 12 (P1.16) in PINSEL2 register (located at 0xE002 C008). This workaround only applies for Rev â-â devices and does not apply for Rev âAâ and newer devices. In order to have both Rev â-â and other revisions coexist in the same piece of software, the MAC module ID can be used to identify the part and determine if port pin P1.6 needs to be set or not. Here are the steps (along with some sample code) to initialize the MAC based on the module ID: 1. In master header file lLPC24xx.h, make sure Module ID is defined (Please note, this ID register is not documented in the User's Manual). #define MAC_BASE_ADDR 0xFFE00000 #define MAC_MODULEID (*(volatile unsigned long *)(MAC_BASE_ADDR + 0xFFC)) /* Module ID reg (RO) */ 2. In the beginning of the MAC initialization file, add below definition: #define OLD_EMAC_MODULE_ID 0x3902 << 16) | 0x2000) 3. In MAC initialization routine, right after setting the EMAC clock in the PCONP register, add a few lines as below: /* Turn on the ethernet MAC clock in PCONP, bit 30 */ regVal = PCONP; regVal |= PCONP_EMAC_CLOCK; PCONP = regVal; /*------------------------------------------------------ * Write to PINSEL2/3 to select the PHY functions on P1[17:0] ES_LPC2364_66_68 . Â© NXP B.V. 2012. All rights reserved.  Rev. 9.1 â 1 July 2012 9 of 20  ES_LPC2364_66_68  LPC2364/66/68 * P1.6, ENET-TX_CLK, has to be set for Rev '-' devices and it * must not be set for Rev 'Aâ and newer devices *------------------------------------------------------*/ regVal = MAC_MODULEID; if ( regVal == OLD_EMAC_MODULE_ID ) { /* On Rev. '-', MAC_MODULEID should be equal to OLD_EMAC_MODULE_ID, P1.6 should be set. */ PINSEL2 = 0x50151105; /* selects P1[0,1,4,6,8,9,10,14,15] */ } else { /* on rev. 'A', MAC_MODULEID should not equal to OLD_EMAC_MODULE_ID, P1.6 should not be set. */ PINSEL2 = 0x50150105; /* selects P1[0,1,4,8,9,10,14,15] */ } PINSEL3 = 0x00000005; /* selects P1[17:16] */ 		3.6 Ethernet.1: Setting up the Ethernet interface in RMII mode 			NXP
LPC2364	 The LPC2364/66/68 has an Ethernet interface, which has a dedicated 16 kB SRAM.  When the Ethernet block is disabled (in the PCONP register located at 0xE01F C0C4), the Ethernet SRAM is also disabled. 	ARM7				 Enable the Ethernet block by setting the PCENET bit (bit no. 30) in the PCONP register. The Ethernet SRAM is now enabled. 		3.7 Ethernet.2: Ethernet SRAM disabled 			NXP
LPC2364	 The Receive number of Descriptors register (RxDescriptor-0xFFE0 0110) defines the number of descriptors in the Descriptor array. Each receive descriptor element in the Descriptor array has an associated status field which consists of the HashCRC word and Status Information word.  The status words are updated incorrectly if the number of Descriptors set in the Receive number of Descriptors register is greater than or equal to 5. 	ARM7				 Define 4 or less in the Receive number of Descriptors register. ES_LPC2364_66_68 . Â© NXP B.V. 2012. All rights reserved.  Rev. 9.1 â 1 July 2012 10 of 20  ES_LPC2364_66_68  LPC2364/66/68 		3.8 Ethernet.3: Receive Status registers will not function correctly if RxDescriptor number is greater than 4 			NXP
LPC2364	 The transmit consume index register defines the descriptor that is going to be transmitted next by the hardware transmit process. After a frame has been transmitted hardware increments the index, wrapping the value to 0 once the value of TxDescriptorNumber has been reached. If the TxConsumeIndex equals TxProduceIndex the descriptor array is empty and the transmit channel will stop transmitting until software produces new descriptors.  The TxConsumeIndex register is not updated correctly (from 0 to 1) after the first frame is sent. After the next frame sent, the TxConsumeIndex register is updated by two (from 0 to 2). This only happens the very first time, so subsequent updates are correct (even those from 0 to 1, after wrapping the value to 0 once the value of TxDescriptorNumber has been reached) 	ARM7				 Software can correct this situation in many ways; for example, sending a dummy frame after initialization. ES_LPC2364_66_68 . Â© NXP B.V. 2012. All rights reserved.  Rev. 9.1 â 1 July 2012 11 of 20  ES_LPC2364_66_68  LPC2364/66/68 		3.9 Ethernet.4: Ethernet TxConsumeIndex register does not update correctly after the first frame is sent 			NXP
LPC2364	 The operating speed of this device out of internal flash/SRAM is specified at 72 MHz.  Code execution from internal flash is restricted depending upon the device revision: 1. Rev âAâ devices: Code execution from internal flash is restricted to a maximum of 60 MHz. For example, use a PLL output frequency of FCCO = 360 MHz and divide it by 6 (CCLKSEL = 5) to generate 60 MHz CPU clock (do not use even values for CCLKSEL). 2. Rev â-â devices: Code execution from internal flash is restricted to a maximum of 60 MHz also. However, this device revision has one more restriction in terms of the PLL output frequency (FCCO - Please refer to PLL.1 above). FCCO is limited to 290 MHz. Considering the same example in PLL.1 (Input crystal-12 MHz, N = 1, M = 12): FCCO = 288 MHz The CPU Clock Configuration register (located at 0xE01F C104) can then be used to divide this frequency by 6 (CCLKSEL = 5) to achieve 48 MHz. Since this register only accepts odd values for CCLKSEL, a division by 5 (CCLKSEL = 4) is not a valid option. In both the above revisions, code can still execute out of SRAM at up to 72 MHz. 	ARM7				 None. 		3.10 Flash.1: Operating speed out of on-chip flash is restricted 			NXP
LPC2364	 The LPC2364/66/68 has an I2S interface, which can be used for audio devices. The I2S interface was initially designed to operate with the general purpose DMA controller.  The DMA controller cannot access the I2S interface. 	ARM7				 No known workaround. ES_LPC2364_66_68 . Â© NXP B.V. 2012. All rights reserved.  Rev. 9.1 â 1 July 2012 12 of 20  ES_LPC2364_66_68  LPC2364/66/68 		3.11 I2S.1: I2S DMA interface is non-operational 			NXP
LPC2364	 The MAM block maximizes the performance of the ARM processor when it is running code in flash memory. It includes three 128-bit buffers called the Prefetch Buffer, the Branch Trail Buffer and the data buffer. It can operate in 3 modes; Mode 0 (MAM off), Mode 1 (MAM partially enabled) and Mode 2 (MAM fully enabled).  Under certain conditions when the MAM is fully enabled (Mode 2) code execution from internal flash can fail. The conditions under which the problem can occur is dependent on the code itself along with its positioning within the flash memory. 	ARM7				 If the above problem is encountered then Mode 2 should not be used. Instead, partially enable the MAM using Mode 1. 		3.12 MAM.1: Under certain conditions in MAM Mode 2 code execution out of internal flash can fail 			NXP
LPC2364	 The PLL input, in the range of 32 KHz to 50 MHz, may initially be divided down by a value âNâ, which may be in the range of 1 to 256. Following the PLL input divider is the PLL multiplier. This can multiply the input divider output through the use of a Current Controlled Oscillator (CCO) by a value âMâ, in the range of 1 through 32768. The resulting frequency, FCCO must be in the range of 275 MHz to 550 MHz.This frequency can be divided down (using the Clock Divider registers) to get the desired clock frequencies for the core and peripherals.  The maximum output of the CCO within the PLL block is limited to 290 MHz. 	ARM7				 Care should be taken while programming the PLL so that FCCO resides in the desired range. The suggested setting is to use a 12 MHz external crystal. Use a PLLdivider (N) of 1 and PLL multiplier (M) of 12. Putting the values in the equation: FCCO = (2 ï´ M ï´ FIN) / N FCCO = 288 MHz The CPU Clock Configuration register (located at 0xE01F C104) can then be used to divide this frequency by 4 to produce the maximum CPU speed of 72 MHz (except on Rev â-â and Rev âAâ, see Flash.1). ES_LPC2364_66_68 . Â© NXP B.V. 2012. All rights reserved.  Rev. 9.1 â 1 July 2012 13 of 20  ES_LPC2364_66_68  LPC2364/66/68 		3.13 PLL.1: PLL output (FCCO) is limited to 290 MHz 			NXP
LPC2364	 The LPC2364/66/68 has 16 kB of SRAM on the AHB2 bus, which would generally be used by the Ethernet block.  The 16 kB of SRAM can only be used as data RAM. Code can not be executed from this memory. 	ARM7				 No known workaround. 		3.14 SRAM.1: 16 kB SRAM cannot be used for code execution 			NXP
LPC2364	 The USB_NEED_CLK signal is used to facilitate going into and waking up from chip Power Down mode. USB_NEED_CLK is asserted if any of the bits of the USBClkSt register are asserted.  The USB_NEED_CLK bit of the USBIntSt register (located at 0xE01F C1C0) is always asserted, preventing the chip from entering Power Down mode when the USBWAKE bit is set in the INTWAKE register (located at 0xE01F C144). 	ARM7				 After setting the PCUSB bit in PCONP (located at 0xE01F C0C4), write 0x1 to address 0xFFE0C008. The USB_NEED_CLK signal will now function correctly. Writing to address 0xFFE0C008 only needs to be done once after each chip reset. 		3.15 USB.1: USB_NEED_CLK is always asserted 			NXP
LPC2364	 U1CONNECT Signal (alternate function of P2.9) is part of the SoftConnect USB feature, which is used to switch an external 1.5 KW resistor under the software control.  The USB U1CONNECT alternate function does not work as expected. 	ARM7				 Configure P2.9 as a GPIO pin, and use it to enable the pull-up resistor on the U1D+ pin. ES_LPC2364_66_68 . Â© NXP B.V. 2012. All rights reserved.  Rev. 9.1 â 1 July 2012 14 of 20  ES_LPC2364_66_68  LPC2364/66/68 		3.16 USB.2: U1CONNECT signal is not functional 			NXP
LPC2364	 The VBUS signal indicates the presence of USB bus power.  The VBUS status input is not functional. 	ARM7				 Configure P1.30 as a GPIO pin, and poll it to determine when VBUS goes to 0, signalling a disconnect event. 		3.17 USB.3: VBUS status input is not functional 			NXP
LPC2364	 The device has a VBAT pin which provides power only to the RTC and Battery RAM. VBAT can be connected to a battery or the same 3.3 V supply used by rest of the device (VDD(3V3) pin, VDD(DCDC)(3V3) pin).  If VBAT is powered before the 3.3 V supply, VBAT is unable to source the start-up current required for the Battery RAM. Therefore, power consumption on the VBAT pin will be high and will remain high until 3.3 V supply is powered up. Once 3.3 V supply is powered up, power consumption on the VBAT pin will reduce to normal and subsequent power cycle on the 3.3 V supply will not cause an increased power consumption on the VBAT pin. 	ARM7				 Provide 3.3 V supply used by rest of the device first and then provide VBAT voltage. 		3.18 VBAT.1: Increased power consumption on VBAT when VBAT is powered before the 3.3 V supply used by rest of the device 			NXP
LPC2364	 The device has a VBAT pin which provides power only to the Real Time Clock (RTC) and Battery RAM. VBAT can be connected to a battery or the same supply used by rest of the device (VDD(3V3) pin, VDD(DCDC)(3V3) pin). The input voltage range on the VBAT pin is 2.0 V minimum to 3.6 V maximum for temperature ï­40 ï°C to +85 ï°C. Normally, if the RTC and the Battery RAM are not used, the VBAT pin can be left floating.  If the VBAT pin is left floating, the internal reset signal within the RTC domain may get corrupted and as a result, prevents the device from starting-up. 	ARM7				 The VBAT should be connected to a battery or the same supply used by rest of the device (VDD(3V3) pin, VDD(DCDC)(3V3) pin). ES_LPC2364_66_68 . Â© NXP B.V. 2012. All rights reserved.  Rev. 9.1 â 1 July 2012 15 of 20  ES_LPC2364_66_68  LPC2364/66/68 		3.19 VBAT.2: The VBAT pin cannot be left floating 			NXP
LPC2364	 The Watchdog timer can reset the microcontroller within a reasonable amount of time if it enters an erroneous state.  After writing 0xAA to WDFEED, any APB register access other than writing 0x55 to WDFEED may cause an immediate reset. 	ARM7				 Avoid APB accesses in the middle of the feed sequence. This implies that interrupts and the GPDMA should be disabled while feeding the Watchdog. ES_LPC2364_66_68 . Â© NXP B.V. 2012. All rights reserved.  Rev. 9.1 â 1 July 2012 16 of 20  ES_LPC2364_66_68  LPC2364/66/68 4. AC/DC deviations detail 		3.20 WDT.1: Accessing non-Watchdog APB registers in the middle of the feed sequence causes a reset 			NXP
LPC2364	 The LPC2364/66/68 is rated for 2 kV ESD. The RTCX1 pin is the input pin for the RTC oscillator circuit.  The LPC2364/66/68 does not meet the required 2 kV ESD specified. 	ARM9				 Observe proper ESD handling precautions for the RTCX1 pin.		4.1 ESD.1: The LPC2364/66/68 does not meet the 2 kV ESD requirements on the RTCX1 pin 			NXP
OMAP-L137	   Note: DMA refers to all non-CPU requests. This includes Internal Direct Memory Access (IDMA) requests and all other system DMA master requests via the Slave Direct Memory Access (SDMA) port.  The C674x Megamodule uses a bandwidth management (BWM) system to arbitrate  between DMA and CPU requests issued to L2 RAM. See TMS320C674x DSP  Megamodule Reference Guide, Literature Number - SPRUFK5 for more information on  the BWM. BWM arbitration grants L2 bandwidth based on programmable priorities and  contention- cycle-counters. The contention-cycle-counters count the number of cycles for which the associated L2 requests are blocked by higher priority requests. When the  contention-cycle-counter reaches a programmed threshold (MAXWAIT), the associated  L2 request is granted a slice of L2 bandwidth. This prevents indefinite blocking of low priority requests when faced with the continuous presence of higher priority requests.  Ideally, the BWM arbitration will grant equal L2 bandwidth between equal priority DMA and CPU requests. Instead, when equal priority DMA and CPU requests arrive at the  BWM, bandwidth is always granted in favor of the CPU over DMA. In the case of  successive CPU requests, it is possible for the CPU to block all DMA requests until CPU  traffic subsides. Additionally, some command logic in the BWM uses priority level 7, which can also result in SDMA stalls when the CPU is also programmed to priority level 7. Figure 2 shows a high level diagram of the arbitration scheme used for L2 RAM  requests.  C674x Megamodule  EDMA  SHAREDRESOURCE  ExternalSystemMasters  Programmable Priority  ARBITRA  MasterPriority  C674x CPU  EMAC  ARBITRA  Programmable Priority  IDMA  L2 RAM  TION  LCDC  Inherit  TION  Priority  SDMA  UHPI  USB  Highest Priority Master Granted Access.  Contention counters implemented to not      starve low priority requestors   Figure 2. Priority Arbitration Scheme for L2 RAM  	ARM9	 	 	 	  Configure DMA and CPU requests to different priority levels. The CPU should not be set to priority level 7. There is no penalty for setting the IDMA and SDMA priorities equal to each other.  CPU request priority is programmed within the CPUARBU register:  /** Pseudo code only **/  Uint32 *CPUARBU;  CPUARBU = ( Uint32 * ) ( 0x01841000 );  /* Set priority different from IDMA/SDMA */  *CPUARBU = [CPU_PRIORITY];  8  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback   3.0 Usage Notes and Known Design Exceptions to Functional Specifications IDMA request priority is programmed within the IDMA1_COUNT register  /** Pseudo code only **/  Uint32 *IDMA1_SRC, *IDMA1_DST;  Uint32 *IDMA1_CNT;  IDMA1_SRC = ( Uint32 * ) ( 0x01820108 );  IDMA1_DST = ( Uint32 * ) ( 0x0182010C );  IDMA1_CNT = ( Uint32 * ) ( 0x01820110 );  *IDMA1_SRC = sourceAddress;  *IDMA1_DST = destinationAddress;  /* Set IDMA priority different from CPU */  *IDMA_CNT = ( [IDMA_PRI] << [IDMA_PRI_SHIFT] ) | buffSize ;  SDMA request priority is inherited from the MSTPRIn registers  /** Pseudo code only **/  Uint32 *MSTPRI1, *MSTPRI2;  MSTPRI1 = ( Uint32 * ) ( 0x01C14114 );  MSTPRI2 = ( Uint32 * ) ( 0x01C14118 );  /* Set SDMA master priorities different from CPU */  *MSTPRI1 = [MAST_PRI] << [MAST_SHIFT];  *MSTPRI2 = [MAST_PRI] << [MAST_SHIFT];  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  9  Submit Documentation Feedback   3.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      	  3.0 and earlier      	 3.0.4   DMA Access to L2 RAM Can Stall When DMA and C674x CPU Command Priorities      are Equal   	 	 	TI
OMAP-L137	   When the USB controller is operating as a device and an attached host resets the device after the completion of the “Device Attached” state by driving both differential data lines low, the USB controller operating as a device could receive multiple RESET interrupts for the single RESET signaling invoked by the host. The multiple interrupt generation only happens for the duration of the RESET signaling on the bus. RESET Interrupt is not generated before or after the completion of RESET.  	ARM9	 	 	 	  Software must service every USB RESET interrupt received. Software should not  proceed on performing any other task, like initialization, until RESET duration has come to completion. The POWER[RESET] bit field will be cleared by the USB Controller when RESET signaling on the bus is removed by the Host. The USB Controller clearing the  POWER[RESET] bit field should be used by software as an indication for the completion of RESET signaling.  10  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback   3.0 Usage Notes and Known Design Exceptions to Functional Specifications 	  3.0 and earlier      	 3.0.6   USB0: Extraneous RESET Interrupt  	 	 	TI
OMAP-L137	   During LCDC initialization, there is the potential for a FIFO underflow condition to occur.  A FIFO underflow condition occurs when the input FIFO is completely empty and the  LCDC raster controller logic that drives data to the output pins attempts to fetch data from the FIFO. When a FIFO underflow condition occurs, incorrect data will be driven out on the LCDC data pins.  An underflow condition will occur if the EMIFB issues a refresh command to the SDRAM  memory during LCDC start up/initialization. The error condition will be captured in the LCD Status register (LCD_STAT) in the FIFO underflow status (FUF) bit field. If the  FUF_EN bit is enabled in Raster Control Register (RASTER_CTRL), the LCDC will send  an interrupt to the CPU.  The FIFO underflow described above is not expected to be a common occurrence  because of the unlikely alignment of events required to produce the underflow condition.  	ARM9	 	 	 	  The EMIFB hardware automatically schedules refresh commands to the SDRAM  memory. Therefore, it is not possible for the user/application code to schedule EMIF  refresh commands to prevent them from being initiated during LCDC start up. This  means that it is not possible to prevent an EMIFB refresh occurrence during the start up of the LCDC.  Software should poll the FUF bit field in the LCD_STAT register to check if an error condition has occurred or service the interrupt if FUF_EN is enabled when FUF occurs. If the FUF bit field has been set to 1, this will indicate an underflow condition has occurred and then the software should execute a reset of the LCDC via the LPSC.  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  11  Submit Documentation Feedback   3.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      	  3.0 and earlier      	 3.0.7      LCDC Underflow During Initialization   	 	 	TI
OMAP-L137	   In Extended Wait mode, during a read access to an asynchronous memory, if the WAIT  input does not go inactive within maximum extended wait cycles programmed in the  Async Wait Cycle Config register, the EMIFA will report a time-out error. The data  returned for this access will be all zeros. If this access is followed by a read to the EMIFA’s memory-mapped register (MMR) space, the EMIFA will still report a time-out  error but with the correct data for the MMR read. The EMIFA will hold the time-out error until another asynchronous access without a time-out error or an SDRAM access is  performed.  This issue is only applicable if all of the following are true:  •  The EMIFA is used for asynchronous memory accesses in Extended Wait mode.  •  There is a potential for a time-out error to occur, that is, the asynchronous memory will not de-assert the WAIT input.  •  If asynchronous memory read with time-out error is followed by an MMR read.  	ARM9	 	 	 	  If a time-out occurs, perform any of the following:  •  A dummy read to another asynchronous memory chip select that is not configured to  be in Extended Wait mode.  •  A dummy read to the same asynchronous memory chip select after disabling the  Extended Wait mode on that chip select.  •  A dummy read to SDRAM  12  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback   3.0 Usage Notes and Known Design Exceptions to Functional Specifications 	  3.0 and earlier      	 3.0.13   EMIFA: Asynchronous Memory Timeout Error Persistence  	 	 	TI
OMAP-L137	   The C674x DSP megamodule supports twelve maskable hardware interrupt signals  (CPUINT4 through CPUINT15). Single system interrupts may be mapped directly to a  CPUINTn hardware interrupt, or multiple system interrupts may be combined by the  ECM into a single signal before mapping to a CPUINTn interrupt. See SPRUFK5 -  TMS320C674x DSP Megamodule Reference Guide for more information on how DSP  interrupts are handled.  The ECM expects all incoming interrupts to be pulse interrupts, however the  [SYSCFG_CHIPSIG_]CHIPINTn interrupts are level interrupts. This mismatch in interrupt types will cause a single CHIPINTn interrupt event to register multiple times in the ECM.  	ARM9	 	 	 	  The CPUINTn hardware interrupts can support both pulse and level interrupts so  CHIPINTn interrupts should be mapped directly to CPUINTn hardware interrupts.  Furthermore, if the ECM is used for other system interrupts, the CHIPINTn interrupts should be masked out in the EVTMASKn registers.  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  13  Submit Documentation Feedback   3.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      	  3.0 and earlier      	 3.0.14  A Single CHIPINTn Interrupt Event Will Register Multiple Times in the DSP Event  Combiner Module (ECM)  	 	 	TI
OMAP-L137	   When a soft reset is invoked by setting the RESET bit of the USB CTRLR register (  CTRLR[RESET] = 1 ), the internal reset timing requirements may be violated. Although this timing violation has not been observed in practice, the potential for a timing violation exists.  USB resets initiated by system-reset and power-on-reset are immune from the timing  violation.  There is no plan to fix this issue in future silicon revisions because:  1. No functional problems have been observed to date  2. A software workaround has been developed to avoid the problem  	ARM9	 	 	 	  The reset timing violation can be avoided by providing the modified soft reset activation sequence outlined below:  1. Enable the USB controller module clock  2. Perform a soft USB reset  3. Wait for the USB soft reset bit to clear  4. Disable the USB controller module clock  5. Configure the USB PHY parameters  6. Enable the PHY  7. Enable the USB controller module clock  14  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback   3.0 Usage Notes and Known Design Exceptions to Functional Specifications 	  3.0 and earlier      	 3.0.15   Potential USB2.0 Soft Reset Timing Violation  	 	 	TI
OMAP-L137	   The VSR register in the ARM Interrupt Controller (AINTC) is not correctly initialized after reset. If this register is not explicitly configured, the AINTC will only allocate 1 byte per interrupt (instead of 4).  	ARM9	 	 	 	  The desired value (even if it is the default value) should be written to the VSR prior to using the interrupt controller.  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  15  Submit Documentation Feedback   3.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      	  3.0 and earlier      	 3.0.17  ARM Interrupt Controller Vector Size Register (VSR) Initialization  	 	 	TI
OMAP-L137	   Interrupts destined for the ARM CPU are managed by the ARM Interrupt Controller  (AINTC). The AINTC detects, combines, and routes system interrupts to the two native ARM interrupt signals FIQ and IRQ. See the device Technical Reference Manual  SPRUH92 for additional information about the AINTC.  The AINTC module expects all incoming interrupts to be pulse interrupts, however the  [SYSCFG_CHIPSIG_]CHIPINTn interrupts are level interrupts. This mismatch in interrupt types will cause a single CHIPINTn interrupt event to register as multiple interrupt pulses in the AINTC. However, the AINTC does not have the capacity to count the number of  interrupt pulses received per system interrupt – it only maintains interrupt flags. A system interrupt is flagged as active until its status is cleared by the user through the AINTC, regardless of the number of interrupts detected.  If the status flag for AINTC CHIPINTn is cleared while the CHIPINTn interrupt is still active, the AINTC will continue to detect CHIPINTn interrupts and its status flag will be set again. This additional setting of the AINTC CHIPINTn status flag is false.  	ARM9	 	 	 	      Method 1   Do not execute the intended interrupt service routine code if the associated CHIPSIGn status flag is not set in the SYSCFG_CHIPSIG register. A cleared CHIPSIGn status flag indicates that the device is responding to a false interrupt. This method is easy to implement, but does not eliminate false interrupts.  /** Pseudo code only **/  void CHIPINT0_ISR(void) {  /* Exit immediately if CHIPSIG0 is not set */  if( (SYSCFG->CHIPSIG & 0x1) == 0 ) {  return;  }  /* Intended service routine code */  SYSCFG->CHIPSIG_CLR = 0x1;  printf(“Hello World!\n”);  }      Method 2   Do not clear the AINTC CHIPINTn status flag until the CHIPSIGn status has been  cleared. This method will eliminate false interrupts, but requires changes to the AINTC  interrupt dispatch code. Changing the dispatch code may introduce undesired behavior in the application.  /** Pseudo code only **/  /* Sequence that is susceptible to false CHIPINTn interrupts */  void AINTC_ISR_DISPATCH_1(void) {  Get_Interrupt_Information();  /* CHIPINTn interrupts continue to be generated after */  /* AINTC CHIPINTn flag is cleared.  */  Clear_AINTC_Interrupt_Flag();  /* CHIPINTn interrupts are only stopped after ISR clears */  /* the status flag.  */  Branch_To_ISR();  }  16  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback   3.0 Usage Notes and Known Design Exceptions to Functional Specifications  /* Sequence that is not susceptible to false CHIPINTn interrupts */  void AINTC_ISR_DISPATCH_2(void) {  Get_Interrupt_Information();  /* ISR will clear CHIPSIGn flag and discontinue CHIPINTn */  /* interrupts to AINTC.  */  Branch_To_ISR();  /* Ok to clear AINTC CHIPINTn flag now.  */  Clear_AINTC_Interrupt_Flag();  }  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  17  Submit Documentation Feedback   3.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      	  3.0 and earlier      	 3.0.18   A Single CHIPINTn Interrupt Event Can Register Multiple Times in the AINTC  	 	 	TI
OMAP-L137	   The C674x CPU supports a Saturation feature for key arithmetic operations. If an  operation results in saturation, the SAT (saturation) bit in the control status register (CSR) is set. In normal operation, one or more functional units can simultaneously  perform arithmetic operations that can result in saturation. In the case of simultaneous arithmetic operations, the SAT bit is set if at least one functional unit’s operation results in saturation. The saturation status register (SSR) provides saturation flags for each functional unit, making it possible for the program to distinguish between saturations caused by different instructions in the same execute packet. Also, there is no direct connection to the SAT bit in the control status register (CSR); writes to the SAT bit have no effect on SSR and writes to SSR have no effect on the SAT bit.  In the case where a 2 cycle .M unit instruction is in the delay slot of a 4 cycle instruction of the same .M unit, and if both instructions are expected to generate results in the same cycle, the CSR:SAT bit will be incorrectly masked. Ideally, the CSR:SAT bit should be set if any one of the two .M unit instruction causes a saturation. Instead, the arithmetic saturation result of the 2 cycle .M unit instruction will overwrite the CSR:SAT bit.  All of the following must take place in order for an application to be affected by this advisory:  1. A 2 cycle .M unit instruction and a 4 cycle .M unit instruction are issued  simultaneously  2. Both instructions are processed on the same side  3. The 2 cycle instruction is in the delay slot of the 4 cycle instruction so that the results of both instructions are generated in the same cycle  4. The saturation result of the 4 cycle .M unit instruction is different from the saturation result of the 2 cycle .M unit instruction  5. The application checks for the saturation flag and uses the saturation result of the 4  cycle instruction  	ARM9	 	 	 	  Perform one of the following:  •  For the location of code where saturation results are monitored, do not mix datatypes so that 2 cycle and 4 cycle .M unit instructions are not issued together.  •  Do not mix floating point .M unit instruction with fixed point 2 cycle .M unit  instructions.  18  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback   3.0 Usage Notes and Known Design Exceptions to Functional Specifications 	  3.0 and earlier      	 3.0.19   Incorrect Masking of the C674x CSR:SAT Bit  	 	 	TI
OMAP-L137	   Note: SDMA refers to all non-CPU requests to the EMC SDMA (Slave Direct Memory Access) port (see Figure 3). SDMA requests are defined as external system bus master requests handled via this port.  The C674x Megamodule uses a two-way set associative cache for L1D. This means that  every physical memory location in the system has two possible set/way locations in the cache where it can reside. See TMS320C674x DSP Megamodule Reference Guide  (Literature Number SPRUFK5) for more information on the L1D cache architecture and  related terminology. Updated (dirty) values in L1D cache are not written back to external memory until cache activity evicts a cache-line (victim write-back) or a write-back is requested by software.  An L1D cache-line corruption event occurs when all of the conditions in the following steps are met (see Figure 3):  1. L1D cache Lines 1, 2, and 3 have the following characteristics:  •  Line 1 is associated with L2 SRAM (Line A in Figure 3), was previously read by  CPU, and is clean. (CPU has not updated the data.)  •  Line 2 is associated with L2 SRAM (Line B in Figure 3), was previously read by  CPU, and is clean. (CPU has not updated the data.)  •  Line 3 was previously read by the CPU and may be either clean or dirty.  2. SDMA receives updated data for L2 SRAM Lines A and B, which correspond to L1D  cache Lines 1 and 2.  3. A snoop write operation is initiated by the L2 to overwrite the L1D cache Lines 1 and 2 with updated L2 SRAM Lines A and B. Before the snoop write operation finishes,  the CPU performs two reads within the same clock cycle:  •  Line E in L2 cache is read as a cache hit. Line E is destined to replace Line 2 in  L1D Cache, which also has a snoop write pending for the updated Line B  content.  •  Line D in L2 SRAM is read. Line D will replace Line 3 in L1D cache.  4. When the snoop write operation completes, Line 2 in L1D cache now contains the  updated L2 SRAM Line B data instead of the L2 cache Line E data.  The correct behavior would have been to kill the pending snoop write initiated to update L1D cache Line 2 with the updated L2 SRAM Line B data in Step 3. The L1D cache  should have evicted Line B and replaced it with Line E data. Instead, the snoop write operation continues and does not complete until after the L1D cache Line 2 has already been replaced with L2 cache Line E data. The snoop write instruction overwrites the L1D  cache Line 2 (containing L2 cache Line E data) with the updated L2 SRAM Line B data.  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  19  Submit Documentation Feedback   3.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  Time Line  System View      Line A   Line E and Line B Map to  STEP 1  STEP 2  STEP 3  STEP 4  same L1D Cache line.  Line A  B  C674x subsystem  Line A  C  C6xCPU  Read Line D  L2  Line A  D  Activity  Read Line E  C6X CPU  Controller  L2 SRAM  SDMA  Write Line A Snoop Write  Line A  E  Activity  Write Line B  Initiated  L1D  EMC  L2 CACHE      L1D Cache   Clean Line A Clean Line A  IN FLUX  Clean Line A  Controller  SDMA PORT      Line 1   (New Data)      L1D Cache   Clean Line B Clean Line B  IN FLUX  CORRUPT  EMAC      Line 2   Line E replaces Line B due  Line      Line 1 A   [A]  PRU      L1D Cache   Clean/Dirty  Clean/Dirty  IN FLUX  Clean Line D  to CPU read.  Line 3  Line C  Line C  Line      Line 2 A   [B/E] Delayed snoop wrtie to Line  EDMA  SYSTEMMASTERS  Line      Line 3 A   [C/D] B corrupts Line E in L1D$  L1D  Corruption happens  CACHE  UHPI  because of this state      EXTERNAL   Figure 3. Example of L1D Cache Corruption  	ARM9	 	 	 	  Method 1: Do not perform two CPU read operations in the same clock cycle. For C  code, use compiler flag (--c64p_dma_l1d_workaround) available in the C6000  Compiler (CodeGen) Tools version 7.0.2 and later. For assembly code, the --  c64p_dma_l1d_workaround flag will only issue a warning.  Method 2: In cases where buffer access will not be shared between CPU and SDMA, unintended CPU/SDMA cache-line sharing can be avoided by aligning CPU and SDMA  buffers to 64-byte boundaries. Aligning buffers to 64-byte boundaries will result in wasted space, however it ensures that the CPU and SDMA buffers will not have partial  segments which overlap into the same L1D cache line.  /** Pseudo code only **/  Uint8 *SDMA_BUFF, *CPU_BUFF;  /* 64-byte aligned allocation Option 1 */  SDMA_BUFF = malloc( (Int32) (( SDMA_BUFF_SIZE + 63)/64) * 64 );  CPU_BUFF = malloc( (Int32) ((CPU_BUFF_SIZE + 63)/64) * 64 );  SDMA_BUFF = (Uint8 *) ( (Int32) SDMA_BUFF & ~63 );  CPU_BUFF = (Uint8 *) ( (Int32) CPU_BUFF & ~63 );  /* 64-byte aligned allocation Option 2 with BIOS Call */  SDMA_BUFF = MEM_alloc( IRAM, SDMA_BUFF_SIZE, 64 );  CPU_BUFF = MEM_alloc( IRAM, CPU_BUFF_SIZE, 64 );  20  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback   3.0 Usage Notes and Known Design Exceptions to Functional Specifications Method 3 Manage access to a 64-byte boundary aligned buffer that is shared between CPU and SDMA by implementing a semaphore and forcing cache writeback operations if  there are CPU writes. With this method, the semaphore ensures that there is clear  ownership of the buffer between CPU and SDMA, and the CPU manages cache  coherence by using explicit cache writeback operations.  /** Pseudo code only **/  /* Example with EDMA as the external master */  EDMA_ISR() {  /* EDMA releases ownership of buffer */  SEM_post(SyncSemaphore);  return;  }  main() {  while(COND) {  /* CPU waits for ownership of buffer */  SEM_pend(SyncSemaphore);  /**********************/  /*** CPU Processing ***/  /**********************/  /* Cache writeback for shared block */  /* Buffer must be 64-byte aligned */  BCACHE_wbInv( blockPtr, blockSize, WAIT );  /* Initiate EDMA */  EDMA_Event_Generate();  }  }  Method 4 Do not allow SDMA to access L2 RAM. SDMA can use buffers in L1D RAM or Shared RAM instead of L2 RAM.  Method 5 Configure the entire L2 RAM as cache. Critical peripheral data can be accessed in L1D RAM or Shared RAM instead of L2 RAM.  Method 6 Configure the entire L2 RAM as normal SRAM (no cache).  Method 7 Configure the entire L1D RAM as normal SRAM (no cache).  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  21  Submit Documentation Feedback   3.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      	  3.0 and earlier      	 3.0.21  SDMA Activity Can Corrupt L1D When L2 Is Configured as Mixed/C ache/SRAM  	 	 	TI
OMAP-L137	   The USB 2.0 On-The-Go (OTG) Session Request Protocol (SRP) allows a USB-  peripheral to request the USB-host to enable Vbus and start a session. On this device, the SRP protocol is not supported.  The OTG Host Negotiation Protocol (HNP), which allows USB-devices to swap roles  between host and peripheral, is supported.  	ARM9	 	 	 	  None  22  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback   3.0 Usage Notes and Known Design Exceptions to Functional Specifications 	  3.0 and earlier      	 3.0.22   USB 2.0 On-The-Go (OTG) Session Request Protocol (SRP) Is Not Supported  	 	 	TI
OMAP-L137	   Under conditions in which the device is subjected to large variations in operating  temperatures, the USB0 PLL temperature compensation circuitry does not have enough  margin to guarantee compensation for PLL drift across all temperature ranges.  As a result, the mean frequency generated by the USB0 (USB 2.0 OTG) PHY PLL will  begin to drift (relative to the expected 480 Mbps) when the temperature of the device is subjected to large swing from the original temperature in which the USB0 PHY was most recently calibrated (initialized).  Once the onset of the PLL drift occurs, the mean frequency will continue to drift outside the expected frequency eventually resulting in failure of USB packet reception and/or transmission. This break in transmission will continue until the USB0 PHY is recalibrated during a USB0 PHY Reset.  If the device is not exposed to large variations in temperature relative to the temperature at which the USB0 PHY was most recently initialized, the temperature compensation  circuitry is expected to provide the proper compensation to prevent the mean PLL  frequency from losing lock and beginning to drift.  More specifically, this advisory is most applicable in applications where the device is expected to operate outside the commercial temperature space (0˚C-90˚C). TI has  identified a point-to-point device temperature range of 0˚C-65˚C in which there is very high confidence in which the compensation circuitry will properly compensate for all variations in temperature provided that the USB0 PHY was most recently initialized  (calibrated) within this same temperature range.  Operating outside the 0˚C-65˚C temperature range increases the susceptibility of the device to experience PLL drift, but does not mean that the application will always  experience a failure in USB transmission.      Root Cause   The Voltage Controlled Oscillator (VCO) Compensation circuitry local to the USB0 PHY  was not designed with a large enough range to compensate for all variations in  temperature across the specified operating range of the device.  How to Most Easily Reproduce the Issue: Reproduction of this issue can most easily be accomplished by the following steps:  1. Allowing the unit to soak in an ambient temperature of -35˚C until the device  temperature reaches approximately the same temperature.  2. Power up the device and provide the necessarily software programming in order to  invoke the USB Signal Quality Test Pattern.  3. Using a USB 2.0 Certified Test Platform, execute the USB signal quality test  procedure across the following temperature set points. -35˚C, 0˚C, +35˚C, +70˚C.  Record the measured mean frequency by the compliance software.  NOTE:  The set points can be varied to obtain finer temperature resolution of  when the PLL begins to drift a per platform basis. The above temperature  profile is provided for reference.  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  23  Submit Documentation Feedback   3.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  	ARM9	 	 	 	  When a break in transmission is detected, USB0 traffic can be recovered by a software reset of the USB0 PHY. A PHY reset implies recalibration of the PHY PLL at the reset temperature. The system has not been observed to reliably recover on its own. A PHY  reset also implies re-enumeration of all devices. There is no way to recalibrate the USB0  PHY without a re-enumeration.  In order to invoke the recovery mechanism (that is a USB0 PHY reset) one needs to  determine when the issue is present. One such approach is to look for an absence of  USB0 Core interrupts over a specified time window. This window should be optimized for the expected USB traffic based upon the application.  As an additional safeguard, an application can also intentionally schedule pre-  determined USB PHY resets at specific temperature points if operation over a broad  range is expected.  Here is an example of one way to power cycle the USB0 PHY via the Chip Configuration 2 Register in the System Configuration (SYSCFG) Module:  #define CFGCHIP2  *((volatile unsigned int *) 0x01C14184)  #define USBPHY_PHYPDWN 0x00000200  Void phy_reset(void) {  CFGCHIP2 |= USBPHY_PHYPDWN;  /* Power down the USB PHY */  mdelay(1);  /* Wait 500ms */  CFGCHIP2 &= ~USBPHY_PHYPDWN;  /* Power up the USB PHY */  }  24  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback   3.0 Usage Notes and Known Design Exceptions to Functional Specifications 	  3.0 and earlier      	 3.0.24  USB0 PLL Mean Frequency Can Drift Across Large Temperature Swings  	 	 	TI
OMAP-L137	   When CPPI DMA completes a receive data transaction it posts a write to the Rx data  buffer located in external memory, posts a write to update the descriptor located in external memory, and raises an interrupt to CPU. When the system load is high, the  posted writes to DDR may not be complete before the CPU receives the interrupt. In this case, the CPU would fetch stale receive data from the Rx data buffer located in external memory.  	ARM9	 	 	 	  Initialize the datalength descriptor field to zero. CPPI DMA updates this field after the completion of an RX DMA operation with the actual number of bytes received. In the ISR  (actually in a deferred call context), poll this field until it becomes a non-zero value to ensure data buffer has been updated with actual data. The descriptor buffer write is posted after the data buffer write, so waiting for the descriptor field to be updated ensures the data buffer has been updated. Since this workaround involves deferred  procedure calls (whose schedule can be delayed depending on OS load), the latency  sensitive application (like ISO Audio) might be affected by delay in notification to the application.  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  25  Submit Documentation Feedback   3.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      	  3.0 and earlier      	 3.0.25  USB0: CPU gets Stale Receive Data from the Data Buffer located in External      Memory   	 	 	TI
OMAP-L137	   The erroneous short packet status can be detected on current endpoint and XDMA  closes the Rx transfer in current endpoint. When more than one endpoint have been  processed, if one of the endpoints has a short packet, then the short packet status is broadcasting to all endpoints.  This results in premature completion of a Rx descriptor in generic RNDIS CPPI DMA  mode.  	ARM9	 	 	 	  The workaround involves monitoring transfer data size before and after transferring and reconfiguring data transfer size by software if the before and after size is different.  Software must keep tracking every endpoint data transferring size. When DMA  completion interrupt is received, software checks size difference. If the size is not equal, software requests the remaining data.  26  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback   3.0 Usage Notes and Known Design Exceptions to Functional Specifications 	  3.0 and earlier      	 3.0.26   USB0: Early DMA Completion in DMA Receive Mode and More Than One Endpoint      is Transferring Data   	 	 	TI
OMAP-L137	   Teardown receive DMA is not working perfectly. This happens when a teardown is  initiated by software during the endpoint is still active. Frequent teardown results in XDMA hung up situation.  	ARM9	 	 	 	  Software should make sure that DMA does not get to an unknown state during teardown  by disabling the DMAEN bit in the RXCSR register. After this the teardown procedure  can be initiated. Software should also add 250 ms delay during teardown.  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  27  Submit Documentation Feedback   2.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      3   Silicon Revision 2.1 Usage Notes and Known Design Exceptions to Functional      Specifications   This section describes the usage notes and advisories that apply to silicon revision 2.1 of the OMAP-L137.      3.1   Usage Notes for Silicon Revision 2.1  Usage notes highlight and describe particular situations where the device's behavior may not match presumed or documented behavior. This may include behaviors that affect device performance or functional correctness. These usage notes will be incorporated into future documentation updates for the device (such as the device-specific data sheet), and the behaviors they describe will not be altered in future silicon revisions.  Silicon revision 2.1 applicable usage notes have been found on a later silicon revision. For more details, see Section 2.1 Usage Notes for Silicon Revision 3.0.      3.2   Silicon Revision 2.1 Known Design Exceptions to Functional Specifications  Silicon revision 2.1 applicable advisories have been found on a later silicon revision. For more details, see Section 2.2 Silicon Revision 3.0 Known Design Exceptions to Functional Specifications Table 3. Silicon Revision 2.1 Advisory List  Title ................................      Page   	  3.0 and earlier      	 3.0.27  USB0: DMA Hung up in Frequent Teardowns  	 	 	TI
OMAP-L137	   The 3.3 V digital I/O buffers on the device exhibit accelerated aging under use conditions with heavy switching activity. As a result, the recommended Power-On Hours (POH)  listed in the device-specific data manual may not apply in all cases. For examples of representative lifetimes, see Examples of Representative Lifetimes (Power-On Hours) .  In a typical use case, the EMIFB clock pin (EMB_CLK) may be impacted due to the high switching rate and may eventually lead to SDRAM-related failures.  NOTE: The information in Examples of Representative Lifetimes (Power-On Hours) and Examples of Representative Lifetimes (Power-On Hours) is provided solely for user  convenience and does not extend or modify the warranty provided under any terms and conditions, including TI’s Standard Terms and Conditions of Sale for Semiconductor  Products.  Examples of Representative Lifetimes (Power-On Hours)      NOMINAL   I/O  LIFETIME ESTIMATES (YEARS)  FAIL  DVDD      SWITCHING   DPPM(1)      RATE   HOURS (HRS) PER DAY OF USE  PERIPHERAL  VOLTAGE  FREQUENCY      ESTIMATE   (%)  (V)  (MHz)  2 HRS  3 HRS  7 HRS  12 HRS      24 HRS   1000   0.1  8.9  5.9  2.5  1.5  0.7  3.30  133  2500  0.25  >15  11.7  5.0  2.9  1.5  EMIFB  5000  0.5  > 15  > 15  7.3  4.3  2.1  1000  0.1  > 15  > 15  > 15  11.6  5.8  3.30  16.94  2500  0.25  > 15  > 15  > 15  > 15  11.5  McASP  5000  0.5  > 15  > 15  > 15  > 15  > 15  (1)  Defective parts per million.  Accelerated aging of buffers depends on I/O switching frequency and I/O voltage.  Prolonged high frequency switching and operating at higher voltages causes buffer  performance to degrade more rapidly.  	ARM9	 	 	 	"  The following methods should be used to prolong the lifetime of the device.      METHOD 1   The 3.3 V output signals should only toggle when required for system functionality. The options are to tristate output buffers when not in use, or to run at the minimum frequency required for the specific application.      METHOD 2   Reduce the I/O voltage, DVDD.  Note: Do not reduce I/O voltage on devices already deployed or showing premature aging effects. To see the effects of premature aging on output signals, See the IO Buffer Premature Aging Assessment Wiki page.  Examples of Representative Lifetimes (Power-On Hours) depicts the subsequent  performance improvements by reducing the I/O voltage.  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  29  Submit Documentation Feedback   2.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  Examples of Representative Lifetimes (Power-On Hours)      NOMINAL   I/O  LIFETIME ESTIMATES (YEARS)  FAIL  DVDD      SWITCHING   DPPM(1)      RATE   HOURS (HRS) PER DAY OF USE  PERIPHERAL  VOLTAGE  FREQUENCY      ESTIMATE   (%)  (V)  (MHz)  2 HRS  3 HRS  7 HRS  12 HRS      24 HRS   1000   0.1  > 15  > 15  7.7  4.5  2.2  3.15  133  2500  0.25  > 15  > 15  > 15  8.8  4.4  EMIFB  5000  0.5  > 15  > 15  > 15  12.9  6.4  1000  0.1  > 15  > 15  > 15  > 15  > 15  3.15  16.94  2500  0.25  > 15  > 15  > 15  > 15  > 15  McASP  5000  0.5  > 15  > 15  > 15  > 15  > 15  (1)  Defective parts per million.  The Recommended Operating Conditions range for DVDD Supply Voltage, I/O, 3.3V,  has been expanded to allow for a minimum voltage of 3.0V for Silicon Revision 2.1  and 2.0 parts with the ""3V"" marking only (for more details on the die symbolization and device revision codes, see Section 1.2, Package Symbolization and Revision  Identification).  Recommended Operating Conditions  MIN  NOM  MAX      UNIT   DVDD   Supply voltage, I/O, 3.3V      3.0   3.3  3.45  V  The Absolute Maximum Ratings requirement for the Input voltage ranges, V I/O, 3.3V  I  (Steady State) has been modified.  Absolute Maximum Ratings Over Operating Case Temperature Range  V I/O, 3.3V  I  Input voltage ranges  –0.3V to DVDD + 0.350V  (Steady State)  See the IO Buffer Premature Aging Assessment Wiki page for more details on the  implementation of the above workarounds.  30  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback   2.0 Usage Notes and Known Design Exceptions to Functional Specifications 4  Silicon Revision 2.0 Usage Notes and Known Design Exceptions to Functional      Specifications   This section describes the usage notes and advisories that apply to silicon revision 2.0 of the OMAP-L137.      4.1   Usage Notes for Silicon Revision 2.0  Usage notes highlight and describe particular situations where the device's behavior may not match presumed or documented behavior. This may include behaviors that affect device performance or functional correctness. These usage notes will be incorporated into future documentation updates for the device (such as the device-specific data sheet), and the behaviors they describe will not be altered in future silicon revisions.  Silicon revision 2.0 applicable usage notes have been found on a later silicon revision. For more details, see Section 2.1 Usage Notes for Silicon Revision 3.0.      4.2   Silicon Revision 2.0 Known Design Exceptions to Functional Specifications  Some silicon revision 2.0 applicable advisories have been found on a later silicon revision. For more details, see  •  Section 2.2, Silicon Revision 3.0 Known Design Exceptions to Functional Specifications  •  Section 3.2, Silicon Revision 2.1 Known Design Exceptions to Functional Specifications Table 4. Silicon Revision 2.0 Advisory List  Title ................................      Page   "	  2.1 and earlier      	 2.1.23  Digital I/O Buffers Age Prematurely  	 	 	TI
OMAP-L137	   For affected silicon revisions, the DSP initiates the system boot sequence when the  device is released from reset. To prepare the ARM for the user, the DSP will first  initialize the ARM reset vector table with an infinite “idle” loop.  The ARM reset vector table is located in the ARM’s local RAM, however the ARM local  RAM can only be accessed by two bus masters: ARM and PRU0. Therefore, the DSP  must program PRU0 to copy the desired reset vector table into the ARM’s local RAM.  The PRU instructions are located inside of an instruction RAM (IRAM) which is initialized by the DSP during ROM boot (see Figure 4). After the instructions are stored to IRAM, the PRU is reset and enabled to execute its instructions. In this case, the PRU is  instructed to initialize the ARM reset vector table.  Read  PRU Core  PRU IRAM  Write  Enable Bit Reset Bit      External Master   (DSP)  Figure 4. PRU and DSP Block Diagram  When the device is first powered-on, the read bus from the PRU IRAM is not initialized and will contain random values (see Figure 5). Under unpredictable circumstances, the random value on the read bus may resemble a reserved instruction which can be  interpreted by the PRU when the core is reset and not enabled.  If the PRU core executes this reserved instruction, it will not be able to properly execute the first functional op-code in the PRU IRAM when the core is later enabled. In this fail state, the PRU will never acknowledge to the DSP that the reset vector table was  successfully initialized and the DSP will be stuck in a polling loop waiting for the PRU to complete its task.  Read Rsvd Inst      PRU Core   Fail State!  PRU IRAM  Write  Enable Bit Reset Bit      External Master   (DSP)  Figure 5. Boot Failure on Power-On  Although the PRU core execution is stuck, the PRU IRAM read bus is now initialized with a non-reserved instruction that was fetched from the IRAM by the PRU core (see  32  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback   2.0 Usage Notes and Known Design Exceptions to Functional Specifications Figure 6). If a secondary reset is provided to the device (either POR or WARM), the PRU  will be able to execute its functional instructions as expected.  Read Good Inst      PRU Core   Pass State!  PRU IRAM  Write  Enable Bit Reset Bit      External Master   (DSP)      Figure 6. Secondary Reset   Note that in order to recover from this fail state with a secondary reset, the DSP must be allowed to execute its boot ROM up to the point where the PRU has fetched a known  instruction from the PRU IRAM. The approximate count of 15k cycles into the boot ROM  is sufficient.  The 15k clock cycle count does not include the 6192 clock cycles required to complete a device POR reset (see Figure 7). With a 24MHz crystal, the first RESET signal must be asserted high for at least 883us (or approximately 1ms).  Greater than 15k Cycles  RESET  RESETOUT      6192 Cycles   Figure 7. First POR Reset Timing  The long-term solution for this problem is to update the DSP boot ROM with a new PRU  initialization sequence that is immune to the described fail mode (see Figure 8):  1. Before resetting the PRU, the DSP will perform a read-back-verify of the PRU IRAM  so that the IRAM read bus will be initialized with a known and safe state.  2. The PRU will be reset and enabled in the same clock cycle by using a single register write so that the core does not have the opportunity to interpret reserved instructions.  3. The DSP will write additional, non-critical op-codes at the beginning of the PRU IRAM  so that the PRU can self-recover even if it interprets a reserved instruction.  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  33  Submit Documentation Feedback   2.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  Read Good Inst      PRU Core   Pass State!  PRU IRAM  Write  Enable Bit Reset Bit  DSP  Read      External Master   (DSP)      Figure 8. New Initialization Sequence   The following symptoms are all observable for this fail mode at power-on:  1. The RESETOUT signal toggles as expected 6192 cycles after the RESET signal is  asserted high.  2. The device produces no boot-mode related activity and the user’s boot program will not be loaded or executed.  3. Connecting to the DSP through JTAG emulation will show that the DSP is stuck in a loop inside of the DSP boot ROM (0x00700000 – 0x007FFFFF memory space).  4. A subsequent reset (either POR or WARM) which is initiated at least 1ms after the first POR reset is asserted high will always produce a successful boot.  5. Following a secondary reset, the device will function as expected without fail until the device is powered-off again.  	ARM9	 	 	 	  Modify the target board so that the affected device is given a secondary reset on power-up as shown in Figure 6. Two example methods are described in the sections that  follow.  Although secondary resets are compatible with future silicon revisions, they are not required for devices where the root cause has been fixed via an updated DSP boot  ROM. In order to reduce BOM costs, board designers may want to route a reset signal  bypass path so that the workaround circuit can be depopulated on future PCB builds.  ❏ Use a reset supervisor device that includes a watchdog timeout function so that the reset supervisor will issue a secondary reset if the device fails to boot. The watchdog should be serviced with a device signal that is controlled by software. Options for  servicing the watchdog timeout include GPIO, unused clock sources such as  OBSCLK or a periodic output peripheral like TIMER and ePWM.  Some TPS382x reset supervisors include a watchdog function (shown in Figure 9).  34  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback  Copyright © 2008–2014, Texas Instruments Incorporated      www.ti.com  Silicon Revision 2.0 Usage Notes and Known Design Exceptions to Functional Specifications TPS3820      3.3V   OMAP-L137   VDD  DVDD  GND  GND  Board Reset  MR  WDI  GPIO  RESET      RESET   0-W      Not Populated   Figure 9. Reset Supervisor with Watchdog Function  The watchdog supervisor workaround is easy to implement, however the watchdog  timeout period may exceed application boot-up time requirements. For example, the  TPS3820 has a typical watchdog timeout period of 200ms. The second workaround can  speed up the reset process.  ❏ Implement a logic-based secondary reset circuit which is timed using RC  components. For the circuit shown in Figure 10, a single board reset control signal  can trigger three logic transitions in a dual XOR gate device.      Not Populated   0-W  1A  R1  1Y  1B  Board Reset  1  C1  1A  RESET  R2  1Y  1B  2  R3  SN74LVC2G86  C2  Dual XOR Gate  SN74LVC2G17      Dual Schmitt Buffer   Figure 10. RC-Timed Secondary Reset  This is possible because each RC load connected to the board reset control signal can output a different rising-edge waveform. With increasing RC load, the resulting control signal will reach the Schmitt buffers’ Vih level at a later point in time. Figure 11 shows the relationship between the board reset signal and the RESET signal produced by the circuit. The blue and green lines represent the voltage as seen by the Schmitt buffers.  The output voltage of a charging RC circuit is defined as: Vo = Vi * (1 - e^[-t / RC]) SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  35  Submit Documentation Feedback   2.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  R1C1  RESET  R2C2  Vih      Board Reset   Figure 11. RESET Signal vs Board Reset  Given ideal conditions, a 3.3V board reset signal, and an input buffer Vih of 1.4V, the following set of component values would generate an initial RESET high period (R1C1  region) of approximately 2ms and a RESET low period (R2C2 region) of approximately  0.5ms:  •  R1 = 36k, C1 = 100nF  •  R2 = 45k, C2 = 100nF  •  R3 = 450k  When implementing this workaround, some important aspects should be kept in mind:  (a) The dual Schmitt buffer is included because the dual XOR gate has an input rise-time requirement that is violated by the RC circuits.  (b) The Board Reset signal must meet the XOR gate input rise-time requirement and  must provide enough output current to charge the RC circuits to the target Vih level.  (c) It is critical for the Vih level of the two input buffers to be very close together so only single-device buffers should be considered for this circuit (such as the 2-in-1 dual Schmitt buffer device used in this example).  (d) Variations in the electrical characteristics of the circuit components may produce waveforms that deviate from ideal calculations.  (e) The sole purpose of the R3 pull-down resistor is to discharge the RC components  before the board reset signal is driven high. Therefore, the value selected for R3  should be sufficiently large enough to not interfere with the RC circuits as they are charging.  36  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback   1.1 Usage Notes and Known Design Exceptions to Functional Specifications 5  Silicon Revision 1.1 Usage Notes and Known Design Exceptions to Functional      Specifications   This section describes the usage notes and advisories that apply to silicon revision 1.1 of the OMAP-L137  device .      5.1   Usage Notes for Silicon Revision 1.1  Usage notes highlight and describe particular situations where the device's behavior may not match presumed or documented behavior. This may include behaviors that affect device performance or functional correctness. These usage notes will be incorporated into future documentation updates for the device (such as the device-specific data sheet), and the behaviors they describe will not be altered in future silicon revisions.  Silicon revision 1.1 applicable usage notes have been found on a later silicon revision. For more details, see Section 2.1, Usage Notes for Silicon Revision 3.0.      5.1.1   RTC Standby Power Consumption Is Elevated if the Module Is Not Configured Correctly On Silicon Revision 1.1 and earlier, the RTC module is designed with the ability to keep time while the rest of the device is power cycled off and on. This ability is achieved by placing the RTC in its own power domain and isolating it from the device reset signal.  When the CVDD supply is powered down, the RTC_CVDD supply will experience elevated standby power consumption because of leakage between the RTC and core power domains. The RTC module includes circuitry that eliminates the leakage paths between the two domains when the SPLITPOWER bit is set to 1  in the control register (CTRL). The SPLITPOWER bit is a write-only bit that will always read back 0.  Therefore, typical read-modify-write sequences should not be used when writing to the CTRL register because the SPLITPOWER bit will be cleared back to 0.  Also note that the SPLITPOWER bit has a default value of 0 after RTC module reset, and the only reset available to the RTC module is a software reset, therefore RTC is in an indeterminate state when the RTC_CVDD supply is first powered on. The RTC module should be reset, and the SPLITPOWER bit should be set to 1 before placing the device in a CVDD powered down standby state. The SPLITPOWER  bit is permanently set to 1 inside the RTC module beginning with Silicon Revision 2.0 of the device.      5.1.2   SYSCFG: Possible Race Condition When Using KICK Registers  On Silicon Revision 1.1 and earlier, when two or more threads are simultaneously accessing the SYSCFG  registers, there is the potential for one thread to lock the SYSCFG registers while another thread is still accessing them. There is no hardware semaphore to prevent this from occurring.  For example, the race condition can occur in the following situation  1. Thread 1 unlocks the SYSCFG register by writing to the KICK registers  2. An interrupt occurs and Thread 2 unlocks the SYSCFG registers as well  3. Thread 2 finishes and locks the SYSCFG registers  4. Thread 1 is locked out of the SYSCFG registers and is unable to complete its task To prevent the SYSCFG lockout race condition, the application should unlock the SYSCFG registers via the KICK registers and leave them permanently unlocked.  Starting with silicon revision 2.0, the KICK registers will be disabled and the SYSCFG registers will be permanently accessible. Writes to the disabled KICK registers will have no effect.      5.2   Silicon Revision 1.1 Known Design Exceptions to Functional Specifications  Some silicon revision 1.1 applicable advisories have been found on a later silicon revision. For more details, see  •  Section 2.2, Silicon Revision 3.0 Known Design Exceptions to Functional Specifications  •  Section 3.2, Silicon Revision 2.1 Known Design Exceptions to Functional Specifications SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  37  Submit Documentation Feedback   1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  •  Section 4.2, Silicon Revision 2.0 Known Design Exceptions to Functional Specifications Table 5. Silicon Revision 1.1 Advisory List  Title ................................      Page   	  2.0 and earlier      	 2.0.20      Intermittent Boot Failures   	 	 	TI
OMAP-L137	   The ARM926 subsystem allows data memory regions to be write-back cachable, write-  through cachable, or non-cached. On this device revision, the Write-Back mode is not functional; therefore, Write-Through or Non-Cached mode must always be used.  	ARM9	 	 	 	  Only the Write-Through or Non-Cached mode can be used. Write-Through mode is preferred for better performance. The cache operation is controlled using the C and B  bits in page or section descriptors. For operation in Write-Through mode, the C and B  bits (bits 3:2 in the descriptor) must be set to a value of 10b.  The following is example code using a section descriptor to create a table entry for the first 1MB of external SDRAM on EMIFB as write-through cachable:  LDR  r1,  SDRAM0_ADDR  ; table offset for SDRAM0 region  LDR  r2,  SDRAM0_DATA  ; descriptor pattern for SDRAM0 region  STR  r2,  [r0, r1, LSL#2]  ; store the table entry at TTB base + table  offset * 4  SDRAM0_ADDR  .word  0x00000C00  SDRAM0_DATA  .word  0xC0000CFA  For more information on ARM data cache modes and how to configure them, refer to the ARM926EJ-S™ Technical Reference Manual available at www.arm.com/documentation.  Chapter 4 of the ARM926EJ-S™ Technical Reference Manual provides details about cache operations on the ARM926EJ-S processor.  Section descriptor: A section descriptor provides the base address of a 1MB block of memory. Figure 12 shows the format of a section descriptor.  31  20  19  12  11  10  9  8  5  4  3  2  1  0  section base address  AP  SBZ  AP  Domain  1  C  B  1  0      Figure 12. Section Descriptor   Table 6 shows the Section Descriptor bit assignments. Table 7 shows the Page Table C  and B bit settings for the DCache.  Table 6. Section Descriptor Bits  BITS      DESCRIPTION   31:20   Form the corresponding bits of the physical address for a section.  19:12  Always written as 0.  11:10  Specify the access permissions for this section.  9  Always written as 0.  Specify one of the 16 possible domains, held in the domain access control register, that contain the primary 8:5  access controls.  4  Should be written as 1, for backwards compatibility.  Indicate if the area of memory mapped by this section is treated as write-back cacheable, write-through 3:2  cacheable, noncached buffered, or noncached nonbuffered.  1:0  These bits must be 10 to indicate a section descriptor  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  39  Submit Documentation Feedback   1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  Table 7. Page Table C and B Bit Settings for the DCache  C BIT  B BIT      DESCRIPTION   ARM926EJ-S BEHAVIOR   DCache disabled. Read from external memory. Write as a nonbuffered  0  0  Noncacheable, nonbufferable  store(s) to external memory. DCache is not updated.  DCache disabled. Read from external memory. Write as a buffered  0  1  Noncacheable, bufferable  store(s) to external memory. DCache is not updated.  DCache enabled:  • Read hit - Read from DCache  • Read miss - Linefill  1  0  Write-through  • Write hit - Write to the DCache, and buffered store to external  memory  • Write miss - Buffered store to external memory  DCache enabled:  • Read hit - Read from DCache  1  1  Write-back  • Read miss - Linefill  • Write hit - Write to the DCache only  • Write miss - Buffered store to external memory  40  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback   1.1 Usage Notes and Known Design Exceptions to Functional Specifications 	  1.1 and earlier      	 1.1.1  ARM Data Cache in Write-Back Mode Is Not Functional: Must Use Write-Through  or Non-Cached Mode  	 	 	TI
OMAP-L137	   When an endpoint is enabled for receive transfer(s) that will be serviced via DMA and data has been received prior to allocating DMA resource, the DMA will generate a  starvation interrupt to notify the application a lack of resource (starvation) in anticipation that the application will furnish the required resource. The CPPI DMA is supposed to generate a single interrupt. But, in this case it continues generating interrupt periodically, until application furnishes a resource. In some use cases, it has been observed that the application may desire to differ the time as to when to service the starvation request due to the CPU handling other urgent task(s). Since the DMA keeps on generating the  starvation interrupt periodically and there exists no capability to mask the starvation interrupt at the USB controller level, the CPU is forced either to fully service the DMA interrupt as it is received or disable all USB interrupt at the CPU level. Disabling the entire USB interrupt might not be the desired option since the CPU needs to be aware of other USB interrupts that are more critical.  	ARM9	 	 	 	  The user can remove the associated channel number entry from the DMA scheduler  Tables (scheduler array) for that endpoint when not expecting data from a host.  Whenever data transfer is initiated by the host, the endpoint interrupt will be generated by the USB controller, which can be used as an indication for an application to secure required resources prior to adding the DMA channel entry for the endpoint onto the  scheduler array.  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  41  Submit Documentation Feedback   1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      	  1.1 and earlier      	 1.1.2  USB0: CPPI Receive Starvation Interrupt  	 	 	TI
OMAP-L137	   When the SPI is in master mode, the generated SPICLK signal is derived from the  internal SPI module clock. This SPICLK signal duty cycle is not 50% when the  SPIFMTn.PRESCALE is set to an even number.  With an even prescale value, the falling edge of the SPICLK is delayed 1-2 ns  regardless of the SPICLK frequency. Therefore, the high side is wider than the low side.  	ARM9	 	 	 	  Use the SPIFMTn.PRESCALE with an odd value if possible.  42  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback   1.1 Usage Notes and Known Design Exceptions to Functional Specifications 	  1.1 and earlier      	 1.1.3   SPI: Internally Generated SPI Clock Is Not 50% Duty Cycle  	 	 	TI
OMAP-L137	   Note: DMA refers to all non-CPU requests. SDMA refers to external system DMA master requests handled via the Slave Direct Memory Access port.  The C674x Megamodule uses a two-way set associative cache for L1D. This means that  every physical memory location in the system has two possible set/way locations in the cache where it can reside. See TMS320C674x DSP Megamodule Reference Guide,  Literature Number - SPRUFK5 for more information on the L1D cache architecture.  Updated (dirty) values in L1D cache are not written back to external memory until cache activity evicts a cache-line (victim write-back) or a write-back is requested by the application.  An L1D cache-line corruption event occurs when all of the following conditions are met: 1. L1D cache evicts a dirty line (Line A) while allocating a new line (Line B) in the same set/way (cache Lines A and B consist of 64-bytes each). In order for this to happen, the following will have taken place:  (a) Line A was previously read by CPU because L1D is a read-allocate cache,  (b) Line A is dirty because its value was modified by CPU, and  (c) Line B is read by CPU  2. Both Line A and Line B are associated with L2 RAM, and  3. While the original L1D victim write-back from condition (1) is in progress, the SDMA performs both:  (a) a read or write operation to Line A in L2 RAM and  (b) a write operation to Line B in L2 RAM.  If all of the above conditions are met, the L2 RAM data associated with the Line A victim writeback will become corrupt. Additionally, the Line B data originating from the SDMA write will also become corrupt in L1D cache. Figure 13 shows an example scenario of  L1D cache and L2 RAM corruption.  Line A and Line B Map to  LINE A  same L1D Cache line.  INITIAL  STEP 1  STEP 2  STEP 3  STATE  C674x Megamodule  LINE B  C674x CPU  CPU Request  Request  L2  C674x CPU  EXTERNAL  Activity  Line B  Pending  Controller  L2  SRAM  SDMA  SDMA Requests  Activity  Writes to both  LineA and LineB  L1D  EMC  L1D Cache  Dirty Line A      Dirty Line A   IN-FLUX   Corrupt  Controller  SDMA PORT  EDMA  SYSTEMMASTERS      Line Status   in L1D Cache in L1D Cache  Line A  Old Data  Old Data  Old Data  Corrupt  L2 SRAM  Line B tries to replace  EMAC  CACHE LINE  Line B  Old Data  Old Data  Old Data      NEW DATA   Dirty Line A in the L1D  L2 SRAM  Cache  L1D  CACHE  Corruption happens  because of this state  TIME LINE      SYSTEM VIEW   Figure 13. Example of L1D Cache and L2 RAM Corruption  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  43  Submit Documentation Feedback   1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  	ARM9	 	 	 	      Method 1   In cases where buffer access will not be shared between CPU and SDMA,  unintended CPU/SDMA cache-line sharing can be avoided by aligning CPU and  SDMA buffers to 64-byte boundaries. Aligning buffers to 64-byte boundaries will  result in wasted space, however it ensures that the CPU and SDMA buffers will not  have partial segments which overlap into the same L1D cache line.  /** Pseudo code only **/  Uint8 *SDMA_BUFF, *CPU_BUFF;  /* 64-byte aligned allocation Option 1 */  SDMA_BUFF = malloc( (Int32) (( SDMA_BUFF_SIZE + 63)/64) * 64 );  CPU_BUFF  = malloc( (Int32) ((CPU_BUFF_SIZE  + 63)/64) * 64 );  SDMA_BUFF = (Uint8 *) ( (Int32) SDMA_BUFF & ~63 );  CPU_BUFF  = (Uint8 *) ( (Int32) CPU_BUFF  & ~63 );  /* 64-byte aligned allocation Option 2 with BIOS Call */  SDMA_BUFF = MEM_alloc( IRAM, SDMA_BUFF_SIZE, 64 );  CPU_BUFF  = MEM_alloc( IRAM, CPU_BUFF_SIZE,  64 );      Method 2   Manage access to a 64-byte boundary aligned buffer that is shared between CPU  and SDMA by implementing a semaphore and forcing cache writeback operations  after CPU writes. With this method, the semaphore ensures that there is clear  ownership of the buffer between CPU and SDMA, and the CPU manages cache  coherence by using explicit cache writeback operations.  /** Pseudo code only **/  /* Example with EDMA as the external master */  EDMA_ISR() {  /* EDMA releases ownership of buffer */  SEM_post(SyncSemaphore);  return;  }  main() {  while(COND) {  /* CPU waits for ownership of buffer */  SEM_pend(SyncSemaphore);  /**********************/  /*** CPU Processing ***/  /**********************/  /* Cache writeback for shared block */  /* Buffer must be 64-byte aligned  */  BCACHE_wbInv( blockPtr, blockSize, WAIT );  /* Initiate EDMA */  EDMA_Event_Generate();  }  }      Method 3   Configure the entire L2 RAM as cache. Critical peripheral data can be accessed in  L1D RAM or L3 RAM instead of L2 RAM.      Method 4   Do not allow SDMA to access L2 RAM. SDMA can use buffers in L1D RAM or L3  RAM instead of L2 RAM.      Method 5   Do not configure L1D memory as cache - use the entire address space as RAM.  44  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback   1.1 Usage Notes and Known Design Exceptions to Functional Specifications 	  1.1 and earlier      	 1.1.5  Under Specific Conditions, SDMA Activity Can Corrupt the L1D Cache and L2 RAM  	 	 	TI
OMAP-L137	   USB 1.1 requires a 15 KΩ pull down on the DP/DM lines. The USB 1.1 Phy does not  include the internal pull down.  	ARM9	 	 	 	  The 15 KΩ pull downs should be added to the DP/DM lines externally to the device.  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  45  Submit Documentation Feedback   1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      	  1.1 and earlier      	 1.1.8  USB 1.1 Phy Does Not Have Internal Pull Down on DP/DM Lines Enabled  	 	 	TI
OMAP-L137	   There is the potential for the 1.8V and 3.3V USB power supplies to experience a latchup condition. The potential for latchup on these supplies is related to the power-on voltage slew rate and the likelihood for latchup with a rapid voltage supply slew rate gradually increases over the device lifetime.  	ARM9	 	 	 	  To prevent a latch up condition from occurring over the life of the device, the following recommendations should be followed:  •  USB0_VDDA18 and USB1_VDDA18 power supply rails must have greater than 1ms  (10%-90%) slew  •  USB0_VDDA33 and USB1_VDDA33 power supply rails must have less than 100-mv  pk-pk noise  •  USB0_VBUS power supply rail must have less than 100-mv pk-pk noise sustained  and must have greater than 1ms (10%-90%) slew  46  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback   1.1 Usage Notes and Known Design Exceptions to Functional Specifications 	  1.1 and earlier      	 1.1.9   USB2.0 (USB0) and USB1.1 (USB1) Power Supply  	 	 	TI
OMAP-L137	   The timing parameters in Table 8 and Table 9 differ from those specified in the OMAP-L137 C6000 DSP+ARM Processor data manual (literature number SPRS563 or later).  Table 8 list the AC timing parameters that should be used on silicon revision 1.1 and earlier.  	ARM9	 	 	 	  During PCB board design and layout, the AC timings specified in Table 8 and Table 9  should be considered when designing interfaces to the EMIFB.  Table 8. Timing requirements Over Recommended Operating Conditions  NO.  PARAMETER  MIN  MAX      UNIT   Input setup time, read data valid on EMB_D[ 31  19  t  1.26  ns  su(DV-CLKH)  :0] before EMB_CLK rising  For the parameter t  , Table 9 and Table 10 are valid under the conditions  OH(CLKH-DQMIV)  described in their respective notes:  Table 9. Switching Characteristics Over Recommended Operating Conditions  NO.  PARAMETER  MIN  MAX      UNIT   Output hold time, EMB_CLK rising to  6  t  0.8(1) (2)  ns  OH(CLKH-DQMIV)  EMB_WE_DQM[3:2] invalid  (1)  This timing requires CVDD = 1.15V ± 1% and DVDD = 3.3V ± 2%.  (2)  This timing parameter ONLY applies to the signals EMB_WE_DQM[3:2]; EMB_WE_DQM [1:0] timings are as shown in the device data manual.  Table 10. Switching Characteristics Over Recommended Operating Conditions  NO.  PARAMETER  MIN  MAX      UNIT   Output hold time, EMB_CLK rising to  6  t  0.7(1) (2)  ns  OH(CLKH-DQMIV)  EMB_WE_DQM[3:2] invalid  (1)  This timing requires CVDD= 1.2V +/- 1% and DVDD= 3.3V +/- 2%.  (2)  This timing parameter ONLY applies to the signals EMB_WE_DQM[3:2]; EMB_WE_DQM [1:0] timings are as shown in the device data manual.  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  47  Submit Documentation Feedback   1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      	  1.1 and earlier      	 1.1.10  EMIFB: AC Timings Differ From Data Manual Specifications  	 	 	TI
OMAP-L137	Details	ARM9	 	 	   The ESD to Charge Device model (CDM) is rated as passing the 300V level instead of  the 500V level. The OSCOUT pin passed 300V testing but failed starting at 400V. The  RSV2 pin had marginality to 500V. All of the other pins are rated as passing the 500V  level.  48  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback   1.1 Usage Notes and Known Design Exceptions to Functional Specifications 	Workaround(s)	 	 1.1.11   Electrostatic Discharge Charged-Device Model Performance  	  1.1 and earlier      	 	TI
OMAP-L137	   The input buffers on the device have shown timing sensitivity to the logic-low input voltage that can cause changes to the AC input timings. Due to this issue, input voltages must be driven at or below 0.4V to limit impact on AC timings.  The timing effect on the input buffers is dependent on the Vil level:  •  Case 1: For signals driven with Vil < = 0.2V, the input timings will be unaffected.  •  For signals driven with 0.2V < Vil < = 0.4V, there may be as much as 0.5 ns degradation to input timings.  This issue applies only to 3.3V LVCMOS inputs or IOs used as inputs. Signals  operated at 1.8V are not affected.  	ARM9	 	 	 	  Although there is no specific workaround, the following recommendations can be used to help prevent this issue:  •  Minimize loads as much as possible, especially DC loads that could cause the Vil to  rise. Point-to-point (single-load) connections are unlikely to be affected.  •  Falling edges should transition as rapidly as possible (so the signal passes through the 0.2V point as early as possible). Heavily loaded nodes resulting in degraded fall times may require drivers to provide rapid input edges.  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  49  Submit Documentation Feedback   1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      	  1.1 and earlier      	 1.1.16  Vil on 3.3V LVCMOS Input Buffers  	 	 	TI
OMAP-L137	"   Note: This advisory is not applicable if DSP L2 memory is configured as 100% cache or L2 RAM is not accessed by IDMA or SDMA during run-time.  The C674x Megamodule has a Master Direct Memory Access (MDMA) bus interface and  a Slave Direct Memory Access (SDMA) bus interface. The MDMA interface provides  DSP access to resources outside the C674x Megamodule.  The MDMA interface is typically used for CPU/cache accesses to memory beyond the  Level 2 (L2) memory level. These accesses include cache line allocates, write-backs, and non-cacheable loads and stores to/from system memories. The cacheable  memories external to the C674x Megamodule are listed in Table 11.  Table 11. Cacheable External Memory Resources  External Memory      Address Range   Shared Ram   0x8000 0000 – 0x8001 FFFF  EMIFA  0x4000 0000 – 0x67FF FFFF  EMIFB  0xC000 0000 – 0xCFFF FFFF  The SDMA interface allows other DMA master peripherals (listed in Table 12 ) to access Level 1 Data (L1D), Level 1 Program (L1P), and L2 RAM DSP memories.  Table 12. DMA Master Peripherals  Peripheral      Group   EDMA TC0 RD   A  EDMA TC0 WR  B  EDMA TC1 RD  C  EDMA TC1 WR  D  EMAC  E  USB1  E  USB0  F  UHPI  F  ARM  G  The C674x Megamodule has an L1D cache and L2 cache both implementing write-back  data caches– it keeps updated values for external memory in cache for as long as  possible. It writes these updated values, called ""victims"", to external memory when it needs to make room for new data or when requested to do so by the application. The  L1D sends its victims to L2. The caching architecture has pipelining, meaning multiple requests could be pending between L1, L2, and MDMA. For more details on the C674x  Megamodule and its MDMA and SDMA ports, see the TMS320C674x Megamodule  Reference Guide (literature number SPRUFK5).  Ideally, the MDMA (dashed-dotted line in Figure 14) and SDMA/IDMA paths (dashed  lines in Figure 14) operate independently with minimal interference. Normally MDMA  accesses may stall for extended periods of time due to expected system level delays (for example, bandwidth limitations). However, when using L2 as RAM, SDMA and IDMA  accesses to L2/L1 may experience unexpected stalling in addition to the normal stalls seen by the MDMA interface. For latency-sensitive traffic, the SDMA stall can result in missing real-time deadlines. In a more severe case, the SDMA stall can produce a  deadlock condition in the device. An IDMA stall cannot produce a deadlock condition.  50  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback   1.1 Usage Notes and Known Design Exceptions to Functional Specifications Note: SDMA/IDMA accesses to L1P/D will not experience an unexpected stall if there are no SDMA/IDMA accesses to L2. Unexpected SDMA/IDMA stalls to L1 happen only  when they are pipelined behind L2 accesses. Additionally, the deadlock scenario will be avoided if there are no SDMA accesses to L2.  Figure 14 is provided for illustrative purposes and is incomplete because of  simplification. The IDMA/SDMA (dashed-lines) path could also go to L1D/L1P memories, and IDMA can go to DSP CFG peripherals. MDMA transactions can originate also from  L1P or L1D through the L2 controller or directly from DSP).  32K bytes  256K bytes      1M bytes   L1P RAM/  L2 RAM  L2 ROM  cache  256  256  256  256  Cache control  Cache control  Memory protect L1P  Memory protect L2  Bandwidth Mgmt  Bandwidth Mgmt  256  256  256  Instruction fetch  256 Power down  C674x      Interrupt   Fixed/floating point CPU  Controller  Register  Register  IDMA  file A  file B  64  64  256  CFG  Bandwidth Mgmt  32  Configuration  EMC  Memory protect L1D  peripherals  Cache control  bus  MDMA  SDMA  8x32  64  64  64  64  32K bytes      High performance   L1D RAM/      switch fabric   SDMA/IDMA Paths      cache   (SCR1)  MDMA Path      Figure 14. C674x Megamodule   The duration of the SDMA/IDMA stalls depend on the quantity/characteristics of the  L1/L2 cache and the MDMA traffic in the system. Therefore, it is difficult to predict if stalling will occur and for how long.  IDMA/SDMA stalling and any system impact is most likely in systems with excessive  context switching, L1/L2 cache miss/victim traffic, and heavy access to external memory.  Use the following procedure to determine if SDMA/IDMA stalling is the cause of real-time deadline misses for existing applications. Situations where real-time deadlines may be missed include loss of McASP samples and poor peripheral throughput.  1. Determine if the transfer that is missing the real-time deadline is accessing L2 or L1D  memory. If not, then SDMA/IDMA stalling is not the source of the real-time deadline  miss.  2. Identify all SDMA transfers to/from L2 memory (for example, EDMA transfer to/from L2 from/to a UART, HPI block transfer to/from L2). If there are no SDMA transfers  to/from L2, then SDMA/IDMA stalling is not the source of the problem.  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  51  Submit Documentation Feedback   1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  3. Redirect all SDMA transfers to L2 memory to other memories using one of the  following methods:  (a) Temporarily transfer all the L2 SDMA transfers to L1D SRAM.  (b) If not all L2 SDMA transfers can be moved to L1D memory, temporarily direct  some of the transfers to memory in Table 1 and keep the rest in L1D memory.  There should be no L2 SDMA transfers.  If real-time deadline misses are solved using any of the options in Step 3, then  IDMA/SDMA stalling is likely the source of the problem.  A deadlock situation may arise if the following sequence of events occurs:  Step 1: A DMA master from any group (listed in Table 12) issues a write command to  the DSP’s SDMA, and a DMA master from the same group issues a subsequent write  command to cacheable memory outside of the C674x Megamodule (listed in Table 1).  All write commands pass through Switched Central Resource 1 (SCR1). For more  details on SCRs, see the device Technical Reference Guide SPRUH93.  Step 2: The DSP’s SDMA asserts itself as not ready and is unable to accept the write data from Step 1, and a cache line writeback is initiated from DSP memory to the same cacheable memory from Step 1. The cache line writeback command also passes  through SCR1.  With the above scenario, it is possible for SCR1 to order the write commands from Step 1 in front of the write commands from Step 2. Due to the MDMA/SDMA blocking  behavior, the SDMA commands from Step 2 will be waiting for the MDMA traffic from  Step 1 to finish, resulting in a deadlock situation at SCR1. Figure 15 is provided for illustrative purposes and is incomplete because of simplification.  DMA  Group A  C674x      SDMA   (L2/L1D)  DMA  Group B  SCR1      DMA   Group xx  Cacheable  Memory  C674x  MDMA      Figure 15. SCR1 System Interconnect   "	ARM9	 	 	 	  Entirely eliminate IDMA/SDMA stalling and potential for a deadlock condition using one of the following two methods:  1. Configure the entire L2 RAM as 100% cache (for example, move all data buffers from L2 to L1D or other memory). Note: Some throughput degradation is expected when  the buffers are moved out to external memo  2. Eliminate all IDMA/SDMA access to L2 RAM when IDMA/SDMA stalling would have  an impact by performing one of the following:  (a) Constrain each DMA master group to perform writes to either DSP memory space  or external memory space, but not to both, or  52  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  SPRZ291I – October 2008 – Revised June 2014  Submit Documentation Feedback   1.1 Usage Notes and Known Design Exceptions to Functional Specifications (b) Force each DMA master group to complete pending write commands to either  DSP memory space or cacheable memory space before initiating writes to a  different destination. Pending write commands from DMA masters are forced to  complete when the DMA master initiates a read from the same destination  memory. Note that in the case of off-chip memory, a read command only forces  the completion of write commands within a 2KB-aligned window.  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  53  Submit Documentation Feedback   1.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      6   Silicon Revision 1.0 Usage Notes and Known Design Exceptions to Functional      Specifications   This section describes the usage notes and advisories that apply to silicon revision 1.0 of the OMAP-L137  device.      6.1   Usage Notes for Silicon Revision 1.0  Usage notes highlight and describe particular situations where the device's behavior may not match presumed or documented behavior. This may include behaviors that affect device performance or functional correctness. These usage notes will be incorporated into future documentation updates for the device (such as the device-specific data sheet), and the behaviors they describe will not be altered in future silicon revisions.  Silicon revision 1.0 applicable usage notes have been found on a later silicon revision. For more details, see Section 4.1, Usage Notes for Silicon Revision 3.0 and see Section 5.1, Usage Notes for Silicon Revision 1.1.      6.2   Silicon Revision 1.0 Known Design Exceptions to Functional Specifications  Some silicon revision 1.0 applicable advisories have been found on a later silicon revision. For more details, see  •  Section 2.2, Silicon Revision 3.0 Known Design Exceptions to Functional Specifications  •  Section 3.2, Silicon Revision 2.1 Known Design Exceptions to Functional Specifications  •  Section 4.2, Silicon Revision 2.0 Known Design Exceptions to Functional Specifications  •  Section 5.2, Silicon Revision 1.1 Known Design Exceptions to Functional Specifications Table 13. Silicon Revision 1.0 Advisory List  Title ................................      Page   	  1.1 and earlier      	 1.1.17   DSP SDMA/IDMA: Unexpected Stalling and Potential Deadlock Condition  	 	 	TI
OMAP-L137	   There is a potential SPI communication failure on data receipt. When the communication failure occurs, the data received in the SPIBUF register is not correct. The data error pattern is not consistent between failures. The failure impacts both master and slave mode.  This issue is caused by un-matched delays between the clock and data paths of the shift register. The non-matched delays cause the clock edge to be detected earlier than the appropriate data. This results in inconsistent/incorrect receive data being copied into the SPIBUF register.  	ARM9	 	 	 	  There is no recommended workaround.  Adjusting the following settings may allow you to find a working region:  •  Adjust the SPI settings of prescale, phase, and polarity  •  Increase the core VDD to a range between 1.25V and 1.32V  •  Decrease the CPU operating frequency  Increasing the core VDD or slowing down the CPU operating frequency is ideal to work across a variety of conditions. Although the adjustments recommended above may be  used to find a working setup and allow further development to take place, these  adjustments cannot be guaranteed to alleviate the issue across devices, hardware  platforms, and temperature.  SPRZ291I – October 2008 – Revised June 2014  OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0  55  Submit Documentation Feedback  Copyright © 2008–2014, Texas Instruments Incorporated      	  1.0      	 1.0.12  SPI Communication Failure for Data Receipt  	 	 	TI
OMAP-L138	   Note: DMA refers to all non-CPU requests. This includes Internal Direct Memory Access (IDMA) requests and all other system DMA master requests via the Slave Direct Memory Access (SDMA) port.  The C674x Megamodule uses a bandwidth management (BWM) system to arbitrate  between DMA and CPU requests issued to L2 RAM. See TMS320C674x DSP  Megamodule Reference Guide, Literature Number - SPRUFK5 for more information on  the BWM. BWM arbitration grants L2 bandwidth based on programmable priorities and  contention- cycle-counters. The contention-cycle-counters count the number of cycles for which the associated L2 requests are blocked by higher priority requests. When the  contention-cycle-counter reaches a programmed threshold (MAXWAIT), the associated  L2 request is granted a slice of L2 bandwidth. This prevents indefinite blocking of low priority requests when faced with the continuous presence of higher priority requests.  Ideally, the BWM arbitration will grant equal L2 bandwidth between equal priority DMA and CPU requests. Instead, when equal priority DMA and CPU requests arrive at the  BWM, bandwidth is always granted in favor of the CPU over DMA. In the case of  successive CPU requests, it is possible for the CPU to block all DMA requests until CPU  traffic subsides. Additionally, some command logic in the BWM uses priority level 7, which can also result in SDMA stalls when the CPU is also programmed to priority level 7. Figure 3 shows a high level diagram of the arbitration scheme used for L2 RAM  requests.  C674x Megamodule  EDMA  SHAREDRESOURCE  ExternalSystemMasters  Programmable Priority  ARBITRA  MasterPriority  C674x CPU  EMAC  ARBITRA  Programmable Priority  IDMA  L2 RAM  TION  LCDC  Inherit  TION  Priority  SDMA  UHPI  USB  Highest Priority Master Granted Access.  Contention counters implemented to not  starve low priority requestors  Figure 3. Priority Arbitration Scheme for L2 RAM  	ARM9	 	 	 	  Configure DMA and CPU requests to different priority levels. There is no penalty for setting the IDMA and SDMA priorities equal to each other.  CPU request priority is programmed within the CPUARBU register:  /** Pseudo code only **/  Uint32 *CPUARBU;  CPUARBU = ( Uint32 * ) ( 0x01841000 );  /* Set priority different from IDMA/SDMA */  *CPUARBU = [CPU_PRIORITY];  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  9  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  IDMA request priority is programmed within the IDMA1_COUNT register  /** Pseudo code only **/  Uint32 *IDMA1_SRC, *IDMA1_DST;  Uint32 *IDMA1_CNT;  IDMA1_SRC = ( Uint32 * ) ( 0x01820108 );  IDMA1_DST = ( Uint32 * ) ( 0x0182010C );  IDMA1_CNT = ( Uint32 * ) ( 0x01820110 );  *IDMA1_SRC = sourceAddress;  *IDMA1_DST = destinationAddress;  /* Set IDMA priority different from CPU */  *IDMA_CNT = ( [IDMA_PRI] << [IDMA_PRI_SHIFT] ) | buffSize ;  SDMA request priority is inherited from the MSTPRIn registers  /** Pseudo code only **/  Uint32 *MSTPRI1, *MSTPRI2;  MSTPRI1 = ( Uint32 * ) ( 0x01C14114 );  MSTPRI2 = ( Uint32 * ) ( 0x01C14118 );  /* Set SDMA master priorities different from CPU */  *MSTPRI1 = [MAST_PRI] << [MAST_SHIFT];  *MSTPRI2 = [MAST_PRI] << [MAST_SHIFT];  10  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications 	      2.3 and earlier   	 2.3.1  DMA Access to L2 RAM Can Stall When DMA and C674x CPU Command Priorities  Are Equal  	 	 	TI
OMAP-L138	   When the USB controller is operating as a device and an attached host resets the device after the completion of the Device Attached state by driving both differential data lines low, the USB controller operating as a device could receive multiple RESET interrupts for the single RESET signaling invoked by the host. The multiple interrupt generation only happens for the duration of the RESET signaling on the bus. RESET Interrupt is not generated before or after the completion of RESET.  	ARM9	 	 	 	  Software must service every USB RESET interrupt received. Software should not  proceed on performing any other task, like initialization, until RESET duration has come to completion. The POWER[RESET] bit field will be cleared by the USB Controller when RESET signaling on the bus is removed by the Host. The USB Controller clearing the  POWER[RESET] bit field should be used by software as an indication for the completion of RESET signaling.  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  11  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  	      2.3 and earlier   	 2.3.3  USB0: Extraneous RESET Interrupt  	 	 	TI
OMAP-L138	   In Extended Wait mode, during a read access to an asynchronous memory, if the WAIT  input does not go inactive within maximum extended wait cycles programmed in the  Async Wait Cycle Config register, the EMIF will report a time-out error. The data  returned for this access will be all zeros. If this access is followed by a read to the EMIFA’s memory-mapped register (MMR) space, the EMIFA will still report a time-out  error but with the correct data for the MMR read. The EMIF will hold the time-out error until another asynchronous access without a time-out error or an SDRAM access is  performed.  This issue is only applicable if all of the following are true:  •  The EMIF is used for asynchronous memory accesses in Extended Wait mode.  •  There is a potential for a time-out error to occur, that is, the asynchronous memory will not de-assert the WAIT input.  •  If asynchronous memory read with time-out error is followed by an MMR read.  	ARM9	 	 	 	  If a time-out occurs, perform any of the following:  •  A dummy read to another asynchronous memory chip select that is not configured to  be in Extended Wait mode.  •  A dummy read to the same asynchronous memory chip select after disabling the  Extended Wait mode on that chip select.  •  A dummy read to SDRAM  12  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications 	      2.3 and earlier   	 2.3.4  EMIFA: Asynchronous Memory Timeout Error Persistence  	 	 	TI
OMAP-L138	   The C674x DSP megamodule supports twelve maskable hardware interrupt signals  (CPUINT4 through CPUINT15). Single system interrupts may be mapped directly to a  CPUINTn hardware interrupt, or multiple system interrupts may be combined by the  ECM into a single signal before mapping to a CPUINTn interrupt. See [SPRUFK5;  TMS320C674x DSP Megamodule] for more information on how DSP interrupts are  handled.  The ECM expects all incoming interrupts to be pulse interrupts, however the  [SYSCFG_CHIPSIG_]CHIPINTn interrupts are level interrupts. This mismatch in interrupt types will cause a single CHIPINTn interrupt event to register multiple times in the ECM.  	ARM9	 	 	 	  The CPUINTn hardware interrupts can support both pulse and level interrupts so  CHIPINTn interrupts should be mapped directly to CPUINTn hardware interrupts.  Furthermore, if the ECM is used for other system interrupts, the CHIPINTn interrupts should be masked out in the EVTMASKn registers.  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  13  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  	      2.3 and earlier   	 2.3.5  A Single CHIPINTn Interrupt Event Will Register Multiple Times in the DSP Event  Combiner Module (ECM)  	 	 	TI
OMAP-L138	   When a soft reset is invoked by setting the RESET bit of the USB CTRLR register (  CTRLR[RESET] = 1 ), the internal reset timing requirements may be violated. Although this timing violation has not been observed in practice, the potential for a timing violation exists.  USB resets initiated by system-reset and power-on-reset are immune from the timing  violation.  There is no plan to fix this issue in future silicon revisions because:  1. No functional problems have been observed to date  2. A software workaround has been developed to avoid the problem  	ARM9	 	 	 	  The reset timing violation can be avoided by providing the modified soft reset activation sequence outlined below:  1. Enable the USB controller module clock through the Power and Sleep Controller  (PSC)      2. Perform a soft USB reset   3. Wait for the USB soft reset bit to clear  4. Disable the USB controller module clock through the PSC  5. Configure the USB PHY parameters      6. Enable the PHY   7. Enable the USB controller module clock through the PSC  14  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications 	      2.3 and earlier   	 2.3.6  Potential USB2.0 Soft Reset Timing Violation  	 	 	TI
OMAP-L138	   The input buffers on the device have shown timing sensitivity to the logic-low input voltage that can cause changes to the AC input timings. Due to this issue, input voltages must be driven to 0.5V or below on all dual-voltage LVCMOS input signals (signals  associated with supplies DVDD1833_A, DVDD1833_B or DVDD1833_C).  Vil driven at or below 0.4V will cause no timing degradation. Vil driven up to 0.5V will cause up to 750 ps degradation in input timings.  The following datasheet parameters will be affected by Vil driven up to 0.5V. Their values adjusted for 0.75 ns degradation are shown.  Table 3. Timing Requirements for the EMIFA SDRAM Interface      1.2V   NO.  PARAMETER  UNIT  MIN  MAX  Input Setup time, read data valid on  19  t      2.75   ns   su(EMA_DV-EM_CLKH)  EMA_D[31:0]  Table 4. Timing Requirements for the EMIFA Asynchronous Memory Interface      1.2V   NO.  PARAMETER  UNIT  MIN  MAX  Setup time, EMA_D[31:0] valid before EMA_OE  12  t      3.75   ns   su(EMDV-EMOEH)  high  Table 5. Timing Requirements for McASP0      1.2V   NO.  PARAMETER  UNIT  MIN  MAX  AHCLKR/X ext input      1.15   Hold time, AFSR/X input after ACLKR/X  6  th(ACLKRX-AFSRX)  (1)  AHCLKR/X ext output      1.15   ns   AHCLKR/X ext input      1.15   Hold time, AXR0[n] input after  8  th(ACLKRX-AXR)  ACLKR/X (1) (2)  AHCLKR/X ext output      1.15   (1)  McASP0 ACLKXCTL.ASYNC=1: Receiver is clocked by its own ACLKR0  (2)  McASP0 ACLKXCTL.ASYNC=0: Receiver is clocked by transmitter's ACLKX0  Table 6. Switching Characteristics for McASP0      1.2V   NO.  PARAMETER  UNIT  MIN  MAX  ACLKR/X ext input      3.5   Delay time, ACLKR/X transmit edge to  13  td(ACLKRX-AFSRX)  AFSX/R output valid (1)  ACLKR/X ext output      3.5   ACLKR/X ext input      3.5   Delay time, ACLKX transmit edge to  14  td(ACLKX-AXRV)  ns  AXR output valid (1)  ACLKR/X ext output      3.5   Disable time, ACLKR/X transmit edge  15  t  to AXR high impedance following last  ACLKR/X ext      3.5   dis(ACLKX-AXRHZ)  data bit  (1)  McASP0 ACLKXCTL.ASYNC=1: Receiver is clocked by its own ACLKR0  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  15  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  Table 7. Timing Requirements for McBSP0      1.2V   NO.  PARAMETER  UNIT  MIN  MAX  Setup time, external FSR high before  5  t  CLKR ext      5.5   su(FRH-CKRL)  CLKR low  7  t  Setup time, DR valid before CLKR low  CLKR ext      5.5   ns   su(DRV-CKRL)  Setup time, external FSX high before  10  t  CLKR ext      5.5   su(FXH-CKXL)  CLKX low  Table 8. Switching Characteristics for McBSP0      1.2V   NO.  PARAMETER  UNIT  MIN  MAX  Delay time, CLKR high to internal FSR  4  t  CLKR ext      2.75   d(CKRH-FRV)  valid  Delay time, CLKX high to internal FSX  9  t  CLKR ext      2.75   ns   d(CKXH-FXV)  valid  2.75 + D1  13  t  Delay time, CLKX high to DX valid  CLKR ext  d(CKXH-DXV)  (1)  (1)  Extra delay from CLKX high to DX valid applies only to the first data bit of a device, if and only if DXENA = 1 in SPCR.  If DXENA = 0, then D1 = D2 = 0  If DXENA = 1, then D1 = 6P, D2 = 12P  Table 9. Switching Characteristics for McBSP1      1.2V   NO.  PARAMETER  UNIT  MIN  MAX  Delay time, CLKR high to internal FSR  4  t  CLKR ext      3.25   d(CKRH-FRV)  valid  Delay time, CLKX high to internal FSX  9  t  CLKR ext      3.25   ns   d(CKXH-FXV)  valid  3.25 + D1  13  t  Delay time, CLKX high to DX valid  CLKR ext  d(CKXH-DXV)  (1)  (1)  Extra delay from CLKX high to DX valid applies only to the first data bit of a device, if and only if DXENA = 1 in SPCR.  If DXENA = 0, then D1 = D2 = 0  If DXENA = 1, then D1 = 6P, D2 = 12P  Table 10. Timing Requirements for Universal Parallel Port (uPP)      1.2V   NO.  PARAMETER  UNIT  MIN  MAX  Setup time, CHn_START valid before CHn_CLK  4  t      4.75   su(STV-INCLKH)  high  Setup time, CHn_ENABLE valid before CHn_CLK  6  t      4.75   su(ENV-INCLKH)  high  Setup time, CHn_DATA/XDATA valid before  8  t      4.75   ns   su(DV-INCLKH)  CHn_CLK high  Setup time, CHn_DATA/XDATA valid before  10  t      4.75   su(DV-INCLKL)  CHn_CLK low  Setup time, CHn_WAIT valid before CHn_CLK  19  t      4.75   su(WTV-INCLKL)  high  16  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications Table 11. Timing Requirements for Video Port Interface (VPIF)      1.2V   NO.  PARAMETER  UNIT  MIN  MAX  Setup time, VP_DINx valid before VP_CLKIN0/1  1  t      4.75   ns   su(VDINV-VKIH)  high  	ARM9	 	 	 	  Although there is no specific workaround, the following recommendations can be used to help prevent this issue:  •  Minimize loads as much as possible, especially DC loads that could cause the Vil to rise. Point-to-point (single-load) connections are unlikely to be affected.  •  Falling edges should transition as rapidly as possible (so the signal passes through the 0.2V point as early as possible). Heavily loaded nodes resulting in degraded fall times may require drivers to provide rapid input edges.  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  17  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  	      2.3 and earlier   	 2.3.9  Vil on Dual-Voltage LVCMOS Input Buffers Operated at 3.3V  	 	 	TI
OMAP-L138	   The VSR register in the ARM Interrupt Controller (AINTC) is not correctly initialized after reset. If this register is not explicitly configured, the AINTC will only allocate 1 byte per interrupt (instead of 4).  	ARM9	 	 	 	  The desired value (even if it is the default value) should be written to the VSR prior to using the interrupt controller.  18  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications 	      2.3 and earlier   	 2.3.10  ARM Interrupt Controller Vector Size Register (VSR) Initialization  	 	 	TI
OMAP-L138	   Interrupts destined for the ARM CPU are managed by the ARM Interrupt Controller  (AINTC). The AINTC detects, combines, and routes system interrupts to the two native ARM interrupt signals FIQ and IRQ. See the device System Reference Guide for  additional information about the AINTC.  The AINTC module expects all incoming interrupts to be pulse interrupts, however the  [SYSCFG_CHIPSIG_]CHIPINTn interrupts are level interrupts. This mismatch in interrupt types will cause a single CHIPINTn interrupt event to register as multiple interrupt pulses in the AINTC. However, the AINTC does not have the capacity to count the number of  interrupt pulses received per system interrupt – it only maintains interrupt flags. A system interrupt is flagged as active until its status is cleared by the user through the AINTC, regardless of the number of interrupts detected.  If the status flag for AINTC CHIPINTn is cleared while the CHIPINTn interrupt is still active, the AINTC will continue to detect CHIPINTn interrupts and its status flag will be set again. This additional setting of the AINTC CHIPINTn status flag is false.  	ARM9	 	 	 	"  Method 1  Do not execute the intended interrupt service routine code if the associated CHIPSIGn status flag is not set in the SYSCFG_CHIPSIG register. A cleared CHIPSIGn status flag indicates that the device is responding to a false interrupt. This method is easy to implement, but does not eliminate false interrupts.  /** Pseudo code only **/  void CHIPINT0_ISR(void) {  /* Exit immediately if CHIPSIG0 is not set */  if( (SYSCFG->CHIPSIG & 0x1) == 0 ) {  return;  }  /* Intended service routine code */  SYSCFG->CHIPSIG_CLR = 0x1;  printf(""Hello World!\n"");  }  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  19  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  Method 2  Do not clear the AINTC CHIPINTn status flag until the CHIPSIGn status has been  cleared. This method will eliminate false interrupts, but requires changes to the AINTC  interrupt dispatch code. Changing the dispatch code may introduce undesired behavior in the application.  /** Pseudo code only **/  /* Sequence that is susceptible to false CHIPINTn interrupts */  void AINTC_ISR_DISPATCH_1(void) {  Get_Interrupt_Information();  /* CHIPINTn interrupts continue to be generated after */  /* AINTC CHIPINTn flag is cleared.  */  Clear_AINTC_Interrupt_Flag();  /* CHIPINTn interrupts are only stopped after ISR clears */  /* the status flag.  */  Branch_To_ISR();  }  /* Sequence that is not susceptible to false CHIPINTn interrupts */  void AINTC_ISR_DISPATCH_2(void) {  Get_Interrupt_Information();  /* ISR will clear CHIPSIGn flag and discontinue CHIPINTn */  /* interrupts to AINTC.  */  Branch_To_ISR();  /* Ok to clear AINTC CHIPINTn flag now.  */  Clear_AINTC_Interrupt_Flag();  }  20  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications "	      2.3 and earlier   	 2.3.12  A Single CHIPINTn Interrupt Event Can Register Multiple Times in the AINTC  	 	 	TI
OMAP-L138	   The C674x CPU supports a Saturation feature for key arithmetic operations. If an  operation results in saturation, the SAT (saturation) bit in the control status register (CSR) is set. In normal operation, one or more functional units can simultaneously  perform arithmetic operations that can result in saturation. In the case of simultaneous arithmetic operations, the SAT bit is set if at least one functional unit’s operation results in saturation. The saturation status register (SSR) provides saturation flags for each functional unit, making it possible for the program to distinguish between saturations caused by different instructions in the same execute packet. Also, there is no direct connection to the SAT bit in the control status register (CSR); writes to the SAT bit have no effect on SSR and writes to SSR have no effect on the SAT bit.  In the case where a 2 cycle .M unit instruction is in the delay slot of a 4 cycle instruction of the same .M unit, and if both instructions are expected to generate results in the same cycle, the CSR:SAT bit will be incorrectly masked. Ideally, the CSR:SAT bit should be set if any one of the two .M unit instruction causes a saturation. Instead, the arithmetic saturation result of the 2 cycle .M unit instruction will overwrite the CSR:SAT bit.  All of the following must take place in order for an application to be affected by this advisory:  1. A 2 cycle .M unit instruction and a 4 cycle .M unit instruction are issued  simultaneously  2. Both instructions are processed on the same side  3. The 2 cycle instruction is in the delay slot of the 4 cycle instruction so that the results of both instructions are generated in the same cycle  4. The saturation result of the 4 cycle .M unit instruction is different from the saturation result of the 2 cycle .M unit instruction  5. The application checks for the saturation flag and uses the saturation result of the 4  cycle instruction  	ARM9	 	 	 	  Perform one of the following:  •  For the location of code where saturation results are monitored, do not mix datatypes so that 2 cycle and 4 cycle .M unit instructions are not issued together.  •  Do not mix floating point .M unit instruction with fixed point 2 cycle .M unit  instructions.  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  21  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  	      2.3 and earlier   	 2.3.13  Incorrect Masking of the C674x CSR:SAT Bit  	 	 	TI
OMAP-L138	   Note: SDMA refers to all non-CPU requests to the EMC SDMA (Slave Direct Memory Access) port (see Figure 4). SDMA requests are defined as external system bus master requests handled via this port.  The C674x Megamodule uses a two-way set associative cache for L1D. This means that  every physical memory location in the system has two possible set/way locations in the cache where it can reside. See TMS320C674x DSP Megamodule Reference Guide  (Literature Number SPRUFK5) for more information on the L1D cache architecture and  related terminology. Updated (dirty) values in L1D cache are not written back to external memory until cache activity evicts a cache-line (victim write-back) or a write-back is requested by software.  An L1D cache-line corruption event occurs when all of the conditions in the following steps are met (see Figure 4):  1. L1D cache Lines 1, 2, and 3 have the following characteristics:  •  Line 1 is associated with L2 SRAM (Line A in Figure 4), was previously read by  CPU, and is clean. (CPU has not updated the data.)  •  Line 2 is associated with L2 SRAM (Line B in Figure 4), was previously read by  CPU, and is clean. (CPU has not updated the data.)  •  Line 3 was previously read by the CPU and may be either clean or dirty.  2. SDMA receives updated data for L2 SRAM Lines A and B, which correspond to L1D  cache Lines 1 and 2.  3. A snoop write operation is initiated by the L2 to overwrite the L1D cache Lines 1 and 2 with updated L2 SRAM Lines A and B. Before the snoop write operation finishes,  the CPU performs two reads within the same clock cycle:  •  Line E in L2 cache is read as a cache hit. Line E is destined to replace Line 2 in  L1D Cache, which also has a snoop write pending for the updated Line B  content.  •  Line D in L2 SRAM is read. Line D will replace Line 3 in L1D cache.  4. When the snoop write operation completes, Line 2 in L1D cache now contains the  updated L2 SRAM Line B data instead of the L2 cache Line E data.  The correct behavior would have been to kill the pending snoop write initiated to update L1D cache Line 2 with the updated L2 SRAM Line B data in Step 3. The L1D cache  should have evicted Line B and replaced it with Line E data. Instead, the snoop write operation continues and does not complete until after the L1D cache Line 2 has already been replaced with L2 cache Line E data. The snoop write instruction overwrites the L1D  cache Line 2 (containing L2 cache Line E data) with the updated L2 SRAM Line B data.  22  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications Time Line  System View  Line A  Line E and Line B Map to  STEP 1  STEP 2  STEP 3  STEP 4  same L1D Cache line.  Line A  B  C674x subsystem  Line A  C  C6xCPU  Read Line D  L2  Line A  D  Activity  Read Line E  C6X CPU  Controller  L2 SRAM  SDMA  Write Line A Snoop Write  Line A  E  Activity  Write Line B  Initiated  L1D  EMC  L2 CACHE  L1D Cache  Clean Line A Clean Line A  IN FLUX  Clean Line A  Controller  SDMA PORT  Line 1  (New Data)  L1D Cache  Clean Line B Clean Line B  IN FLUX  CORRUPT  EMAC  Line 2  Line E replaces Line B due  Line  Line 1 A  [A]  PRU  L1D Cache  Clean/Dirty  Clean/Dirty  IN FLUX  Clean Line D  to CPU read.  Line 3  Line C  Line C  Line  Line 2 A  [B/E] Delayed snoop wrtie to Line  EDMA  SYSTEMMASTERS  Line  Line 3 A  [C/D] B corrupts Line E in L1D$  L1D  Corruption happens  CACHE  UHPI  because of this state  EXTERNAL  Figure 4. Example of L1D Cache Corruption  	ARM9	 	 	 	  Method 1: Do not perform two CPU read operations in the same clock cycle. For C  code, use compiler flag (--c64p_dma_l1d_workaround) available in the C6000  Compiler (CodeGen) Tools version 7.0.2 and later. For assembly code, the --  c64p_dma_l1d_workaround flag will only issue a warning.  Method 2: In cases where buffer access will not be shared between CPU and SDMA, unintended CPU/SDMA cache-line sharing can be avoided by aligning CPU and SDMA  buffers to 64-byte boundaries. Aligning buffers to 64-byte boundaries will result in wasted space, however it ensures that the CPU and SDMA buffers will not have partial  segments which overlap into the same L1D cache line.  /** Pseudo code only **/  Uint8 *SDMA_BUFF, *CPU_BUFF;  /* 64-byte aligned allocation Option 1 */  SDMA_BUFF = malloc( (Int32) (( SDMA_BUFF_SIZE + 63)/64) * 64 );  CPU_BUFF = malloc( (Int32) ((CPU_BUFF_SIZE + 63)/64) * 64 );  SDMA_BUFF = (Uint8 *) ( (Int32) SDMA_BUFF & ~63 );  CPU_BUFF = (Uint8 *) ( (Int32) CPU_BUFF & ~63 );  /* 64-byte aligned allocation Option 2 with BIOS Call */  SDMA_BUFF = MEM_alloc( IRAM, SDMA_BUFF_SIZE, 64 );  CPU_BUFF = MEM_alloc( IRAM, CPU_BUFF_SIZE, 64 );  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  23  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  Method 3 Manage access to a 64-byte boundary aligned buffer that is shared between CPU and SDMA by implementing a semaphore and forcing cache writeback operations if  there are CPU writes. With this method, the semaphore ensures that there is clear  ownership of the buffer between CPU and SDMA, and the CPU manages cache  coherence by using explicit cache writeback operations.  /** Pseudo code only **/  /* Example with EDMA as the external master */  EDMA_ISR() {  /* EDMA releases ownership of buffer */  SEM_post(SyncSemaphore);  return;  }  main() {  while(COND) {  /* CPU waits for ownership of buffer */  SEM_pend(SyncSemaphore);  /**********************/  /*** CPU Processing ***/  /**********************/  /* Cache writeback for shared block */  /* Buffer must be 64-byte aligned */  BCACHE_wbInv( blockPtr, blockSize, WAIT );  /* Initiate EDMA */  EDMA_Event_Generate();  }  }  Method 4 Do not allow SDMA to access L2 RAM. SDMA can use buffers in L1D RAM or Shared RAM instead of L2 RAM.  Method 5 Configure the entire L2 RAM as cache. Critical peripheral data can be accessed in L1D RAM or Shared RAM instead of L2 RAM.  Method 6 Configure the entire L2 RAM as normal SRAM (no cache).  Method 7 Configure the entire L1D RAM as normal SRAM (no cache).  24  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications 	      2.3 and earlier   	 2.3.17  SDMA Activity Can Corrupt L1D When L2 Is Configured as Mixed/Cache/SRAM  	 	 	TI
OMAP-L138	   A condition can occur during the device power supply ramp in which the DVDD18  supply, which should be at 1.8V nominal, can be pulled up on-chip by the DVDD3318_A, DVDD3318_B or DVDD3318_C supplies operated at 3.3V. For the sake of this  description, DVDD3318_x means any combination of DVDD3318_A, DVDD3318_B or  DVDD3318_C.  Important Note: The 3.3V DVDD3318_x supplies must not be driven to 0V during zones A – E or high current capable of damaging the device may occur. The 3.3V  DVDD3318_x supplies should not be driven during this time.  A normal example power-supply ramp is shown below:  A  B  C  D  E  F  G      3.3V   VT   1.8V      1.2V   Figure 5. Normal power-supply ramp  •  A. All device supplies are undriven  •  B. The 1.2V supplies are ramped to their nominal levels  •  C. Potential delay between supply ramps (not required)  •  D. The 1.8V supplies (specifically DVDD18) are ramped to their nominal levels.  During the DVDD18 ramp there will be some minor drift up in the undriven  DVDD3318_x supplies. This is normal and is not a problem.  •  E. Potential delay between supply ramps (not required)  •  F. DVDD3318_x is ramping but is less than DVDD18 + VT  •  G. DVDD3318_x is ramping but is greater than DVDD18 + VT  When the fault condition occurs, the supplies behave as shown below:  A  B  C  D  E  F  G  3.3V      ~2.7V   VT   1.2V   Figure 6. Faulty power-supply ramp  The behavior is the same until zone G. When the DVDD3318_x supply exceeds  DVDD18 by a transistor V , the DVDD18 supply begins to be pulled up by the  T  DVDD3318_x supply and follows the DVDD3318_x supply by DVDD3318_x- V . Since  T  the DVDD18 supply is often connected to other 1.8V supplies in the design, these other supplies can be pulled up also.  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  25  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  The condition occurs because the dual-voltage IO buffers have voltage detection circuitry that monitors DVDD3318_x during reset and determines whether the applied supply  voltage is 1.8V or 3.3V. This detection circuitry then configures the IOs to operate at the appropriate voltage. As the DVDD3318_x supply ramps, there is a small range near  DVDD18 + V where the voltage detection circuit finds the state indeterminate and briefly T  turns on circuitry associated with both voltage options creating a current path between them. This current path can cause the DVDD18 supply to be pulled up. The mechanism  for this behavior is explained below:  DVDD3318_x  Dual-Voltage IO Buffer  Behavior of the IO buffer during Zone F:  As the DVDD3318_x supply ramps, but is not yet one V above the  T  DVDD18 supply, the comparator enables the 1.8V mode logic      3.3V Mode   section and disables the 3.3V mode logic section. No unexpected  Enable  Logic  +  current flows between the two sections.  DVDD18  -      1.8V Mode   Enable   Logic  Iload  External  Loads  Figure 7. Behavior of the IO buffer during Zone F  DVDD3318_x  Dual-Voltage IO Buffer  Error State of the IO buffer during Zone G:  As DVDD3318_x exceeds DVDD18+V , some of the circuitry  T  across the boundary of the two voltage domains will turn on and      3.3V Mode   DVDD18   Enable  causes a leakage current (in red) to flow between the two voltage  Logic  +  domains. This current pulls up the DVDD18 supply unless the  Ileakage  power source providing that supply can oppose it or unless the  -  load current is strong enough to counteract it.  Enable 1.8V Mode  Logic  If DVDD18 continues to rise as DVDD3318_x ramps, the  I  comparator never sees enough difference between the two  load  supplies to switch to 3.3V mode.  External  Loads  Figure 8. Error State of the IO buffer during Zone G  DVDD3318_x  Dual-Voltage IO Buffer  Recovered State of the IO buffer during Zone G:  If the load current is high enough or the DVDD18 power supply can  oppose the leakage current, then the DVDD18 voltage stays low      3.3V Mode   enough for:   Enable  Logic  +  DVDD18  • the comparator to recognize 3.3V mode  • the 1.8V mode logic is turned off  -      1.8V Mode   • the leakage stops  Enable  Logic  Iload  External  Loads  Figure 9. Recovered State of the IO buffer during Zone G  26  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications This error condition may occur when either of the following conditions are present:  •  The regulator used to control the DVDD18 supply can only regulate voltage up and  relies on the load to pull the output voltage down  •  There is low load on the DVDD18 supply during the DVDD3318_x power supply  ramp  This condition will not occur in designs where:  •  All DVDD3318_x supplies are operated at 1.8V, or  •  The regulator used to supply DVDD18 has the capability to actively regulate (drive) its output voltage up or down and doesn’t rely on system load to pull the voltage  down, or  •  The load on the DVDD18 supply during the DVDD3318_x power supply ramp is  sufficient to oppose the leakage current.  	ARM9	 	 	 	  1. Design simulation has indicated that under the worst-case  process/voltage/temperature conditions the maximum leakage current into the  DVDD18 supply due to this phenomenon will be 140 mA (the 140 mA is a cumulative  current generated by all of the dual-voltage IOs). So this error state can be prevented by ensuring that the load on the DVDD18 supply during the DVDD13318_x supply  ramp exceeds 140 mA. This can be achieved by any combination of the following as  long as they cumulatively produce >140 mA load on DVDD18 during the  DVDD3318_x ramp period:  (a) Maintain sufficient bulk capacitance on the DVDD18 supply such that the charging current for these capacitors provides all or part of the required >140 mA. Bulk  capacitance in this context means the total capacitance seen by the DVDD18  supply (filter capacitors, bypass capacitors, etc.). Capacitor charging current is  defined as I = C*(dV/dt). So the ramp rate of the DVDD3318_x supply and the  total bulk capacitance on the DVDD18 supply can be used to calculate the current  produced. This solution provides additional power supply filtering and little current leakage after the supplies are ramped (depending on the type of capacitors used).  The table below shows some examples of the bulk capacitance that would be  required to use this solution alone:  Table 12. Bulk Capacitance  DVDD3318_x ramp  dV/dt (in V per second)  Required capacitance to generate 140 mA  time for 3.3V  100 µs  33000  4.2 µF  250 µs  13200  10.6 µF  500 µs  6600  21.2 µF  1 ms  3300  42.4 µF  10 ms  330  424.2 µF  (b) Use an additional shunt regulator to control the voltage at DVDD18. The shunt  regulator is placed between DVDD18 and Vss. As an example, the TLVH431 can  provide up to 70 mA of additional load current to help maintain the DVDD18  voltage. When the voltage drops back to the normal 1.8V range, the current flow  through the shunt regulator drops into the <100 uA range. This solution requires the shunt regulator and two additional resistors to set the desired regulation  voltage.  (c) Use a resistor to provide additional load between DVDD18 and Vss. This solution is less desirable since it continues to draw power even after the supply ramp is  completed but would likely be the lowest cost. An improvement is to use a  FET/switch in series with the resistor between DVDD18 and Vss that can later be  turned off (by the RESET signal or a GPIO signal for example).  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  27  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      2.   Choose a regulator for the DVDD18 supply (or grouped 1.8V supplies) that is  capable of actively regulating voltage up and down. Many high-efficiency switching  regulators switch current into the load only when the voltage needs to be raised and rely on the load to pulldown the current. In this error condition, a regulator of this type will not be able to compensate for the leakage current described above.  Synchronous buck regulators use external inductance to pulldown the regulated  voltage when necessary.  28  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications 	      2.3 and earlier   	 2.3.18  DVDD18 Can Pull Up to 2.7V When Using Dual-Voltage IOs at 3.3V  	 	 	TI
OMAP-L138	   The USB 2.0 On-The-Go (OTG) Session Request Protocol (SRP) allows a USB-  peripheral to request the USB-host to enable Vbus and start a session. On this device, the SRP protocol is not supported.  The OTG Host Negotiation Protocol (HNP), which allows USB-devices to swap roles  between host and peripheral, is supported.  	ARM9	 	 	 	  None  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  29  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  	      2.3 and earlier   	 2.3.19  USB 2.0 On-The-Go (OTG) Session Request Protocol (SRP) Is Not Supported  	 	 	TI
OMAP-L138	:   When connecting a SATA GEN3 capable target, for example a Hard Disk Drive (HDD),  to a device with a SATA Host Subsystem (after power-up or reset) the speed negotiation fails between the two devices and no link is established.  Two different types of failure behaviors with the same results have been observed:  Losing Synchronization:  The Target (Device) always starts the speed negotiation at the highest speed supported, in this case GEN3, by sending an ALIGNp primitive data pattern to the Host SATA  subsystem. The Host SATA subsystem sends a continuous D10.2 Tone at GEN1 speed  (1.5 GBits/sec) and should ideally remain at this state until the Host recognizes the Targets' ALIGNp primitive data pattern [at GEN2 or GEN1 but not GEN3 speed]. While  the Target (Device) is still at GEN3, due to aliasing, etc., the Host SATA subsystem falsely responds back to the Device with an ALIGNp primitive data pattern at a different speed (GEN2 speed). The Host completes the speed negotiation at GEN2 speed and  transitions to a logical IDLE state (Non-ALIGNp primitive SYNCp) before the Target  (Device) timeout period expires (54.6 µs). Once the timeout period expires for GEN3  speed, the Target (Device) starts sending an ALIGNp primitive data pattern at GEN2  speed, expecting an ALIGNp primitive data pattern from the Host which never happens because the Host is in a logical IDLE state at GEN2 speed. Another timeout period  expires because the target (Device) did not receive the ALIGNp primitive data pattern at GEN2 speed. This forces the Target (Device) to drop its speed from GEN2 to GEN1 and attempt to establish a link at GEN1 speed. The Host still remains in a logical IDLE state at GEN2 speed. After the final timeout period expires, the Target (Device) requests a RESET (by sending COMINIT signal) to restart the link establishment process with the Host. This new link establishment results in the same outcome with the Host and Target always being out of sync.  Unknown State/Lock-up:  The Target (Device) always starts the speed negotiation at the highest speed supported, in this case GEN3, by sending an ALIGNp primitive data pattern to the Host SATA  subsystem. The Host SATA subsystem sends a continuous D10.2 Tone at GEN1 speed  (1.5 GBits/sec) and ideally should remains at this state until the Host recognizes the Targets' ALIGNp primitive data pattern [at GEN2 or GEN1 but not GEN3 speed]. While  the Target (Device) is still at GEN3, due to aliasing, etc., the Host SATA subsystem falsely responds back to the Target (Device) with an ALIGNp primitive data pattern at a different speed (GEN2 speed) and remains at this state (sending the GEN2 ALIGNp  primitive). The Target (Device) times out (54.6 µs) and starts sending an ALIGNp  primitive data pattern at GEN2 speed. Target (Device) now recognizes the Host GEN2  ALIGNp primitive data pattern and responds with a logical IDLE state (Non-ALIGNp  primitive SYNCp) completing the link establishment from the Target (Device)  perspective. However, the Host is stuck in an unknown state sending GEN2 ALIGNp  primitive and never completes the link establishment. Both the Host and Target (Device) remain at this state until a higher Host SATA Controller application (User S/W) performs a Reset.  Note: This issue does not apply to Target devices with maximum speed capability of GEN2 or GEN1 speed.  30  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications 	ARM9	 	 	 	:  •  Use GEN2 or GEN1 maximum speed drives to avoid the issue  or  •  Use GEN3 drives with jumper restricting capabilities to restrict their speed to GEN2  or  •  The Host Application S/W can continually perform Port resets to restart the link  establishment eventually succeeding in establishing a link. Note: This is not a preferred method because an excessive amount of resets might be required to  establishment the link.  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  31  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  	:      2.3 and earlier   	 2.3.22  SATA: Link Establishment Fails With SATA GEN3 Capable Targets  	 	 	TI
OMAP-L138	:   The PUPD_SEL[29] register does not get initialized when the device is first powered on and in Reset. This register controls the internal pullup and pulldown resistors for the BOOT[7:0] pins. The contents of the PUPD_SEL[29] register at this state are  unpredictable and may contain random values. These random values can result in the  internal pullups being enabled for some or all of the BOOT[7:0] pins during reset after every power-on, which conflicts with the datasheet claim that the internal pulldowns are enabled during reset.  Internal pullups being enabled on the BOOT[7:0] pins may result in boot failures. If weak external pulldown resistors are used on the PCB to select the boot mode, they may not be able to overpower the internal pullups. This can result in the wrong boot mode being latched in the BOOTCFG[7:0] register when coming out of Reset.  Once the device is out of Reset, the PUPD_SEL[29] register is initialized, and the  internal pulldown resistors for the BOOT[7:0] pins are all enabled. Issuing a second Power-On Reset (POR) results in the intended boot mode being latched, since the pins are internally pulled down as expected.  Figure 10 shows the behavior of the PUPD_SEL[29] register before and after reset.  Assuming weak or no external pull resistors are on the BOOT[7:0] pins, the BOOTCFG  register will latch the unknown values after the device initially comes out of Reset. Note that, TRST must always be low in order to issue a POR and latch the boot pin values --  the boot pins are not latched after a Warm Reset.  RESET  TRST  PUPD_SEL[29] Register  0h  BOOTCFG[7:0] Registers  Figure 10. Initialization of PUPD_SEL[29] and BOOTCFG[7:0] Registers with Weak or No External Pull Resistors on BOOT[7:0] Pins  Other device pins with configurable internal pullup or pulldown resistors are always internally pulled down during reset and are not affected by this advisory.  	ARM9	 	 	 	:  One of the following Workarounds must be implemented to ensure that the boot pins are always latched correctly:  Method 1  Use strong external pull resistors on BOOT[7:0] pins. Since either the internal pullup or pulldown resistors could be enabled after every power-on, the external resistors must be strong enough to oppose the internal pulls in either case.  Section 4, Device Operating Conditions, of the device datasheet shows the electrical characteristics information which can be used to calculate the maximum external pull resistance required. The value is dependent on the DVDD3318_C I/O supply level.  For BOOT pins which need to be sampled as logical low, the external pulldown  resistance (R  ) must be selected by assuming the internal pullup is enabled. The  PDmax  calculation is shown in Table 13.  32  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications Table 13. Required Pulldown Resistance (R  ) for Logical Low BOOT Pins  PDmax  æ V ö  IL  ç  ÷  DVDD3318_C  I  V  I  IL  è I  R  I ø  PDmax      3.3 V   310 µA      0.80 V   2.58 kΩ      1.8 V   310 µA      0.80 V   2.03 kΩ  For BOOT pins which need to be sampled as logical high, the external pullup resistance (R  ) must be selected by assuming the internal pulldown is enabled. The calculation  PUmax  is shown in Table 2.  Table 14. Required Pullup Resistance (R  ) for Logical High BOOT Pins  PUmax  æ DVDD 3318 _ C - V  ö  IH  ç  ÷  DVDD3318_C  I  V  I  IH  I  è  I  ø  RPUmax      3.3 V   270 µA      2.00 V   4.81 kΩ      1.8 V   270 µA      1.17 V   2.33 kΩ  Method 2  For applications that have already implemented the Secondary Reset Workaround  described in 	      2.3 and earlier   	 2.3.23  BOOT: Internal Pullup Resistors for BOOT[7:0] Pins Are Sometimes Enabled  During Reset, Leading to Boot Failures  	 	 	TI
OMAP-L138	Details	ARM9	 	 	 	Workaround(s)	Revision(s) Affected	 2.0.20, no additional modifications are required as a fix for this Advisory.  As shown in Figure 10, issuing a second POR will always latch the BOOT pins while the internal pulldown resistors enabled.  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  33  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  	 	 	TI
OMAP-L138	":  The ROM bootloader (RBL) reads a NAND page in segments of 512 bytes (user data)  over the External Memory Interface A (EMIFA). The EMIF also reads the associated  ECC data which is stored in the spare area of the flash (as shown in Figure 11). The ECC Correct function in the RBL can correct up to 4 bit errors in the user data and/or ECC data by using the syndrome generated from the ECC data and the parity of the  user data calculated by the EMIFA module.  However, over the life span of the NAND flash, ECC data stored in the spare area can develop errors due to bit flips. When the calculated syndrome indicates an error in the ECC data, the ECC Correct and Read functions of the RBL abort the read process even though, it is possible to correct up to 4 bit errors combined in user and ECC data.  Consequently the device fails to boot.  Explanation of Current ROM Bootloader Behavior:  The RBL implements a search mechanism to look for the boot image in NAND flash by  using an Open function and a Read function. The Open function includes a bad block  check where the RBL skips to the next block (shown as (A) in Figure 11) if the block under consideration is marked as ""bad"" (in the spare area). On finding a good block, the RBL attempts to read page0 (the first page) in that block.  If page0 of the good block has an ECC data error or an uncorrectable error (more than 4  bit errors combined), the RBL skips to the next block (shown as (B) in Figure 11). This bad block check mechanism enables the device to check up to the first 32 blocks in the NAND flash for booting (the boot process will fail if all 32 blocks have uncorrectable or ECC data errors in page0). Note that the RBL does not abort on detecting an error in ECC data on page0.  Once the RBL finds a good block with a good page0, it continues to read subsequent  pages in that block. If an uncorrectable or ECC error is detected in subsequent pages, the RBL will abort with a boot error (shown as (C) in Figure 11). The workaround,  described below, enables the boot process to continue for both types of errors (ECC  data and uncorrectable errors).  34  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated    www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications (1)  All pages marked in green are good and all pages marked in red have ""uncorrectable"" errors.  Figure 11. D800K008 ROM Behavior Before Application of Software Patch(1)  "	ARM9	 	 	 	":  The workaround ignores errors in ECC data (these errors do not need to be corrected) so that the boot process can continue, correcting errors in the user data (up to 4 bit errors total), as necessary. The workaround also includes a mechanism to restart the NAND read process from the next good block if an uncorrectable error (more than 4 bit errors) is detected on any page of a good block.  This workaround is implemented using a software patch that is loaded in device RAM at boot time and is designed to change the default behavior of the ECC Correct and Read functions in the RBL. The patch binary replaces function pointers to the ECC Correct and Read functions in the ROM function table, (defined in device internal memory),  during boot. The patch binary will reside in page0 of the NAND block and so will be applied only after the page0 of a good block has been read.  Once the patch is read, all subsequent page reads in the block will use the new ECC  Correct and Read functions. ECC data errors on any page (other than page0) are  ignored, any user data error (up to 4 bit errors total) is corrected and the boot process continues. If an uncorrectable error is detected on any page, the block is skipped and the boot process is restarted on the next good block. The behavior of the device boot from the NAND after application of the patch is shown in Figure 12.  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  35  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated    Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  (1)  All pages marked in green are good and all pages marked in red have ""uncorrectable"" errors.  Figure 12. D800K008 ROM Behavior With Software Patch Applied(1)  The software patch is available as a pre-built file with the latest version of the AIS tool that is used to generate the NAND flash boot image. The Using the OMAP-L132/L138  Bootloader Application Report (Literature number: SPRAB41) provides a link to the install package for the AIS tool which includes the following in the install directory: prebuilt patch files, the GUI AIS generation tool (AISGEN.exe, version 1.11 or later), command-line AIS generation tool and an example INI file.  Application of the Software Patch to NAND Boot Images:  •  For the GUI tool, AISGEN.exe version 1.11 or later (found in the install directory), the patch integrates the modified ECC Correct function into the user application file to generate one binary AIS file.  •  For the Command line AIS tool, HEXAIS_OMAP_L138.exe users (found in the install  directory), the patch can be integrated into the user application file to generate one binary AIS file by inserting lines below to the end of the INI configuration file.  The patch name is: ARM_nand_ecc_patch_OMAP-L138.out  36  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications  [INPUTFILE] ; get the NAND ECC patch file  FILENAME=Patch_name.out  ; patch the NAND ECC handling routine  [AIS_Jump]  LOCATION=_NAND_ECC_patchApply  •  The patch will be burnt on page0, as it is in the head of AIS file. Once page0 has  been read successfully, the AIS set command will overwrite the function pointer in the RBL with the modified function pointer and the modified function will be applied to the later pages read. Memory usage of the patch at boot time is as follows:  –  500 bytes at location 0xFFFF 0B00  Recommendations to Improve Robustness:  •  Page0 should be stored on multiple blocks as backup to take advantage of the safety mechanism built into Silicon Revision 2.1 to cycle to the next block when a page0  read fails in a good block.  •  Maintain backup boot images in multiple blocks. The patch to the Abort function  reinitializes the boot process and forces the boot to cycle to the next good block and restart the boot process by reading from it.  •  Silicon Revision 2.1 supports booting from Block 0 of the flash which many NAND  manufacturers guarantee as a “more reliable” block than all other blocks. Hence,  setting up boot to start from that Block 0 could help improve the reliability of boot.  This is a hardware change, requiring the bootmode pins BOOT[6:5] = 1x.  For more details on the bootmode pins, see the Using the OMAP-L132/L138  Bootloader Application Report (Literature number: SPRAB41), NAND-Boot Modes.  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  37  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  "	  2.3 and 2.1 (ROM Versions D800K008)  	 2.3.24  Boot: ECC Data Error in Spare Area Causes NAND Boot Failure  	 	 	TI
OMAP-L138	   When CPPI DMA completes a receive data transaction it posts a write to the Rx data  buffer located in external memory, posts a write to update the descriptor located in external memory, and raises an interrupt to CPU. When the system load is high, the  posted writes to DDR may not be complete before the CPU receives the interrupt. In this case, the CPU would fetch stale receive data from the Rx data buffer located in external memory.  	ARM9	 	 	 	  Initialize the datalength descriptor field to zero. CPPI DMA updates this field after the completion of an RX DMA operation with the actual number of bytes received. In the ISR  (actually in a deferred call context), poll this field until it becomes a non-zero value to ensure data buffer has been updated with actual data. The descriptor buffer write is posted after the data buffer write, so waiting for the descriptor field to be updated ensures the data buffer has been updated. Since this workaround involves deferred  procedure calls (whose schedule can be delayed depending on OS load), the latency  sensitive application (like ISO Audio) might be affected by delay in notification to the application.  38  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications 	      2.3 and earlier   	 2.3.25  USB0: CPU gets Stale Receive Data from the Data Buffer located in External  Memory  	 	 	TI
OMAP-L138	   The erroneous short packet status can be detected on current endpoint and XDMA  closes the Rx transfer in current endpoint. When more than one endpoint have been  processed, if one of the endpoints has a short packet, then the short packet status is broadcasting to all endpoints.  This results in premature completion of a Rx descriptor in generic RNDIS CPPI DMA  mode.  	ARM9	 	 	 	  The workaround involves monitoring transfer data size before and after transferring and reconfiguring data transfer size by software if the before and after size is different.  Software must keep tracking every endpoint data transferring size. When DMA  completion interrupt is received, software checks size difference. If the size is not equal, software requests the remaining data.  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  39  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  	      2.3 and earlier   	 2.3.26  USB0: Early DMA Completion in DMA Receive Mode and More Than One Endpoint  is Transferring Data  	 	 	TI
OMAP-L138	   Teardown receive DMA is not working perfectly. This happens when a teardown is  initiated by software during the endpoint is still active. Frequent teardown results in XDMA hung up situation.  	ARM9	 	 	 	  Software should make sure that DMA does not get to an unknown state during teardown by disabling the DMAEN bit in the RXCSR register. After this the teardown procedure can be initiated. Software should also add 250 ms delay during teardown.  40  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.1 Usage Notes and Known Design Exceptions to Functional Specifications 3  Silicon Revision 2.1 Usage Notes and Known Design Exceptions to Functional  Specifications  This section describes the usage notes and advisories that apply to silicon revision 2.1 and earlier of the device.      3.1   Usage Notes for Silicon Revision 2.1  Usage notes highlight and describe particular situations where the device's behavior may not match presumed or documented behavior. This may include behaviors that affect device performance or functional correctness. These usage notes will be incorporated into future documentation updates for the device (such as the device-specific data sheet), and the behaviors they describe will not be altered in future silicon revisions.  Silicon revision 2.0 applicable usage notes have been found on a later silicon revision. For more details, see Section 2.2, Silicon Revision 2.3 Known Design Exceptions to Functional Specifications.      3.2   Silicon Revision 2.1 Known Design Exceptions to Functional Specifications  The advisories are not enumerated in sequential order and hence some numbers may not appear in the document  Table 15. Silicon Revision 2.1 Advisory List  Title ................................  Page  	      2.3 and earlier   	 2.3.27  USB0: DMA Hung up in Frequent Teardowns  	 	 	TI
OMAP-L138	   Under conditions in which the device is subjected to large variations in operating  temperatures, the USB0 PLL temperature compensation circuitry does not have enough  margin to guarantee compensation for PLL drift across all temperature ranges.  As a result, the mean frequency generated by the USB0 (USB 2.0 OTG) PHY PLL will  begin to drift (relative to the expected 480 Mbps) when the temperature of the device is subjected to large swing from the original temperature in which the USB0 PHY was most recently calibrated (initialized).  Once the onset of PLL drift occurs, the mean frequency will continue to drift outside the expected frequency and will eventually cause the PLL to lose lock resulting in failure of USB packet reception and/or transmission. This break in transmission will continue until the USB0 PHY is recalibrated during a USB0 PHY Reset.  If the device is not exposed to large variations in temperature relative to the temperature at which the USB0 PHY was most recently initialized, the temperature compensation  circuitry is expected to provide the proper compensation to prevent the mean PLL  frequency from losing lock and beginning to drift.  More specifically, this advisory is most applicable in applications where the device is expected to operate outside the commercial temperature range of 0˚C to 90˚C. TI has identified a point-to-point device temperature range in which there is a very high  confidence the compensation circuitry will properly compensate for all temperature  variations, provided the USB0 PHY was most recently initialized (calibrated) within this same temperature range.  Operating outside the 0˚C-65˚C temperature range increases the susceptibility of the device to experience PLL drift, but does not mean that the application will always  experience a failure in USB transmission.  Root Cause  The Voltage Controlled Oscillator (VCO) Compensation circuitry local to the USB0 PHY  was not designed with a large enough range to compensate for all variations in  temperature across the specified operating range of the device.  How to Most Easily Reproduce the Issue: Reproduction of this issue can most easily be accomplished by the following steps:  1. Allowing the unit to soak in an ambient temperature of -35˚C until the device  temperature reaches approximately the same temperature.  2. Power up the device and provide the necessarily software programming in order to invoke the USB Signal Quality Test Pattern.  3. Using a USB 2.0 Certified Test Platform, execute the USB signal quality test  procedure across the following temperature set points. -35˚C, 0˚C, +35˚C, +70˚C.  Record the measured mean frequency by the compliance software.  NOTE:  The set points can be varied to obtain finer temperature resolution of  when the PLL begins to drift a per platform basis. The above temperature  profile is provided for reference.  42  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.1 Usage Notes and Known Design Exceptions to Functional Specifications 	ARM9	 	 	 	  When a break in transmission is detected, USB0 traffic can be recovered by a software reset of the USB0 PHY. A PHY reset implies recalibration of the PHY PLL at the reset temperature. The system has not been observed to reliably recover on its own. A PHY  reset also implies re-enumeration of all devices. There is no way to recalibrate the USB0  PHY without a re-enumeration.  In order to invoke the recovery mechanism (that is a USB0 PHY reset) one needs to  determine when the issue is present. One such approach is to look for an absence of USB0 Core interrupts over a specified time window. This window should be optimized for the expected USB traffic based upon the application.  As an additional safeguard, an application can also intentionally schedule pre-  determined USB PHY resets at specific temperature points if operation over a broad  range is expected.  Here is an example of one way to power cycle the USB0 PHY via the Chip Configuration 2 Register in the System Configuration (SYSCFG) Module:  #define CFGCHIP2  *((volatile unsigned int *) 0x01C14184)  #define USBPHY_PHYPDWN 0x00000200  Void phy_reset(void) {  CFGCHIP2 |= USBPHY_PHYPDWN;  /* Power down the USB PHY */  mdelay(1);  /* Wait 500ms */  CFGCHIP2 &= ~USBPHY_PHYPDWN;  /* Power up the USB PHY */  }  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  43  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 2.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  4  Silicon Revision 2.0 Usage Notes and Known Design Exceptions to Functional  Specifications  This section describes the usage notes and advisories that apply to silicon revision 2.0 of the device.      4.1   Usage Notes for Silicon Revision 2.0  Usage notes highlight and describe particular situations where the device's behavior may not match presumed or documented behavior. This may include behaviors that affect device performance or functional correctness. These usage notes will be incorporated into future documentation updates for the device (such as the device-specific data sheet), and the behaviors they describe will not be altered in future silicon revisions.  Silicon revision 2.0 applicable usage notes have been found on a later silicon revision. For more details, see Section 2.2, Silicon Revision 2.3 Known Design Exceptions to Functional Specifications.      4.2   Silicon Revision 2.0 Known Design Exceptions to Functional Specifications  Table 16. Silicon Revision 2.0 Advisory List  Title ................................  Page  	      2.1 and earlier   	 2.1.21  USB0 PLL Mean Frequency Can Drift Across Large Temperature Swings  	 	 	TI
OMAP-L138	   For affected silicon revisions, the DSP initiates the system boot sequence when the device is released from reset. Before the ARM can take control of the user boot mode, the DSP must first initialize the ARM reset vector table so that the ARM will execute from its boot ROM.  The ARM reset vector table is located in the ARM’s local RAM, however the ARM local RAM can only be accessed by two bus masters: ARM and PRU0. Therefore, the DSP  must program PRU0 to copy the desired reset vector table into the ARM’s local RAM.  The PRU instructions are located inside of an instruction RAM (IRAM) which is initialized by the DSP during ROM boot (see Figure 13). After the instructions are stored to IRAM, the PRU is reset and enabled to execute its instructions. In this case, the PRU is  instructed to initialize the ARM reset vector table.  Read  PRU Core  PRU IRAM  Write  Enable Bit Reset Bit  External Master  (DSP)  Figure 13. PRU and DSP Block Diagram  When the device is first powered-on, the read bus from the PRU IRAM is not initialized and will contain random values (see Figure 14). Under unpredictable circumstances, the random value on the read bus may resemble a reserved instruction which can be  interpreted by the PRU when the core is reset and not enabled.  If the PRU core executes this reserved instruction, it will not be able to properly execute the first functional op-code in the PRU IRAM when the core is later enabled. In this fail state, the PRU will never acknowledge to the DSP that the reset vector table was  successfully initialized and the DSP will be stuck in a polling loop waiting for the PRU to complete its task.  Read Rsvd Inst  PRU Core  Fail State!  PRU IRAM  Write  Enable Bit Reset Bit  External Master  (DSP)  Figure 14. Boot Failure on Power-On  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  45  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 2.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  Although the PRU core execution is stuck, the PRU IRAM read bus is now initialized with a non-reserved instruction that was fetched from the IRAM by the PRU core (see  Figure 15). If a secondary reset is provided to the device (either POR or WARM), the PRU will be able to execute its functional instructions as expected.  Read Good Inst  PRU Core  Pass State!  PRU IRAM  Write  Enable Bit Reset Bit  External Master  (DSP)  Figure 15. Secondary Reset  Note that in order to recover from this fail state with a secondary reset, the DSP must be allowed to execute its boot ROM up to the point where the PRU has fetched a known  instruction from the PRU IRAM. The approximate count of 15k cycles into the boot ROM  is sufficient.  The 15k clock cycle count does not include the 6192 clock cycles required to complete a device POR reset (see Figure 16). With a 24MHz crystal, the first RESET signal must be asserted high for at least 883us (or approximately 1ms).  Greater than 15k Cycles  RESET  RESETOUT  6192 Cycles  Figure 16. First POR Reset Timing  	ARM9	 	 	 	  Modify the target board so that the affected device is given a secondary reset on power-up as shown in Figure 16. Two example methods are described in the sections that  follow.  Although secondary resets are compatible with future silicon revisions, they are not required for devices where the root cause has been fixed via an updated DSP boot  ROM. In order to reduce BOM costs, board designers may want to route a reset signal bypass path so that the workaround circuit can be depopulated on future PCB builds.  ❏ Use a reset supervisor device that includes a watchdog timeout function so that the reset supervisor will issue a secondary reset if the device fails to boot. The watchdog should be serviced with a device signal that is controlled by software. Options for servicing the watchdog timeout include GPIO, unused clock sources such as  CLKOUT or a periodic output peripheral like TIMER and ePWM.  46  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated      www.ti.com  Silicon Revision 2.0 Usage Notes and Known Design Exceptions to Functional Specifications Potential reset supervisors are TPS382x for 3.3V IOs (shown in Figure 17) and TPS312x for 1.8V IOs.  TPS3820      3.3V   OMAP-L138   VDD  DVDD3318  GND  GND  Board Reset  MR  WDI  CLKOUT  RESET  RESET  0-W  Not Populated  Figure 17. Reset Supervisor with Watchdog Function  The watchdog supervisor workaround is easy to implement, however the watchdog  timeout period may exceed application boot-up time requirements. For example, the  TPS3820 has a typical watchdog timeout period of 200ms. The second workaround can  speed up the reset process.  ❏ Implement a logic-based secondary reset circuit which is timed using RC  components. For the circuit shown in Figure 18, a single board reset control signal can trigger three logic transitions in a dual XOR gate device.  Not Populated  0-W  1A  R1  1Y  1B  Board Reset  1  C1  1A  RESET  R2  1Y  1B  2  R3  SN74LVC2G86  C2  Dual XOR Gate  SN74LVC2G17  Dual Schmitt Buffer  Figure 18. RC-Timed Secondary Reset  This is possible because each RC load connected to the board reset control signal can output a different rising-edge waveform. With increasing RC load, the resulting control signal will reach the Schmitt buffers’ Vih level at a later point in time. Figure 19 shows the relationship between the board reset signal and the RESET signal produced by the circuit. The blue and green lines represent the voltage as seen by the Schmitt buffers.  The output voltage of a charging RC circuit is defined as: Vo = Vi * (1 - e^[-t / RC]) SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  47  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 2.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  R1C1  RESET  R2C2  Vih  Board Reset  Figure 19. RESET Signal vs Board Reset  Given ideal conditions, a 3.3V board reset signal, and an input buffer Vih of 1.4V, the following set of component values would generate an initial RESET high period (R1C1  region) of approximately 2ms and a RESET low period (R2C2 region) of approximately  0.5ms:  •  R1 = 36k, C1 = 100nF,  •  R2 = 45k, C2 = 100nF,  •  R3 = 450k  When implementing this workaround, some important aspects should be kept in mind:  (a) The dual Schmitt buffer is included because the dual XOR gate has an input rise-time requirement that is violated by the RC circuits,  (b) The Board Reset signal must meet the XOR gate input rise-time requirement and  must provide enough output current to charge the RC circuits to the target Vih level, (c) It is critical for the Vih level of the two input buffers to be very close together so only single-device buffers should be considered for this circuit (such as the 2-in-1 dual Schmitt buffer device used in this example),  (d) Variations in the electrical characteristics of the circuit components may produce waveforms that deviate from ideal calculations, and  (e) The sole purpose of the R3 pulldown resistor is to discharge the RC components  before the board reset signal is driven high. Therefore, the value selected for R3  should be sufficiently large enough to not interfere with the RC circuits as they are charging.  48  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 1.1 Usage Notes and Known Design Exceptions to Functional Specifications 5  Silicon Revision 1.1 Usage Notes and Known Design Exceptions to Functional  Specifications  This section describes the usage notes and advisories that apply to silicon revision 1.1 of the device.      5.1   Usage Notes for Silicon Revision 1.1  Usage notes highlight and describe particular situations where the device's behavior may not match presumed or documented behavior. This may include behaviors that affect device performance or functional correctness. These usage notes will be incorporated into future documentation updates for the device (such as the device-specific data sheet), and the behaviors they describe will not be altered in future silicon revisions.  Silicon revision 1.1 applicable usage notes have been found on a later silicon revision. For more details, see Section 2.2, Silicon Revision 2.3 Known Design Exceptions to Functional Specifications.  5.1.1  RTC Standby Power Consumption Is Elevated if the Module Is Not Configured Correctly The RTC module is designed with the ability to keep time while the rest of the device is power cycled off and on. This ability is achieved by placing the RTC in its own power domain and isolating it from the device reset signal.  When the CVDD supply is powered down, the RTC_CVDD supply will experience elevated standby power consumption because of leakage between the RTC and core power domains. The RTC module includes circuitry that eliminates the leakage paths between the two domains when the SPLITPOWER bit is set to 1  in the control register (CTRL). The SPLITPOWER bit is a write-only bit that will always read back 0.  Therefore, typical read-modify-write sequences should not be used when writing to the CTRL register because the SPLITPOWER bit will be cleared back to 0.  Also note that the SPLITPOWER bit has a default value of 0 after RTC module reset, and the only reset available to the RTC module is a software reset, therefore RTC is in an indeterminate state when the RTC_CVDD supply is first powered on. The RTC module should be reset, and the SPLITPOWER bit should be set to 1 before placing the device in a CVDD powered down standby state.  The SPLITPOWER bit is permanently set to 1 inside the RTC module beginning with Silicon Revision 2.0  of the device.  5.1.2  SYSCFG: Possible Race Condition When Using KICK Registers  When two or more threads are simultaneously accessing the SYSCFG registers, there is the potential for one thread to lock the SYSCFG registers while another thread is still accessing them. There is no hardware semaphore to prevent this from occurring.  For example, the race condition can occur in the following situation  1. Thread 1 unlocks the SYSCFG register by writing to the KICK registers  2. An interrupt occurs and Thread 2 unlocks the SYSCFG registers as well  3. Thread 2 finishes and locks the SYSCFG registers  4. Thread 1 is locked out of the SYSCFG registers and is unable to complete its task To prevent the SYSCFG lockout race condition, the application should unlock the SYSCFG registers via the KICK registers and leave them permanently unlocked.  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  49  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  5.1.3  SATA & USB Digital Supplies Must Be Powered for Proper Device Operation  For silicon revisions prior to 2.0, the SATA and USB digital supply pins must be powered up. These supplies provide power to logic that is critical for device initialization during reset. A bad initialization sequence will cause the device boot process to fail. Another symptom of a bad initialization sequence is that the DIEIDRx registers (0x01C14008h – 0x01C14017h) will appear as all zeros.  Starting with silicon revision 2.0, the affected logic will be powered by the CVDD core supply instead of the USB and SATA supplies.  The following is a list of the supply pins affected:  Table 17. Supply Pins Affected  Digital Supply  Pin  SATA_VDD  M2  SATA_VDD  N4  SATA_VDD  P1  SATA_VDD  P2  USB_CVDD  M12      5.2   Silicon Revision 1.1 Known Design Exceptions to Functional Specifications  Silicon revision 1.1 applicable advisories have been found on a later silicon revision. For more details, see Section 2.2, Silicon Revision 2.3 Known Design Exceptions to Functional Specifications The advisories are not enumerated in sequential order and hence some numbers may not appear in the document.  Table 18. Silicon Revision 1.1 Advisory List  Title ................................  Page  	      2.0 and earlier   	 2.0.20  Intermittent Boot Failures  	 	 	TI
OMAP-L138	   Note: DMA refers to all non-CPU requests. SDMA refers to external system DMA master requests handled via the Slave Direct Memory Access port.  The C674x Megamodule uses a two-way set associative cache for L1D. This means that  every physical memory location in the system has two possible set/way locations in the cache where it can reside. See TMS320C674x DSP Megamodule Reference Guide,  Literature Number - SPRUFK5 for more information on the L1D cache architecture.  Updated (dirty) values in L1D cache are not written back to external memory until cache activity evicts a cache-line (victim write-back) or a write-back is requested by the application.  An L1D cache-line corruption event occurs when all of the following conditions are met: 1. L1D cache evicts a dirty line (Line A) while allocating a new line (Line B) in the same set/way (cache Lines A and B consist of 64-bytes each). In order for this to happen, the following will have taken place:  (a) Line A was previously read by CPU because L1D is a read-allocate cache,  (b) Line A is dirty because its value was modified by CPU, and  (c) Line B is read by CPU  2. Both Line A and Line B are associated with L2 RAM, and  3. While the original L1D victim write-back from condition (1) is in progress, the SDMA performs both:  (a) a read or write operation to Line A in L2 RAM and  (b) a write operation to Line B in L2 RAM.  If all of the above conditions are met, the L2 RAM data associated with the Line A victim writeback will become corrupt. Additionally, the Line B data originating from the SDMA write will also become corrupt in L1D cache. Figure 20 shows an example scenario of L1D cache and L2 RAM corruption.  Line A and Line B Map to  LINE A  same L1D Cache line.  INITIAL  STEP 1  STEP 2  STEP 3  STATE  C674x Megamodule  LINE B  C674x CPU  CPU Request  Request  L2  C674x CPU  EXTERNAL  Activity  Line B  Pending  Controller  L2  SRAM  SDMA  SDMA Requests  Read/Write to Line A  Activity  & Write to Line B  L1D  EMC  L1D Cache  Dirty Line A  Dirty Line A  IN-FLUX  Corrupt  Controller  SDMA PORT  EDMA  SYSTEMMASTERS  Line Status  in L1D Cache in L1D Cache  Line A  Old Data  Old Data  Old Data  Corrupt  L2 SRAM  Line B tries to replace  EMAC  CACHE LINE  Line B  Old Data  Old Data  Old Data  NEW DATA  Dirty Line A in the L1D  L2 SRAM  Cache  L1D  CACHE  Corruption happens  because of this state  TIME LINE  SYSTEM VIEW  Figure 20. Example of L1D Cache and L2 RAM Corruption  	ARM9	 	 	 	  Method 1  In cases where buffer access will not be shared between CPU and SDMA,  unintended CPU/SDMA cache-line sharing can be avoided by aligning CPU and  SDMA buffers to 64-byte boundaries. Aligning buffers to 64-byte boundaries will  result in wasted space, however it ensures that the CPU and SDMA buffers will not  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  51  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  have partial segments which overlap into the same L1D cache line.  /** Pseudo code only **/  Uint8 *SDMA_BUFF, *CPU_BUFF;  /* 64-byte aligned allocation Option 1 */  SDMA_BUFF = malloc( (Int32) (( SDMA_BUFF_SIZE + 63)/64) * 64 );  CPU_BUFF  = malloc( (Int32) ((CPU_BUFF_SIZE  + 63)/64) * 64 );  SDMA_BUFF = (Uint8 *) ( (Int32) SDMA_BUFF & ~63 );  CPU_BUFF  = (Uint8 *) ( (Int32) CPU_BUFF  & ~63 );  /* 64-byte aligned allocation Option 2 with BIOS Call */  SDMA_BUFF = MEM_alloc( IRAM, SDMA_BUFF_SIZE, 64 );  CPU_BUFF  = MEM_alloc( IRAM, CPU_BUFF_SIZE,  64 );  Method 2  Manage access to a 64-byte boundary aligned buffer that is shared between CPU  and SDMA by implementing a semaphore and forcing cache writeback operations  after CPU writes. With this method, the semaphore ensures that there is clear  ownership of the buffer between CPU and SDMA, and the CPU manages cache  coherence by using explicit cache writeback operations.  /** Pseudo code only **/  /* Example with EDMA as the external master */  EDMA_ISR() {  /* EDMA releases ownership of buffer */  SEM_post(SyncSemaphore);  return;  }  main() {  while(COND) {  /* CPU waits for ownership of buffer */  SEM_pend(SyncSemaphore);  /**********************/  /*** CPU Processing ***/  /**********************/  /* Cache writeback for shared block */  /* Buffer must be 64-byte aligned  */  BCACHE_wbInv( blockPtr, blockSize, WAIT );  /* Initiate EDMA */  EDMA_Event_Generate();  }  }  Method 3  Configure the entire L2 RAM as cache. Critical peripheral data can be accessed in  L1D RAM or L3 RAM instead of L2 RAM.  Method 4  Do not allow SDMA to access L2 RAM. SDMA can use buffers in L1D RAM or L3  RAM instead of L2 RAM.  52  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 1.1 Usage Notes and Known Design Exceptions to Functional Specifications Method 5  Do not configure L1D memory as cache - use the entire address space as RAM.  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  53  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  	      1.1 and earlier   	 1.1.2  Under Specific Conditions, SDMA Activity Can Corrupt the L1D Cache and L2 RAM  	 	 	TI
OMAP-L138	   The low-voltage operating points are not supported on revisions 1.1 and earlier. The support of these operating points is planned for revision 2.0.  	ARM9	 	 	 	  None  54  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 1.1 Usage Notes and Known Design Exceptions to Functional Specifications 	      1.1 and earlier   	 1.1.7  Low Voltage Operating Points (1.1V, 1.0V) Not Supported  	 	 	TI
OMAP-L138	   A potential reliability issue has been discovered when hardware resets (RESET pin high-to-low transitions) occur. If any of the dual-voltage LVCMOS IOs on the device are being operated at 3.3V nominal and a hardware reset occurs, some 1.8V transistors in the IOs buffers are briefly exposed to 3.3V. This exposure to high voltage has the potential to degrade the gate oxide integrity of the transistors over repeated resets.  This issue does not occur during a power-up condition where the RESET pin is held low.  This issue does not occur with software resets or watchdog timer induced resets.  This issue does not occur if all dual-voltage LVCMOS IO buffers are being operated at 1.8V nominal.  Reliability estimates have been made to determine a budget for the number of resets in a product lifetime to maintain the reliability of the device under 50 FIT.  •  At a junction temperature of 105°C, the total number of hardware resets in the  product lifetime should not exceed 125,000 hardware resets.  •  At a junction temperature of 90°C, the total number of hardware resets in the product lifetime should not exceed 250,000 hardware resets.  	ARM9	 	 	 	  Limit the number of hardware reset to within the limits listed above.  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  55  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  	      1.1 and earlier   	 1.1.11  Hardware RESET Reliability Lifetime  	 	 	TI
OMAP-L138	   Device peripherals often include an emulation suspend function that gracefully halts peripheral activity. This function is activated when the target CPU is halted through emulator debug. While halted, the control and status registers for the module can be viewed and manipulated for debug purposes.  In a multicore device, it is desirable to choose a single CPU to master the emulation suspend function. Typically, the CPU that configures a module is chosen to be its  suspend source CPU (ARM or DSP). The SUSPSRC register in the SYSCFG module  allows the user to choose which CPU controls the emulation suspend function for each peripheral.  For the affected silicon revisions, the SUSPSRC fields MCBSP0SRC, MCBSP1SRC,  TIMER64P_2SRC, and VPIFSRC are not functional. The ARM will always be the  suspend source regardless of the bit settings. If the ARM is connected and halted  through emulator debug, the affected peripherals will appear to be halted as observed by the DSP. Similarly, if the ARM is free-running, the affected peripherals will never halt when the DSP is halted.  The described condition is only present during emulation debug – the peripherals will function as expected when the device is free-running in an application.  	ARM9	 	 	 	  When developing DSP software, the affected peripherals can be removed from halted  states by either free-running the ARM CPU or by setting the peripheral-specific  emulation mode to FREE. The affected peripherals can be placed into halted states by halting the ARM CPU.  Code Composer Studio (CCS) allows the user to set Global Breakpoints such that the  DSP and ARM CPUs will both halt at the same time on a given breakpoint. CCS also  includes the ability to simultaneously set debug states (such as RUN and HALT) across multiple processors. When the ARM and DSP both run and halt at the same time, the  peripherals will appear as if their suspend source is the DSP.  56  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 1.1 Usage Notes and Known Design Exceptions to Functional Specifications 	      1.1 and earlier   	 1.1.14  SYSCFG SUSPSRC Bits Not Functional for McBSP0, McBSP1, TIMER2, and VPIF  	 	 	TI
OMAP-L138	"   Note: This advisory is not applicable if DSP L2 memory is configured as 100% cache or L2 RAM is not accessed by IDMA or SDMA during run-time.  The C674x Megamodule has a Master Direct Memory Access (MDMA) bus interface and  a Slave Direct Memory Access (SDMA) bus interface. The MDMA interface provides  DSP access to resources outside the C674x Megamodule.  The MDMA interface is typically used for CPU/cache accesses to memory beyond the  Level 2 (L2) memory level. These accesses include cache line allocates, write-backs, and non-cacheable loads and stores to/from system memories. The cacheable  memories external to the C674x Megamodule are listed in Table 19.  Table 19. Cacheable External Memory Resources  External Memory  Address Range  Shared Ram  0x8000 0000 – 0x8001 FFFF  EMIFA  0x4000 0000 – 0x67FF FFFF  DDR2/mDDR  0xC000 0000 – 0xCFFF FFFF  The SDMA interface allows other DMA master peripherals (listed in Table 20 ) to access Level 1 Data (L1D), Level 1 Program (L1P), and L2 RAM DSP memories.  Table 20. DMA Master Peripherals  Peripheral  Group  EDMA0 TC0 RD  A  EDMA0 TC0 WR  B  EDMA0 TC1 RD  C  EDMA0 TC1 WR  D  EDMA1 TC0 RD  E  EDMA1 TC0 WR  F  UHPI  G  USB0  G  USB1  G  EMAC  G  PRU  H  SATA  I  UPP  I  VPIF  I  ARM  J  The C674x Megamodule has an L1D cache and L2 cache both implementing write-back  data caches– it keeps updated values for external memory in cache for as long as  possible. It writes these updated values, called ""victims"", to external memory when it needs to make room for new data or when requested to do so by the application. The  L1D sends its victims to L2. The caching architecture has pipelining, meaning multiple requests could be pending between L1, L2, and MDMA. For more details on the C674x  Megamodule and its MDMA and SDMA ports, see the TMS320C674x Megamodule  Reference Guide (literature number SPRUFK5).  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  57  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  Ideally, the MDMA (dashed-dotted line in Figure 21) and SDMA/IDMA paths (dashed  lines in Figure 21) operate independently with minimal interference. Normally MDMA  accesses may stall for extended periods of time due to expected system level delays (for example, bandwidth limitations). However, when using L2 as RAM, SDMA and IDMA  accesses to L2/L1 may experience unexpected stalling in addition to the normal stalls seen by the MDMA interface. For latency-sensitive traffic, the SDMA stall can result in missing real-time deadlines. In a more severe case, the SDMA stall can produce a  deadlock condition in the device. An IDMA stall cannot produce a deadlock condition.  Note: SDMA/IDMA accesses to L1P/D will not experience an unexpected stall if there are no SDMA/IDMA accesses to L2. Unexpected SDMA/IDMA stalls to L1 happen only  when they are pipelined behind L2 accesses. Additionally, the deadlock scenario will be avoided if there are no SDMA accesses to L2.  Figure 21 is provided for illustrative purposes and is incomplete because of  simplification. The IDMA/SDMA (dashed-lines) path could also go to L1D/L1P memories, and IDMA can go to DSP CFG peripherals. MDMA transactions can originate also from  L1P or L1D through the L2 controller or directly from DSP).  32K bytes  256K bytes  1M bytes  L1P RAM/  L2 RAM  L2 ROM  cache  256  256  256  256  Cache control  Cache control  Memory protect L1P  Memory protect L2  Bandwidth Mgmt  Bandwidth Mgmt  256  256  256  Instruction fetch  256 Power down  C674x  Interrupt  Fixed/floating point CPU  Controller  Register  Register  IDMA  file A  file B  64  64  256  CFG  Bandwidth Mgmt  32  Configuration  EMC  Memory protect L1D  peripherals  Cache control  bus  MDMA  SDMA  8x32  64  64  64  64  32K bytes  High performance  L1D RAM/  switch fabric  SDMA/IDMA Paths  cache  (SCR1)  MDMA Path  Figure 21. C674x Megamodule  The duration of the SDMA/IDMA stalls depend on the quantity/characteristics of the  L1/L2 cache and the MDMA traffic in the system. Therefore, it is difficult to predict if stalling will occur and for how long.  IDMA/SDMA stalling and any system impact is most likely in systems with excessive  context switching, L1/L2 cache miss/victim traffic, and heavy access to external memory.  58  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 1.1 Usage Notes and Known Design Exceptions to Functional Specifications Use the following procedure to determine if SDMA/IDMA stalling is the cause of real-time deadline misses for existing applications. Situations where real-time deadlines may be missed include loss of McASP samples and poor peripheral throughput.  1. Determine if the transfer that is missing the real-time deadline is accessing L2 or L1D  memory. If not, then SDMA/IDMA stalling is not the source of the real-time deadline miss.  2. Identify all SDMA transfers to/from L2 memory (for example, EDMA transfer to/from L2 from/to a UART, HPI block transfer to/from L2). If there are no SDMA transfers  to/from L2, then SDMA/IDMA stalling is not the source of the problem.  3. Redirect all SDMA transfers to L2 memory to other memories using one of the  following methods:  (a) Temporarily transfer all the L2 SDMA transfers to L1D SRAM.  (b) If not all L2 SDMA transfers can be moved to L1D memory, temporarily direct  some of the transfers to memory in Table 1 and keep the rest in L1D memory.  There should be no L2 SDMA transfers.  If real-time deadline misses are solved using any of the options in Step 3, then  IDMA/SDMA stalling is likely the source of the problem.  A deadlock situation may arise if the following sequence of events occurs:  Step 1: A DMA master from any group (listed in Table 2) issues a write command to the DSP’s SDMA, and a DMA master from the same group issues a subsequent write  command to cacheable memory outside of the C674x Megamodule (listed in Table 1).  All write commands pass through Switched Central Resource 1 (SCR1). For more  details on SCRs, see the device System Reference Guide SPRUG84.  Step 2: The DSP’s SDMA asserts itself as not ready and is unable to accept the write data from Step 1, and a cache line writeback is initiated from DSP memory to the same cacheable memory from Step 1. The cache line writeback command also passes  through SCR1.  With the above scenario, it is possible for SCR1 to order the write commands from Step 1 in front of the write commands from Step 2. Due to the MDMA/SDMA blocking  behavior, the SDMA commands from Step 2 will be waiting for the MDMA traffic from  Step 1 to finish, resulting in a deadlock situation at SCR1. Figure 22 is provided for illustrative purposes and is incomplete because of simplification.  DMA  Group A  C674x  SDMA  (L2/L1D)  DMA  Group B  SCR1  DMA  Group xx  Cacheable  Memory  C674x  MDMA  Figure 22. SCR1 System Interconnect  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  59  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated  Silicon Revision 1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  "	ARM9	 	 	 	  Entirely eliminate IDMA/SDMA stalling and potential for a deadlock condition using one of the following two methods:  1. Configure the entire L2 RAM as 100% cache (for example, move all data buffers from L2 to L1D or other memory). Note: Some throughput degradation is expected when  the buffers are moved out to external memo  2. Eliminate all IDMA/SDMA access to L2 RAM when IDMA/SDMA stalling would have  an impact by performing one of the following:  (a) Constrain each DMA master group to perform writes to either DSP memory space  or external memory space, but not to both, or  (b) Force each DMA master group to complete pending write commands to either  DSP memory space or cacheable memory space before initiating writes to a  different destination. Pending write commands from DMA masters are forced to  complete when the DMA master initiates a read from the same destination  memory. Note that in the case of off-chip memory, a read command only forces  the completion of write commands within a 2KB-aligned window.  60  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  SPRZ301M – June 2009 – Revised March 2014  1.1 and 1.0  Submit Documentation Feedback  Copyright © 2009–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 1.0 Usage Notes and Known Design Exceptions to Functional Specifications 6  Silicon Revision 1.0 Usage Notes and Known Design Exceptions to Functional  Specifications  This section describes the usage notes and advisories that apply to silicon revision 1.0 of the devices.      6.1   Usage Notes for Silicon Revision 1.0  Silicon revision 1.0 applicable usage notes have been found on a later silicon revision. For more details, see Section 2.2, Silicon Revision 2.3 Known Design Exceptions to Functional Specifications.      6.2   Silicon Revision 1.0 Known Design Exceptions to Functional Specifications  Silicon revision 1.0 applicable advisories have been found on a later silicon revision. For more details, see Section 2.2, Silicon Revision 2.3 Known Design Exceptions to Functional Specifications.  SPRZ301M – June 2009 – Revised March 2014  OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0,  61  Submit Documentation Feedback  1.1 and 1.0  Copyright © 2009–2014, Texas Instruments Incorporated      	      1.1 and earlier   	 1.1.16  DSP SDMA/IDMA: Unexpected Stalling and Potential Deadlock Condition  	 	 	TI
OMAP-L132	   Note: DMA refers to all non-CPU requests. This includes Internal Direct Memory Access (IDMA) requests and all other system DMA master requests via the Slave Direct Memory Access (SDMA) port.  The C674x Megamodule uses a bandwidth management (BWM) system to arbitrate  between DMA and CPU requests issued to L2 RAM. See TMS320C674x DSP  Megamodule Reference Guide, Literature Number - SPRUFK5 for more information on the BWM. BWM arbitration grants L2 bandwidth based on programmable priorities and contention- cycle-counters. The contention-cycle-counters count the number of cycles for which the associated L2 requests are blocked by higher priority requests. When the contention-cycle-counter reaches a programmed threshold (MAXWAIT), the associated L2 request is granted a slice of L2 bandwidth. This prevents indefinite blocking of low priority requests when faced with the continuous presence of higher priority requests.  Ideally, the BWM arbitration will grant equal L2 bandwidth between equal priority DMA and CPU requests. Instead, when equal priority DMA and CPU requests arrive at the BWM, bandwidth is always granted in favor of the CPU over DMA. In the case of  successive CPU requests, it is possible for the CPU to block all DMA requests until CPU  traffic subsides. Additionally, some command logic in the BWM uses priority level 7, which can also result in SDMA stalls when the CPU is also programmed to priority level 7. Figure 3 shows a high level diagram of the arbitration scheme used for L2 RAM  requests.  C674x Megamodule  EDMA  SHAREDRESOURCE  ExternalSystemMasters  Programmable Priority  ARBITRA  MasterPriority  C674x CPU  EMAC  ARBITRA  Programmable Priority  IDMA  L2 RAM  TION  Inherit  TION  Priority  SDMA  USB  Highest Priority Master Granted Access.  Contention counters implemented to not      starve low priority requestors   Figure 3. Priority Arbitration Scheme for L2 RAM  	ARM9	 	 	 	  Configure DMA and CPU requests to different priority levels. There is no penalty for setting the IDMA and SDMA priorities equal to each other.  CPU request priority is programmed within the CPUARBU register:  /** Pseudo code only **/  Uint32 *CPUARBU;  CPUARBU = ( Uint32 * ) ( 0x01841000 );  /* Set priority different from IDMA/SDMA */  *CPUARBU = [CPU_PRIORITY];  8  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  SPRZ317G – August 2011 – Revised March 2014  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications IDMA request priority is programmed within the IDMA1_COUNT register  /** Pseudo code only **/  Uint32 *IDMA1_SRC, *IDMA1_DST;  Uint32 *IDMA1_CNT;  IDMA1_SRC = ( Uint32 * ) ( 0x01820108 );  IDMA1_DST = ( Uint32 * ) ( 0x0182010C );  IDMA1_CNT = ( Uint32 * ) ( 0x01820110 );  *IDMA1_SRC = sourceAddress;  *IDMA1_DST = destinationAddress;  /* Set IDMA priority different from CPU */  *IDMA_CNT = ( [IDMA_PRI] << [IDMA_PRI_SHIFT] ) | buffSize ;  SDMA request priority is inherited from the MSTPRIn registers  /** Pseudo code only **/  Uint32 *MSTPRI1, *MSTPRI2;  MSTPRI1 = ( Uint32 * ) ( 0x01C14114 );  MSTPRI2 = ( Uint32 * ) ( 0x01C14118 );  /* Set SDMA master priorities different from CPU */  *MSTPRI1 = [MAST_PRI] << [MAST_SHIFT];  *MSTPRI2 = [MAST_PRI] << [MAST_SHIFT];  SPRZ317G – August 2011 – Revised March 2014  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  9  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      	  2.3 and earlier      	 2.3.1   DMA Access to L2 RAM Can Stall When DMA and C674x CPU Command Priorities      Are Equal   	 	 	TI
OMAP-L132	   When the USB controller is operating as a device and an attached host resets the device after the completion of the Device Attached state by driving both differential data lines low, the USB controller operating as a device could receive multiple RESET interrupts for the single RESET signaling invoked by the host. The multiple interrupt generation only happens for the duration of the RESET signaling on the bus. RESET Interrupt is not generated before or after the completion of RESET.  	ARM9	 	 	 	  Software must service every USB RESET interrupt received. Software should not  proceed on performing any other task, like initialization, until RESET duration has come to completion. The POWER[RESET] bit field will be cleared by the USB Controller when RESET signaling on the bus is removed by the Host. The USB Controller clearing the POWER[RESET] bit field should be used by software as an indication for the completion of RESET signaling.  10  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  SPRZ317G – August 2011 – Revised March 2014  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications 	  2.3 and earlier      	 2.3.3   USB0: Extraneous RESET Interrupt  	 	 	TI
OMAP-L132	   In Extended Wait mode, during a read access to an asynchronous memory, if the WAIT  input does not go inactive within maximum extended wait cycles programmed in the Async Wait Cycle Config register, the EMIF will report a time-out error. The data returned for this access will be all zeros. If this access is followed by a read to the EMIFA’s memory-mapped register (MMR) space, the EMIFA will still report a time-out error but with the correct data for the MMR read. The EMIF will hold the time-out error until another asynchronous access without a time-out error or an SDRAM access is performed.  This issue is only applicable if all of the following are true:  •  The EMIF is used for asynchronous memory accesses in Extended Wait mode.  •  There is a potential for a time-out error to occur, that is, the asynchronous memory will not de-assert the WAIT input.  •  If asynchronous memory read with time-out error is followed by an MMR read.  	ARM9	 	 	 	  If a time-out occurs, perform any of the following:  •  A dummy read to another asynchronous memory chip select that is not configured to be in Extended Wait mode.  •  A dummy read to the same asynchronous memory chip select after disabling the  Extended Wait mode on that chip select.  •  A dummy read to SDRAM  SPRZ317G – August 2011 – Revised March 2014  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  11  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      	  2.3 and earlier      	 2.3.4  EMIFA: Asynchronous Memory Timeout Error Persistence  	 	 	TI
OMAP-L132	   The C674x DSP megamodule supports twelve maskable hardware interrupt signals  (CPUINT4 through CPUINT15). Single system interrupts may be mapped directly to a CPUINTn hardware interrupt, or multiple system interrupts may be combined by the ECM into a single signal before mapping to a CPUINTn interrupt. See [SPRUFK5;  TMS320C674x DSP Megamodule] for more information on how DSP interrupts are  handled.  The ECM expects all incoming interrupts to be pulse interrupts, however the  [SYSCFG_CHIPSIG_]CHIPINTn interrupts are level interrupts. This mismatch in interrupt types will cause a single CHIPINTn interrupt event to register multiple times in the ECM.  	ARM9	 	 	 	  The CPUINTn hardware interrupts can support both pulse and level interrupts so CHIPINTn interrupts should be mapped directly to CPUINTn hardware interrupts.  Furthermore, if the ECM is used for other system interrupts, the CHIPINTn interrupts should be masked out in the EVTMASKn registers.  12  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  SPRZ317G – August 2011 – Revised March 2014  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications 	  2.3 and earlier      	 2.3.5   A Single CHIPINTn Interrupt Event Will Register Multiple Times in the DSP Event  Combiner Module (ECM)  	 	 	TI
OMAP-L132	   When a soft reset is invoked by setting the RESET bit of the USB CTRLR register (  CTRLR[RESET] = 1 ), the internal reset timing requirements may be violated. Although this timing violation has not been observed in practice, the potential for a timing violation exists.  USB resets initiated by system-reset and power-on-reset are immune from the timing violation.  There is no plan to fix this issue in future silicon revisions because:  1. No functional problems have been observed to date  2. A software workaround has been developed to avoid the problem  	ARM9	 	 	 	  The reset timing violation can be avoided by providing the modified soft reset activation sequence outlined below:  1. Enable the USB controller module clock through the Power and Sleep Controller (PSC)  2. Perform a soft USB reset  3. Wait for the USB soft reset bit to clear  4. Disable the USB controller module clock through the PSC  5. Configure the USB PHY parameters  6. Enable the PHY  7. Enable the USB controller module clock through the PSC  SPRZ317G – August 2011 – Revised March 2014  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  13  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      	  2.3 and earlier      	 2.3.6  Potential USB2.0 Soft Reset Timing Violation  	 	 	TI
OMAP-L132	   The input buffers on the device have shown timing sensitivity to the logic-low input voltage that can cause changes to the AC input timings. Due to this issue, input voltages must be driven to 0.5V or below on all dual-voltage LVCMOS input signals (signals associated with supplies DVDD1833_A, DVDD1833_B or DVDD1833_C).  Vil driven at or below 0.4V will cause no timing degradation. Vil driven up to 0.5V will cause up to 750 ps degradation in input timings.  The following datasheet parameters will be affected by Vil driven up to 0.5V. Their values adjusted for 0.75 ns degradation are shown.  Table 3. Timing Requirements for the EMIFA SDRAM Interface  1.2V  NO.  PARAMETER  UNIT  MIN      MAX   Input Setup time, read data valid on  19  t  2.75  ns  su(EMA_DV-EM_CLKH)  EMA_D[31:0]  Table 4. Timing Requirements for the EMIFA Asynchronous Memory Interface  1.2V  NO.  PARAMETER  UNIT  MIN      MAX   Setup time, EMA_D[31:0] valid before EMA_OE  12  t  3.75  ns  su(EMDV-EMOEH)  high  Table 5. Timing Requirements for McASP0  1.2V  NO.  PARAMETER  UNIT  MIN      MAX   AHCLKR/X ext input  1.15  Hold time, AFSR/X input after ACLKR/X  6  th(ACLKRX-AFSRX)  (1)  AHCLKR/X ext output  1.15  ns  AHCLKR/X ext input  1.15  Hold time, AXR0[n] input after  8  th(ACLKRX-AXR)  ACLKR/X (1) (2)  AHCLKR/X ext output  1.15  (1)  McASP0 ACLKXCTL.ASYNC=1: Receiver is clocked by its own ACLKR0  (2)  McASP0 ACLKXCTL.ASYNC=0: Receiver is clocked by transmitter's ACLKX0  Table 6. Switching Characteristics for McASP0  1.2V  NO.  PARAMETER  UNIT  MIN      MAX   ACLKR/X ext input  3.5  Delay time, ACLKR/X transmit edge to  13  td(ACLKRX-AFSRX)  AFSX/R output valid (1)  ACLKR/X ext output  3.5  ACLKR/X ext input  3.5  Delay time, ACLKX transmit edge to  14  td(ACLKX-AXRV)  ns  AXR output valid (1)  ACLKR/X ext output  3.5  Disable time, ACLKR/X transmit edge  15  t  to AXR high impedance following last  ACLKR/X ext  3.5  dis(ACLKX-AXRHZ)  data bit  (1)  McASP0 ACLKXCTL.ASYNC=1: Receiver is clocked by its own ACLKR0  14  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  SPRZ317G – August 2011 – Revised March 2014  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications Table 7. Timing Requirements for McBSP0  1.2V  NO.  PARAMETER  UNIT  MIN      MAX   Setup time, external FSR high before  5  t  CLKR ext  5.5  su(FRH-CKRL)  CLKR low  7  t  Setup time, DR valid before CLKR low  CLKR ext  5.5  ns  su(DRV-CKRL)  Setup time, external FSX high before  10  t  CLKR ext  5.5  su(FXH-CKXL)  CLKX low  Table 8. Switching Characteristics for McBSP0  1.2V  NO.  PARAMETER  UNIT  MIN      MAX   Delay time, CLKR high to internal FSR  4  t  CLKR ext  2.75  d(CKRH-FRV)  valid  Delay time, CLKX high to internal FSX  9  t  CLKR ext  2.75  ns  d(CKXH-FXV)  valid  2.75 + D1  13  t  Delay time, CLKX high to DX valid  CLKR ext  d(CKXH-DXV)  (1)  (1)  Extra delay from CLKX high to DX valid applies only to the first data bit of a device, if and only if DXENA = 1 in SPCR.  If DXENA = 0, then D1 = D2 = 0  If DXENA = 1, then D1 = 6P, D2 = 12P  Table 9. Switching Characteristics for McBSP1  1.2V  NO.  PARAMETER  UNIT  MIN      MAX   Delay time, CLKR high to internal FSR  4  t  CLKR ext  3.25  d(CKRH-FRV)  valid  Delay time, CLKX high to internal FSX  9  t  CLKR ext  3.25  ns  d(CKXH-FXV)  valid  3.25 + D1  13  t  Delay time, CLKX high to DX valid  CLKR ext  d(CKXH-DXV)  (1)  (1)  Extra delay from CLKX high to DX valid applies only to the first data bit of a device, if and only if DXENA = 1 in SPCR.  If DXENA = 0, then D1 = D2 = 0  If DXENA = 1, then D1 = 6P, D2 = 12P  	ARM9	 	 	 	  Although there is no specific workaround, the following recommendations can be used to help prevent this issue:  •  Minimize loads as much as possible, especially DC loads that could cause the Vil to rise. Point-to-point (single-load) connections are unlikely to be affected.  •  Falling edges should transition as rapidly as possible (so the signal passes through the 0.2V point as early as possible). Heavily loaded nodes resulting in degraded fall times may require drivers to provide rapid input edges.  SPRZ317G – August 2011 – Revised March 2014  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  15  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      	  2.3 and earlier      	 2.3.9   Vil on Dual-Voltage LVCMOS Input Buffers Operated at 3.3V  	 	 	TI
OMAP-L132	   The VSR register in the ARM Interrupt Controller (AINTC) is not correctly initialized after reset. If this register is not explicitly configured, the AINTC will only allocate 1 byte per interrupt (instead of 4).  	ARM9	 	 	 	  The desired value (even if it is the default value) should be written to the VSR prior to using the interrupt controller.  16  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  SPRZ317G – August 2011 – Revised March 2014  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications 	  2.3 and earlier      	 2.3.10   ARM Interrupt Controller Vector Size Register (VSR) Initialization  	 	 	TI
OMAP-L132	   Interrupts destined for the ARM CPU are managed by the ARM Interrupt Controller (AINTC). The AINTC detects, combines, and routes system interrupts to the two native ARM interrupt signals FIQ and IRQ. See the device System Reference Guide for  additional information about the AINTC.  The AINTC module expects all incoming interrupts to be pulse interrupts, however the  [SYSCFG_CHIPSIG_]CHIPINTn interrupts are level interrupts. This mismatch in interrupt types will cause a single CHIPINTn interrupt event to register as multiple interrupt pulses in the AINTC. However, the AINTC does not have the capacity to count the number of interrupt pulses received per system interrupt – it only maintains interrupt flags. A system interrupt is flagged as active until its status is cleared by the user through the AINTC, regardless of the number of interrupts detected.  If the status flag for AINTC CHIPINTn is cleared while the CHIPINTn interrupt is still active, the AINTC will continue to detect CHIPINTn interrupts and its status flag will be set again. This additional setting of the AINTC CHIPINTn status flag is false.  	ARM9	 	 	 	"      Method 1   Do not execute the intended interrupt service routine code if the associated CHIPSIGn status flag is not set in the SYSCFG_CHIPSIG register. A cleared CHIPSIGn status flag indicates that the device is responding to a false interrupt. This method is easy to implement, but does not eliminate false interrupts.  /** Pseudo code only **/  void CHIPINT0_ISR(void) {  /* Exit immediately if CHIPSIG0 is not set */  if( (SYSCFG->CHIPSIG & 0x1) == 0 ) {  return;  }  /* Intended service routine code */  SYSCFG->CHIPSIG_CLR = 0x1;  printf(""Hello World!\n"");  }  SPRZ317G – August 2011 – Revised March 2014  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  17  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      Method 2   Do not clear the AINTC CHIPINTn status flag until the CHIPSIGn status has been cleared. This method will eliminate false interrupts, but requires changes to the AINTC  interrupt dispatch code. Changing the dispatch code may introduce undesired behavior in the application.  /** Pseudo code only **/  /* Sequence that is susceptible to false CHIPINTn interrupts */  void AINTC_ISR_DISPATCH_1(void) {  Get_Interrupt_Information();  /* CHIPINTn interrupts continue to be generated after */  /* AINTC CHIPINTn flag is cleared.  */  Clear_AINTC_Interrupt_Flag();  /* CHIPINTn interrupts are only stopped after ISR clears */  /* the status flag.  */  Branch_To_ISR();  }  /* Sequence that is not susceptible to false CHIPINTn interrupts */  void AINTC_ISR_DISPATCH_2(void) {  Get_Interrupt_Information();  /* ISR will clear CHIPSIGn flag and discontinue CHIPINTn */  /* interrupts to AINTC.  */  Branch_To_ISR();  /* Ok to clear AINTC CHIPINTn flag now.  */  Clear_AINTC_Interrupt_Flag();  }  18  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  SPRZ317G – August 2011 – Revised March 2014  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications "	  2.3 and earlier      	 2.3.12  A Single CHIPINTn Interrupt Event Can Register Multiple Times in the AINTC  	 	 	TI
OMAP-L132	   The C674x CPU supports a Saturation feature for key arithmetic operations. If an operation results in saturation, the SAT (saturation) bit in the control status register (CSR) is set. In normal operation, one or more functional units can simultaneously perform arithmetic operations that can result in saturation. In the case of simultaneous arithmetic operations, the SAT bit is set if at least one functional unit’s operation results in saturation. The saturation status register (SSR) provides saturation flags for each functional unit, making it possible for the program to distinguish between saturations caused by different instructions in the same execute packet. Also, there is no direct connection to the SAT bit in the control status register (CSR); writes to the SAT bit have no effect on SSR and writes to SSR have no effect on the SAT bit.  In the case where a 2 cycle .M unit instruction is in the delay slot of a 4 cycle instruction of the same .M unit, and if both instructions are expected to generate results in the same cycle, the CSR:SAT bit will be incorrectly masked. Ideally, the CSR:SAT bit should be set if any one of the two .M unit instruction causes a saturation. Instead, the arithmetic saturation result of the 2 cycle .M unit instruction will overwrite the CSR:SAT bit.  All of the following must take place in order for an application to be affected by this advisory:  1. A 2 cycle .M unit instruction and a 4 cycle .M unit instruction are issued  simultaneously  2. Both instructions are processed on the same side  3. The 2 cycle instruction is in the delay slot of the 4 cycle instruction so that the results of both instructions are generated in the same cycle  4. The saturation result of the 4 cycle .M unit instruction is different from the saturation result of the 2 cycle .M unit instruction  5. The application checks for the saturation flag and uses the saturation result of the 4  cycle instruction  	ARM9	 	 	 	  Perform one of the following:  •  For the location of code where saturation results are monitored, do not mix datatypes so that 2 cycle and 4 cycle .M unit instructions are not issued together.  •  Do not mix floating point .M unit instruction with fixed point 2 cycle .M unit instructions.  SPRZ317G – August 2011 – Revised March 2014  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  19  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      	  2.3 and earlier      	 2.3.13  Incorrect Masking of the C674x CSR:SAT Bit  	 	 	TI
OMAP-L132	   Note: SDMA refers to all non-CPU requests to the EMC SDMA (Slave Direct Memory Access) port (see Figure 4). SDMA requests are defined as external system bus master requests handled via this port.  The C674x Megamodule uses a two-way set associative cache for L1D. This means that every physical memory location in the system has two possible set/way locations in the cache where it can reside. See TMS320C674x DSP Megamodule Reference Guide  (Literature Number SPRUFK5) for more information on the L1D cache architecture and related terminology. Updated (dirty) values in L1D cache are not written back to external memory until cache activity evicts a cache-line (victim write-back) or a write-back is requested by software.  An L1D cache-line corruption event occurs when all of the conditions in the following steps are met (see Figure 4):  1. L1D cache Lines 1, 2, and 3 have the following characteristics:  •  Line 1 is associated with L2 SRAM (Line A in Figure 4), was previously read by CPU, and is clean. (CPU has not updated the data.)  •  Line 2 is associated with L2 SRAM (Line B in Figure 4), was previously read by CPU, and is clean. (CPU has not updated the data.)  •  Line 3 was previously read by the CPU and may be either clean or dirty.  2. SDMA receives updated data for L2 SRAM Lines A and B, which correspond to L1D  cache Lines 1 and 2.  3. A snoop write operation is initiated by the L2 to overwrite the L1D cache Lines 1 and 2 with updated L2 SRAM Lines A and B. Before the snoop write operation finishes, the CPU performs two reads within the same clock cycle:  •  Line E in L2 cache is read as a cache hit. Line E is destined to replace Line 2 in L1D Cache, which also has a snoop write pending for the updated Line B  content.  •  Line D in L2 SRAM is read. Line D will replace Line 3 in L1D cache.  4. When the snoop write operation completes, Line 2 in L1D cache now contains the updated L2 SRAM Line B data instead of the L2 cache Line E data.  The correct behavior would have been to kill the pending snoop write initiated to update L1D cache Line 2 with the updated L2 SRAM Line B data in Step 3. The L1D cache should have evicted Line B and replaced it with Line E data. Instead, the snoop write operation continues and does not complete until after the L1D cache Line 2 has already been replaced with L2 cache Line E data. The snoop write instruction overwrites the L1D  cache Line 2 (containing L2 cache Line E data) with the updated L2 SRAM Line B data.  20  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  SPRZ317G – August 2011 – Revised March 2014  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications Time Line  System View      Line A   Line E and Line B Map to  STEP 1  STEP 2  STEP 3  STEP 4  same L1D Cache line.  Line A  Line B  C674x subsystem  Line A  Line C  C6xCPU  Read Line D  L2  Line A  Line D  Activity  Read Line E  C6X CPU  Controller  L2 SRAM  SDMA  Write Line A Snoop Write  Line A  Line E  Activity  Write Line B  Initiated  L1D  EMC  L2 CACHE      L1D Cache   Clean Line A Clean Line A  IN FLUX  Clean Line A  Controller  SDMA PORT      Line 1   (New Data)      L1D Cache   Clean Line B Clean Line B  IN FLUX  CORRUPT  EMAC      Line 2   Line E replaces Line B due      Line A   Line 1 [A]  PRU      L1D Cache   Clean/Dirty  Clean/Dirty  IN FLUX  Clean Line D  to CPU read.  Line 3  Line C  Line C  SYSTEM MASTERS      Line A   Line 2 [B/E] Delayed snoop wrtie to Line  EDMA      Line A   Line 3 [C/D] B corrupts Line E in L1D$  L1D  Corruption happens  CACHE  EXTERNAL      because of this state   Figure 4. Example of L1D Cache Corruption  	ARM9	 	 	 	  Method 1: Do not perform two CPU read operations in the same clock cycle. For C  code, use compiler flag (--c64p_dma_l1d_workaround) available in the C6000  Compiler (CodeGen) Tools version 7.0.2 and later. For assembly code, the --  c64p_dma_l1d_workaround flag will only issue a warning.  Method 2: In cases where buffer access will not be shared between CPU and SDMA, unintended CPU/SDMA cache-line sharing can be avoided by aligning CPU and SDMA buffers to 64-byte boundaries. Aligning buffers to 64-byte boundaries will result in wasted space, however it ensures that the CPU and SDMA buffers will not have partial  segments which overlap into the same L1D cache line.  /** Pseudo code only **/  Uint8 *SDMA_BUFF, *CPU_BUFF;  /* 64-byte aligned allocation Option 1 */  SDMA_BUFF = malloc( (Int32) (( SDMA_BUFF_SIZE + 63)/64) * 64 );  CPU_BUFF = malloc( (Int32) ((CPU_BUFF_SIZE + 63)/64) * 64 );  SDMA_BUFF = (Uint8 *) ( (Int32) SDMA_BUFF & ~63 );  CPU_BUFF = (Uint8 *) ( (Int32) CPU_BUFF & ~63 );  /* 64-byte aligned allocation Option 2 with BIOS Call */  SDMA_BUFF = MEM_alloc( IRAM, SDMA_BUFF_SIZE, 64 );  CPU_BUFF = MEM_alloc( IRAM, CPU_BUFF_SIZE, 64 );  SPRZ317G – August 2011 – Revised March 2014  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  21  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  Method 3 Manage access to a 64-byte boundary aligned buffer that is shared between CPU and SDMA by implementing a semaphore and forcing cache writeback operations if there are CPU writes. With this method, the semaphore ensures that there is clear ownership of the buffer between CPU and SDMA, and the CPU manages cache  coherence by using explicit cache writeback operations.  /** Pseudo code only **/  /* Example with EDMA as the external master */  EDMA_ISR() {  /* EDMA releases ownership of buffer */  SEM_post(SyncSemaphore);  return;  }  main() {  while(COND) {  /* CPU waits for ownership of buffer */  SEM_pend(SyncSemaphore);  /**********************/  /*** CPU Processing ***/  /**********************/  /* Cache writeback for shared block */  /* Buffer must be 64-byte aligned */  BCACHE_wbInv( blockPtr, blockSize, WAIT );  /* Initiate EDMA */  EDMA_Event_Generate();  }  }  Method 4 Do not allow SDMA to access L2 RAM. SDMA can use buffers in L1D RAM  instead of L2 RAM.  Method 5 Configure the entire L2 RAM as cache. Critical peripheral data can be accessed in L1D RAM instead of L2 RAM.  Method 6 Configure the entire L2 RAM as normal SRAM (no cache).  Method 7 Configure the entire L1D RAM as normal SRAM (no cache).  22  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  SPRZ317G – August 2011 – Revised March 2014  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications 	  2.3 and earlier      	 2.3.17   SDMA Activity Can Corrupt L1D When L2 Is Configured as Mixed/Cache/SRAM  	 	 	TI
OMAP-L132	   A condition can occur during the device power supply ramp in which the DVDD18  supply, which should be at 1.8V nominal, can be pulled up on-chip by the DVDD3318_A, DVDD3318_B or DVDD3318_C supplies operated at 3.3V. For the sake of this  description, DVDD3318_x means any combination of DVDD3318_A, DVDD3318_B or  DVDD3318_C.  Important Note: The 3.3V DVDD3318_x supplies must not be driven to 0V during zones A – E or high current capable of damaging the device may occur. The 3.3V  DVDD3318_x supplies should not be driven during this time.  A normal example power-supply ramp is shown below:  A  B  C  D  E  F  G  3.3V  VT  1.8V      1.2V   Figure 5. Normal power-supply ramp  •  A. All device supplies are undriven  •  B. The 1.2V supplies are ramped to their nominal levels  •  C. Potential delay between supply ramps (not required)  •  D. The 1.8V supplies (specifically DVDD18) are ramped to their nominal levels.  During the DVDD18 ramp there will be some minor drift up in the undriven  DVDD3318_x supplies. This is normal and is not a problem.  •  E. Potential delay between supply ramps (not required)  •  F. DVDD3318_x is ramping but is less than DVDD18 + VT  •  G. DVDD3318_x is ramping but is greater than DVDD18 + VT  When the fault condition occurs, the supplies behave as shown below:  A  B  C  D  E  F  G      3.3V   ~2.7V  VT      1.2V   Figure 6. Faulty power-supply ramp  The behavior is the same until zone G. When the DVDD3318_x supply exceeds  DVDD18 by a transistor V , the DVDD18 supply begins to be pulled up by the  T  DVDD3318_x supply and follows the DVDD3318_x supply by DVDD3318_x- V . Since  T  the DVDD18 supply is often connected to other 1.8V supplies in the design, these other supplies can be pulled up also.  SPRZ317G – August 2011 – Revised March 2014  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  23  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  The condition occurs because the dual-voltage IO buffers have voltage detection circuitry that monitors DVDD3318_x during reset and determines whether the applied supply voltage is 1.8V or 3.3V. This detection circuitry then configures the IOs to operate at the appropriate voltage. As the DVDD3318_x supply ramps, there is a small range near DVDD18 + V where the voltage detection circuit finds the state indeterminate and briefly T  turns on circuitry associated with both voltage options creating a current path between them. This current path can cause the DVDD18 supply to be pulled up. The mechanism for this behavior is explained below:      DVDD3318_x   Dual-Voltage IO Buffer   Behavior of the IO buffer during Zone F:  As the DVDD3318_x supply ramps, but is not yet one V above the      T   DVDD18 supply, the comparator enables the 1.8V mode logic      3.3V Mode   section and disables the 3.3V mode logic section. No unexpected  Enable      Logic   +  current flows between the two sections.      DVDD18   -   1.8V Mode  Enable  Logic  Iload  External      Loads   Figure 7. Behavior of the IO buffer during Zone F      DVDD3318_x   Dual-Voltage IO Buffer   Error State of the IO buffer during Zone G:  As DVDD3318_x exceeds DVDD18+V , some of the circuitry      T   across the boundary of the two voltage domains will turn on and  3.3V Mode  DVDD18      Enable   causes a leakage current (in red) to flow between the two voltage      Logic   +  domains. This current pulls up the DVDD18 supply unless the      Ileakage   power source providing that supply can oppose it or unless the  -  load current is strong enough to counteract it.  Enable 1.8V Mode      Logic   If DVDD18 continues to rise as DVDD3318_x ramps, the      I   comparator never sees enough difference between the two      load   supplies to switch to 3.3V mode.  External      Loads   Figure 8. Error State of the IO buffer during Zone G      DVDD3318_x   Dual-Voltage IO Buffer   Recovered State of the IO buffer during Zone G:  If the load current is high enough or the DVDD18 power supply can  oppose the leakage current, then the DVDD18 voltage stays low      3.3V Mode   enough for:   Enable      Logic   +      DVDD18   • the comparator to recognize 3.3V mode  • the 1.8V mode logic is turned off  -      1.8V Mode   • the leakage stops  Enable  Logic  Iload  External      Loads   Figure 9. Recovered State of the IO buffer during Zone G  24  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  SPRZ317G – August 2011 – Revised March 2014  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications This error condition may occur when either of the following conditions are present:  •  The regulator used to control the DVDD18 supply can only regulate voltage up and relies on the load to pull the output voltage down  •  There is low load on the DVDD18 supply during the DVDD3318_x power supply  ramp  This condition will not occur in designs where:  •  All DVDD3318_x supplies are operated at 1.8V, or  •  The regulator used to supply DVDD18 has the capability to actively regulate (drive) its output voltage up or down and doesn’t rely on system load to pull the voltage down, or  •  The load on the DVDD18 supply during the DVDD3318_x power supply ramp is  sufficient to oppose the leakage current.  	ARM9	 	 	 	  1. Design simulation has indicated that under the worst-case  process/voltage/temperature conditions the maximum leakage current into the  DVDD18 supply due to this phenomenon will be 140 mA (the 140 mA is a cumulative current generated by all of the dual-voltage IOs). So this error state can be prevented by ensuring that the load on the DVDD18 supply during the DVDD13318_x supply  ramp exceeds 140 mA. This can be achieved by any combination of the following as long as they cumulatively produce >140 mA load on DVDD18 during the  DVDD3318_x ramp period:  (a) Maintain sufficient bulk capacitance on the DVDD18 supply such that the charging current for these capacitors provides all or part of the required >140 mA. Bulk capacitance in this context means the total capacitance seen by the DVDD18  supply (filter capacitors, bypass capacitors, etc.). Capacitor charging current is defined as I = C*(dV/dt). So the ramp rate of the DVDD3318_x supply and the  total bulk capacitance on the DVDD18 supply can be used to calculate the current produced. This solution provides additional power supply filtering and little current leakage after the supplies are ramped (depending on the type of capacitors used).  The table below shows some examples of the bulk capacitance that would be  required to use this solution alone:  Table 10. Bulk Capacitance      DVDD3318_x ramp   dV/dt (in V per second)  Required capacitance to generate 140 mA      time for 3.3V   100 µs  33000  4.2 µF  250 µs  13200  10.6 µF  500 µs  6600  21.2 µF  1 ms  3300  42.4 µF  10 ms  330  424.2 µF  (b) Use an additional shunt regulator to control the voltage at DVDD18. The shunt regulator is placed between DVDD18 and Vss. As an example, the TLVH431 can  provide up to 70 mA of additional load current to help maintain the DVDD18  voltage. When the voltage drops back to the normal 1.8V range, the current flow through the shunt regulator drops into the <100 uA range. This solution requires the shunt regulator and two additional resistors to set the desired regulation voltage.  (c) Use a resistor to provide additional load between DVDD18 and Vss. This solution is less desirable since it continues to draw power even after the supply ramp is completed but would likely be the lowest cost. An improvement is to use a  FET/switch in series with the resistor between DVDD18 and Vss that can later be turned off (by the RESET signal or a GPIO signal for example).  SPRZ317G – August 2011 – Revised March 2014  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  25  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  2.  Choose a regulator for the DVDD18 supply (or grouped 1.8V supplies) that is  capable of actively regulating voltage up and down. Many high-efficiency switching regulators switch current into the load only when the voltage needs to be raised and rely on the load to pulldown the current. In this error condition, a regulator of this type will not be able to compensate for the leakage current described above.  Synchronous buck regulators use external inductance to pulldown the regulated  voltage when necessary.  26  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  SPRZ317G – August 2011 – Revised March 2014  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications 	  2.3 and earlier      	 2.3.18  DVDD18 Can Pull Up to 2.7V When Using Dual-Voltage IOs at 3.3V  	 	 	TI
OMAP-L132	   The USB 2.0 On-The-Go (OTG) Session Request Protocol (SRP) allows a USB-  peripheral to request the USB-host to enable Vbus and start a session. On this device, the SRP protocol is not supported.  The OTG Host Negotiation Protocol (HNP), which allows USB-devices to swap roles between host and peripheral, is supported.  	ARM9	 	 	 	  None  SPRZ317G – August 2011 – Revised March 2014  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  27  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      	  2.3 and earlier      	 2.3.19  USB 2.0 On-The-Go (OTG) Session Request Protocol (SRP) Is Not Supported  	 	 	TI
OMAP-L132	:  The PUPD_SEL[29] register does not get initialized when the device is first powered on and in Reset. This register controls the internal pullup and pulldown resistors for the BOOT[7:0] pins. The contents of the PUPD_SEL[29] register at this state are  unpredictable and may contain random values. These random values can result in the internal pullups being enabled for some or all of the BOOT[7:0] pins during reset after every power-on, which conflicts with the datasheet claim that the internal pulldowns are enabled during reset.  Internal pullups being enabled on the BOOT[7:0] pins may result in boot failures. If weak external pulldown resistors are used on the PCB to select the boot mode, they may not be able to overpower the internal pullups. This can result in the wrong boot mode being latched in the BOOTCFG[7:0] register when coming out of Reset.  Once the device is out of Reset, the PUPD_SEL[29] register is initialized, and the internal pulldown resistors for the BOOT[7:0] pins are all enabled. Issuing a second Power-On Reset (POR) results in the intended boot mode being latched, since the pins are internally pulled down as expected.  Figure 10 shows the behavior of the PUPD_SEL[29] register before and after reset.  Assuming weak or no external pull resistors are on the BOOT[7:0] pins, the BOOTCFG  register will latch the unknown values after the device initially comes out of Reset. Note that, TRST must always be low in order to issue a POR and latch the boot pin values --  the boot pins are not latched after a Warm Reset.  RESET  TRST  PUPD_SEL[29] Register  0h  BOOTCFG[7:0] Registers  Figure 10. Initialization of PUPD_SEL[29] and BOOTCFG[7:0] Registers with Weak or No External Pull Resistors on BOOT[7:0] Pins  Other device pins with configurable internal pullup or pulldown resistors are always internally pulled down during reset and are not affected by this advisory.  	ARM9	 	 	 	:  The following Workaround must be implemented to ensure that the boot pins are always latched correctly:  Use strong external pull resistors on BOOT[7:0] pins. Since either the internal pullup or pulldown resistors could be enabled after every power-on, the external resistors must be strong enough to oppose the internal pulls in either case.  Section 4, Device Operating Conditions, of the device datasheet shows the electrical characteristics information which can be used to calculate the maximum external pull resistance required. The value is dependent on the DVDD3318_C I/O supply level.  For BOOT pins which need to be sampled as logical low, the external pulldown  resistance (R  ) must be selected by assuming the internal pullup is enabled. The  PDmax  calculation is shown in Table 11.  28  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  SPRZ317G – August 2011 – Revised March 2014  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications Table 11. Required Pulldown Resistance (R  ) for Logical Low BOOT Pins      PDmax   æ V ö  IL  ç  ÷  DVDD3318_C  I  V  I      IL   è I      R   I ø      PDmax   3.3 V  310 µA  0.80 V  2.58 kΩ  1.8 V  310 µA  0.80 V  2.03 kΩ  For BOOT pins which need to be sampled as logical high, the external pullup resistance (R  ) must be selected by assuming the internal pulldown is enabled. The calculation PUmax  is shown in Table 2.  Table 12. Required Pullup Resistance (R  ) for Logical High BOOT Pins      PUmax   æ DVDD 3318 _ C - V  ö  IH  ç  ÷  DVDD3318_C  I  V  I      IH   I   è  I  ø      RPUmax   3.3 V  270 µA  2.00 V  4.81 kΩ  1.8 V  270 µA  1.17 V  2.33 kΩ  SPRZ317G – August 2011 – Revised March 2014  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  29  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      	  2.3 and earlier  	 2.3.23   BOOT: Internal Pullup Resistors for BOOT[7:0] Pins Are Sometimes Enabled  During Reset, Leading to Boot Failures  	 	 	TI
OMAP-L132	":  The ROM bootloader (RBL) reads a NAND page in segments of 512 bytes (user data) over the External Memory Interface A (EMIFA). The EMIF also reads the associated ECC data which is stored in the spare area of the flash (as shown in Figure 11). The ECC Correct function in the RBL can correct up to 4 bit errors in the user data and/or ECC data by using the syndrome generated from the ECC data and the parity of the user data calculated by the EMIFA module.  However, over the life span of the NAND flash, ECC data stored in the spare area can develop errors due to bit flips. When the calculated syndrome indicates an error in the ECC data, the ECC Correct and Read functions of the RBL abort the read process even though, it is possible to correct up to 4 bit errors combined in user and ECC data.  Consequently the device fails to boot.  Explanation of Current ROM Bootloader Behavior:  The RBL implements a search mechanism to look for the boot image in NAND flash by using an Open function and a Read function. The Open function includes a bad block check where the RBL skips to the next block (shown as (A) in Figure 11) if the block under consideration is marked as ""bad"" (in the spare area). On finding a good block, the RBL attempts to read page0 (the first page) in that block.  If page0 of the good block has an ECC data error or an uncorrectable error (more than 4  bit errors combined), the RBL skips to the next block (shown as (B) in Figure 11). This bad block check mechanism enables the device to check up to the first 32 blocks in the NAND flash for booting (the boot process will fail if all 32 blocks have uncorrectable or ECC data errors in page0). Note that the RBL does not abort on detecting an error in ECC data on page0.  Once the RBL finds a good block with a good page0, it continues to read subsequent pages in that block. If an uncorrectable or ECC error is detected in subsequent pages, the RBL will abort with a boot error (shown as (C) in Figure 11). The workaround, described below, enables the boot process to continue for both types of errors (ECC  data and uncorrectable errors).  30  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  SPRZ317G – August 2011 – Revised March 2014  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated    www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications (1)  All pages marked in green are good and all pages marked in red have ""uncorrectable"" errors.  Figure 11. D800K008 ROM Behavior Before Application of Software Patch(1)  "	ARM9	 	 	 	":  The workaround ignores errors in ECC data (these errors do not need to be corrected) so that the boot process can continue, correcting errors in the user data (up to 4 bit errors total), as necessary. The workaround also includes a mechanism to restart the NAND read process from the next good block if an uncorrectable error (more than 4 bit errors) is detected on any page of a good block.  This workaround is implemented using a software patch that is loaded in device RAM at boot time and is designed to change the default behavior of the ECC Correct and Read functions in the RBL. The patch binary replaces function pointers to the ECC Correct and Read functions in the ROM function table, (defined in device internal memory), during boot. The patch binary will reside in page0 of the NAND block and so will be applied only after the page0 of a good block has been read.  Once the patch is read, all subsequent page reads in the block will use the new ECC  Correct and Read functions. ECC data errors on any page (other than page0) are ignored, any user data error (up to 4 bit errors total) is corrected and the boot process continues. If an uncorrectable error is detected on any page, the block is skipped and the boot process is restarted on the next good block. The behavior of the device boot from the NAND after application of the patch is shown in Figure 12.  SPRZ317G – August 2011 – Revised March 2014  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  31  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated    Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com  (1)  All pages marked in green are good and all pages marked in red have ""uncorrectable"" errors.  Figure 12. D800K008 ROM Behavior With Software Patch Applied(1)  The software patch is available as a pre-built file with the latest version of the AIS tool that is used to generate the NAND flash boot image. The Using the OMAP-L132/L138  Bootloader Application Report (Literature number: SPRAB41) provides a link to the install package for the AIS tool which includes the following in the install directory: prebuilt patch files, the GUI AIS generation tool (AISGEN.exe, version 1.11 or later), command-line AIS generation tool and an example INI file.  Application of the Software Patch to NAND Boot Images:  •  For the GUI tool, AISGEN.exe version 1.11 or later (found in the install directory), the patch integrates the modified ECC Correct function into the user application file to generate one binary AIS file.  •  For the Command line AIS tool, HEXAIS_OMAP_L138.exe users (found in the install directory), the patch can be integrated into the user application file to generate one binary AIS file by inserting lines below to the end of the INI configuration file.  The patch name is: ARM_nand_ecc_patch_OMAP-L138.out  32  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  SPRZ317G – August 2011 – Revised March 2014  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications  [INPUTFILE] ; get the NAND ECC patch file  FILENAME=Patch_name.out  ; patch the NAND ECC handling routine  [AIS_Jump]  LOCATION=_NAND_ECC_patchApply  •  The patch will be burnt on page0, as it is in the head of AIS file. Once page0 has been read successfully, the AIS set command will overwrite the function pointer in the RBL with the modified function pointer and the modified function will be applied to the later pages read. Memory usage of the patch at boot time is as follows:  –  500 bytes at location 0xFFFF 0B00  Recommendations to Improve Robustness:  •  Page0 should be stored on multiple blocks as backup to take advantage of the safety mechanism built into Silicon Revision 2.1 to cycle to the next block when a page0  read fails in a good block.  •  Maintain backup boot images in multiple blocks. The patch to the Abort function reinitializes the boot process and forces the boot to cycle to the next good block and restart the boot process by reading from it.  •  Silicon Revision 2.1 supports booting from Block 0 of the flash which many NAND  manufacturers guarantee as a “more reliable” block than all other blocks. Hence, setting up boot to start from that Block 0 could help improve the reliability of boot.  This is a hardware change, requiring the bootmode pins BOOT[6:5] = 1x.  For more details on the bootmode pins, see the Using the OMAP-L132/L138  Bootloader Application Report (Literature number: SPRAB41), NAND-Boot Modes.  SPRZ317G – August 2011 – Revised March 2014  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  33  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      "	  2.3 and 2.1 (ROM Versions D800K008)  	 2.3.24   Boot: ECC Data Error in Spare Area Causes NAND Boot Failure  	 	 	TI
OMAP-L132	   When CPPI DMA completes a receive data transaction it posts a write to the Rx data buffer located in external memory, posts a write to update the descriptor located in external memory, and raises an interrupt to CPU. When the system load is high, the posted writes to DDR may not be complete before the CPU receives the interrupt. In this case, the CPU would fetch stale receive data from the Rx data buffer located in external memory.  	ARM9	 	 	 	  Initialize the datalength descriptor field to zero. CPPI DMA updates this field after the completion of an RX DMA operation with the actual number of bytes received. In the ISR  (actually in a deferred call context), poll this field until it becomes a non-zero value to ensure data buffer has been updated with actual data. The descriptor buffer write is posted after the data buffer write, so waiting for the descriptor field to be updated ensures the data buffer has been updated. Since this workaround involves deferred procedure calls (whose schedule can be delayed depending on OS load), the latency sensitive application (like ISO Audio) might be affected by delay in notification to the application.  34  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  SPRZ317G – August 2011 – Revised March 2014  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications 	  2.3 and earlier      	 2.3.25   USB0: CPU gets Stale Receive Data from the Data Buffer located in External      Memory   	 	 	TI
OMAP-L132	   The erroneous short packet status can be detected on current endpoint and XDMA closes the Rx transfer in current endpoint. When more than one endpoint have been processed, if one of the endpoints has a short packet, then the short packet status is broadcasting to all endpoints.  This results in premature completion of a Rx descriptor in generic RNDIS CPPI DMA mode.  	ARM9	 	 	 	  The workaround involves monitoring transfer data size before and after transferring and reconfiguring data transfer size by software if the before and after size is different.  Software must keep tracking every endpoint data transferring size. When DMA  completion interrupt is received, software checks size difference. If the size is not equal, software requests the remaining data.  SPRZ317G – August 2011 – Revised March 2014  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  35  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com      	  2.3 and earlier      	 2.3.26  USB0: Early DMA Completion in DMA Receive Mode and More Than One Endpoint      is Transferring Data   	 	 	TI
OMAP-L132	   Teardown receive DMA is not working perfectly. This happens when a teardown is initiated by software during the endpoint is still active. Frequent teardown results in XDMA hung up situation.  	ARM9	 	 	 	  Software should make sure that DMA does not get to an unknown state during teardown by disabling the DMAEN bit in the RXCSR register. After this the teardown procedure can be initiated. Software should also add 250 ms delay during teardown.  36  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  SPRZ317G – August 2011 – Revised March 2014  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.1 Usage Notes and Known Design Exceptions to Functional Specifications 3  Silicon Revision 2.1 Usage Notes and Known Design Exceptions to Functional      Specifications   This section describes the usage notes and advisories that apply to silicon revision 2.1 and earlier of the device.      3.1   Usage Notes for Silicon Revision 2.1  Usage notes highlight and describe particular situations where the device's behavior may not match presumed or documented behavior. This may include behaviors that affect device performance or functional correctness. These usage notes will be incorporated into future documentation updates for the device (such as the device-specific data sheet), and the behaviors they describe will not be altered in future silicon revisions.  Silicon revision 2.0 applicable usage notes have been found on a later silicon revision. For more details, see Section 2.2, Silicon Revision 2.3 Known Design Exceptions to Functional Specifications.      3.2   Silicon Revision 2.1 Known Design Exceptions to Functional Specifications  The advisories are not enumerated in sequential order and hence some numbers may not appear in the document  Table 13. Silicon Revision 2.1 Advisory List  Title ................................      Page   	  2.3 and earlier      	 2.3.27   USB0: DMA Hung up in Frequent Teardowns  	 	 	TI
OMAP-L132	   Under conditions in which the device is subjected to large variations in operating temperatures, the USB0 PLL temperature compensation circuitry does not have enough margin to guarantee compensation for PLL drift across all temperature ranges.  As a result, the mean frequency generated by the USB0 (USB 2.0 OTG) PHY PLL will begin to drift (relative to the expected 480 Mbps) when the temperature of the device is subjected to large swing from the original temperature in which the USB0 PHY was most recently calibrated (initialized).  Once the onset of PLL drift occurs, the mean frequency will continue to drift outside the expected frequency and will eventually cause the PLL to lose lock resulting in failure of USB packet reception and/or transmission. This break in transmission will continue until the USB0 PHY is recalibrated during a USB0 PHY Reset.  If the device is not exposed to large variations in temperature relative to the temperature at which the USB0 PHY was most recently initialized, the temperature compensation circuitry is expected to provide the proper compensation to prevent the mean PLL  frequency from losing lock and beginning to drift.  More specifically, this advisory is most applicable in applications where the device is expected to operate outside the commercial temperature range of 0˚C to 90˚C. TI has identified a point-to-point device temperature range in which there is a very high confidence the compensation circuitry will properly compensate for all temperature variations, provided the USB0 PHY was most recently initialized (calibrated) within this same temperature range.  Operating outside the 0˚C-65˚C temperature range increases the susceptibility of the device to experience PLL drift, but does not mean that the application will always experience a failure in USB transmission.      Root Cause   The Voltage Controlled Oscillator (VCO) Compensation circuitry local to the USB0 PHY  was not designed with a large enough range to compensate for all variations in temperature across the specified operating range of the device.  How to Most Easily Reproduce the Issue: Reproduction of this issue can most easily be accomplished by the following steps:  1. Allowing the unit to soak in an ambient temperature of -35˚C until the device temperature reaches approximately the same temperature.  2. Power up the device and provide the necessarily software programming in order to invoke the USB Signal Quality Test Pattern.  3. Using a USB 2.0 Certified Test Platform, execute the USB signal quality test procedure across the following temperature set points. -35˚C, 0˚C, +35˚C, +70˚C.  Record the measured mean frequency by the compliance software.  NOTE:  The set points can be varied to obtain finer temperature resolution of  when the PLL begins to drift a per platform basis. The above temperature  profile is provided for reference.  38  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  SPRZ317G – August 2011 – Revised March 2014  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated  www.ti.com  Silicon Revision 2.1 Usage Notes and Known Design Exceptions to Functional Specifications 	ARM9	 	 	 	  When a break in transmission is detected, USB0 traffic can be recovered by a software reset of the USB0 PHY. A PHY reset implies recalibration of the PHY PLL at the reset temperature. The system has not been observed to reliably recover on its own. A PHY  reset also implies re-enumeration of all devices. There is no way to recalibrate the USB0  PHY without a re-enumeration.  In order to invoke the recovery mechanism (that is a USB0 PHY reset) one needs to determine when the issue is present. One such approach is to look for an absence of USB0 Core interrupts over a specified time window. This window should be optimized for the expected USB traffic based upon the application.  As an additional safeguard, an application can also intentionally schedule pre-determined USB PHY resets at specific temperature points if operation over a broad range is expected.  Here is an example of one way to power cycle the USB0 PHY via the Chip Configuration 2 Register in the System Configuration (SYSCFG) Module:  #define CFGCHIP2  *((volatile unsigned int *) 0x01C14184)  #define USBPHY_PHYPDWN 0x00000200  Void phy_reset(void) {  CFGCHIP2 |= USBPHY_PHYPDWN;  /* Power down the USB PHY */  mdelay(1);  /* Wait 500ms */  CFGCHIP2 &= ~USBPHY_PHYPDWN;  /* Power up the USB PHY */  }  SPRZ317G – August 2011 – Revised March 2014  OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1  39  Submit Documentation Feedback  Copyright © 2011–2014, Texas Instruments Incorporated      	  2.1      	 2.1.21   USB0 PLL Mean Frequency Can Drift Across Large Temperature Swings  	 	 	TI
